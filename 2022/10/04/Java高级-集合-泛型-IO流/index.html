<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Java集合-泛型-IO流</title><meta name="author" content="Qinghai2021"><meta name="copyright" content="Qinghai2021"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="一、集合1.1集合的概述1.集合与数组 集合、数组都是对多个数据进行存储操作的结构，简称Java容器。 说明：此时的存储，主要指的是内存层面的存储，不涉及到持久化的存储（.txt,.jpg,.avi，数据库中）  数组优缺点：  数组在存储多个数据方面的特点： 一旦初始化以后，其长度就确定了。 数组一旦定义好，其元素的类型也就确定了。我们也就只能操作指定类型的数据了。比如：String[] arr">
<meta property="og:type" content="article">
<meta property="og:title" content="Java集合-泛型-IO流">
<meta property="og:url" content="http://example.com/2022/10/04/Java%E9%AB%98%E7%BA%A7-%E9%9B%86%E5%90%88-%E6%B3%9B%E5%9E%8B-IO%E6%B5%81/index.html">
<meta property="og:site_name" content="Qinghai2021·博客">
<meta property="og:description" content="一、集合1.1集合的概述1.集合与数组 集合、数组都是对多个数据进行存储操作的结构，简称Java容器。 说明：此时的存储，主要指的是内存层面的存储，不涉及到持久化的存储（.txt,.jpg,.avi，数据库中）  数组优缺点：  数组在存储多个数据方面的特点： 一旦初始化以后，其长度就确定了。 数组一旦定义好，其元素的类型也就确定了。我们也就只能操作指定类型的数据了。比如：String[] arr">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/images/background.jpg">
<meta property="article:published_time" content="2022-10-03T16:00:00.000Z">
<meta property="article:modified_time" content="2022-10-05T08:45:08.554Z">
<meta property="article:author" content="Qinghai2021">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/images/background.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2022/10/04/Java%E9%AB%98%E7%BA%A7-%E9%9B%86%E5%90%88-%E6%B3%9B%E5%9E%8B-IO%E6%B5%81/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":500},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: Qinghai2021","link":"链接: ","source":"来源: Qinghai2021·博客","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://fastly.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://fastly.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java集合-泛型-IO流',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-10-05 16:45:08'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.2.0"><link rel="alternate" href="/atom.xml" title="Qinghai2021·博客" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Qinghai2021</div><div class="author-info__description">阳光宅男💛</div></div><div class="card-info-social-icons is-center"><a class="social-icon" href="//github.com/Qinghai2021?tab=repositories" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:xxxxxx@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-clock"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://www.bilibili.com/blackboard/fe/activity-HQjQSdd3L8.html"><i class="fa-fw fas fa-gamepad"></i><span> 游戏</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-tools"></i><span> 工具</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" target="_blank" rel="noopener" href="https://draw.xbyzs.cf"><span> Draw画布</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Qinghai2021·博客</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-clock"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://www.bilibili.com/blackboard/fe/activity-HQjQSdd3L8.html"><i class="fa-fw fas fa-gamepad"></i><span> 游戏</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-tools"></i><span> 工具</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" target="_blank" rel="noopener" href="https://draw.xbyzs.cf"><span> Draw画布</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">Java集合-泛型-IO流</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2022-10-03T16:00:00.000Z" title="发表于 2022-10-04 00:00:00">2022-10-04</time></span></div><div class="meta-secondline"></div></div></div><article class="post-content" id="article-container"><h2 id="一、集合"><a href="#一、集合" class="headerlink" title="一、集合"></a>一、集合</h2><h3 id="1-1集合的概述"><a href="#1-1集合的概述" class="headerlink" title="1.1集合的概述"></a>1.1集合的概述</h3><h4 id="1-集合与数组"><a href="#1-集合与数组" class="headerlink" title="1.集合与数组"></a>1.集合与数组</h4><ol>
<li>集合、数组都是对多个数据进行存储操作的结构，简称Java容器。</li>
<li>说明：此时的存储，主要指的是内存层面的存储，不涉及到持久化的存储（.txt,.jpg,.avi，数据库中）</li>
</ol>
<p><strong>数组优缺点：</strong></p>
<ol>
<li>数组在存储多个数据方面的特点：<ol>
<li>一旦初始化以后，其长度就确定了。</li>
<li>数组一旦定义好，其元素的类型也就确定了。我们也就只能操作指定类型的数据了。比如：String[] arr;int[] arr1;Object[] arr2;</li>
</ol>
</li>
<li>数组在存储多个数据方面的缺点：<ol>
<li>一旦初始化以后，其长度就不可修改。</li>
<li>数组中提供的方法非常有限，对于添加、删除、插入数据等操作，非常不便，同时效率不高。</li>
<li>获取数组中实际元素的个数的需求，数组没有现成的属性或方法可用</li>
<li>数组存储数据的特点：有序、可重复。对于无序、不可重复的需求，不能满足。</li>
</ol>
</li>
</ol>
<h4 id="2-集合的框架"><a href="#2-集合的框架" class="headerlink" title="2.集合的框架"></a>2.集合的框架</h4><ol>
<li><p>Collection接口：单列集合，用来存储一个一个的对象</p>
<ol>
<li><p><strong>List接口：存储有序的、可重复的数据</strong>。  –&gt;“动态”数组</p>
<p>例如：ArrayList、LinkedList、Vector（实现类）</p>
</li>
<li><p><strong>Set接口：存储无序的、不可重复的数据</strong>   –&gt;高中讲的“集合”</p>
<p>例如：HashSet、LinkedHashSet、TreeSet（实现类）</p>
</li>
</ol>
</li>
<li><p>Map接口：双列集合，用来存储一对(key - value)一对的数据   –&gt;高中函数：y &#x3D; f(x)</p>
<p>例如：HashMap、LinkedHashMap、TreeMap、Hashtable、Properties（实现类）</p>
</li>
</ol>
<h3 id="1-2Collection接口中方法"><a href="#1-2Collection接口中方法" class="headerlink" title="1.2Collection接口中方法"></a>1.2Collection接口中方法</h3><p>声明方式一：Collection coll &#x3D; new ArrayList()</p>
<p>声明方式二：调用Arrays的静态方法asList,<strong>形参为可变形参</strong>，返回ArrayList<br>Collection coll1 &#x3D; Arrays.asList(123,456);</p>
<ol>
<li><p>add(Object e)</p>
<p>将元素e添加到集合coll中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Collection</span> <span class="variable">coll</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();    <span class="comment">//集合的声明</span></span><br><span class="line">coll.add(<span class="string">&quot;AA&quot;</span>);</span><br><span class="line">coll.add(<span class="string">&quot;BB&quot;</span>);</span><br><span class="line">coll.add(<span class="number">123</span>);<span class="comment">//自动装箱Integer</span></span><br><span class="line">coll.add(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br></pre></td></tr></table></figure>
</li>
<li><p>size()</p>
<p>获取添加的元素的个数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(coll.size());  <span class="comment">//4</span></span><br></pre></td></tr></table></figure>


</li>
<li><p>addAll(Collection coll1)</p>
<p>将coll1集合中的元素添加到当前的集合中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Collection coll1 = new ArrayList();</span><br><span class="line">coll1.add(456);</span><br><span class="line">coll1.add(&quot;CC&quot;);</span><br><span class="line">coll.addAll(coll1); </span><br></pre></td></tr></table></figure>


</li>
<li><p>clear()</p>
<p>清空集合元素，不是删除集合，而是清空元素</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">coll.clear();  </span><br></pre></td></tr></table></figure>


</li>
<li><p>isEmpty()</p>
<p>判断当前集合是否为空</p>
</li>
<li><p>boolean   contains(Object obj)</p>
<p>判断当前集合中是否包含obj，我们在判断时会调用obj对象所在类的equals()。如果不重写equals方法，则会调用Object中的equals()，使用的是&#x3D;&#x3D;，不同对象比的是地址，所以必须重写equals( )</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">boolean contains = coll.contains(123);</span><br><span class="line"></span><br><span class="line">contain1 = coll.contains(new Person(&quot;Jerry&quot;,20));</span><br></pre></td></tr></table></figure>


</li>
<li><p>containsAll(Collection coll1)</p>
<p>判断形参coll1中的所有元素是否都存在于当前集合中。同样调用equals方法，所以重写equals很重要</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Collection</span> <span class="variable">coll</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        coll.add(<span class="number">456</span>);</span><br><span class="line">        coll.add(<span class="number">123</span>);</span><br><span class="line"><span class="comment">//        Person p = new Person(&quot;Jerry&quot;,20);</span></span><br><span class="line"><span class="comment">//        coll.add(p);</span></span><br><span class="line">        coll.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Jerry&quot;</span>,<span class="number">20</span>));</span><br><span class="line">        coll.add(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Tom&quot;</span>));</span><br><span class="line">        coll.add(<span class="literal">false</span>);</span><br><span class="line">声明方式：调用Arrays的静态方法asList,形参为可变形参，返回ArrayList</span><br><span class="line"><span class="type">Collection</span> <span class="variable">coll1</span> <span class="operator">=</span> Arrays.asList(<span class="number">123</span>,<span class="number">456</span>);</span><br><span class="line">System.out.println(coll.containsAll(coll1));</span><br><span class="line"><span class="type">Collection</span> <span class="variable">coll2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">coll2.add(<span class="number">123</span>);</span><br><span class="line">coll2.add(<span class="number">456</span>);</span><br><span class="line">coll2.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Jerry&quot;</span>,<span class="number">20</span>));</span><br><span class="line">System.out.println(coll.containsAll(coll2));</span><br></pre></td></tr></table></figure>
</li>
<li><p>remove(Object obj)</p>
<p>从当前集合中移除obj元素。无返回值，直接修改当前集合元素</p>
<p>同样调用equals方法，查找是否存在此元素</p>
<p>coll.remove(1234);</p>
</li>
<li><p>removeAll(Collection coll1)</p>
<p>差集：从当前集合中移除coll1中所有的元素。移除该集合与形参集合交集部分。也是调用equals方法，查找是否存在此元素，</p>
</li>
<li><p>retainAll(Collection coll1)</p>
<p>交集：获取当前集合和coll1集合的交集，并返回给当前集合。将两集合交集替换当前集合元素</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Collection</span> <span class="variable">coll1</span> <span class="operator">=</span> Arrays.asList(<span class="number">123</span>,<span class="number">456</span>,<span class="number">789</span>);</span><br><span class="line">   coll.retainAll(coll1);  </span><br><span class="line">     System.out.println(coll); <span class="comment">//123,456</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>equals(Object obj)</p>
<p>要想返回true，需要当前集合和形参集合的元素都相同（加入顺序和集合元素都是相同的）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Collection</span> <span class="variable">coll1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">coll1.add(<span class="number">123</span>);</span><br><span class="line">coll1.add(<span class="number">456</span>);</span><br><span class="line"><span class="type">Collection</span> <span class="variable">coll2</span> <span class="operator">=</span> Arrays.asList(<span class="number">123</span>,<span class="number">456</span>);</span><br><span class="line">System.out.println(coll.equals(coll2));</span><br></pre></td></tr></table></figure>
</li>
<li><p>hashCode()</p>
<p>返回当前对象的哈希值</p>
</li>
<li><p>集合 —&gt;数组：  toArray()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Object[] arr = coll.toArray();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; arr.length;i++)&#123;</span><br><span class="line">    System.out.println(arr[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>拓展：数组 —&gt;集合:调用Arrays类的静态方法asList(T…..t)   形参为对象的可变形参，看做一个个对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;AA&quot;</span>, <span class="string">&quot;BB&quot;</span>, <span class="string">&quot;CC&quot;</span>&#125;);</span><br><span class="line">System.out.println(list);</span><br><span class="line"></span><br><span class="line"><span class="type">List</span> <span class="variable">arr1</span> <span class="operator">=</span> Arrays.asList(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">123</span>, <span class="number">456</span>&#125;);</span><br><span class="line">System.out.println(arr1.size());<span class="comment">//1 这int数组看做一个对象，所以里面只有 1 </span></span><br><span class="line"></span><br><span class="line"><span class="type">List</span> <span class="variable">arr2</span> <span class="operator">=</span> Arrays.asList(<span class="keyword">new</span> <span class="title class_">Integer</span>[]&#123;<span class="number">123</span>, <span class="number">456</span>&#125;);</span><br><span class="line">System.out.println(arr2.size());<span class="comment">//2  这Integer数组内部成员可看成一个个对象，所以为 2 </span></span><br></pre></td></tr></table></figure>
</li>
<li><p>iterator( ）    迭代器</p>
<p>返回Iterator接口的实例，用于遍历集合元素。放在IteratorTest.java中测试——下一结介绍</p>
</li>
</ol>
<h3 id="1-3iterator-迭代器接口"><a href="#1-3iterator-迭代器接口" class="headerlink" title="1.3iterator 迭代器接口"></a>1.3iterator 迭代器接口</h3><h4 id="1-iterator-）-迭代器"><a href="#1-iterator-）-迭代器" class="headerlink" title="1.iterator(） 迭代器"></a>1.iterator(） 迭代器</h4><p><strong>Collection中的方法：iterator( ）    迭代器</strong></p>
<p>返回Iterator接口的实例，<strong>用于遍历集合元素。用于集合元素的遍历操作</strong>，使用迭代器Iterator接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Collection</span> <span class="variable">coll</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">coll.add(<span class="number">123</span>);</span><br><span class="line">coll.add(<span class="number">456</span>);</span><br><span class="line"><span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> coll.iterator();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>Iterator接口介绍：</strong></p>
<ol>
<li><p>内部的方法：</p>
<p>hasNext() ： 判断是否还有下一个元素</p>
<p>  next()   ：①指针下移 ②将下移以后集合位置上的元素返回</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">一般使用方式：用于遍历集合   </span><br><span class="line">    <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> coll.iterator();</span><br><span class="line">       <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">           System.out.println(iterator.next());</span><br><span class="line">   </span><br></pre></td></tr></table></figure>
</li>
<li><p>集合对象每次调用iterator()方法都得到一个全新的迭代器对象，默认游标都在集合的第一个元素之前。</p>
</li>
<li><p>内部定义了remove(),可以在遍历的时候，删除集合中的元素。此方法不同于集合直接调用remove()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除集合中&quot;Tom&quot;</span></span><br><span class="line"><span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> coll.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">     <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;Tom&quot;</span>.equals(obj))&#123; 防止空指针，将Tom放外面</span><br><span class="line">            iterator.remove();</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">错误方式：</span><br><span class="line">如果还未调用next()或在上一次调用 next 方法之后已经调用了 remove 方法，再调用remove都会报IllegalStateException。</span><br><span class="line"> <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> coll.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line"> 错误一：    iterator.remove();</span><br><span class="line">            <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&quot;Tom&quot;</span>.equals(obj))&#123;</span><br><span class="line"> 错误二：        iterator.remove();</span><br><span class="line">                iterator.remove();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">   </span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="2-foreach循环"><a href="#2-foreach循环" class="headerlink" title="2.foreach循环"></a>2.foreach循环</h4><p>jdk 5.0 新增了forEach循环（或增强for循环），用于遍历集合、数组</p>
<ol>
<li><p>格式：for(集合元素的类型 局部变量 : 集合对象)        </p>
</li>
<li><p>内部仍然调用了迭代器。（循环过程：集合对象从内部调用迭代器判断并获取，将元素<strong>赋给</strong>局部变量）       </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(Object obj : coll)&#123;</span><br><span class="line">        System.out.println(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    <span class="comment">//for(数组元素的类型 局部变量 : 数组对象)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i : arr)&#123;</span><br><span class="line">    <span class="comment">//i = 3; 修改i不能真正修改集合中元素</span></span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="1-4List接口实现类及方法"><a href="#1-4List接口实现类及方法" class="headerlink" title="1.4List接口实现类及方法"></a>1.4List接口实现类及方法</h3><h4 id="1-三者实现类的比较"><a href="#1-三者实现类的比较" class="headerlink" title="1.三者实现类的比较"></a>1.三者实现类的比较</h4><p><strong>面试题：</strong>ArrayList、LinkedList、Vector三者的异同？</p>
<p><strong>相同：</strong>三个类都是实现了List接口，存储数据的特点相同：存储有序的、可重复的数据</p>
<p><strong>补充使用须知：三者添加的数据，其所在的类一定要重写equals( ) 方法（原因：比如说调用Collection接口中的contains()时会调用所在类的equals，没有重写则会调用Object中的equals，即&#x3D;&#x3D;）</strong></p>
<p><strong>不同：</strong></p>
<ol>
<li>ArrayList：作为List接口的主要实现类；线程不安全的，效率高；底层使用Object[] elementData存储</li>
<li>LinkedList：对于频繁的插入、删除操作，使用此类效率比ArrayList高；底层使用双向链表存储</li>
<li>Vector：作为List接口的古老实现类；线程安全的，效率低；底层使用Object[] elementData存储</li>
</ol>
<p><strong>三者源码深入分析：</strong></p>
<p><strong>一、ArrayList的源码分析：</strong></p>
<p><strong>1.jdk 7情况下</strong></p>
<ol>
<li><p>ArrayList list &#x3D; new ArrayList();</p>
<p><strong>&#x2F;&#x2F;底层创建了长度是10的Object[]数组elementData</strong></p>
<p>list.add(123);    &#x2F;&#x2F;<strong>底层：elementData[0] &#x3D; new Integer(123);</strong></p>
<p>…</p>
<p>list.add(11);&#x2F;&#x2F;<strong>如果此次的添加导致底层elementData数组容量不够，则扩容。</strong></p>
<p><strong>默认情况下，扩容为原来的容量的1.5倍，同时需要将原有数组中的数据复制到新的数组中。</strong></p>
<p><strong>结论：建议开发中使用带参的构造器：ArrayList list &#x3D; new ArrayList(int capacity)</strong></p>
</li>
</ol>
<p><strong>2.jdk 8中ArrayList的变化：</strong></p>
<ol>
<li><p>ArrayList list &#x3D; new ArrayList();</p>
<p>&#x2F;&#x2F;<strong>底层Object[] elementData初始化为{}.并没有创建长度为10的数组</strong></p>
<p>list.add(123);&#x2F;<strong>&#x2F;第一次调用add()时，底层才创建了长度10的数组，并将数据123添加到elementData[0]</strong></p>
<p>…</p>
<p><strong>后续的添加和扩容操作与jdk 7 无异。</strong></p>
</li>
</ol>
<p><strong>小结：jdk7中的ArrayList的对象的创建类似于单例的饿汉式，而jdk8中的ArrayList的对象的创建类似于单例的懒汉式，延迟了数组的创建，节省内存。</strong></p>
<p><strong>二、LinkedList的源码分析：</strong></p>
<ol>
<li><p>LinkedList list &#x3D; new LinkedList(); 内部声明了Node类型的first和last属性，默认值为null</p>
<p>list.add(123);&#x2F;&#x2F;将123封装到Node中，创建了Node对象。其中，Node定义为：体现了LinkedList的双向链表的说法</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">底层源码：</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt; &#123;</span><br><span class="line">    E item;</span><br><span class="line">     Node&lt;E&gt; next;</span><br><span class="line">     Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">     Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">     <span class="built_in">this</span>.item = element;</span><br><span class="line">     <span class="built_in">this</span>.next = next;</span><br><span class="line">     <span class="built_in">this</span>.prev = prev;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>三、Vector的源码分析：</strong></p>
<p>jdk7和jdk8中通过Vector()构造器创建对象时，底层都创建了长度为10的数组。</p>
<p>在扩容方面，默认扩容为原来的数组长度的2倍。</p>
<h4 id="2-List接口中常用方法"><a href="#2-List接口中常用方法" class="headerlink" title="2.List接口中常用方法"></a>2.List接口中常用方法</h4><ol>
<li><p>void add(int index, Object ele)</p>
<p>在index位置插入ele元素</p>
<p>list.add(1,”BB”);</p>
</li>
<li><p>boolean addAll(int index, Collection eles)</p>
<p>从index位置开始将eles中的所有元素添加进来</p>
<p> List list1 &#x3D; Arrays.asList(1, 2, 3);</p>
<p>list.addAll(list1);   不写index默认为0</p>
</li>
<li><p>Object get(int index)</p>
<p>获取指定index位置的元素</p>
</li>
<li><p>int indexOf(Object obj)</p>
<p>返回obj在集合中首次出现的位置</p>
</li>
<li><p>int lastIndexOf(Object obj)</p>
<p>返回obj在当前集合中末次出现的位置</p>
</li>
<li><p>Object remove(int index)</p>
<p>移除指定index位置的元素，并返回此元素</p>
</li>
<li><p>Object set(int index, Object ele)</p>
<p>设置指定index位置的元素为ele</p>
</li>
<li><p>List subList(int fromIndex, int toIndex)</p>
<p>返回从fromIndex到toIndex位置的子集合</p>
</li>
<li><p>总结：常用方法<br>增：add(Object obj)<br>删：List接口：remove(int index) &#x2F; Collection接口：remove(Object obj)<br>改：set(int index, Object ele)<br>查：get(int index)<br>插：add(int index, Object ele)<br>长度：size()<br>遍历：① Iterator迭代器方式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> list.iterator();</span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">    System.out.println(iterator.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​             ② 增强for循环</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(Object obj : list)&#123;</span><br><span class="line">    System.out.println(obj);</span><br><span class="line">&#125;         </span><br></pre></td></tr></table></figure></li>
</ol>
<p>​                     ③ 普通的循环</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; list.size();i++)&#123;</span><br><span class="line">    System.out.println(list.get(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-5Set接口及实现类介绍"><a href="#1-5Set接口及实现类介绍" class="headerlink" title="1.5Set接口及实现类介绍"></a>1.5Set接口及实现类介绍</h3><h4 id="1-三个实现类介绍"><a href="#1-三个实现类介绍" class="headerlink" title="1.三个实现类介绍"></a>1.三个实现类介绍</h4><p>Collection接口：单列集合，用来存储一个一个的对象</p>
<p>Collection接口子Set接口：<strong>存储无序的、不可重复的数据</strong>   –&gt;高中讲的“集合”</p>
<p><strong>使用须知：HashSet、LinkedHashSet添加的数据，其所在的类一定要重写hashCode()和equals()。TreeSet则需要重写compareTo或compare方法</strong></p>
<p><strong>说明：</strong></p>
<ol>
<li><p>HashSet：<strong>作为Set接口的主要实现类；线程不安全的；可以存储null值</strong></p>
<p>补充：new HashSet()其实底层是new HashMap() , 但是Set是单列Map是双列，所以用key来保存HashSet元素，value用一个常量来暂时隐蔽起来</p>
</li>
<li><p>LinkedHashSet：作为HashSet的子类；遍历其内部数据时，可以按照添加的顺序遍历</p>
<p>LinkedHashSet的使用<br><strong>LinkedHashSet作为HashSet的子类，在添加数据的同时，每个数据还维护了两个引用，记录此数据前一个数据和后一个数据。</strong>（因此该类迭代效率高于HashSet）<br>优点：对于频繁的遍历操作，LinkedHashSet效率高于HashSet</p>
<p>底层图示：</p>
<p><img src="/2022/10/04/Java%E9%AB%98%E7%BA%A7-%E9%9B%86%E5%90%88-%E6%B3%9B%E5%9E%8B-IO%E6%B5%81/Snipaste_2022-02-02_20-12-36.png" alt="Snipaste_2022-02-02_20-12-36"></p>
</li>
<li><p>TreeSet：<strong>可以按照添加对象的指定属性，进行排序。遍历时可有序遍历</strong></p>
<ol>
<li><p><strong>向TreeSet中添加的数据，要求是同一个类的对象。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">TreeSet</span> <span class="variable">set</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeSet</span>();</span><br><span class="line">set.add(<span class="number">34</span>);</span><br><span class="line">set.add(-<span class="number">34</span>);</span><br><span class="line">set.add(<span class="number">43</span>);</span><br><span class="line">set.add(<span class="number">11</span>);</span><br><span class="line">set.add(<span class="number">8</span>)；输出：按照从从小到大输出</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>TreeSet对属性进行排序使用两种排序方式</strong>：自然排序（实现Comparable接口） 和 定制排序（Comparator）</p>
<p>1.自然排序中，比较两个对象是否相同的标准为：compareTo()返回0.不再是equals()，<strong>该类要求实现Comparable接口，重写compareTo</strong></p>
<p><img src="/2022/10/04/Java%E9%AB%98%E7%BA%A7-%E9%9B%86%E5%90%88-%E6%B3%9B%E5%9E%8B-IO%E6%B5%81/image-20220320101407300.png" alt="image-20220320101407300"></p>
<p>2.定制排序中，比较两个对象是否相同的标准为：compare()返回0.不再是equals()，<strong>TreeSet有形参为Comparator的构造器</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Comparator</span> <span class="variable">com</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Comparator</span>() &#123;</span><br><span class="line">    <span class="comment">//按照年龄从小到大排列</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object o1, Object o2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(o1 <span class="keyword">instanceof</span> User &amp;&amp; o2 <span class="keyword">instanceof</span> User)&#123;</span><br><span class="line">            <span class="type">User</span> <span class="variable">u1</span> <span class="operator">=</span> (User)o1;</span><br><span class="line">            <span class="type">User</span> <span class="variable">u2</span> <span class="operator">=</span> (User)o2;</span><br><span class="line">            <span class="keyword">return</span> Integer.compare(u1.getAge(),u2.getAge());</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;输入的数据类型不匹配&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">TreeSet</span> <span class="variable">set</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeSet</span>(com);</span><br><span class="line">set.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Tom&quot;</span>,<span class="number">12</span>));</span><br><span class="line">set.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Jerry&quot;</span>,<span class="number">32</span>));</span><br><span class="line">set.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Jim&quot;</span>,<span class="number">2</span>));</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h4 id="2-Set接口介绍"><a href="#2-Set接口介绍" class="headerlink" title="2.Set接口介绍"></a>2.Set接口介绍</h4><p><strong>Set接口使用说明：</strong></p>
<ol>
<li><p><strong>Set接口中没有额外定义新的方法，使用的都是Collection中声明过的方法。</strong></p>
</li>
<li><p>要求：向Set(主要指：HashSet、LinkedHashSet)中<strong>添加的数据，其所在的类一定要重写hashCode()和equals()</strong></p>
</li>
<li><p>要求：重写的hashCode()和equals()尽可能保持一致性：相等的对象必须具有相等的散列码（一般用自动生成）</p>
</li>
<li><p>重写两个方法的小技巧：对象中用作 equals() 方法比较的 Field，都应该用来计算 hashCode 值。<br>​</p>
<p><strong>一、Set：存储无序的、不可重复的数据</strong><br>以HashSet为例说明：</p>
<ol>
<li><strong>无序性</strong>：不等于随机性。存储的数据在底层数组中并非按照数组索引的顺序添加，而是根据数据的哈希值决定的。</li>
<li><strong>不可重复性</strong>：保证添加的元素按照equals()判断时，不能返回true.即：相同的元素只能添加一个。</li>
</ol>
<p><strong>二、添加元素的过程介绍两个特性：以HashSet为例：</strong></p>
<p>我们向HashSet中添加元素a,首先调用元素a所在类的hashCode()方法，计算元素a的哈希值，此哈希值接着通过某种算法计算出在HashSet底层数组中的存放位置（即为：索引位置），判断数组此位置上是否已经有元素：</p>
<p>1.如果此位置上没有其他元素，则元素a添加成功。 —&gt;情况1<br>2.如果此位置上有其他元素b(或以链表形式存在的多个元素），则比较元素a与元素b的hash值：</p>
<ol>
<li>如果hash值不相同，则元素a添加成功。—&gt;情况2</li>
<li>如果hash值相同，进而需要调用元素a所在类的equals()方法：<ol>
<li>equals()返回true,元素a添加失败</li>
<li>equals()返回false,则元素a添加成功。—&gt;情况3</li>
</ol>
</li>
</ol>
<p><strong>过程总结：先计算hashcode，将元素按某种算法算出下标填入数组，如有重复则进行比较两者hashcode值</strong>（<strong>若不等则就以链表形式一起存在该数组下标，若相等则用equals方法继续比较，还相等则不要，否则就要</strong></p>
<p><strong>—-小结：hashcode相等两者不一定相等，但两者相等，hashcode一定相等</strong></p>
<p><strong>—补充特例：首先添加元素为1，后又通过地址修改元素为2，在添加一个元素为2，此时的hashcode值是不同，有位置就直接存入数组了，就存在相同元素了</strong>）</p>
<p>对于添加成功的情况2和情况3而言：元素a 与已经存在指定索引位置上数据以链表的方式存储。</p>
<p>jdk 7 :元素a放到数组中，指向原来的元素。<br>jdk 8 :原来的元素在数组中，指向元素a<br>总结：七上八下</p>
<p>HashSet底层：数组+链表的结构。</p>
</li>
</ol>
<h3 id="1-6Map的实现类及理解"><a href="#1-6Map的实现类及理解" class="headerlink" title="1.6Map的实现类及理解"></a>1.6Map的实现类及理解</h3><h4 id="1-Map的实现类的结构："><a href="#1-Map的实现类的结构：" class="headerlink" title="1.Map的实现类的结构："></a>1.Map的实现类的结构：</h4><p>Map:<strong>双列数据，存储key-value对的数据</strong>   —类似于高中的函数：y &#x3D; f(x)</p>
<ol>
<li><p>HashMap:<strong>作为Map的主要实现类；线程不安全的，效率高；存储null的key和value</strong></p>
</li>
<li><p>LinkedHashMap<strong>继承于</strong>HashMap:<strong>保证在遍历map元素时，可以按照添加的顺序实现遍历。</strong></p>
<p>原因：在原有的HashMap底层结构基础上，添加了一对指针，指向前一个和后一个元素。</p>
<p>对于频繁的遍历操作，此类执行效率高于HashMap。</p>
</li>
<li><p>TreeMap:<strong>保证按照添加的key-value对进行排序，实现排序遍历。此时考虑key的自然排序或定制排序。底层使用红黑树</strong></p>
</li>
<li><p>Hashtable:作为古老（出现早）的实现类<strong>；线程安全的，效率低；不能存储null的key和value</strong></p>
</li>
<li><p>Properties<strong>继承于</strong>Hashtable:<strong>常用来处理配置文件。key和value都是String类型</strong></p>
</li>
</ol>
<p>HashMap的底层：数组+链表  （jdk7及之前）</p>
<p>数组+链表+红黑树 （jdk 8）</p>
<p>面试题：</p>
<p>HashMap的底层实现原理？</p>
<p>HashMap 和 Hashtable的异同？</p>
<p>CurrentHashMap 与 Hashtable的异同？（暂时不讲）</p>
<h4 id="2-Map结构的理解："><a href="#2-Map结构的理解：" class="headerlink" title="2.Map结构的理解："></a>2.Map结构的理解：</h4><p>通俗理解：高中的函数：key &#x3D; x  value &#x3D; y;  x 可是无序的，但不能重复，y也可是无序的，但可以重复（二次函数多个x对一个y)</p>
<ol>
<li><p>Map中的key:<strong>无序的、不可重复的，使用Set存储所有的key  —&gt; key所在的类要重写equals()和hashCode() （以HashMap为例）</strong></p>
</li>
<li><p>Map中的value:<strong>无序的、可重复的，使用Collection存储所有的value —&gt;value所在的类要重写equals()</strong></p>
</li>
<li><p><strong>一个键值对：key-value构成了一个Entry对象。</strong></p>
</li>
<li><p><strong>Map中的entry:无序的、不可重复的，使用Set存储所有的entry</strong></p>
</li>
<li><p>Entry将键值对的对应关系封装成了对象，即键值对对象，这样我们在遍历Map集合时，就可以从每一个键值对（Entry）对象中获取对应的键与对应的值。</p>
<p><strong>Entry静态内部嵌套接口，修饰为静态可以通过类名调用。</strong></p>
<p><strong>Entry中方法：getKey()和getValue(),获取键值对</strong></p>
</li>
<li><p>图示：</p>
<p><img src="/2022/10/04/Java%E9%AB%98%E7%BA%A7-%E9%9B%86%E5%90%88-%E6%B3%9B%E5%9E%8B-IO%E6%B5%81/Snipaste_2022-02-03_10-41-34.png" alt="Snipaste_2022-02-03_10-41-34"></p>
</li>
</ol>
<h4 id="3-HashMap底层实现原理"><a href="#3-HashMap底层实现原理" class="headerlink" title="3.HashMap底层实现原理"></a>3.HashMap底层实现原理</h4><p>面试题：<strong>HashMap的底层实现原理？以jdk7为例说明：</strong></p>
<ol>
<li><p>HashMap map &#x3D; new HashMap()</p>
<p>在实例化以后，底层创建了长度是16的一维数组Entry[] table。</p>
<p>…可能已经执行过多次put…</p>
</li>
<li><p>map.put(key1,value1)</p>
<p>首先，调用key1所在类的hashCode()计算key1哈希值，此哈希值经过某种算法计算以后，得到在Entry数组中的存放位置。</p>
<p>1.如果此位置上的数据为空，此时的key1-value1添加成功。 —-情况1</p>
<p>2.如果此位置上的数据不为空，(意味着此位置上存在一个或多个数据(以链表形式存在)),<strong>比较key1和已经存在的一个或多个数据的哈希值：</strong></p>
<ol>
<li>如果key1的哈希值与已经存在的数据的哈希值都不相同，此时key1-value1添加成功。—-情况2</li>
<li>如果key1的哈希值和已经存在的某一个数据(key2-value2)的哈希值相同，继续比较：<strong>调用key1所在类的equals(key2)方法，比较：</strong><ol>
<li>如果equals()返回false:此时key1-value1添加成功。—-情况3</li>
<li><strong>如果equals()返回true:使用value1替换value2。put因此也有修改的作用</strong></li>
</ol>
</li>
<li>补充：关于情况2和情况3：此时key1-value1和原来的数据以链表的方式存储。</li>
</ol>
</li>
</ol>
<p><strong>扩容问题：</strong></p>
<p>在不断的添加过程中，会涉及到扩容问题，当超出临界值(且要存放的位置非空–凌临界值不等于数组长度)时，扩容。默认的扩容方式：<strong>扩容为原来容量的2倍，并将原有的数据复制过来</strong>。</p>
<p><strong>jdk8 相较于jdk7在底层实现方面的不同：</strong></p>
<ol>
<li><p>new HashMap():<strong>底层没有创建一个长度为16的数组</strong></p>
</li>
<li><p>jdk 8底层的数组是：Node[],而非Entry[]</p>
</li>
<li><p><strong>首次调用put()方法时，底层创建长度为16的数组</strong></p>
</li>
<li><p><strong>jdk7底层结构只有：数组+链表。jdk8中底层结构：数组+链表+红黑树。</strong></p>
<p>4.1 形成链表时，<strong>七上八下（jdk7:新的元素指向旧的元素。jdk8：旧的元素指向新的元素）</strong></p>
<p>4.2 <strong>当数组的某一个索引位置上的元素以链表形式存在的数据个数 &gt; 8 且当前数组的长度 &gt; 64（如小于64则转为扩容）时，此时此索引位置上的所数据改为使用红黑树存储。</strong></p>
</li>
</ol>
<p><strong>底层代码的关键常量：</strong></p>
<ol>
<li>DEFAULT_INITIAL_CAPACITY : HashMap的默认容量，16</li>
<li>DEFAULT_LOAD_FACTOR：HashMap的默认加载因子：0.75</li>
<li>threshold：<strong>扩容的临界值</strong>，&#x3D;容量*填充因子：16 * 0.75 &#x3D;&gt; 12</li>
<li>TREEIFY_THRESHOLD：Bucket中链表长度大于该默认值，转化为红黑树:8</li>
<li>MIN_TREEIFY_CAPACITY：桶中的Node被树化时最小的hash表容量:64</li>
</ol>
<h4 id="4-LinkedHashMap的底层实现原理（了解）"><a href="#4-LinkedHashMap的底层实现原理（了解）" class="headerlink" title="4.LinkedHashMap的底层实现原理（了解）"></a>4.LinkedHashMap的底层实现原理（了解）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> 源码中：</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">HashMap</span>.Node&lt;K,V&gt; &#123;</span><br><span class="line">Entry&lt;K,V&gt; before, after;<span class="comment">//能够记录添加的元素的先后顺序</span></span><br><span class="line"> Entry(<span class="type">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">              <span class="built_in">super</span>(hash, key, value, next);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h4 id="5-TreeMap实现类使用"><a href="#5-TreeMap实现类使用" class="headerlink" title="5.TreeMap实现类使用"></a>5.TreeMap实现类使用</h4><p>向TreeMap中添加key-value，要求key必须是由同一个类创建的对象<br>因为要按照key进行排序：自然排序 、定制排序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自然排序：在User重写compareTo方法</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">TreeMap</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeMap</span>();</span><br><span class="line">    <span class="type">User</span> <span class="variable">u1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Tom&quot;</span>,<span class="number">23</span>);</span><br><span class="line">    <span class="type">User</span> <span class="variable">u2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Jerry&quot;</span>,<span class="number">32</span>);</span><br><span class="line">    <span class="type">User</span> <span class="variable">u3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Jack&quot;</span>,<span class="number">20</span>);</span><br><span class="line">    <span class="type">User</span> <span class="variable">u4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Rose&quot;</span>,<span class="number">18</span>);</span><br><span class="line"></span><br><span class="line">    map.put(u1,<span class="number">98</span>);</span><br><span class="line">    map.put(u2,<span class="number">89</span>);</span><br><span class="line">    map.put(u3,<span class="number">76</span>);</span><br><span class="line">    map.put(u4,<span class="number">100</span>);<span class="comment">//添加类型一致</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//定制排序</span></span><br><span class="line">  <span class="type">TreeMap</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeMap</span>(<span class="keyword">new</span> <span class="title class_">Comparator</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object o1, Object o2)</span> &#123;</span><br><span class="line">         <span class="keyword">if</span>(o1 <span class="keyword">instanceof</span> User &amp;&amp; o2 <span class="keyword">instanceof</span> User)&#123;</span><br><span class="line">             <span class="type">User</span> <span class="variable">u1</span> <span class="operator">=</span> (User)o1;</span><br><span class="line">             <span class="type">User</span> <span class="variable">u2</span> <span class="operator">=</span> (User)o2;</span><br><span class="line">            <span class="keyword">return</span> Integer.compare(u1.getAge(),u2.getAge());</span><br><span class="line">                &#125;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;输入的类型不匹配！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>





<h4 id="6-Properties实现类子类的使用"><a href="#6-Properties实现类子类的使用" class="headerlink" title="6.Properties实现类子类的使用"></a>6.Properties实现类子类的使用</h4><p>Properties:常用来处理配置文件。key和value都是String类型</p>
<p>配置文件：是一种计算机文件，可以为一些计算机程序配置参数和初始设置。”</p>
<p>配置文件的创建：一般创建在整个工程下，创建File 后缀名为properties，也可直接点击Resource  Bundle 创建自动添加后缀名</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先做简单了解：</span></span><br><span class="line"><span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">Properties</span> <span class="variable">pros</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line"></span><br><span class="line">    fis = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;jdbc.properties&quot;</span>);</span><br><span class="line">    pros.load(fis);<span class="comment">//加载流对应的文件</span></span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;name = &quot;</span> + name + <span class="string">&quot;, password = &quot;</span> + password);</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h3 id="1-7Map接口中常用方法"><a href="#1-7Map接口中常用方法" class="headerlink" title="1.7Map接口中常用方法"></a>1.7Map接口中常用方法</h3><h4 id="1-添加、删除、修改操作："><a href="#1-添加、删除、修改操作：" class="headerlink" title="1.添加、删除、修改操作："></a>1.添加、删除、修改操作：</h4><ol>
<li><p>Object put(Object key,Object value)</p>
<p>将指定key-value<strong>添加到(或修改)当前map对象中</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"><span class="comment">//添加</span></span><br><span class="line">map.put(<span class="string">&quot;AA&quot;</span>,<span class="number">123</span>);</span><br><span class="line">map.put(<span class="number">45</span>,<span class="number">123</span>);</span><br><span class="line">map.put(<span class="string">&quot;BB&quot;</span>,<span class="number">56</span>);</span><br><span class="line"><span class="comment">//修改</span></span><br><span class="line">map.put(<span class="string">&quot;AA&quot;</span>,<span class="number">87</span>); <span class="comment">//只看key，如果有相同，则替换为新加的</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>void putAll(Map m)</p>
<p>将m中的所有key-value对存放到当前map中</p>
</li>
<li><p>Object remove(Object key)</p>
<p>移除指定key的key-value对，并返回value</p>
</li>
<li><p>void clear()</p>
<p>清空当前map中的所有数据</p>
</li>
</ol>
<h4 id="2-元素查询的操作："><a href="#2-元素查询的操作：" class="headerlink" title="2.元素查询的操作："></a>2.元素查询的操作：</h4><ol>
<li><p>Object get(Object key)</p>
<p><strong>获取指定key对应的value</strong></p>
</li>
<li><p>boolean containsKey(Object key)</p>
<p>是否包含指定的key</p>
</li>
<li><p>boolean containsValue(Object value)</p>
<p><strong>是否包含指定的value</strong></p>
</li>
<li><p>int size()</p>
<p>返回map中key-value对的个数</p>
</li>
<li><p>boolean isEmpty()</p>
<p>判断当前map是否为空</p>
</li>
<li><p>boolean equals(Object obj)</p>
<p>判断当前map和参数对象obj是否相等</p>
</li>
</ol>
<h4 id="3-元视图及遍历操作"><a href="#3-元视图及遍历操作" class="headerlink" title="3.元视图及遍历操作"></a>3.元视图及遍历操作</h4><p>元视图操作(能够单独取出key集或value集或key-value集)的方法：</p>
<ol>
<li><p>Set keySet()：返回所有key构成的Set集合</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        map.put(<span class="string">&quot;AA&quot;</span>,<span class="number">123</span>);</span><br><span class="line">        map.put(<span class="number">45</span>,<span class="number">1234</span>);</span><br><span class="line">        map.put(<span class="string">&quot;BB&quot;</span>,<span class="number">56</span>);</span><br><span class="line"><span class="comment">//遍历所有的key集：keySet()</span></span><br><span class="line"><span class="type">Set</span> <span class="variable">set</span> <span class="operator">=</span> map.keySet();</span><br><span class="line">    <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> set.iterator();</span><br><span class="line">    <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">        System.out.println(iterator.next());</span><br></pre></td></tr></table></figure>
</li>
<li><p>Collection values()：返回所有value构成的Collection集合</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历所有的value集：values()</span></span><br><span class="line"><span class="type">Collection</span> <span class="variable">values</span> <span class="operator">=</span> map.values();</span><br><span class="line"><span class="keyword">for</span>(Object obj : values)&#123;</span><br><span class="line">    System.out.println(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Set entrySet()：返回所有key-value对构成的Set集合</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历所有的key-value</span></span><br><span class="line"><span class="comment">//方式一：entrySet()</span></span><br><span class="line"><span class="type">Set</span> <span class="variable">entrySet</span> <span class="operator">=</span> map.entrySet();</span><br><span class="line"><span class="type">Iterator</span> <span class="variable">iterator1</span> <span class="operator">=</span> entrySet.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator1.hasNext())&#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> iterator1.next();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//entrySet集合中的元素都是entry：一个key一个value</span></span><br><span class="line">    Map.<span class="type">Entry</span> <span class="variable">entry</span> <span class="operator">=</span> (Map.Entry) obj; <span class="comment">//强转</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//getKey()getValue()为entry接口内部静态方法</span></span><br><span class="line">    System.out.println(entry.getKey() + <span class="string">&quot;----&gt;&quot;</span> + entry.getValue());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//方式二：利用keySet()和Map中get()配合</span></span><br><span class="line">        <span class="type">Set</span> <span class="variable">keySet</span> <span class="operator">=</span> map.keySet(); 取出集合key</span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">iterator2</span> <span class="operator">=</span> keySet.iterator();</span><br><span class="line">        <span class="keyword">while</span>(iterator2.hasNext())&#123;</span><br><span class="line">           <span class="type">Object</span> <span class="variable">key</span> <span class="operator">=</span> iterator2.next();</span><br><span class="line">           <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> map.get(key);<span class="comment">//key对应value</span></span><br><span class="line">          System.out.println(key + <span class="string">&quot;=====&quot;</span> + value);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="4-总结：常用方法"><a href="#4-总结：常用方法" class="headerlink" title="4.总结：常用方法"></a>4.总结：常用方法</h4><ul>
<li>添加：put(Object key,Object value)</li>
<li>删除：remove(Object key)</li>
<li>修改：put(Object key,Object value)</li>
<li>查询：get(Object key)</li>
<li>长度：size()</li>
<li>遍历：keySet() &#x2F; values() &#x2F; entrySet()</li>
</ul>
<h3 id="1-8Collections工具类"><a href="#1-8Collections工具类" class="headerlink" title="1.8Collections工具类"></a>1.8Collections工具类</h3><h4 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h4><p>Collections 是一个操作Set、List、和Map等集合的工具类。类似于操作数组的工具类：Arrays，其内部方法都是静态方法</p>
<h4 id="2-常用方法"><a href="#2-常用方法" class="headerlink" title="2.常用方法"></a>2.常用方法</h4><p>Collections:操作Collection、Map的工具类</p>
<p>面试题：Collection 和 Collections的区别？</p>
<ol>
<li><p>void  reverse(List)</p>
<p>反转 List 中元素的顺序</p>
</li>
<li><p>void shuffle(List)</p>
<p>对 List 集合元素进行<strong>随机排序</strong></p>
</li>
<li><p>void  sort(List)    <strong>自然排序</strong></p>
<p>根据元素的自然顺序对指定 List 集合元素按升序排序</p>
</li>
<li><p>void  sort(List，Comparator)    <strong>定制排序</strong></p>
<p>根据指定的 Comparator 产生的顺序对 List 集合元素进行排序</p>
</li>
<li><p>void  swap(List，int， int)</p>
<p>将指定 list 集合中的 i 处元素和 j 处元素进行交换</p>
</li>
<li><p>Object max(Collection)</p>
<p>根据元素的<strong>自然顺序</strong>，返回给定集合中的最大元素</p>
</li>
<li><p>Object max(Collection，Comparator)</p>
<p>根据 Comparator <strong>指定的顺序</strong>，返回给定集合中的最大元素</p>
</li>
<li><p>Object min(Collection)</p>
</li>
<li><p>Object min(Collection，Comparator)</p>
</li>
<li><p>int frequency(Collection，Object)</p>
<p>返回指定集合中指定元素的出现次数</p>
</li>
<li><p>void copy(List dest,List src)</p>
<p>将src中的内容复制到dest中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//        List dest = new ArrayList();</span></span><br><span class="line"><span class="comment">//        Collections.copy(dest,list);</span></span><br><span class="line"><span class="comment">//报异常：IndexOutOfBoundsException(&quot;Source does not fit in dest&quot;)内部需要list.size()&lt;=dest.size()才能复制</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//正确的：利用工具类Arrays中asList将一个list.size()数组作为形参建一个的神态</span></span><br><span class="line">  <span class="type">List</span> <span class="variable">dest</span> <span class="operator">=</span> Arrays.asList(<span class="keyword">new</span> <span class="title class_">Object</span>[list.size()]);</span><br><span class="line">        System.out.println(dest.size());<span class="comment">//list.size();</span></span><br><span class="line">        Collections.copy(dest,list);</span><br><span class="line"></span><br><span class="line">        System.out.println(dest);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>boolean replaceAll(List list，Object oldVal，Object newVal)</p>
<p>使用新值替换 List 对象的所有旧值</p>
</li>
<li><p>ArrayList 和 HashMap 都是线程不安全的，如果程序要求线程安全，我们<strong>可以将ArrayList、HashMap转换线程安全的。</strong></p>
<p>使用<strong>synchronizedList(List  list) 和 synchronizedMap(Map  map)</strong></p>
</li>
</ol>
<h1 id="二、泛型"><a href="#二、泛型" class="headerlink" title="二、泛型"></a>二、泛型</h1><h3 id="2-1为什么要有泛型"><a href="#2-1为什么要有泛型" class="headerlink" title="2.1为什么要有泛型"></a>2.1为什么要有泛型</h3><p><strong>1.生活中例子</strong></p>
<p>举例：     泛型：标签</p>
<ol>
<li>中药店，每个抽屉外面贴着标签</li>
<li>超市购物架上很多瓶子，每个瓶子装的是什么，有标签</li>
</ol>
<p><strong>2.泛型的理解</strong></p>
<ol>
<li>把元素的类型设计成一个参数，这个<strong>类型参数</strong>叫做<strong>泛型</strong></li>
<li>所谓泛型，就是允许<strong>在定义类、接口时通过一个标识</strong>表示类中某个<strong>属性的类型</strong>或者是某个<strong>方法的返回值</strong>及<strong>参数类型</strong>。</li>
<li>这个类型参数将在使用时（例如，继<strong>承或实现这个接口，用这个类型声明变量、创建对象</strong>时）确定（即传入实际的类型参数，也称为类型实参）。</li>
</ol>
<p><strong>3.那么为什么要有泛型呢，直接Object不是也可以存储数据吗？</strong></p>
<ol>
<li>解决元素存储的安全性问题，好比商品、药品标签，不会弄错。</li>
<li>解决获取数据元素时，需要类型强制转换的问题，好比不用每回拿商品、药品都要辨别。</li>
<li>Java泛型可以保证如果程序在编译时没有发出警告，运行时就不会产生ClassCastException异常。同时，代码更加简洁、健壮。</li>
<li>由于数据类型的不确定性，因此使用泛型，提高代码的复用性</li>
</ol>
<h3 id="2-2集合中使用泛型"><a href="#2-2集合中使用泛型" class="headerlink" title="2.2集合中使用泛型"></a>2.2集合中使用泛型</h3><p>泛型的使用：jdk 5.0新增的特性</p>
<ol>
<li><p>在集合没有泛型之前出现的问题：</p>
<ul>
<li>问题一：添加数据时，有统一类型的需要，类型可以不一致的集合成为缺点</li>
<li>问题二：需要强转时，可能会出现类型转换异常ClassCastException</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ArrayList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        <span class="comment">//需求：存放学生的成绩</span></span><br><span class="line">        list.add(<span class="number">78</span>);</span><br><span class="line">        list.add(<span class="number">76</span>);</span><br><span class="line">        list.add(<span class="number">89</span>);</span><br><span class="line">        list.add(<span class="number">88</span>);</span><br><span class="line">        <span class="comment">//问题一：类型不安全</span></span><br><span class="line"><span class="comment">//        list.add(&quot;Tom&quot;);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(Object score : list)&#123;</span><br><span class="line">            <span class="comment">//问题二：强转时，可能出现ClassCastException</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">stuScore</span> <span class="operator">=</span> (Integer) score;</span><br><span class="line"></span><br><span class="line">            System.out.println(stuScore);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>使用泛型后，会将这些问题解决。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> ArrayList&lt;Integer&gt; list =  <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">        list.add(<span class="number">78</span>);</span><br><span class="line">        list.add(<span class="number">87</span>);</span><br><span class="line">        list.add(<span class="number">99</span>);</span><br><span class="line">        list.add(<span class="number">65</span>);</span><br><span class="line">        <span class="comment">//编译时，就会进行类型检查，保证数据的安全</span></span><br><span class="line"><span class="comment">//        list.add(&quot;Tom&quot;);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//方式一：直接声明为Integer</span></span><br><span class="line">        <span class="keyword">for</span>(Integer score : list)&#123;</span><br><span class="line">            <span class="comment">//避免了强转操作</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">stuScore</span> <span class="operator">=</span> score;</span><br><span class="line"></span><br><span class="line">            System.out.println(stuScore);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//方式二：Iterator也是声明泛型接口</span></span><br><span class="line">        Iterator&lt;Integer&gt; iterator = list.iterator();</span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">stuScore</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">            System.out.println(stuScore);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>集合接口或集合类在jdk5.0时都修改为带泛型的结构。</p>
</li>
<li><p>在实例化集合类时，可以指明具体的泛型类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; list =  <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br></pre></td></tr></table></figure>
</li>
<li><p>如有声明多个泛型，则用逗号隔开。以Map接口中key - value为例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String,Integer&gt;();</span><br></pre></td></tr></table></figure>
</li>
<li><p>泛型可嵌套—遍历操作</p>
<p>有泛型的遍历操作：entrySet()返回所有key-value对构成的Set集合</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Map.Entry&lt;String,Integer&gt;&gt; entry = map.entrySet();</span><br><span class="line">Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; iterator = entry.iterator();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">    Map.Entry&lt;String, Integer&gt; e = iterator.next();</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> e.getKey();</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">value</span> <span class="operator">=</span> e.getValue();</span><br><span class="line">    System.out.println(key + <span class="string">&quot;----&quot;</span> + value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>指明完以后，在集合类或接口中凡是定义类或接口时，内部结构（比如：方法、构造器、属性等）使用到类的泛型的位置，都指定为实例化的泛型类型。</p>
<p>比如：内部结构：add(E e)  —&gt;实例化以后：使用时：add(Integer e)</p>
</li>
<li><p><strong>注意点：泛型的类型必须是类，不能是基本数据类型。</strong>需要用到基本数据类型的位置，拿包装类替换</p>
</li>
<li><p>如果实例化时，没有指明泛型的类型。默认类型为java.lang.Object类型。</p>
</li>
</ol>
<h3 id="2-3自定义泛型结构"><a href="#2-3自定义泛型结构" class="headerlink" title="2.3自定义泛型结构"></a>2.3自定义泛型结构</h3><p>可自定义泛型类、泛型接口、泛型方法</p>
<h4 id="1-自定义泛型类注意点"><a href="#1-自定义泛型类注意点" class="headerlink" title="1.自定义泛型类注意点"></a>1.自定义泛型类注意点</h4><ol>
<li><p>泛型类可能有多个参数，此时应将多个参数一起放在尖括号内。比如：&lt;E1,E2,E3&gt;</p>
</li>
<li><p>泛型类的声明构造器时不需要加<E>声明</E></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">GenericClass</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//错误的：public GenericClass&lt;E&gt;()&#123;&#125;</span></span><br></pre></td></tr></table></figure>

<p>形参中是可以用的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">T info ;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(T info)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.info = info; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p><strong>实例化后，操作原来泛型位置的结构必须与指定的泛型类型一致。</strong></p>
</li>
<li><p><strong>泛型不同的引用不能相互赋值。</strong>尽管在编译时ArrayList<String>和ArrayList<Integer>是两种类型，但是，在运行时只有一个ArrayList被加载到JVM中。</Integer></String></p>
</li>
<li><p><strong>泛型如果不指定，将被擦除，泛型对应的类型均按照Object处理，但不等价于Object。</strong></p>
<p>经验：泛型要使用一路都用。要不用，一路都不要用。</p>
</li>
<li><p>如果泛型结构是一个接口或抽象类，则不可创建泛型类的对象。</p>
<p>本质是接口和抽象类不能实例化，但是能做声明时使用–多态性</p>
</li>
<li><p>jdk1.7，泛型的简化操作：ArrayList<Fruit> flist &#x3D; new ArrayList&lt;&gt;();</Fruit></p>
</li>
<li><p>泛型的指定中不能使用基本数据类型，可以使用包装类替换。</p>
</li>
<li><p><strong>在类&#x2F;接口上声明的泛型，在本类或本接口中即代表某种类型，可以作为非静态属性的类型、非静态方法的参数类型、非静态方法的返回值类型。</strong></p>
<p>但在<strong>静态方法中不能使用类的泛型</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(T orderT)</span>&#123;  <span class="comment">//编译不通过</span></span><br><span class="line"><span class="comment">//        System.out.println(orderT);</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>异常类不能是泛型的</strong></p>
<p>错误的：try{ } catch(T e){ }</p>
</li>
<li><p><strong>不能直接使用new E[]。</strong></p>
<p>但是可以：E[] elements &#x3D; (E[])new Object[capacity];</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编译不通过</span></span><br><span class="line">T[] arr = <span class="keyword">new</span> <span class="title class_">T</span>[<span class="number">10</span>];</span><br><span class="line"><span class="comment">//编译通过</span></span><br><span class="line">T[] arr = (T[]) <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">10</span>];</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>参考：ArrayList源码中声明：Object[] elementData，而非泛型参数类型数组。</p>
</li>
<li><p><strong>父类有泛型，子类可以选择保留泛型也可以选择指定泛型类型：</strong></p>
<p>1.子类不保留父类的泛型：按需实现</p>
<ol>
<li><p>没有类型 擦除</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span>  <span class="keyword">extends</span> <span class="title class_">Father</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等价于class Son extends Father&lt;Object,Object&gt;&#123;    &#125;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span>&lt;T&gt;  <span class="keyword">extends</span> <span class="title class_">Father</span>&#123;  <span class="comment">//自已定义自己用</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>具体类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Son2</span> <span class="keyword">extends</span> <span class="title class_">Father</span>&lt;Integer, String&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son2</span>&lt;A, B&gt; <span class="keyword">extends</span> <span class="title class_">Father</span>&lt;Integer, String&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;   <span class="comment">//自已定义自己用</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>2.子类保留父类的泛型：泛型子类</p>
<ol>
<li><p>全部保留</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Son3</span>&lt;T1, T2&gt; <span class="keyword">extends</span> <span class="title class_">Father</span>&lt;T1, T2&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son3</span>&lt;T1, T2, A, B&gt; <span class="keyword">extends</span> <span class="title class_">Father</span>&lt;T1, T2&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;   <span class="comment">//自已定义多余的自己用</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>部分保留</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Son4</span>&lt;T2&gt; <span class="keyword">extends</span> <span class="title class_">Father</span>&lt;Integer, T2&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son4</span>&lt;T2, A, B&gt; <span class="keyword">extends</span> <span class="title class_">Father</span>&lt;Integer, T2&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;    <span class="comment">//自已定义多余的自己用</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>结论：子类必须是“富二代”，子类除了指定或保留父类的泛型，还可以增加自己的泛型。</p>
<p><strong>使用细节：父类有泛型时</strong></p>
<ol>
<li><p><strong>子类不保留的泛型，则在继承时父类一定要指明泛型类型，父类中用该泛型声明的变量也就确定了，进而子类继承的是指明后的父类</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Son4</span> <span class="keyword">extends</span> <span class="title class_">Father</span>&lt; String&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>子类保留的泛型，则在继承时只需写出泛型形式<T></T></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Son4</span>&lt;T2&gt; <span class="keyword">extends</span> <span class="title class_">Father</span>&lt; T2&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;     </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son4</span>&lt;T2&gt; <span class="keyword">extends</span> <span class="title class_">Father</span>&lt;Integer, T2&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h4 id="2-自定义泛型方法"><a href="#2-自定义泛型方法" class="headerlink" title="2.自定义泛型方法"></a>2.自定义泛型方法</h4><p>如下的方法都不是泛型方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">getOrderT</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> orderT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setOrderT</span><span class="params">(T orderT)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.orderT = orderT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>泛型方法：</p>
<ol>
<li><p>在方法中出现了泛型的结构，泛型参数与类的泛型参数没有任何关系。</p>
<p>换句话说，<strong>泛型方法所属的类是不是泛型类都没有关系。</strong></p>
</li>
<li><p>泛型方法，<strong>可以声明为静态的。</strong></p>
<p>原因：泛型参数是在调用方法时确定的。并非在实例化类时确定。</p>
<ul>
<li>自定义泛型类中，泛型声明在类的声明中，可提供给属性，非静态方法使用，在new本类对象时指明就不会出错</li>
<li>自定义泛型类中，泛型方法声明在方法声明中，泛型方法所属的类是不是泛型类都没有关系，所以<strong>泛型方法可以是静态的也可以是非静态的</strong>，泛型参数是在调用方法时确定的。并非在实例化类时确定。</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//格式如下：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt;  List&lt;E&gt; <span class="title function_">copyFromArrayToList</span><span class="params">(E[] arr)</span>&#123; </span><br><span class="line"></span><br><span class="line">    ArrayList&lt;E&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(E e : arr)&#123;</span><br><span class="line">        list.add(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-4泛型在继承方面的体现"><a href="#2-4泛型在继承方面的体现" class="headerlink" title="2.4泛型在继承方面的体现"></a>2.4泛型在继承方面的体现</h3><ol>
<li><p>虽然类A是类B的父类，但是G<A> 和G<B>二者不具备子父类关系，二者是并列关系。</B></A></p>
</li>
<li><p>面向对象–具有子父类关系的可以相互赋值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">   <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">   obj = str;</span><br><span class="line">   </span><br><span class="line">   Object[] arr1 = <span class="literal">null</span>;</span><br><span class="line">   String[] arr2 = <span class="literal">null</span>;</span><br><span class="line">   arr1 = arr2; </span><br></pre></td></tr></table></figure>

<p>以下使用情况–二者是并列关系。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Object&gt; list1 = <span class="literal">null</span>;</span><br><span class="line">List&lt;String&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line"><span class="comment">//此时的list1和list2的类型不具有子父类关系</span></span><br><span class="line"><span class="comment">//编译不通过</span></span><br><span class="line"><span class="comment">//    list1 = list2;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>补充：类A是类B的父类，A<G> 是 B<G> 的父类</G></G></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list2 = <span class="literal">null</span>;</span><br><span class="line">ArrayList&lt;String&gt; list3 = <span class="literal">null</span>;</span><br><span class="line">   list2 = list3;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="2-5通配符的使用"><a href="#2-5通配符的使用" class="headerlink" title="2.5通配符的使用"></a>2.5通配符的使用</h3><p>1.出现背景</p>
<p>由于泛型不体现多态性，在调用方法方法形参和实参只能一对一，因此引入通配符，多个不同泛型对象可以使用一个通配符，这样就这可实现一个方法对多个对象了</p>
<p>2.说明</p>
<p>  通配符：?</p>
<p>  类A是类B的父类，G<A>和G<B>是没有关系的，二者共同的父类是：G&lt;?&gt;</B></A></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    List&lt;Object&gt; list1 = <span class="literal">null</span>;</span><br><span class="line">    List&lt;String&gt; list2 = <span class="literal">null</span>;</span><br><span class="line">    List&lt;?&gt; list = <span class="literal">null</span>;</span><br><span class="line">    list = list1;</span><br><span class="line">    list = list2;</span><br><span class="line">    <span class="comment">//编译通过</span></span><br><span class="line"><span class="comment">//    print(list1);</span></span><br><span class="line"><span class="comment">//    print(list2);</span></span><br><span class="line"><span class="comment">//此print方法声明：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(List&lt;?&gt; list)</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​     </p>
<p>3.使用通配符声明后的操作说明</p>
<ol>
<li><p><strong>添加(写入)：对于List&lt;?&gt;就不能向其内部添加数据。</strong></p>
<p>除了添加null之外。</p>
<p>list.add(“DD”);</p>
<p>list.add(‘?’);</p>
<p>list.add(null);</p>
</li>
<li><p><strong>获取(读取)：允许读取数据，读取的数据类型为Object</strong>。<br>Object o &#x3D; list.get(0);<br>System.out.println(o);</p>
</li>
</ol>
<p>4.有限制条件的通配符的使用</p>
<ol>
<li><p>? extends A:      理解：? &lt;&#x3D;  A  小于等于</p>
<p>G&lt;? extends A&gt; 可以作为G<A>和G<B>的父类，其中B是A的子类</B></A></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;? <span class="keyword">extends</span> <span class="title class_">Person</span>&gt; list1 = <span class="literal">null</span>;</span><br><span class="line">List&lt;Student&gt; list3 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Student&gt;();</span><br><span class="line">List&lt;Person&gt; list4 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Person&gt;();</span><br><span class="line">List&lt;Object&gt; list5 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Object&gt;();</span><br><span class="line">list1 = list3;</span><br><span class="line">list1 = list4</span><br></pre></td></tr></table></figure>
</li>
<li><p>? super A:         理解：? &gt;&#x3D;  A  大于等于</p>
<p>G&lt;? super A&gt; 可以作为G<A>和G<B>的父类，其中B是A的父类</B></A></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;? <span class="built_in">super</span> Person&gt; list2 = <span class="literal">null</span>;</span><br><span class="line">list2 = list4;</span><br><span class="line">list2 = list5;</span><br></pre></td></tr></table></figure>
</li>
<li><p>有限制条件通配符读取和写入数据 </p>
<p>读取数据：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> List&lt;? <span class="keyword">extends</span> <span class="title class_">Person</span>&gt; list1 = <span class="literal">null</span>;</span><br><span class="line"> List&lt;? <span class="built_in">super</span> Person&gt; list2 = <span class="literal">null</span>;</span><br><span class="line"> List&lt;Student&gt; list3 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Student&gt;();</span><br><span class="line"> List&lt;Person&gt; list4 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Person&gt;();</span><br><span class="line"> List&lt;Object&gt; list5 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Object&gt;();</span><br><span class="line"> list1 = list3;</span><br><span class="line"> <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> list1.get(<span class="number">0</span>);</span><br><span class="line"> <span class="comment">//编译不通过:返回值小于等于Person，因此用Person接收</span></span><br><span class="line">    <span class="comment">//Student s = list1.get(0);</span></span><br><span class="line">    list2 = list4;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> list2.get(<span class="number">0</span>);</span><br><span class="line">`</span><br><span class="line">    <span class="comment">//编译不通过：返回值大于等于Person，因此用Object接收</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">//Person obj = list2.get(0);</span></span><br></pre></td></tr></table></figure>

<p>写入数据：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编译不通过：list1不能写入数据，由于父类不能赋给子类，而？ extend A 小于等于A 所以当？是Student的子类不能赋Student</span></span><br><span class="line"><span class="comment">//  list1.add(new Student());</span></span><br><span class="line"><span class="comment">//编译通过：list2都可以写，由于大于等于，所以？是Person或Person的父类，所以可以赋Person和Person的子类</span></span><br><span class="line"> list2.add(<span class="keyword">new</span> <span class="title class_">Person</span>());</span><br><span class="line"> list2.add(<span class="keyword">new</span> <span class="title class_">Student</span>());</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="三、IO流"><a href="#三、IO流" class="headerlink" title="三、IO流"></a>三、IO流</h2><h3 id="3-1File类的使用"><a href="#3-1File类的使用" class="headerlink" title="3.1File类的使用"></a>3.1File类的使用</h3><h4 id="1-介绍-1"><a href="#1-介绍-1" class="headerlink" title="1.介绍"></a>1.介绍</h4><ol>
<li>File类的一个对象，代表一个文件或一个文件目录(俗称：文件夹)</li>
<li>File类声明在java.io包下</li>
<li>File类中涉及到关于文件或文件目录的创建、删除、重命名、修改时间、文件大小等方法，并未涉及到写入或读取文件内容的操作。如果需要读取或写入文件内容，必须使用IO流来完成。后续File类的对象常会作为参数传递到流的构造器中，指明读取或写入的”终点”.</li>
</ol>
<h4 id="2-构造器介绍"><a href="#2-构造器介绍" class="headerlink" title="2.构造器介绍"></a>2.构造器介绍</h4><p><strong>1.两种路径说明</strong></p>
<ol>
<li><p>相对路径：相较于某个路径下，指明的路径。</p>
<p>File file1 &#x3D; new File(“hello.txt”);</p>
</li>
<li><p>绝对路径：包含盘符在内的文件或文件目录的路径</p>
<p>File file2 &#x3D;  new File(“D:\workspace_idea1\JavaSenior\day08\he.txt”);</p>
</li>
</ol>
<p>相对路径说明：</p>
<p>IDEA中：开发中使用JUnit单元测试方法测试，相对路径即为当前Module下。如果使用main( ) 测试，相对路径即为当前的Project下。</p>
<p>Eclipse中：不管使用单元测试还是使用main( ) 测试，相对路径都是当前的Project</p>
<p><strong>2.路径分隔符</strong><br> windows: \ <br> unix: &#x2F;</p>
<p> <strong>3.如何创建File类的实例</strong></p>
<ol>
<li><p>File(String filePath)—构造器1</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">file1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;hello.txt&quot;</span>);<span class="comment">//相对于当前module</span></span><br><span class="line"><span class="type">File</span> <span class="variable">file2</span> <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\workspace_idea1\\JavaSenior\\day08\\he.txt&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>File(String parentPath,String childPath)—构造器2</p>
<p>File file3 &#x3D; new File(“D:\workspace_idea1”,”JavaSenior”);</p>
</li>
<li><p>File(File parentFile,String childPath)—构造器3</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">File file4 = new File(file3,&quot;hi.txt&quot;);</span><br><span class="line">   </span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="3-File中的常用方法"><a href="#3-File中的常用方法" class="headerlink" title="3.File中的常用方法"></a>3.File中的常用方法</h4><p><strong>1.获取File基本信息</strong></p>
<ol>
<li><p>public String getAbsolutePath()</p>
<p>获取绝对路径</p>
</li>
<li><p>public String getPath() </p>
<p>获取路径</p>
</li>
<li><p>public String getName() </p>
<p>获取名称</p>
</li>
<li><p>public String getParent()</p>
<p>获取上层文件目录路径。若无，返回null</p>
</li>
<li><p>public long length() </p>
<p>获取文件长度（即：字节数）。不能获取目录的长度。</p>
</li>
<li><p>public long lastModified() </p>
<p>获取最后一次的修改时间，毫秒值–可用Date接收显示</p>
</li>
</ol>
<p><strong>2.获取文件目录</strong></p>
<ol>
<li>public String[] list() ：获取指定目录下的所有文件或者文件目录的名称数组</li>
<li>public File[] listFiles() ：获取指定目录下的所有文件或者文件目录的File数组</li>
</ol>
<p><strong>3.重命名文件路径</strong></p>
<p> public boolean renameTo(File dest):把文件重命名为指定的文件路径</p>
<p>比如：file1.renameTo(file2)为例：要想保证返回true,需要file1在硬盘中是存在的，且file2不能在硬盘中存在。</p>
<p><strong>4.判断File基本信息</strong></p>
<ol>
<li>public boolean isDirectory()：判断是否是文件目录</li>
<li>public boolean isFile() ：判断是否是文件</li>
<li>public boolean exists() ：判断是否存在</li>
<li>public boolean canRead() ：判断是否可读</li>
<li>public boolean canWrite() ：判断是否可写</li>
<li>public boolean isHidden() ：判断是否隐藏</li>
</ol>
<p><strong>5.创建硬盘中对应的文件或文件目录</strong></p>
<ol>
<li><p>public  boolean createNewFile() —会报异常</p>
<p>创建文件。若文件存在，则不创建，返回false</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">file1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;hi.txt&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(!file1.exists())&#123;</span><br><span class="line">     <span class="comment">//文件的创建</span></span><br><span class="line">     file1.createNewFile();</span><br><span class="line">     System.out.println(<span class="string">&quot;创建成功&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>public boolean mkdir() </p>
<p>创建文件目录。如果此文件目录存在，就不创建了。<strong>如果此文件目录的上层目录不存在，也不创建。</strong></p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//文件目录的创建</span></span><br><span class="line"><span class="type">File</span> <span class="variable">file1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:\\io\\io1\\io3&quot;</span>);</span><br><span class="line"> <span class="type">boolean</span> <span class="variable">mkdir</span> <span class="operator">=</span> file1.mkdir();</span><br><span class="line">  <span class="keyword">if</span>(mkdir)&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;创建成功1&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol>
<li><p>public boolean mkdirs() </p>
<p>创建文件目录。如果此文件目录存在，就不创建了。<strong>如果上层文件目录不存在，一并创建</strong></p>
</li>
</ol>
<p><strong>6.删除磁盘中的文件或文件目录</strong></p>
<p>public boolean delete()：删除文件或者文件夹</p>
<p>删除注意事项：</p>
<ol>
<li>Java中的删除不走回收站。</li>
<li>删除目录：只能删除空目录，该目录下不能有子目录或文件</li>
</ol>
<h3 id="3-2-IO原理及流的分类"><a href="#3-2-IO原理及流的分类" class="headerlink" title="3.2 IO原理及流的分类"></a>3.2 IO原理及流的分类</h3><h4 id="1-IO原理介绍"><a href="#1-IO原理介绍" class="headerlink" title="1.IO原理介绍"></a>1.IO原理介绍</h4><ol>
<li>I&#x2F;O是Input&#x2F;Output的缩写， I&#x2F;O技术是非常实用的技术，<strong>用于处理设备之间的数据传输</strong>。如读&#x2F;写文件，网络通讯等。</li>
<li>Java程序中，对于数据的输入&#x2F;输出操作以“流(stream)” 的方式进行。</li>
<li>java.io包下提供了各种“流”类和接口，用以获取不同种类的数据，并<strong>通过标准的方法</strong>输入或输出数据</li>
<li>输入（读入）input：<strong>读取外部数据</strong>（磁盘、光盘等存储设备的数据）<strong>到程序（内存）中</strong>。</li>
<li>输出（写出）output：<strong>将程序（内存）数据输出到磁盘、光盘等存储设备</strong>中</li>
</ol>
<h4 id="2-流的分类"><a href="#2-流的分类" class="headerlink" title="2.流的分类"></a>2.流的分类</h4><p><strong>1.流的分类</strong></p>
<ol>
<li><p>按操作<strong>数据单位</strong>不同分为：字节流(8 bit)，字符流(16 bit)</p>
<p>字节流：是操作进制数表示的数据（如：图片）</p>
<p>字符流：是来操作字符数据（如：文件）</p>
</li>
<li><p>按数据流的<strong>流向</strong>不同分为：输入流，输出流</p>
</li>
<li><p>按流的<strong>角色</strong>的不同分为：节点流，处理流</p>
<p>节点流：直接操作流的传输</p>
<p>处理流：对流的传输加以修饰（如：加速传输）</p>
</li>
</ol>
<p><strong>图示：在操作中的位置</strong></p>
<p><img src="/2022/10/04/Java%E9%AB%98%E7%BA%A7-%E9%9B%86%E5%90%88-%E6%B3%9B%E5%9E%8B-IO%E6%B5%81/Snipaste_2022-02-06_20-59-41.png" alt="Snipaste_2022-02-06_20-59-41"></p>
<p><strong>字节流和字符流使用结论：</strong></p>
<ol>
<li>对于文本文件(.txt,.java,.c,.cpp)，使用字符流处理</li>
<li>对于非文本文件(.jpg,.mp3,.mp4,.avi,.doc,.ppt,…)，使用字节流处理</li>
<li><strong>如果只是单纯的复制文本文件，字节流也可处理，只不过用字符流更高效</strong></li>
</ol>
<p><strong>2.流的体系结构</strong></p>
<p>一、Java的IO流共涉及40多个类，实际上非常规则，<strong>都是从如下4个抽象基类派生的。</strong></p>
<table>
<thead>
<tr>
<th>抽象基类</th>
<th>字节流</th>
<th>字符流</th>
</tr>
</thead>
<tbody><tr>
<td>输入流</td>
<td>InputStream</td>
<td>Reader</td>
</tr>
<tr>
<td>输出流</td>
<td>OutputStream</td>
<td>Writer</td>
</tr>
</tbody></table>
<p>二、由这四个类派生出来的子类名称都是以其父类名作为子类名后缀</p>
<p><img src="/2022/10/04/Java%E9%AB%98%E7%BA%A7-%E9%9B%86%E5%90%88-%E6%B3%9B%E5%9E%8B-IO%E6%B5%81/Snipaste_2022-02-07_21-34-55.png" alt="Snipaste_2022-02-07_21-34-55"></p>
<p>三、列举最基本的流</p>
<p>抽象基类</p>
<ol>
<li>InputStream</li>
<li>OutputStream</li>
<li>Reader</li>
<li>Writer</li>
</ol>
<p>节点流（或文件流） –后加使用时对应的读写方法</p>
<ol>
<li>FileInputStream  (read(byte[] buffer))</li>
<li>FileOutputStream    (write(byte[] buffer,0,len)</li>
<li>FileReader    (read(char[] cbuf))</li>
<li>FileWriter    (write(char[] cbuf,0,len)</li>
</ol>
<p>缓冲流（处理流的一种）–后加使用时对应的读写方法</p>
<ol>
<li>BufferedInputStream    (read(byte[] buffer))</li>
<li>BufferedOutputStream    (write(byte[] buffer,0,len) &#x2F; flush()</li>
<li>BufferedReader    (read(char[] cbuf) &#x2F; readLine())</li>
<li>BufferedWriter    (write(char[] cbuf,0,len) &#x2F; flush()</li>
</ol>
<h3 id="3-3节点流-或文件流"><a href="#3-3节点流-或文件流" class="headerlink" title="3.3节点流(或文件流)"></a>3.3节点流(或文件流)</h3><h4 id="1-共有四种节点流"><a href="#1-共有四种节点流" class="headerlink" title="1.共有四种节点流"></a>1.共有四种节点流</h4><ol>
<li><p>字节流读入写出</p>
<p>FileInputStream  ： (read(byte[] buffer))          </p>
<p>FileOutputStream  ：(write(byte[] buffer,0,len)  </p>
</li>
<li><p>字符流读入写出</p>
<p>FileReader ：(read(char[] cbuf))                 </p>
<p>FileWriter： (write(char[] cbuf,0,len))</p>
</li>
</ol>
<h4 id="2-字符流读写演示"><a href="#2-字符流读写演示" class="headerlink" title="2.字符流读写演示"></a>2.字符流读写演示</h4><p>读写方法：</p>
<ol>
<li>read()返回Ascll码值，没有返回-1&#x2F;writer(String str)</li>
<li>read(char[] cbuf)&#x2F;write(char[] cbuf,0,len) – 常用这个</li>
</ol>
<p><strong>1.FileReader</strong></p>
<p><strong>说明点：</strong></p>
<ol>
<li>read()的理解：返回读入的一个字符。如果达到文件末尾，返回-1</li>
<li>异常的处理：为了保证流资源一定可以执行关闭操作。需要使用try-catch-finally处理</li>
<li>读入的文件一定要存在，否则就会报FileNotFoundException。</li>
</ol>
<p>代码及步骤演示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">一般不使用read（）空参方法，而是使用带参重载的</span><br><span class="line"></span><br><span class="line"><span class="comment">//将day09下的hello.txt文件内容读入程序中，并输出到控制台</span></span><br><span class="line"><span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.实例化File类的对象，指明要操作的文件</span></span><br><span class="line">            <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;hello.txt&quot;</span>);<span class="comment">//相较于当前Module</span></span><br><span class="line">            <span class="comment">//2.提供具体的流</span></span><br><span class="line">            fr = <span class="keyword">new</span> <span class="title class_">FileReader</span>(file);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//3.数据的读入</span></span><br><span class="line">            <span class="comment">//read():返回读入的一个字符。如果达到文件末尾，返回-1   </span></span><br><span class="line">            <span class="type">int</span> data;</span><br><span class="line">            <span class="keyword">while</span>((data = fr.read()) != -<span class="number">1</span>)&#123;</span><br><span class="line">                System.out.print((<span class="type">char</span>)data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//4.流的关闭操作</span></span><br><span class="line">            <span class="keyword">if</span>(fr != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fr.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>由于上述对操作每次只读一个字符速度过慢，可使用read()操作升级：使用read的重载方法read(char[] cbuf)读入字符数组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"> 对read()操作升级：使用read的重载方法</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFileReader1</span><span class="params">()</span>  &#123;</span><br><span class="line">        <span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.File类的实例化</span></span><br><span class="line">            <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//2.FileReader流的实例化</span></span><br><span class="line">            fr = <span class="keyword">new</span> <span class="title class_">FileReader</span>(file);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//3.读入的操作</span></span><br><span class="line">            <span class="comment">//read(char[] cbuf):返回每次读入cbuf数组中的字符的个数。如果达到文件末尾，返回-1</span></span><br><span class="line"> 由于最后读入的数据可能不超过<span class="number">5</span>，防止最后输出之前输出过的数据，所以用len记录个数便于输出</span><br><span class="line">            <span class="type">char</span>[] cbuf = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">5</span>];</span><br><span class="line">            <span class="type">int</span> len;</span><br><span class="line">            <span class="keyword">while</span>((len = fr.read(cbuf)) != -<span class="number">1</span>)&#123;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//正确的写法--for循环</span></span><br><span class="line"><span class="comment">//                for(int i = 0;i &lt; len;i++)&#123;</span></span><br><span class="line"><span class="comment">//                    System.out.print(cbuf[i]);</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line">   </span><br><span class="line">                <span class="comment">//正确的写法--使用String给的构造器</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(cbuf,<span class="number">0</span>,len);</span><br><span class="line">                System.out.print(str);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(fr != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="comment">//4.资源的关闭</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fr.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p><strong>2.FileWriter</strong></p>
<p><strong>说明：</strong></p>
<ol>
<li>输出操作，对应的File可以不存在的。并不会报异常</li>
<li>File对应的硬盘中的文件如果不存在，在输出的过程中，会自动创建此文件。</li>
<li>File对应的硬盘中的文件如果存在：<ol>
<li>如果流使用的构造器是：FileWriter(file,false) &#x2F; FileWriter(file):对原有文件的覆盖</li>
<li>如果流使用的构造器是：FileWriter(file,true):不会对原有文件覆盖，而是在原有文件基础上追加内容</li>
</ol>
</li>
</ol>
<p>代码演示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从内存中写出数据到硬盘的文件里。</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFileWriter</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//1.提供File类的对象，指明写出到的文件</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;hello1.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.提供FileWriter的对象，用于数据的写出</span></span><br><span class="line">        fw = <span class="keyword">new</span> <span class="title class_">FileWriter</span>(file,<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.写出的操作</span></span><br><span class="line">        fw.write(<span class="string">&quot;I have a dream!\n&quot;</span>);</span><br><span class="line">        fw.write(<span class="string">&quot;you need to have a dream!&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//4.流资源的关闭</span></span><br><span class="line">        <span class="keyword">if</span>(fw != <span class="literal">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fw.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>3.复制文本数据操作</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFileReaderFileWriter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.创建File类的对象，指明读入和写出的文件</span></span><br><span class="line">            <span class="type">File</span> <span class="variable">srcFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line">            <span class="type">File</span> <span class="variable">destFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;hello2.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//不能使用字符流来处理图片等字节数据</span></span><br><span class="line"><span class="comment">//            File srcFile = new File(&quot;爱情与友情.jpg&quot;);</span></span><br><span class="line"><span class="comment">//            File destFile = new File(&quot;爱情与友情1.jpg&quot;);</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//2.创建输入流和输出流的对象</span></span><br><span class="line">            fr = <span class="keyword">new</span> <span class="title class_">FileReader</span>(srcFile);</span><br><span class="line">            fw = <span class="keyword">new</span> <span class="title class_">FileWriter</span>(destFile);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//3.数据的读入和写出操作</span></span><br><span class="line">            <span class="type">char</span>[] cbuf = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">5</span>];</span><br><span class="line">            <span class="type">int</span> len;<span class="comment">//记录每次读入到cbuf数组中的字符的个数</span></span><br><span class="line">            <span class="keyword">while</span>((len = fr.read(cbuf)) != -<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">//每次写出len个字符</span></span><br><span class="line">                fw.write(cbuf,<span class="number">0</span>,len);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//4.关闭流资源</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(fw != <span class="literal">null</span>)</span><br><span class="line">                    fw.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(fr != <span class="literal">null</span>)</span><br><span class="line">                    fr.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="3-字节流读入演示"><a href="#3-字节流读入演示" class="headerlink" title="3.字节流读入演示"></a>3.字节流读入演示</h4><p>读写方法：</p>
<p>read(byte[] buffer)   和  write(byte[] buffer,0,len)</p>
<h5 id="1-FileInputStream"><a href="#1-FileInputStream" class="headerlink" title="1.FileInputStream"></a>1.FileInputStream</h5><p> FileOutputStream操作在复制图片演示</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用字节流FileInputStream处理文本文件，可能出现乱码。</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFileInputStream</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//1. 造文件</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.造流</span></span><br><span class="line">        fis = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.读数据</span></span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">5</span>];</span><br><span class="line">        <span class="type">int</span> len;<span class="comment">//记录每次读取的字节的个数</span></span><br><span class="line">        <span class="keyword">while</span>((len = fis.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(buffer,<span class="number">0</span>,len);</span><br><span class="line">            System.out.print(str);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(fis != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//4.关闭资源</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fis.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="2-复制图片数据"><a href="#2-复制图片数据" class="headerlink" title="2.复制图片数据"></a>2.复制图片数据</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFileInputOutputStream</span><span class="params">()</span>  &#123;</span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">srcFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;爱情与友情.jpg&quot;</span>);</span><br><span class="line">        <span class="type">File</span> <span class="variable">destFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;爱情与友情2.jpg&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        fis = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(srcFile);</span><br><span class="line">        fos = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(destFile);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//复制的过程</span></span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">5</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span>((len = fis.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            fos.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(fos != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(fis != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fis.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="3-4缓冲流-处理流之一"><a href="#3-4缓冲流-处理流之一" class="headerlink" title="3.4缓冲流(处理流之一)"></a>3.4缓冲流(处理流之一)</h3><h4 id="1-共有四种缓冲流"><a href="#1-共有四种缓冲流" class="headerlink" title="1.共有四种缓冲流"></a>1.共有四种缓冲流</h4><p>1.缓冲流（处理流的一种）–后加使用时对应的读写方法</p>
<ol>
<li>BufferedInputStream    (read(byte[] buffer))</li>
<li>BufferedOutputStream    (write(byte[] buffer,0,len) &#x2F; flush()</li>
<li>BufferedReader    (read(char[] cbuf) &#x2F; readLine())</li>
<li>BufferedWriter    (write(char[] cbuf,0,len) &#x2F; flush()</li>
</ol>
<p>flush() : 刷新缓冲区 —writer内部方法已经调用为加速写出，这里只作了解</p>
<p>readLine() : 读入一行文本数据，但不自动换行，以下是换行方法</p>
<ol>
<li>readLine(流 + “\n”)</li>
<li>在使用后调用一次newLine()</li>
</ol>
<p>2.作用：提供流的读取、写入的速度</p>
<p>提高读写速度的原因：内部提供了一个缓冲区</p>
<p>3.处理流，就是“套接”在已有的流的基础上。</p>
<h4 id="2-复制非文本文件"><a href="#2-复制非文本文件" class="headerlink" title="2.复制非文本文件"></a>2.复制非文本文件</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">实现非文本文件的复制 BufferedInputStream和BufferedOutputStream </span><br><span class="line">   </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">BufferedStreamTest</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        <span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.造文件</span></span><br><span class="line">            <span class="type">File</span> <span class="variable">srcFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;爱情与友情.jpg&quot;</span>);</span><br><span class="line">            <span class="type">File</span> <span class="variable">destFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;爱情与友情3.jpg&quot;</span>);</span><br><span class="line">            <span class="comment">//2.造流</span></span><br><span class="line">            <span class="comment">//2.1 造节点流</span></span><br><span class="line">      <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>((srcFile));</span><br><span class="line">      <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(destFile);</span><br><span class="line">            <span class="comment">//2.2 造缓冲流</span></span><br><span class="line">            bis = <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(fis);</span><br><span class="line">            bos = <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(fos);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//3.复制的细节：读取、写入</span></span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">10</span>];</span><br><span class="line">            <span class="type">int</span> len;</span><br><span class="line">            <span class="keyword">while</span>((len = bis.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">                bos.write(buffer,<span class="number">0</span>,len);</span><br><span class="line"><span class="comment">//                bos.flush();//刷新缓冲区--不需要调用</span></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//4.资源关闭</span></span><br><span class="line">            <span class="comment">//要求：先关闭外层的流，再关闭内层的流</span></span><br><span class="line">            <span class="keyword">if</span>(bos != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    bos.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(bis != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    bis.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//说明：关闭外层流的同时，内层流也会自动的进行关闭。关于内层流的关闭，我们可以省略.</span></span><br><span class="line"><span class="comment">//        fos.close();</span></span><br><span class="line"><span class="comment">//        fis.close();</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h4 id="3-复制文本文件"><a href="#3-复制文本文件" class="headerlink" title="3.复制文本文件"></a>3.复制文本文件</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    使用BufferedReader和BufferedWriter实现文本文件的复制</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testBufferedReaderBufferedWriter</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建文件和相应的流---匿名方式简单创建</span></span><br><span class="line">         br = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;dbcp.txt&quot;</span>)));</span><br><span class="line">         bw = <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;dbcp1.txt&quot;</span>)));</span><br><span class="line"></span><br><span class="line">            <span class="comment">//读写操作</span></span><br><span class="line">            <span class="comment">//方式一：使用char[]数组</span></span><br><span class="line"><span class="comment">//            char[] cbuf = new char[1024];</span></span><br><span class="line"><span class="comment">//            int len;</span></span><br><span class="line"><span class="comment">//            while((len = br.read(cbuf)) != -1)&#123;</span></span><br><span class="line"><span class="comment">//                bw.write(cbuf,0,len);</span></span><br><span class="line"><span class="comment">//    //            bw.flush();</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"> </span><br><span class="line">            <span class="comment">//方式二：使用String   readLine()</span></span><br><span class="line">            String data;</span><br><span class="line">            <span class="keyword">while</span>((data = br.readLine()) != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="comment">//方法一：</span></span><br><span class="line"><span class="comment">//                bw.write(data + &quot;\n&quot;);//data中不包含换行符</span></span><br><span class="line">                <span class="comment">//方法二：</span></span><br><span class="line">                bw.write(data);<span class="comment">//data中不包含换行符</span></span><br><span class="line">                bw.newLine();<span class="comment">//提供换行的操作</span></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//关闭资源</span></span><br><span class="line">            <span class="keyword">if</span>(bw != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    bw.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(br != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    br.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="4-复制视频及对比节点流和缓冲流速度"><a href="#4-复制视频及对比节点流和缓冲流速度" class="headerlink" title="4.复制视频及对比节点流和缓冲流速度"></a>4.复制视频及对比节点流和缓冲流速度</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">这里只列举了缓冲流复制视频，也有测试结果<span class="comment">//618 和 176</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">copyFileWithBuffered</span><span class="params">(String srcPath,String destPath)</span>&#123;</span><br><span class="line">        <span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.造文件</span></span><br><span class="line">            <span class="type">File</span> <span class="variable">srcFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(srcPath);</span><br><span class="line">            <span class="type">File</span> <span class="variable">destFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(destPath);</span><br><span class="line">            <span class="comment">//2.造流</span></span><br><span class="line">            <span class="comment">//2.1 造节点流</span></span><br><span class="line">            <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>((srcFile));</span><br><span class="line">            <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(destFile);</span><br><span class="line">            <span class="comment">//2.2 造缓冲流</span></span><br><span class="line">            bis = <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(fis);</span><br><span class="line">            bos = <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(fos);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//3.复制的细节：读取、写入</span></span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">int</span> len;</span><br><span class="line">            <span class="keyword">while</span>((len = bis.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">                bos.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//4.资源关闭</span></span><br><span class="line">            <span class="comment">//要求：先关闭外层的流，再关闭内层的流</span></span><br><span class="line">            <span class="keyword">if</span>(bos != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    bos.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(bis != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    bis.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testCopyFileWithBuffered</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">srcPath</span> <span class="operator">=</span> <span class="string">&quot;C:\\Users\\Administrator\\Desktop\\01-视频.avi&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">destPath</span> <span class="operator">=</span> <span class="string">&quot;C:\\Users\\Administrator\\Desktop\\03-视频.avi&quot;</span>;</span><br><span class="line"></span><br><span class="line">        copyFileWithBuffered(srcPath,destPath);</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;复制操作花费的时间为：&quot;</span> + (end - start));<span class="comment">//618 - 176</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="5-课后练习题之加密解密图片"><a href="#5-课后练习题之加密解密图片" class="headerlink" title="5.课后练习题之加密解密图片"></a>5.课后练习题之加密解密图片</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//图片的加密</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        fis = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;爱情与友情.jpg&quot;</span>);</span><br><span class="line">        fos = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;爱情与友情secret.jpg&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">20</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = fis.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">     <span class="comment">//主要代码：利用异或，同0不同1 有规律的改变字节       </span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">                buffer[i] = (<span class="type">byte</span>) (buffer[i] ^ <span class="number">5</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fos.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (fos != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (fis != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fis.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//图片的解密</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123; <span class="comment">//调换位置</span></span><br><span class="line">        fis = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;爱情与友情secret.jpg&quot;</span>);</span><br><span class="line">        fos = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;爱情与友情4.jpg&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">20</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = fis.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">         <span class="comment">//在用异或一次相同数，就可进行解密</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">                buffer[i] = (<span class="type">byte</span>) (buffer[i] ^ <span class="number">5</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fos.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (fos != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (fis != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fis.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="6-获取文本上字符出现的次数"><a href="#6-获取文本上字符出现的次数" class="headerlink" title="6.获取文本上字符出现的次数"></a>6.获取文本上字符出现的次数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">练习<span class="number">3</span>:获取文本上字符出现的次数,把数据写入文件</span><br><span class="line"> *</span><br><span class="line"> * 思路：</span><br><span class="line"> * <span class="number">1.</span>遍历文本每一个字符</span><br><span class="line"> * <span class="number">2.</span>字符出现的次数存在Map中</span><br><span class="line"> *</span><br><span class="line"> * Map&lt;Character,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Character,Integer&gt;();</span><br><span class="line"> * map.put(<span class="string">&#x27;a&#x27;</span>,<span class="number">18</span>);</span><br><span class="line"> * map.put(<span class="string">&#x27;你&#x27;</span>,<span class="number">2</span>);</span><br><span class="line"> *</span><br><span class="line"> * <span class="number">3.</span>把map中的数据写入文件</span><br><span class="line"> *</span><br><span class="line"> * <span class="meta">@author</span> shkstart</span><br><span class="line"> * <span class="meta">@create</span> <span class="number">2019</span> 下午 <span class="number">3</span>:<span class="number">47</span></span><br><span class="line"> */</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WordCount</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    说明：如果使用单元测试，文件相对路径为当前module</span></span><br><span class="line"><span class="comment">          如果使用main()测试，文件相对路径为当前工程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testWordCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.创建Map集合</span></span><br><span class="line">            Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Character, Integer&gt;();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//2.遍历每一个字符,每一个字符出现的次数放到map中</span></span><br><span class="line">            fr = <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;dbcp.txt&quot;</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((c = fr.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">//int 还原 char</span></span><br><span class="line">                <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> (<span class="type">char</span>) c;</span><br><span class="line">                <span class="comment">// 判断char是否在map中第一次出现</span></span><br><span class="line">                <span class="keyword">if</span> (map.get(ch) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    map.put(ch, <span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    map.put(ch, map.get(ch) + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//3.把map中数据存在文件count.txt</span></span><br><span class="line">            <span class="comment">//3.1 创建Writer</span></span><br><span class="line">            bw = <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;wordcount.txt&quot;</span>));</span><br><span class="line"></span><br><span class="line">            <span class="comment">//3.2 遍历map,再写入数据</span></span><br><span class="line">            Set&lt;Map.Entry&lt;Character, Integer&gt;&gt; entrySet = map.entrySet();</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;Character, Integer&gt; entry : entrySet) &#123;</span><br><span class="line">                <span class="keyword">switch</span> (entry.getKey()) &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27; &#x27;</span>:</span><br><span class="line">                        bw.write(<span class="string">&quot;空格=&quot;</span> + entry.getValue());</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;\t&#x27;</span>:<span class="comment">//\t表示tab 键字符</span></span><br><span class="line">                       bw.write(<span class="string">&quot;tab键=&quot;</span> + entry.getValue());</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;\r&#x27;</span>:</span><br><span class="line">                        bw.write(<span class="string">&quot;回车=&quot;</span> + entry.getValue());</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;\n&#x27;</span>:</span><br><span class="line">                        bw.write(<span class="string">&quot;换行=&quot;</span> + entry.getValue());</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">          bw.write(entry.getKey() + <span class="string">&quot;=&quot;</span> + entry.getValue());</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                bw.newLine();<span class="comment">//每次弄一次换行</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//4.关流</span></span><br><span class="line">            <span class="keyword">if</span> (fr != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fr.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (bw != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    bw.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="3-5转换流-处理流之二"><a href="#3-5转换流-处理流之二" class="headerlink" title="3.5转换流(处理流之二)"></a>3.5转换流(处理流之二)</h3><h4 id="1-转换流介绍"><a href="#1-转换流介绍" class="headerlink" title="1.转换流介绍"></a>1.转换流介绍</h4><p><strong>1.转换流：属于字符流—看后缀</strong></p>
<ol>
<li>InputStreamReader：将一个字节的输入流转换为字符的输入流</li>
<li>OutputStreamWriter：将一个字符的输出流转换为字节的输出流</li>
</ol>
<p><strong>2.作用：</strong></p>
<ol>
<li>提供字节流与字符流之间的转换</li>
<li>字节流中的数据都是字符时，转成字符流操作更高效。 </li>
<li>很多时候我们使用转换流来处理文件乱码问题。实现编码和解码的功能<ol>
<li>解码：字节、字节数组  —&gt;字符数组、字符串</li>
<li>编码：字符数组、字符串 —&gt; 字节、字节数组</li>
</ol>
</li>
</ol>
<p>3.转换过程图示：</p>
<p><img src="/2022/10/04/Java%E9%AB%98%E7%BA%A7-%E9%9B%86%E5%90%88-%E6%B3%9B%E5%9E%8B-IO%E6%B5%81/Snipaste_2022-02-07_17-43-10.png" alt="Snipaste_2022-02-07_17-43-10"></p>
<h4 id="2-转换流的使用"><a href="#2-转换流的使用" class="headerlink" title="2.转换流的使用"></a>2.转换流的使用</h4><p>一、InputStreamReader的使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">为清晰看代码此时处理异常的话，仍然应该使用<span class="keyword">try</span>-<span class="keyword">catch</span>-<span class="keyword">finally</span></span><br><span class="line">InputStreamReader的使用，实现字节的输入流到字符的输入流的转换</span><br><span class="line">     */</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">     <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;dbcp.txt&quot;</span>);</span><br><span class="line"><span class="comment">//   InputStreamReader isr = new InputStreamReader(fis);//使用系统默认的字符集</span></span><br><span class="line"><span class="comment">//参数2指明了字符集，具体使用哪个字符集，取决于文件dbcp.txt保存时使用的字符集，这里使用系统默认的字符集</span></span><br><span class="line"><span class="type">InputStreamReader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(fis,<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">      </span><br><span class="line">        <span class="type">char</span>[] cbuf = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">20</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span>((len = isr.read(cbuf)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(cbuf,<span class="number">0</span>,len);</span><br><span class="line">            System.out.print(str);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        isr.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>二、综合使用InputStreamReader和OutputStreamWriter</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">此时处理异常的话，仍然应该使用try-catch-finally</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">综合使用InputStreamReader和OutputStreamWriter</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">//1.造文件、造流</span></span><br><span class="line">    <span class="type">File</span> <span class="variable">file1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;dbcp.txt&quot;</span>);</span><br><span class="line">    <span class="type">File</span> <span class="variable">file2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;dbcp_gbk.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file1);</span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(file2);</span><br><span class="line"></span><br><span class="line"> <span class="type">InputStreamReader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(fis,<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line"> <span class="type">OutputStreamWriter</span> <span class="variable">osw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(fos,<span class="string">&quot;gbk&quot;</span>);</span><br><span class="line"><span class="comment">//写出时可自己选择字符集</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.读写过程</span></span><br><span class="line">    <span class="type">char</span>[] cbuf = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="keyword">while</span>((len = isr.read(cbuf)) != -<span class="number">1</span>)&#123;</span><br><span class="line">        osw.write(cbuf,<span class="number">0</span>,len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.关闭资源</span></span><br><span class="line">    isr.close();</span><br><span class="line">    osw.close();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="3-多种字符编码集"><a href="#3-多种字符编码集" class="headerlink" title="3.多种字符编码集"></a>3.多种字符编码集</h4><p>1.常见种类</p>
<ol>
<li>ASCII：美国标准信息交换码，用一个字节的7位可以表示。</li>
<li>ISO8859-1：拉丁码表。欧洲码表，用一个字节的8位表示。</li>
<li>GB2312：中国的中文编码表，最多两个字节编码所有字符</li>
<li>GBK：中国的中文编码表升级，融合了更多的中文文字符号。最多两个字节编码</li>
<li>Unicode：国际标准码，融合了目前人类使用的所有字符。为每个字符分配唯一的字符码。所有的文字都用两个字节来表示。</li>
<li>UTF-8：变长的编码方式，可用1-4个字节来表示一个字符。</li>
</ol>
<p>2.Unicode和UTF-8</p>
<p>一、Unicode不完美，这里就有三个问题</p>
<ol>
<li><p>一个是，我们已经知道，英文字母只用一个字节表示就够了</p>
</li>
<li><p>第二个问题是如何才能区别Unicode和ASCII？计算机怎么知道两个字节表示一个符号，而不是分别表示两个符号呢？</p>
</li>
<li><p>第三个，如果和GBK等双字节编码方式一样，用最高位是1或0表示两个字节和一个字节，就少了很多值无法用于表示字符，不够表示所有字符。Unicode在很长一段时间内无法推广，直到互联网的出现。</p>
</li>
</ol>
<p>二、面向传输的众多 UTF（UCS Transfer Format）标准出现了，顾名思义，UTF- </p>
<p>8就是每次8个位传输数据，而UTF-16就是每次16个位。这是为传输而设计的</p>
<p>编码，并使编码无国界，这样就可以显示全世界上所有文化的字符了。</p>
<p>三、Unicode只是定义了一个庞大的、全球通用的字符集，并为每个字符规定了唯</p>
<p>一确定的编号，具体存储成什么样的字节流，取决于字符编码方案。推荐的</p>
<p>Unicode编码是UTF-8和UTF-16</p>
<p>四、Unicode转换到UTF-8</p>
<p><img src="/2022/10/04/Java%E9%AB%98%E7%BA%A7-%E9%9B%86%E5%90%88-%E6%B3%9B%E5%9E%8B-IO%E6%B5%81/Snipaste_2022-02-07_20-20-05.png" alt="Snipaste_2022-02-07_20-20-05"></p>
<p>五、所有字符编码集关系</p>
<p><img src="/2022/10/04/Java%E9%AB%98%E7%BA%A7-%E9%9B%86%E5%90%88-%E6%B3%9B%E5%9E%8B-IO%E6%B5%81/Snipaste_2022-02-07_20-20-19.png" alt="Snipaste_2022-02-07_20-20-19"></p>
<h3 id="3-6标准输入输出流"><a href="#3-6标准输入输出流" class="headerlink" title="3.6标准输入输出流"></a>3.6标准输入输出流</h3><h4 id="1-介绍-2"><a href="#1-介绍-2" class="headerlink" title="1.介绍"></a>1.介绍</h4><p>System.in和System.out分别代表了系统标准的输入和输出设备</p>
<ol>
<li>默认输入设备是：键盘，输出设备是：显示器</li>
<li>System.in的类型是InputStream</li>
<li>System.out的类型是PrintStream，其是OutputStream的子类FilterOutputStream 的子类</li>
</ol>
<p>重定向：通过System类的setIn，setOut方法对默认设备进行改变。（<strong>重新指定一个流进行读取写出。例如从文件中读数据而不是键盘中输入，输出数据到指定文件中而不是控制台）</strong></p>
<ol>
<li>public static void setIn(InputStream in)</li>
<li>public static void setOut(PrintStream out)</li>
</ol>
<h4 id="2-练习演示1"><a href="#2-练习演示1" class="headerlink" title="2.练习演示1"></a>2.练习演示1</h4><p>从键盘输入字符串，要求将读取到的整行字符串转成大写输出。然后继续进行输入操作，直至当输入“e”或者“exit”时，退出程序。</p>
<p>方法一：使用Scanner实现，调用next()返回一个字符串<br>方法二：使用System.in实现。System.in  —&gt;  转换流 —&gt; BufferedReader的readLine()</p>
<p>代码演示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法二：使用System.in实现。System.in  ---&gt;  转换流 ---&gt; BufferedReader的readLine()</span></span><br><span class="line"><span class="comment">//想用用字符流的缓冲流中readLine(),由于System.in是字节流，所以可以放入转换流构造器中</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="type">InputStreamReader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in);</span><br><span class="line">        br = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(isr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;请输入字符串：&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> br.readLine();</span><br><span class="line">            <span class="comment">//equalsIgnoreCase(data)忽略大小写</span></span><br><span class="line">           <span class="keyword">if</span> (<span class="string">&quot;e&quot;</span>.equalsIgnoreCase(data) || <span class="string">&quot;exit&quot;</span>.equalsIgnoreCase(data)) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;程序结束&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">String</span> <span class="variable">upperCase</span> <span class="operator">=</span> data.toUpperCase();</span><br><span class="line">            System.out.println(upperCase);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (br != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                br.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="3-练习2"><a href="#3-练习2" class="headerlink" title="3.练习2"></a>3.练习2</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyInput.java: Contain the methods for reading int, double, float, boolean, short, byte and</span></span><br><span class="line"><span class="comment">// string values from the keyboard</span></span><br><span class="line">相当于创建一个System.in输入类，调用方法，从键盘中输入获取想要类型的值</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyInput</span> &#123;</span><br><span class="line">    <span class="comment">// Read a string from the keyboard</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">readString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Declare and initialize the string</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">string</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Get the string from the keyboard</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            string = br.readLine();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            System.out.println(ex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Return the string obtained from the keyboard</span></span><br><span class="line">        <span class="keyword">return</span> string;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read an int value from the keyboard</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">readInt</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.parseInt(readString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read a double value from the keyboard</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">readDouble</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Double.parseDouble(readString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read a byte value from the keyboard</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">readByte</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Byte.parseByte(readString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read a short value from the keyboard</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">readShort</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Short.parseShort(readString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read a long value from the keyboard</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">readLong</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Long.parseLong(readString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read a float value from the keyboard</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">readFloat</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Float.parseFloat(readString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="3-7打印流-了解"><a href="#3-7打印流-了解" class="headerlink" title="3.7打印流(了解)"></a>3.7打印流(了解)</h3><p>实现将基本数据类型的数据格式转化为字符串输出</p>
<ol>
<li><strong>打印流：PrintStream和PrintWriter</strong></li>
<li><strong>提供了一系列重载的print()和println()方法，用于多种数据类型的输出</strong></li>
<li>PrintStream和PrintWriter的输出不会抛出IOException异常</li>
<li>PrintStream和PrintWriter有自动flush功能</li>
<li>PrintStream 打印的所有字符都使用平台的默认字符编码转换为字节。</li>
<li>在需要写入字符而不是写入字节的情况下，应该使用 PrintWriter 类。 </li>
<li><strong>System.out返回的是PrintStream的实例</strong></li>
</ol>
<p>练习演示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">PrintStream</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\IO\\text.txt&quot;</span>));</span><br><span class="line">        <span class="comment">// 创建打印输出流,设置为自动刷新模式(写入换行符或字节 &#x27;\n&#x27; 时都会刷新输出缓冲区)</span></span><br><span class="line">        ps = <span class="keyword">new</span> <span class="title class_">PrintStream</span>(fos, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">if</span> (ps != <span class="literal">null</span>) &#123;<span class="comment">// 把标准输出流(控制台输出)改成文件</span></span><br><span class="line">            System.setOut(ps);</span><br><span class="line">        &#125;</span><br><span class="line">  <span class="comment">//此时输出流被改为输出到指定文件</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= <span class="number">255</span>; i++) &#123; <span class="comment">// 输出ASCII字符</span></span><br><span class="line">            System.out.print((<span class="type">char</span>) i);</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">50</span> == <span class="number">0</span>) &#123; <span class="comment">// 每50个数据一行</span></span><br><span class="line">                System.out.println(); <span class="comment">// 换行</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ps != <span class="literal">null</span>) &#123;</span><br><span class="line">            ps.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="3-8数据流-了解"><a href="#3-8数据流-了解" class="headerlink" title="3.8数据流(了解)"></a>3.8数据流(了解)</h3><p>1.为了方便地操作Java语言的基本数据类型和String的数据，可以使用数据流。</p>
<p>2.数据流有两个类：用于读取和写出基本数据类型、String类的数据</p>
<p>3.DataInputStream 和 DataOutputStream分别“套接”在 InputStream 和 OutputStream 子类的流上 </p>
<p>DataInputStream中的方法</p>
<ol>
<li>boolean readBoolean() </li>
<li>byte readByte()</li>
<li>char readChar() </li>
<li>float readFloat()</li>
<li>double readDouble() </li>
<li>short readShort()</li>
<li>long readLong() </li>
<li>int readInt()</li>
<li>String readUTF() void readFully(byte[] b)</li>
</ol>
<p>DataOutputStream中的方法</p>
<p>将上述的方法的read改为相应的write即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">练习：将内存中的字符串、基本数据类型的变量写出到文件中。</span><br><span class="line">注意：处理异常的话，仍然应该使用<span class="keyword">try</span>-<span class="keyword">catch</span>-<span class="keyword">finally</span>.</span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//1.</span></span><br><span class="line">        <span class="type">DataOutputStream</span> <span class="variable">dos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;data.txt&quot;</span>));</span><br><span class="line">        <span class="comment">//2.</span></span><br><span class="line">        dos.writeUTF(<span class="string">&quot;刘建辰&quot;</span>);</span><br><span class="line">        dos.flush();<span class="comment">//刷新操作，将内存中的数据写入文件</span></span><br><span class="line">        dos.writeInt(<span class="number">23</span>);</span><br><span class="line">        dos.flush();</span><br><span class="line">        dos.writeBoolean(<span class="literal">true</span>);</span><br><span class="line">        dos.flush();</span><br><span class="line">        <span class="comment">//3.</span></span><br><span class="line">        dos.close();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    将文件中存储的基本数据类型变量和字符串读取到内存中，保存在变量中。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    注意点：读取不同类型的数据的顺序要与当初写入文件时，保存的数据的顺序一致！</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//1.</span></span><br><span class="line">        <span class="type">DataInputStream</span> <span class="variable">dis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;data.txt&quot;</span>));</span><br><span class="line">        <span class="comment">//2.</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> dis.readUTF();</span><br><span class="line">        <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> dis.readInt();</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isMale</span> <span class="operator">=</span> dis.readBoolean();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;name = &quot;</span> + name);</span><br><span class="line">        System.out.println(<span class="string">&quot;age = &quot;</span> + age);</span><br><span class="line">        System.out.println(<span class="string">&quot;isMale = &quot;</span> + isMale);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.</span></span><br><span class="line">        dis.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="3-9对象流"><a href="#3-9对象流" class="headerlink" title="3.9对象流"></a>3.9对象流</h3><h4 id="1-介绍-3"><a href="#1-介绍-3" class="headerlink" title="1.介绍"></a>1.介绍</h4><p>对象流涵盖了数据流，它不仅可以用于存储和读取基本数据类型数据且存储和读取对象。</p>
<p>ObjectInputStream和OjbectOutputSteam</p>
<ul>
<li>用于存储和读取基本数据类型数据或对象的处理流。它的强大之处就是可以把Java中的对象写入到数据源中，也能把对象从数据源中还原回来。</li>
</ul>
<p>序列化：用ObjectOutputStream类保存基本类型数据或对象的机制</p>
<p>反序列化：用ObjectInputStream类读取基本类型数据或对象的机制</p>
<h4 id="2-对象流的使用"><a href="#2-对象流的使用" class="headerlink" title="2.对象流的使用"></a>2.对象流的使用</h4><p><strong>1.使用步骤：</strong></p>
<p>序列化：  —-<strong>用String举例：String类本身也实现了Serializable 接口</strong></p>
<ol>
<li><p>若某个<strong>类实现了 Serializable 接口</strong>，该类的对象就是可序列化的：</p>
</li>
<li><p><strong>创建一个 ObjectOutputStream流</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ObjectOutputStream</span>  <span class="variable">oos</span> <span class="operator">=</span>   <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;object.dat&quot;</span>)); </span><br><span class="line"><span class="comment">//文件后缀可自选</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>调用 ObjectOutputStream 对象的 writeObject(对象) 方法输出可序列化对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">oos.writeObject(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;我爱北京天安门&quot;</span>));<span class="comment">//这里将String类型序列化</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>注意写出一次，操作flush()一次</p>
<p>oos.flush();&#x2F;&#x2F;刷新操作</p>
</li>
<li><p>关闭流</p>
<p>oos.close()</p>
</li>
<li><p>仍需要用try-catch-finally解决异常</p>
</li>
</ol>
<p>反序列化：</p>
<ol>
<li><p>创建一个 ObjectInputStream</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ObjectInputStream</span>  <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;object.dat&quot;</span>));</span><br></pre></td></tr></table></figure>
</li>
<li><p>调用 readObject() 方法读取流中的对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> ois.readObject();</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> (String) obj;</span><br><span class="line">System.out.println(str);</span><br></pre></td></tr></table></figure>
</li>
<li><p>关闭流</p>
<p>ois.close()</p>
</li>
<li><p>仍需要用try-catch-finally解决异常</p>
</li>
</ol>
<p><strong>详细代码演示：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//提醒：一般只序列化一种类型，但是有多种类型时，反序列化时得按照序列化时的优先顺序--这也是所有流读入写出时遇到多种类型时需要遵守的</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testObjectOutputStream</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//1.</span></span><br><span class="line">                oos = <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;object.dat&quot;</span>));</span><br><span class="line">                <span class="comment">//2.</span></span><br><span class="line">                oos.writeObject(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;我爱北京天安门&quot;</span>));</span><br><span class="line">                oos.flush();<span class="comment">//刷新操作</span></span><br><span class="line"></span><br><span class="line">                oos.writeObject(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;王铭&quot;</span>,<span class="number">23</span>));</span><br><span class="line">                oos.flush();</span><br><span class="line"></span><br><span class="line">                oos.writeObject(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;张学良&quot;</span>,<span class="number">23</span>,<span class="number">1001</span>,<span class="keyword">new</span> <span class="title class_">Account</span>(<span class="number">5000</span>)));</span><br><span class="line">                oos.flush();</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(oos != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//3.</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                oos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">反序列化：将磁盘文件中的对象还原为内存中的一个java对象</span></span><br><span class="line"><span class="comment">使用ObjectInputStream来实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testObjectInputStream</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ois = <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;object.dat&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> ois.readObject();</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> (String) obj;</span><br><span class="line"></span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> (Person) ois.readObject();</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> (Person) ois.readObject();</span><br><span class="line"></span><br><span class="line">        System.out.println(str);</span><br><span class="line">        System.out.println(p);</span><br><span class="line">        System.out.println(p1);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(ois != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ois.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>2.自定义类可序列化</strong></p>
<p>Person需要满足如下的要求，方可序列化</p>
<ol>
<li><p>需要实现接口：Serializable</p>
</li>
<li><p>当前类提供一个全局常量（<strong>序列版本号</strong>）：serialVersionUID</p>
<p>意思是给每个序列化指定一个ID区分，不写的话，系统会自动分配，但是建议写上</p>
</li>
<li><p>除了当前Person类需要实现Serializable接口之外，还必须保证其内部所有属性也必须是可序列化的。（默认情况下，基本数据类型可序列化）</p>
<p>强调：如果某个类声明的属性不是基本数据类型或 String 类型，而是另一个引用类型，那么这个引用类型必须是可序列化的，否则拥有该类型的Field 的类也不能序列化</p>
</li>
</ol>
<p><strong>补充</strong>：ObjectOutputStream和ObjectInputStream不能序列化static和transient修饰的成员变量</p>
<ol>
<li>static ：本身属于类而不是属于对象，所以不能序列化</li>
<li>transient：用于修饰不想被序列化的属性</li>
</ol>
<p>代码演示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码简化：只需要看有没有满足可序列条件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span>&#123; <span class="number">1.</span>实现接口</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">475463534532L</span>;                               <span class="number">2.</span>提供一个全局常量</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="type">int</span> age;  <span class="number">4.</span>不想被序列化，可用该关键字修饰</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> Account acct;      <span class="number">3.</span>如果有引用类型声明的属性，那么该引用类型也是可序列化的</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age, <span class="type">int</span> id, Account acct)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.acct = acct;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">4754534532L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> balance;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="3-10随机存取文件流"><a href="#3-10随机存取文件流" class="headerlink" title="3.10随机存取文件流"></a>3.10随机存取文件流</h3><h4 id="1-介绍-4"><a href="#1-介绍-4" class="headerlink" title="1.介绍"></a>1.介绍</h4><p>一、RandomAccessFile 类</p>
<ol>
<li>RandomAccessFile 声明在java.io包下，但直接继承于java.lang.Object类。并且它实现了DataInput、DataOutput这两个接口，也就意味着这个类既可以读也可以写。</li>
<li>RandomAccessFile 类支持 “随机访问” 的方式，程序可以直接跳到文件的任意地方来读、写文件<ol>
<li>支持只访问文件的部分内容</li>
<li>可以向已存在的文件后追加内容</li>
</ol>
</li>
</ol>
<p>二、细节使用</p>
<ol>
<li>RandomAccessFile 对象包含一个记录指针，用以标示当前读写处的位置。</li>
<li>RandomAccessFile 类对象可以自由移动记录指针：<ol>
<li>long getFilePointer()：获取文件记录指针的当前位置</li>
<li>void seek(long pos)：将文件记录指针定位到 pos 位置</li>
</ol>
</li>
</ol>
<p>三、构造器</p>
<ol>
<li>public RandomAccessFile(File file, String mode) </li>
<li>public RandomAccessFile(String name, String mode)</li>
</ol>
<p>四、构造器mode参数说明</p>
<p>创建 RandomAccessFile 类实例需要指定一个 mode 参数，该参数指定 RandomAccessFile 的访问模式：</p>
<ol>
<li>r: 以只读方式打开</li>
<li>rw：打开以便读取和写入</li>
<li>rwd:打开以便读取和写入；同步文件内容的更新</li>
<li>rws:打开以便读取和写入；同步文件内容和元数据的更新</li>
</ol>
<p>五、四种访问模式使用区别</p>
<p>r 和 rw：如果模式为只读r。则不会创建文件，而是会去读取一个已经存在的文件，如果读取的文件不存在则会出现异常。 如果模式为rw读写。如果文件不存在则会去创建文件，如果存在则不会创建。</p>
<p>rw和rwd：JDK 1.6 上面写的每次write数据时，“rw”模式，数据不会立即写到硬盘中；而“rwd”，写数据会被立即写入硬盘中。好处是如果写数据过程发生异常，“rwd”模式中已被write的数据被保存带硬盘中，而“rw”则全部丢失</p>
<h4 id="2-RandomAccessFile使用"><a href="#2-RandomAccessFile使用" class="headerlink" title="2.RandomAccessFile使用"></a>2.RandomAccessFile使用</h4><p>说明：</p>
<ol>
<li><p>RandomAccessFile直接继承于java.lang.Object类，实现了DataInput和DataOutput接口</p>
</li>
<li><p>RandomAccessFile既可以作为一个输入流，又可以作为一个输出流。</p>
<p><strong>代码演示一–说明</strong></p>
</li>
<li><p>如果RandomAccessFile作为输出流时，写出到的文件如果不存在，则在执行过程中自动创建。</p>
<p>如果写出到的文件存在，则会对原有文件内容进行覆盖。（默认情况下，从头覆盖）—-<strong>-代码演示二–说明</strong></p>
</li>
<li><p>可以通过相关的操作，实现RandomAccessFile“插入”数据的效果，满足一些需求而不在是覆盖 —-<strong>-代码演示三–说明</strong></p>
</li>
</ol>
<p>代码演示 一：(RandomAccessFile既可作为输入流，又可作为输出流)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RandomAccessFileTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span>   <span class="comment">//复制图片</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">RandomAccessFile</span> <span class="variable">raf1</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">RandomAccessFile</span> <span class="variable">raf2</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.造文件造流</span></span><br><span class="line">raf1 = <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;爱情与友情.jpg&quot;</span>),<span class="string">&quot;r&quot;</span>);</span><br><span class="line">raf2 = <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;爱情与友情1.jpg&quot;</span>),<span class="string">&quot;rw&quot;</span>);</span><br><span class="line">            <span class="comment">//2.读入写出过程</span></span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">int</span> len;</span><br><span class="line">            <span class="keyword">while</span>((len = raf1.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">                raf2.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//3.关闭流</span></span><br><span class="line">            <span class="keyword">if</span>(raf1 != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    raf1.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(raf2 != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    raf2.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>代码演示二：如果写出到的文件存在，则会对原有文件内容进行覆盖。（默认情况下，从头覆盖）–也可使用seek()指定角标位置进行覆盖</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span> <span class="comment">//为笔记清晰，省略使用try-catch-finally</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">RandomAccessFile</span> <span class="variable">raf1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;hello.txt&quot;</span>,<span class="string">&quot;rw&quot;</span>);</span><br><span class="line"></span><br><span class="line">    raf1.seek(<span class="number">3</span>);<span class="comment">//将指针调到角标为3的位置</span></span><br><span class="line">    raf1.write(<span class="string">&quot;xyz&quot;</span>.getBytes());<span class="comment">//这里write形参是byte数组</span></span><br><span class="line">								<span class="comment">//不是字符串</span></span><br><span class="line">    raf1.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>代码演示三：可以通过相关的操作，实现RandomAccessFile“插入”数据的效果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">使用RandomAccessFile实现数据的插入效果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">RandomAccessFile</span> <span class="variable">raf1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;hello.txt&quot;</span>,<span class="string">&quot;rw&quot;</span>);</span><br><span class="line">    <span class="comment">//方式一：使用StringBuilder</span></span><br><span class="line">    raf1.seek(<span class="number">3</span>);<span class="comment">//将指针调到角标为3的位置</span></span><br><span class="line">    <span class="comment">//保存指针3后面的所有数据到StringBuilder中</span></span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>((<span class="type">int</span>) <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;hello.txt&quot;</span>).length());</span><br><span class="line">    </span><br><span class="line">    <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="keyword">while</span>((len = raf1.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">        builder.append(<span class="keyword">new</span> <span class="title class_">String</span>(buffer,<span class="number">0</span>,len)) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//调回指针，写入“xyz”</span></span><br><span class="line">    raf1.seek(<span class="number">3</span>);</span><br><span class="line">    raf1.write(<span class="string">&quot;xyz&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将StringBuilder中的数据写入到文件中</span></span><br><span class="line">    raf1.write(builder.toString().getBytes());</span><br><span class="line"></span><br><span class="line">    raf1.close();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方式二：思考：将StringBuilder替换为ByteArrayOutputStream</span></span><br><span class="line"><span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line"><span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> len;</span><br><span class="line"><span class="keyword">while</span>((len = raf1.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">baos.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">&#125;</span><br><span class="line">raf1.seek(<span class="number">5</span>);</span><br><span class="line">raf1.write(<span class="string">&quot;xyz&quot;</span>.getBytes());</span><br><span class="line">raf1.write(baos.toString().getBytes());</span><br><span class="line">baos.close();</span><br><span class="line">raf1.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="3-11NIO-2中Path、Paths、Files类的使用"><a href="#3-11NIO-2中Path、Paths、Files类的使用" class="headerlink" title="3.11NIO.2中Path、Paths、Files类的使用"></a>3.11NIO.2中Path、Paths、Files类的使用</h3><p>由于难度跳跃且暂时用不到，这里暂做了解</p>
<h4 id="1-NIO概述"><a href="#1-NIO概述" class="headerlink" title="1.NIO概述"></a>1.NIO概述</h4><ol>
<li>Java NIO (New IO，Non-Blocking IO)是从Java 1.4版本开始引入的一套新 的IO API，可以替代标准的Java IO API。NIO与原来的IO有同样的作用和目的，但是使用的方式完全不同，NIO支持面向缓冲区的(IO是面向流的)、基于通道的IO操作。NIO将以更加高效的方式进行文件的读写操作</li>
<li>Java API中提供了两套NIO，一套是针对标准输入输出NIO，另一套就是网络编程NIO。 </li>
<li>java.nio.channels.Channel</li>
<li>FileChannel:处理本地文件</li>
<li>SocketChannel：TCP网络编程的客户端的Channel</li>
<li>ServerSocketChannel:TCP网络编程的服务器端的Channel</li>
<li>DatagramChannel：UDP网络编程中发送端和接收端的Channel</li>
</ol>
<h4 id="2-NIO-2概述"><a href="#2-NIO-2概述" class="headerlink" title="2.NIO.2概述"></a>2.NIO.2概述</h4><ol>
<li>随着 JDK 7 的发布，Java对NIO进行了极大的扩展，增强了对文件处理和文件系统特性的支持，以至于我们称他们为 NIO.2。</li>
<li>因为 NIO 提供的一些功能，NIO已经成为文件处理中越来越重要的部分。</li>
<li>早期的Java只提供了一个File类来访问文件系统，但File类的功能比较有限，所提供的方法性能也不高。而且，大多数方法在出错时仅返回失败，并不会提供异常信息。</li>
<li>NIO. 2为了弥补这种不足，引入了Path接口，代表一个平台无关的平台路径，描述了目录结构中文件的位置。<strong>Path可以看成是File类的升级版本</strong>，实际引用的资源也可以不存在。</li>
</ol>
<p>Path、Paths和Files核心API</p>
<ul>
<li>同时，NIO.2在java.nio.file包下还提供了Files、Paths工具类，Files包含了大量静态的工具方法来操作文件；Paths则包含了两个返回Path的静态工厂方法。</li>
</ul>
<p>Paths 类提供的静态 get() 方法用来获取 Path 对象：</p>
<ol>
<li>static Path get(String first, String … more) : 用于将多个字符串串连成路径</li>
<li>static Path get(URI uri): 返回指定uri对应的Path路径</li>
</ol>
<h4 id="3-Path接口"><a href="#3-Path接口" class="headerlink" title="3.Path接口"></a>3.Path接口</h4><p>说明：Path替换File</p>
<p>如何实例化：</p>
<p>Paths 类提供的静态 get() 方法用来获取 Path 对象：</p>
<ol>
<li>static Path get(String first, String … more) : 用于将多个字符串串连成路径</li>
<li>static Path get(URI uri): 返回指定uri对应的Path路径</li>
</ol>
<p>常用方法：</p>
<p>Path 常用方法：</p>
<ol>
<li>String toString() ： 返回调用 Path 对象的字符串表示形式</li>
<li>boolean startsWith(String path) : 判断是否以 path 路径开始</li>
<li>boolean endsWith(String path) : 判断是否以 path 路径结束</li>
<li>boolean isAbsolute() : 判断是否是绝对路径</li>
<li>Path getParent() ：返回Path对象包含整个路径，不包含 Path 对象指定的文件路径</li>
<li>Path getRoot() ：返回调用 Path 对象的根路径</li>
<li>Path getFileName() : 返回与调用 Path 对象关联的文件名</li>
<li>int getNameCount() : 返回Path 根目录后面元素的数量</li>
<li>Path getName(int idx) : 返回指定索引位置 idx 的路径名称</li>
<li>Path toAbsolutePath() : 作为绝对路径返回调用 Path 对象</li>
<li>Path resolve(Path p) :合并两个路径，返回合并后的路径对应的Path对象</li>
<li>File toFile(): 将Path转化为File类的对象</li>
</ol>
<h4 id="4-Files工具类"><a href="#4-Files工具类" class="headerlink" title="4.Files工具类"></a>4.Files工具类</h4><p>作用：java.nio.file.Files 用于操作文件或目录的工具类。</p>
<p>常用方法：</p>
<ol>
<li>Path copy(Path src, Path dest, CopyOption … how) : 文件的复制</li>
<li>Path createDirectory(Path path, FileAttribute&lt;?&gt; … attr) : 创建一个目录</li>
<li>Path createFile(Path path, FileAttribute&lt;?&gt; … arr) : 创建一个文件</li>
<li>void delete(Path path) : 删除一个文件&#x2F;目录，如果不存在，执行报错</li>
<li>void deleteIfExists(Path path) : Path对应的文件&#x2F;目录如果存在，执行删除</li>
<li>Path move(Path src, Path dest, CopyOption…how) : 将 src 移动到 dest 位置</li>
<li>long size(Path path) : 返回 path 指定文件的大小</li>
</ol>
<p>Files常用方法：用于判断</p>
<ol>
<li>boolean exists(Path path, LinkOption … opts) : 判断文件是否存在</li>
<li>boolean isDirectory(Path path, LinkOption … opts) : 判断是否是目录</li>
<li>boolean isRegularFile(Path path, LinkOption … opts) : 判断是否是文件</li>
<li>boolean isHidden(Path path) : 判断是否是隐藏文件</li>
<li>boolean isReadable(Path path) : 判断文件是否可读</li>
<li>boolean isWritable(Path path) : 判断文件是否可写</li>
<li>boolean notExists(Path path, LinkOption … opts) : 判断文件是否不存在</li>
</ol>
<p>Files常用方法：用于操作内容</p>
<ol>
<li>SeekableByteChannel newByteChannel(Path path, OpenOption…how) : 获取与指定文件的连接，how 指定打开方式。</li>
<li>DirectoryStream<Path> newDirectoryStream(Path path) : 打开 path 指定的目录</Path></li>
<li>InputStream newInputStream(Path path, OpenOption…how):获取 InputStream 对象</li>
<li>OutputStream newOutputStream(Path path, OpenOption…how) : 获取 OutputStream 对象</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Qinghai2021</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2022/10/04/Java%E9%AB%98%E7%BA%A7-%E9%9B%86%E5%90%88-%E6%B3%9B%E5%9E%8B-IO%E6%B5%81/">http://example.com/2022/10/04/Java%E9%AB%98%E7%BA%A7-%E9%9B%86%E5%90%88-%E6%B3%9B%E5%9E%8B-IO%E6%B5%81/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">Qinghai2021·博客</a>！</span></div></div><div class="tag_share"><div class="post_share"><div class="social-share" data-image="/images/background.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://fastly.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/10/05/Java%E9%AB%98%E7%BA%A7-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-%E5%8F%8D%E5%B0%84-8%E6%96%B0%E7%89%B9%E6%80%A7/"><img class="prev-cover" src="/images/background.jpg" onerror="onerror=null;src='https://api.ixiaowai.cn/gqapi/gqapi.php'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Java网络编程-反射-8新特性</div></div></a></div><div class="next-post pull-right"><a href="/2022/10/03/Java%E9%AB%98%E7%BA%A7-%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%B8%B8%E7%94%A8%E7%B1%BB-%E6%9E%9A%E4%B8%BE%E7%B1%BB%E4%B8%8E%E6%B3%A8%E8%A7%A3/"><img class="next-cover" src="/images/background.jpg" onerror="onerror=null;src='https://api.ixiaowai.cn/gqapi/gqapi.php'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Java多线程-常用类-枚举类与注解</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E9%9B%86%E5%90%88"><span class="toc-number">1.</span> <span class="toc-text">一、集合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1%E9%9B%86%E5%90%88%E7%9A%84%E6%A6%82%E8%BF%B0"><span class="toc-number">1.1.</span> <span class="toc-text">1.1集合的概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%9B%86%E5%90%88%E4%B8%8E%E6%95%B0%E7%BB%84"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.集合与数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%9B%86%E5%90%88%E7%9A%84%E6%A1%86%E6%9E%B6"><span class="toc-number">1.1.2.</span> <span class="toc-text">2.集合的框架</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2Collection%E6%8E%A5%E5%8F%A3%E4%B8%AD%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.</span> <span class="toc-text">1.2Collection接口中方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3iterator-%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.3.</span> <span class="toc-text">1.3iterator 迭代器接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-iterator-%EF%BC%89-%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">1.3.1.</span> <span class="toc-text">1.iterator(） 迭代器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-foreach%E5%BE%AA%E7%8E%AF"><span class="toc-number">1.3.2.</span> <span class="toc-text">2.foreach循环</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4List%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%E7%B1%BB%E5%8F%8A%E6%96%B9%E6%B3%95"><span class="toc-number">1.4.</span> <span class="toc-text">1.4List接口实现类及方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%B8%89%E8%80%85%E5%AE%9E%E7%8E%B0%E7%B1%BB%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">1.4.1.</span> <span class="toc-text">1.三者实现类的比较</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-List%E6%8E%A5%E5%8F%A3%E4%B8%AD%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">1.4.2.</span> <span class="toc-text">2.List接口中常用方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5Set%E6%8E%A5%E5%8F%A3%E5%8F%8A%E5%AE%9E%E7%8E%B0%E7%B1%BB%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.5.</span> <span class="toc-text">1.5Set接口及实现类介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%B8%89%E4%B8%AA%E5%AE%9E%E7%8E%B0%E7%B1%BB%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.5.1.</span> <span class="toc-text">1.三个实现类介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Set%E6%8E%A5%E5%8F%A3%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.5.2.</span> <span class="toc-text">2.Set接口介绍</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6Map%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%B1%BB%E5%8F%8A%E7%90%86%E8%A7%A3"><span class="toc-number">1.6.</span> <span class="toc-text">1.6Map的实现类及理解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Map%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%B1%BB%E7%9A%84%E7%BB%93%E6%9E%84%EF%BC%9A"><span class="toc-number">1.6.1.</span> <span class="toc-text">1.Map的实现类的结构：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Map%E7%BB%93%E6%9E%84%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9A"><span class="toc-number">1.6.2.</span> <span class="toc-text">2.Map结构的理解：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-HashMap%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">1.6.3.</span> <span class="toc-text">3.HashMap底层实现原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-LinkedHashMap%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="toc-number">1.6.4.</span> <span class="toc-text">4.LinkedHashMap的底层实现原理（了解）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-TreeMap%E5%AE%9E%E7%8E%B0%E7%B1%BB%E4%BD%BF%E7%94%A8"><span class="toc-number">1.6.5.</span> <span class="toc-text">5.TreeMap实现类使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-Properties%E5%AE%9E%E7%8E%B0%E7%B1%BB%E5%AD%90%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">1.6.6.</span> <span class="toc-text">6.Properties实现类子类的使用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-7Map%E6%8E%A5%E5%8F%A3%E4%B8%AD%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">1.7.</span> <span class="toc-text">1.7Map接口中常用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%B7%BB%E5%8A%A0%E3%80%81%E5%88%A0%E9%99%A4%E3%80%81%E4%BF%AE%E6%94%B9%E6%93%8D%E4%BD%9C%EF%BC%9A"><span class="toc-number">1.7.1.</span> <span class="toc-text">1.添加、删除、修改操作：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%85%83%E7%B4%A0%E6%9F%A5%E8%AF%A2%E7%9A%84%E6%93%8D%E4%BD%9C%EF%BC%9A"><span class="toc-number">1.7.2.</span> <span class="toc-text">2.元素查询的操作：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%85%83%E8%A7%86%E5%9B%BE%E5%8F%8A%E9%81%8D%E5%8E%86%E6%93%8D%E4%BD%9C"><span class="toc-number">1.7.3.</span> <span class="toc-text">3.元视图及遍历操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E6%80%BB%E7%BB%93%EF%BC%9A%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">1.7.4.</span> <span class="toc-text">4.总结：常用方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-8Collections%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-number">1.8.</span> <span class="toc-text">1.8Collections工具类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.8.1.</span> <span class="toc-text">1.介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">1.8.2.</span> <span class="toc-text">2.常用方法</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%B3%9B%E5%9E%8B"><span class="toc-number"></span> <span class="toc-text">二、泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89%E6%B3%9B%E5%9E%8B"><span class="toc-number">0.1.</span> <span class="toc-text">2.1为什么要有泛型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2%E9%9B%86%E5%90%88%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%B3%9B%E5%9E%8B"><span class="toc-number">0.2.</span> <span class="toc-text">2.2集合中使用泛型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%9B%E5%9E%8B%E7%BB%93%E6%9E%84"><span class="toc-number">0.3.</span> <span class="toc-text">2.3自定义泛型结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%9B%E5%9E%8B%E7%B1%BB%E6%B3%A8%E6%84%8F%E7%82%B9"><span class="toc-number">0.3.1.</span> <span class="toc-text">1.自定义泛型类注意点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95"><span class="toc-number">0.3.2.</span> <span class="toc-text">2.自定义泛型方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4%E6%B3%9B%E5%9E%8B%E5%9C%A8%E7%BB%A7%E6%89%BF%E6%96%B9%E9%9D%A2%E7%9A%84%E4%BD%93%E7%8E%B0"><span class="toc-number">0.4.</span> <span class="toc-text">2.4泛型在继承方面的体现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5%E9%80%9A%E9%85%8D%E7%AC%A6%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">0.5.</span> <span class="toc-text">2.5通配符的使用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81IO%E6%B5%81"><span class="toc-number">1.</span> <span class="toc-text">三、IO流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1File%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">1.1.</span> <span class="toc-text">3.1File类的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BB%8B%E7%BB%8D-1"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%9E%84%E9%80%A0%E5%99%A8%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.1.2.</span> <span class="toc-text">2.构造器介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-File%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">1.1.3.</span> <span class="toc-text">3.File中的常用方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-IO%E5%8E%9F%E7%90%86%E5%8F%8A%E6%B5%81%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">1.2.</span> <span class="toc-text">3.2 IO原理及流的分类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-IO%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.2.1.</span> <span class="toc-text">1.IO原理介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%B5%81%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">1.2.2.</span> <span class="toc-text">2.流的分类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3%E8%8A%82%E7%82%B9%E6%B5%81-%E6%88%96%E6%96%87%E4%BB%B6%E6%B5%81"><span class="toc-number">1.3.</span> <span class="toc-text">3.3节点流(或文件流)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%85%B1%E6%9C%89%E5%9B%9B%E7%A7%8D%E8%8A%82%E7%82%B9%E6%B5%81"><span class="toc-number">1.3.1.</span> <span class="toc-text">1.共有四种节点流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%AD%97%E7%AC%A6%E6%B5%81%E8%AF%BB%E5%86%99%E6%BC%94%E7%A4%BA"><span class="toc-number">1.3.2.</span> <span class="toc-text">2.字符流读写演示</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%AD%97%E8%8A%82%E6%B5%81%E8%AF%BB%E5%85%A5%E6%BC%94%E7%A4%BA"><span class="toc-number">1.3.3.</span> <span class="toc-text">3.字节流读入演示</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-FileInputStream"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">1.FileInputStream</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%A4%8D%E5%88%B6%E5%9B%BE%E7%89%87%E6%95%B0%E6%8D%AE"><span class="toc-number">1.3.3.2.</span> <span class="toc-text">2.复制图片数据</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4%E7%BC%93%E5%86%B2%E6%B5%81-%E5%A4%84%E7%90%86%E6%B5%81%E4%B9%8B%E4%B8%80"><span class="toc-number">1.4.</span> <span class="toc-text">3.4缓冲流(处理流之一)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%85%B1%E6%9C%89%E5%9B%9B%E7%A7%8D%E7%BC%93%E5%86%B2%E6%B5%81"><span class="toc-number">1.4.1.</span> <span class="toc-text">1.共有四种缓冲流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%A4%8D%E5%88%B6%E9%9D%9E%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6"><span class="toc-number">1.4.2.</span> <span class="toc-text">2.复制非文本文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%A4%8D%E5%88%B6%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6"><span class="toc-number">1.4.3.</span> <span class="toc-text">3.复制文本文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%A4%8D%E5%88%B6%E8%A7%86%E9%A2%91%E5%8F%8A%E5%AF%B9%E6%AF%94%E8%8A%82%E7%82%B9%E6%B5%81%E5%92%8C%E7%BC%93%E5%86%B2%E6%B5%81%E9%80%9F%E5%BA%A6"><span class="toc-number">1.4.4.</span> <span class="toc-text">4.复制视频及对比节点流和缓冲流速度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E8%AF%BE%E5%90%8E%E7%BB%83%E4%B9%A0%E9%A2%98%E4%B9%8B%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E5%9B%BE%E7%89%87"><span class="toc-number">1.4.5.</span> <span class="toc-text">5.课后练习题之加密解密图片</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E8%8E%B7%E5%8F%96%E6%96%87%E6%9C%AC%E4%B8%8A%E5%AD%97%E7%AC%A6%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0"><span class="toc-number">1.4.6.</span> <span class="toc-text">6.获取文本上字符出现的次数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5%E8%BD%AC%E6%8D%A2%E6%B5%81-%E5%A4%84%E7%90%86%E6%B5%81%E4%B9%8B%E4%BA%8C"><span class="toc-number">1.5.</span> <span class="toc-text">3.5转换流(处理流之二)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%BD%AC%E6%8D%A2%E6%B5%81%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.5.1.</span> <span class="toc-text">1.转换流介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%BD%AC%E6%8D%A2%E6%B5%81%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">1.5.2.</span> <span class="toc-text">2.转换流的使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%A4%9A%E7%A7%8D%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E9%9B%86"><span class="toc-number">1.5.3.</span> <span class="toc-text">3.多种字符编码集</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81"><span class="toc-number">1.6.</span> <span class="toc-text">3.6标准输入输出流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BB%8B%E7%BB%8D-2"><span class="toc-number">1.6.1.</span> <span class="toc-text">1.介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%BB%83%E4%B9%A0%E6%BC%94%E7%A4%BA1"><span class="toc-number">1.6.2.</span> <span class="toc-text">2.练习演示1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E7%BB%83%E4%B9%A02"><span class="toc-number">1.6.3.</span> <span class="toc-text">3.练习2</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-7%E6%89%93%E5%8D%B0%E6%B5%81-%E4%BA%86%E8%A7%A3"><span class="toc-number">1.7.</span> <span class="toc-text">3.7打印流(了解)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-8%E6%95%B0%E6%8D%AE%E6%B5%81-%E4%BA%86%E8%A7%A3"><span class="toc-number">1.8.</span> <span class="toc-text">3.8数据流(了解)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-9%E5%AF%B9%E8%B1%A1%E6%B5%81"><span class="toc-number">1.9.</span> <span class="toc-text">3.9对象流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BB%8B%E7%BB%8D-3"><span class="toc-number">1.9.1.</span> <span class="toc-text">1.介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%AF%B9%E8%B1%A1%E6%B5%81%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">1.9.2.</span> <span class="toc-text">2.对象流的使用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-10%E9%9A%8F%E6%9C%BA%E5%AD%98%E5%8F%96%E6%96%87%E4%BB%B6%E6%B5%81"><span class="toc-number">1.10.</span> <span class="toc-text">3.10随机存取文件流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BB%8B%E7%BB%8D-4"><span class="toc-number">1.10.1.</span> <span class="toc-text">1.介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-RandomAccessFile%E4%BD%BF%E7%94%A8"><span class="toc-number">1.10.2.</span> <span class="toc-text">2.RandomAccessFile使用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-11NIO-2%E4%B8%ADPath%E3%80%81Paths%E3%80%81Files%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">1.11.</span> <span class="toc-text">3.11NIO.2中Path、Paths、Files类的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-NIO%E6%A6%82%E8%BF%B0"><span class="toc-number">1.11.1.</span> <span class="toc-text">1.NIO概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-NIO-2%E6%A6%82%E8%BF%B0"><span class="toc-number">1.11.2.</span> <span class="toc-text">2.NIO.2概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-Path%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.11.3.</span> <span class="toc-text">3.Path接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-Files%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-number">1.11.4.</span> <span class="toc-text">4.Files工具类</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Qinghai2021</div><div class="author-info__description">阳光宅男💛</div></div><div class="card-info-social-icons is-center"><a class="social-icon" href="//github.com/Qinghai2021?tab=repositories" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:xxxxxx@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">来的都是大哥！</div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/10/05/Java%E9%AB%98%E7%BA%A7-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-%E5%8F%8D%E5%B0%84-8%E6%96%B0%E7%89%B9%E6%80%A7/" title="Java网络编程-反射-8新特性">Java网络编程-反射-8新特性</a><time datetime="2022-10-04T16:00:00.000Z" title="发表于 2022-10-05 00:00:00">2022-10-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/10/04/Java%E9%AB%98%E7%BA%A7-%E9%9B%86%E5%90%88-%E6%B3%9B%E5%9E%8B-IO%E6%B5%81/" title="Java集合-泛型-IO流">Java集合-泛型-IO流</a><time datetime="2022-10-03T16:00:00.000Z" title="发表于 2022-10-04 00:00:00">2022-10-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/10/03/Java%E9%AB%98%E7%BA%A7-%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%B8%B8%E7%94%A8%E7%B1%BB-%E6%9E%9A%E4%B8%BE%E7%B1%BB%E4%B8%8E%E6%B3%A8%E8%A7%A3/" title="Java多线程-常用类-枚举类与注解">Java多线程-常用类-枚举类与注解</a><time datetime="2022-10-02T16:00:00.000Z" title="发表于 2022-10-03 00:00:00">2022-10-03</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/10/02/%E5%B0%9A%E7%A1%85%E8%B0%B7java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/" title="Java编程基础">Java编程基础</a><time datetime="2022-10-01T16:00:00.000Z" title="发表于 2022-10-02 00:00:00">2022-10-02</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/09/30/JavaWeb/" title="JavaWeb笔记">JavaWeb笔记</a><time datetime="2022-09-29T16:00:00.000Z" title="发表于 2022-09-30 00:00:00">2022-09-30</time></div></div></div></div></div></div></main><footer id="footer" style="background: #FFFFFF"><div id="footer-wrap"><div class="copyright">&copy;2022 By Qinghai2021</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/chenxz21/hexo-theme-bcxm">Bcxm</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://fastly.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><div class="js-pjax"></div><script type="text/javascript" src="https://fastly.jsdelivr.net/npm/leancloud-storage@4.10.0/dist/av-min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://fastly.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script id="click-heart" src="https://fastly.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>