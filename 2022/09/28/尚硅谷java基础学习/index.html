<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Java基础</title><meta name="author" content="Qinghai2021"><meta name="copyright" content="Qinghai2021"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="项目及工具1.eclipse1.eclipse安装配置见—文档 2.eclipse快捷键 1.补全代码的声明：alt + &#x2F; 2.快速修复: ctrl + 1  3.批量导包：ctrl + shift + o 4.使用单行注释：ctrl + &#x2F; 5.使用多行注释： ctrl + shift + &#x2F;  6.取消多行注释：ctrl + shift + \ 7.复制指定行的">
<meta property="og:type" content="article">
<meta property="og:title" content="Java基础">
<meta property="og:url" content="http://example.com/2022/09/28/%E5%B0%9A%E7%A1%85%E8%B0%B7java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/index.html">
<meta property="og:site_name" content="Qinghai2021·博客">
<meta property="og:description" content="项目及工具1.eclipse1.eclipse安装配置见—文档 2.eclipse快捷键 1.补全代码的声明：alt + &#x2F; 2.快速修复: ctrl + 1  3.批量导包：ctrl + shift + o 4.使用单行注释：ctrl + &#x2F; 5.使用多行注释： ctrl + shift + &#x2F;  6.取消多行注释：ctrl + shift + \ 7.复制指定行的">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/images/background.jpg">
<meta property="article:published_time" content="2022-09-28T09:45:41.000Z">
<meta property="article:modified_time" content="2022-09-28T08:10:52.405Z">
<meta property="article:author" content="Qinghai2021">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/images/background.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2022/09/28/%E5%B0%9A%E7%A1%85%E8%B0%B7java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":500},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: Qinghai2021","link":"链接: ","source":"来源: Qinghai2021·博客","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://fastly.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://fastly.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java基础',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-09-28 16:10:52'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.2.0"><link rel="alternate" href="/atom.xml" title="Qinghai2021·博客" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Qinghai2021</div><div class="author-info__description">阳光宅男💛</div></div><div class="card-info-social-icons is-center"><a class="social-icon" href="//github.com/Qinghai2021?tab=repositories" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:xxxxxx@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-clock"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://www.bilibili.com/blackboard/fe/activity-HQjQSdd3L8.html"><i class="fa-fw fas fa-gamepad"></i><span> 游戏</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-tools"></i><span> 工具</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" target="_blank" rel="noopener" href="https://draw.xbyzs.cf"><span> Draw画布</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Qinghai2021·博客</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-clock"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://www.bilibili.com/blackboard/fe/activity-HQjQSdd3L8.html"><i class="fa-fw fas fa-gamepad"></i><span> 游戏</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-tools"></i><span> 工具</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" target="_blank" rel="noopener" href="https://draw.xbyzs.cf"><span> Draw画布</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">Java基础</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2022-09-28T09:45:41.000Z" title="发表于 2022-09-28 17:45:41">2022-09-28</time></span></div><div class="meta-secondline"></div></div></div><article class="post-content" id="article-container"><h1 id="项目及工具"><a href="#项目及工具" class="headerlink" title="项目及工具"></a>项目及工具</h1><h2 id="1-eclipse"><a href="#1-eclipse" class="headerlink" title="1.eclipse"></a>1.eclipse</h2><h3 id="1-eclipse-1"><a href="#1-eclipse-1" class="headerlink" title="1.eclipse"></a>1.eclipse</h3><p>安装配置见—文档</p>
<h3 id="2-eclipse快捷键"><a href="#2-eclipse快捷键" class="headerlink" title="2.eclipse快捷键"></a>2.eclipse快捷键</h3><ul>
<li><strong>1.补全代码的声明：alt + &#x2F;</strong></li>
<li>2.快速修复: ctrl + 1 </li>
<li><strong>3.批量导包：ctrl + shift + o</strong></li>
<li><strong>4.使用单行注释：ctrl + &#x2F;</strong></li>
<li><strong>5.使用多行注释： ctrl + shift + &#x2F;</strong> </li>
<li>6.取消多行注释：ctrl + shift + \</li>
<li><strong>7.复制指定行的代码：ctrl + alt + down 或 ctrl + alt + up</strong></li>
<li><strong>8.删除指定行的代码：ctrl + d</strong></li>
<li>9.上下移动代码：alt + up 或 alt + down</li>
<li>10.切换到下一行代码空位：shift + enter</li>
<li>11.切换到上一行代码空位：ctrl + shift + enter</li>
<li><strong>12.如何查看源码：ctrl + 选中指定的结构 或 ctrl + shift + t</strong></li>
<li>13.退回到前一个编辑的页面：alt + left </li>
<li>14.进入到下一个编辑的页面(针对于上面那条来说的)：alt + right</li>
<li><strong>15.光标选中指定的类，查看继承树结构：ctrl + t</strong></li>
<li>16.复制代码： ctrl + c</li>
<li><strong>17.撤销： ctrl + z</strong></li>
<li><strong>18.反撤销： ctrl + y</strong></li>
<li>19.剪切：ctrl + x </li>
<li>20.粘贴：ctrl + v</li>
<li><strong>21.保存： ctrl + s</strong></li>
<li><strong>22.全选：ctrl + a</strong></li>
<li><strong>23.格式化代码： ctrl + shift + f</strong> (使代码格式整洁)</li>
<li><strong>24.选中数行，整体往后移动：tab</strong></li>
<li><strong>25.选中数行，整体往前移动：shift + tab</strong></li>
<li><strong>26.在当前类中，显示类结构，并支持搜索指定的方法、属性等：ctrl + o</strong></li>
<li>27.批量修改指定的变量名、方法名、类名等：alt + shift + r</li>
<li>28.选中的结构的大小写的切换：变成大写： ctrl + shift + x</li>
<li>29.选中的结构的大小写的切换：变成小写：ctrl + shift + y</li>
<li><strong>30.调出生成 getter&#x2F;setter&#x2F;构造器等结构： alt + shift + s</strong></li>
<li>31.显示当前选择资源(工程 or 文件)的属性：alt + enter</li>
<li>32**.快速查找：参照选中的 Word 快速定位到下一个 ：ctrl + k** </li>
<li>33.关闭当前窗口：ctrl + w</li>
<li>34.关闭所有的窗口：ctrl + shift + w</li>
<li>35.查看指定的结构使用过的地方：ctrl + alt + g</li>
<li>36.查找与替换：ctrl + f</li>
<li>37.最大化当前的 View：ctrl + m</li>
<li>38.<strong>直接定位到当前行的首位：home</strong></li>
<li><strong>39.直接定位到当前行的末位：end</strong></li>
</ul>
<h3 id="3-Debug-调试"><a href="#3-Debug-调试" class="headerlink" title="3.Debug  调试"></a>3.Debug  调试</h3><p>调试代码，查找bug所需，见网上教程</p>
<h2 id="2-项目要求"><a href="#2-项目要求" class="headerlink" title="2.项目要求"></a>2.项目要求</h2><ol>
<li><p>至少独立完成一遍以上的项目代码</p>
</li>
<li><p>积累完成项目的过程中常见的bug的调试</p>
<p>方式一: “硬看”，必要时，添加一些输出语句</p>
<p>方式二：Debug</p>
</li>
<li><p>最重要的：捋顺思路，强化逻辑</p>
</li>
<li><p>对象、数组等内存结构的解析</p>
</li>
<li><p>遵守编码的规范，标识符的命名规范</p>
</li>
<li><p>在类前，方法前，方法内具体逻辑的实现步骤等添加必要的注释</p>
<p>单行、多行、以及文档（项目大时十分重要）</p>
<p>类前、方法前、属性前：文档注释</p>
<p>逻辑步骤：单行、多行注释。</p>
</li>
</ol>
<h2 id="3-客户信息管理软件"><a href="#3-客户信息管理软件" class="headerlink" title="3.客户信息管理软件"></a>3.客户信息管理软件</h2><p>项目二：</p>
<h3 id="1-分为三大类"><a href="#1-分为三大类" class="headerlink" title="1.分为三大类"></a>1.分为三大类</h3><p>CustomerView为主模块，负责菜单的显示和处理用户操作</p>
<p>CustomerList为Customer对象的管理模块，内部用数组管理一组Customer对象，并提供相应的添加、修改、删除和遍历方法，供CustomerView调用</p>
<p>Customer为实体对象，用来封装客户信息</p>
<h3 id="2-Customer类的设计"><a href="#2-Customer类的设计" class="headerlink" title="2.Customer类的设计"></a>2.Customer类的设计</h3><p>Customer为实体类，用来封装客户信息 该类封装客户的以下信息：</p>
<p>String name ：客户姓名</p>
<p>char gender  ：性别</p>
<p>int age          ：年龄</p>
<p>String phone：电话号码</p>
<p>String email ：电子邮箱 </p>
<p>提供各属性的get&#x2F;set方法   (以上都是private)</p>
<p>提供所需的构造器（可自行确定）</p>
<h3 id="3-CustomerList类的设计"><a href="#3-CustomerList类的设计" class="headerlink" title="3.CustomerList类的设计"></a>3.CustomerList类的设计</h3><p>CustomerList为Customer对象的管理模块，内部使用数组管理一组Customer对象本类封装以下信息：</p>
<p>Customer[] customers：用来保存客户对象的数组</p>
<p>int total &#x3D; 0                 ：记录已保存客户对象的数量该类至少提供以下构造器和方法：</p>
<p>public CustomerList(int totalCustomer) &#x2F;&#x2F;构造器</p>
<p>public boolean addCustomer(Customer customer)&#x2F;&#x2F;将指定用户添加到数组中</p>
<p> public boolean replaceCustomer(int index, Customer cust)&#x2F;&#x2F;修改指定索引的值</p>
<p>public boolean deleteCustomer(int index)&#x2F;&#x2F;删除指定索引值，元素前移补位</p>
<p>public Customer[] getAllCustomers()&#x2F;&#x2F;获取所有客户信息</p>
<p> public Customer getCustomer(int index) 	&#x2F;&#x2F;索引指定位置的客户</p>
<p>public int getTotal()&#x2F;&#x2F;获取存储客户的数量</p>
<h3 id="4-CustomerView类的设计"><a href="#4-CustomerView类的设计" class="headerlink" title="4.CustomerView类的设计"></a>4.CustomerView类的设计</h3><p>本类封装以下信息：</p>
<p>CustomerList customerList &#x3D; new CustomerList(10);	</p>
<p>创建最大包含10个客户对象的CustomerList 对象，供以下各成员方法使用。该类至少提供以下方法：</p>
<p>public void enterMainMenu() &#x2F;&#x2F;进入主目录</p>
<p>private void addNewCustomer() &#x2F;&#x2F;添加新客户</p>
<p>private void modifyCustomer()	&#x2F;&#x2F;修改客户</p>
<p>private void deleteCustomer()&#x2F;&#x2F;删除客户信息</p>
<p>private void listAllCustomers()&#x2F;&#x2F;获取所有客户信息</p>
<p>public static void main(String[] args)&#x2F;&#x2F;main方法</p>
<h2 id="4-错题事件"><a href="#4-错题事件" class="headerlink" title="4.错题事件"></a>4.错题事件</h2><h3 id="1-三元运算符"><a href="#1-三元运算符" class="headerlink" title="1.三元运算符"></a>1.三元运算符</h3><p><img src="/2022/09/28/%E5%B0%9A%E7%A1%85%E8%B0%B7java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/Snipaste_2022-01-14_21-02-00.png" alt="Snipaste_2022-01-14_21-02-00"></p>
<h2 id="5-面试题："><a href="#5-面试题：" class="headerlink" title="5.面试题："></a>5.面试题：</h2><h4 id="1-多态性"><a href="#1-多态性" class="headerlink" title="1.多态性"></a>1.多态性</h4><p><img src="/2022/09/28/%E5%B0%9A%E7%A1%85%E8%B0%B7java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/Java%5Cimg%5CSnipaste_2022-01-16_10-49-40.png" alt="Snipaste_2022-01-16_10-49-40"></p>
<h1 id="Java编程基础"><a href="#Java编程基础" class="headerlink" title="Java编程基础"></a>Java编程基础</h1><h2 id="1-java概述"><a href="#1-java概述" class="headerlink" title="1.java概述"></a>1.java概述</h2><h3 id="1-1-Java通识介绍"><a href="#1-1-Java通识介绍" class="headerlink" title="1.1 Java通识介绍"></a>1.1 Java通识介绍</h3><p>(1)Java基础是学习JavaEE、大数据、Android开发的基石！</p>
<p>(2)人机交互方式：1.图形化界面GUI简单直观易于上手    2.命令行方式CLI需要一个控制台，输入特定的指令，让计算机完成一些</p>
<p>(3)Java    API 文档：习惯上将语言提供的 类库称为API，API文档是解释如何是这些泪流的说明书</p>
<h3 id="1-2常用的DOS命令"><a href="#1-2常用的DOS命令" class="headerlink" title="1.2常用的DOS命令"></a>1.2常用的DOS命令</h3><p>d: （进入D盘盘符)、cd（进入指定目录，可以直接进入也可一步一步进）、cd..（退回到上一级）、cd\（退回到根目录）、del（删除文件）、rd（删除目录，直接rd有文件的目录可选择删除该文件下的所有文件）、md（创建目录）、dir（列出当前目录下的文件及文件夹）、del *.txt（星花表示所有的意思）</p>
<h3 id="1-3-编写HelloWorld"><a href="#1-3-编写HelloWorld" class="headerlink" title="1.3 编写HelloWorld"></a>1.3 编写HelloWorld</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HelloChina</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Hello,World&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ol>
<li><p>首先创建一个java文件，在文件中写入内容（如以上格式），cmd命令操作进入到文件所在位置写入 <strong>编译</strong>操作javac  文件名.java，此时会自动生成一个HelloChina.class文件，在写入<strong>运行</strong>操作java  文件名（class的文件名)</p>
</li>
<li><p>在一个java源文件中可以声明多个class。但是只能最多有一个类声明为public的。而且要求声明为public的类的类名必须与源文件名相同。</p>
</li>
<li><p>程序的入口是main（）方法，格式是固定的</p>
</li>
<li><p>输出语句：</p>
<p>System.out.println();  先输出数据后换行，单写就是换行</p>
<p>System.out.print();       只输出数据</p>
</li>
<li><p>每一行语句执行都以分号“；”结束</p>
</li>
<li><p>编译的过程：编译以后，会生成一个或多个字结码文件</p>
</li>
</ol>
<p>注意：Java严格区分大小写</p>
<h3 id="1-4-注释（comment）"><a href="#1-4-注释（comment）" class="headerlink" title="1.4 注释（comment）"></a>1.4 注释（comment）</h3><ol>
<li><p>​         &#x2F;&#x2F;单行注释    </p>
</li>
<li><p>​         &#x2F;* 多行注释 *&#x2F;</p>
</li>
<li><p>​           文档注释 Java特有的  </p>
<p>   &#x2F;** </p>
<p>@author 指定Java程序作者</p>
<p>@version 指定源文件版本</p>
<p> *&#x2F;</p>
<p>注释内容可以被JDK提供的工具javadoc所解析，生成一套以网页文件形式体现的该程序的说明文档</p>
<p>操作码为Javadoc  -d  目录名  -author  -version 文件名.java（需要解析的文件）</p>
</li>
</ol>
<h2 id="2-java基础语法"><a href="#2-java基础语法" class="headerlink" title="2.java基础语法"></a>2.java基础语法</h2><h3 id="2-1关键字与保留字"><a href="#2-1关键字与保留字" class="headerlink" title="2.1关键字与保留字"></a>2.1关键字与保留字</h3><p>  定义：被java语言赋予特殊含义，用做专门用途的字符串</p>
<p>  特点：关键字中所有字母都为小写</p>
<ol>
<li><p>用于定义整型类型的关键字    class\interface\enum\byte\short\int\long\float\double\char\boolean\void</p>
</li>
<li><p>用于定义流程控制的关键字</p>
</li>
</ol>
<p>​     if\else\switch\case\default\while\do\for\break\continue\return</p>
<ol start="3">
<li>用于定义访问权限修饰符的关键字</li>
</ol>
<p>   private\protected\public</p>
<ol start="4">
<li><p>用于定义类、函数、变量修饰符的关键字</p>
<p>abstract\final\static\synchronized</p>
</li>
<li><p>用于定义类与类之间关系的关键字  </p>
<p>extends\implements\</p>
</li>
<li><p>用于定义建议实例及引用实例，判断实例的关键字</p>
<p>new\this\super\instanceof</p>
</li>
<li><p>用于异常处理的关键字</p>
<p>try\catch\finally\throw\throws</p>
</li>
<li><p>用于包的关键字</p>
<p>package\import</p>
</li>
<li><p>其他修饰符关键字</p>
<p>native\strictfp\transient\volatile\assert</p>
</li>
<li><p>用于定义数据类型值的字面值（不属于关键字）</p>
</li>
</ol>
<p>  true\false\null</p>
<ol start="11">
<li>保留字goto、const</li>
</ol>
<h3 id="2-2-标识符"><a href="#2-2-标识符" class="headerlink" title="2.2 标识符"></a>2.2 标识符</h3><ol>
<li>定义：凡是自己可以起名字的地方都叫标识符</li>
</ol>
<p>​             比如：类名、变量名、方法名、接口名、包名</p>
<ol start="2">
<li>标识符的命名规则（不规则影响运行）</li>
</ol>
<p>​            由26个英文字母大小写、0-9、__ 、或$组成</p>
<p>​            数字不可以开头</p>
<p>​            不可以使用关键字和保留字，但能包含</p>
<p>​            Java严格区分大小写，长度无限制</p>
<p>​            标识符不能包含空格</p>
<ol start="3">
<li>Java中的名称命名的规范(不规范不影响运行，影响美观和可读性)</li>
</ol>
<p>​              包名：多组单词组成时所有字母都小写：xxxxyyzzz</p>
<p>​              类名、接口名：多组单词组成时，所有单词的首字母大写：XxxYyyZzz</p>
<p>​             变量名、方法名：多组单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写：xxYyyZzz</p>
<p>​             常量名：左右字母都大写，多单词时每个单词用下划线连接：XXX_YYY_ZZZ</p>
<h3 id="2-3变量"><a href="#2-3变量" class="headerlink" title="2.3变量"></a>2.3变量</h3><h4 id="1-变量的概念"><a href="#1-变量的概念" class="headerlink" title="1.变量的概念"></a>1.变量的概念</h4><p>​       变量是程序中最基本的存储单元，包含变量类型、变量名和存储的值，内存中的一个存储区域，用于在内存中保存数据</p>
<h4 id="2-使用变量注意："><a href="#2-使用变量注意：" class="headerlink" title="2.使用变量注意："></a>2.使用变量注意：</h4><p>2.1java 中每个变量必须先声明并赋值（a&#x3D;0），后使用</p>
<p>2.2使用变量名访问这块区域的数据，只能在作用域才有效，也就是{  }中</p>
<p>2.3同一个作用域内，不能定义重名的变量</p>
<h4 id="3-基本数据类型"><a href="#3-基本数据类型" class="headerlink" title="3.基本数据类型"></a>3.基本数据类型</h4><h5 id="1-整型："><a href="#1-整型：" class="headerlink" title="1.整型："></a>1.整型：</h5><p>​          byte\short\int\long </p>
<p>​         byte（1字节&#x3D;8bit）\short（2字节）\int（4字节）\long （8字节）</p>
<p>​         byte范围：-128 ~ 127</p>
<p>​         声明long型变量：必须以“l”或者“L”结尾  （long  b&#x3D; 1234L）</p>
<p>​          通常使用int类型</p>
<h5 id="2-浮点型："><a href="#2-浮点型：" class="headerlink" title="2. 浮点型："></a>2. 浮点型：</h5><p>​                    float\double</p>
<p>​                      float（4字节）\double（8字节）</p>
<p>​                    浮点型表示带小数点的数值</p>
<p>​                     float表示数值范围比long还大</p>
<p>​                    定义float类型变量时，变量要以“f”或者“F”结尾</p>
<p>​                     通常使用double型</p>
<h5 id="3-字符型："><a href="#3-字符型：" class="headerlink" title="3.字符型："></a>3.字符型：</h5><p>​    char  （1字符 &#x3D; 2字节）</p>
<p>​     定义char型变量，通常用一对 ‘ ’ ，内部只能写一个字符  a&#x3D;‘b’ 。也可用直接用数字</p>
<ol>
<li><p>当是char &#x3D; ‘A’ 时</p>
<p>直接输出，就是A</p>
<p>如果做运算在输出，这是对应的Ascll码值做运算后的数：’A’ &#x3D;65  ‘A’ -1&#x3D;64;</p>
</li>
<li><p>当是char  &#x3D;  65</p>
<p>直接输出就是对应的A（字符）</p>
<p>做运算后就是数</p>
</li>
<li><p>&#x3D;&#x3D;比较的是Ascll码值</p>
<p>char num5 &#x3D;’A’;</p>
<p>char num6 &#x3D;65;</p>
<p>System.out.println(num5&#x3D;&#x3D;num6);</p>
<p>&#x2F;&#x2F;true</p>
<p>  转义字符：\b退格符\n换行符\r回车符\t制表符大空格&quot;引号\\反斜杠</p>
</li>
</ol>
<h5 id="4-布尔型："><a href="#4-布尔型：" class="headerlink" title="4.布尔型："></a>4.布尔型：</h5><p>​                     boolean</p>
<p>​                     ture、false（常用于条件判断，循环结构中使用）</p>
<h4 id="4-引用数据类型"><a href="#4-引用数据类型" class="headerlink" title="4.引用数据类型"></a>4.引用数据类型</h4><p>补充：引用类型变量，只可能存储两类值：null  或  地址值（含变量类型）</p>
<h5 id="1-类：class"><a href="#1-类：class" class="headerlink" title="1.类：class"></a>1.类：class</h5><h5 id="2-接口：interface"><a href="#2-接口：interface" class="headerlink" title="2.接口：interface"></a>2.接口：interface</h5><h5 id="3-数组：array"><a href="#3-数组：array" class="headerlink" title="3.数组：array"></a>3.数组：array</h5><ol>
<li><p>强制转换</p>
<p>需要强制转换符（），注意转换时可能会导致精度损失</p>
<p>double d1&#x3D;12.9;</p>
<p>int i&#x3D;(int)d1;</p>
</li>
<li><p>自动类型提升</p>
<p>结论：当容量小的数据类型变量与容量大的数据类型变量做运算时，结果自动提升为容量大的数据类型</p>
<p>byte\char\short--&gt;int–&gt;long–&gt;float–&gt;double</p>
<p>特别地，当byte\char\short做运算时结果都为int</p>
</li>
</ol>
<h5 id="4-String类型变量"><a href="#4-String类型变量" class="headerlink" title="4.String类型变量"></a>4.String类型变量</h5><ol>
<li><p>String属于引用数据类型，意思是  字符串</p>
</li>
<li><p>声明String类型变量时，使用一对“”</p>
</li>
<li><p>String可以和八种数据类型变量做运算，且运算只能是连接运算 +  </p>
</li>
<li><p>在String之后的运算结果仍然是String类型</p>
<p>String s &#x3D; “ hello”</p>
<p>int  i &#x3D; 1；</p>
<p>int j &#x3D;  2；</p>
<p>s +  i  +j  &#x3D;hello12</p>
<p>i + j  +  s &#x3D; 3hello </p>
<p>注意定义String  s2 &#x3D; “”；  &#x2F;&#x2F;可为空</p>
<p> char  s3 &#x3D; ‘’  &#x2F;&#x2F;不可为空​</p>
</li>
</ol>
<h3 id="2-4进制转换"><a href="#2-4进制转换" class="headerlink" title="2.4进制转换"></a>2.4进制转换</h3><p>对于整数，有四种表达方式：</p>
<ol>
<li><p>二进制    满二进一，以0b或0B开头</p>
</li>
<li><p>十进制      满十进一</p>
</li>
<li><p>八进制      满八进一  以数字0开头表示</p>
</li>
<li><p>十六进制   满十六进一   以0x或0X开头 </p>
</li>
<li><p>二进制转换其他进制 0  、1 ，满二进一，以0b或0B开头</p>
<ol>
<li><p>十进制</p>
<p>1011&#x3D;1*2的0次方+1 *2的1次方+0 *2的2次方+1 *2的3次方&#x3D; 11</p>
<p><strong>注意</strong>有小数点时：1011.01 先计算整数部分剩余0.01&#x3D;0 *2的0次方+1 *2的-1次方&#x3D;0.5</p>
</li>
<li><p>八进制</p>
<p>1011看成三位一组001-011&#x3D;&gt;1+3&#x3D;4</p>
</li>
<li><p>十六进制</p>
<p>1011看成四位一组1011&#x3D;&gt;B</p>
</li>
</ol>
</li>
<li><p>十进制转换其他进制  0—9</p>
<p>​         想转什么进制就除什么倒取余法</p>
<p>​         <strong>注意</strong>转二进制有小数点时：先计算整数部分，如剩余0.5，不断乘2取整，直到小数部分为零0.5对应的二进制是0.1,0.25对应0.01</p>
</li>
<li><p>八进制转换其他进制 0—-7</p>
<ol>
<li><p>二进制</p>
<p>每个数看成三个位数一组的二进制</p>
</li>
<li><p>十进制</p>
<p>先转成二进制在二转十</p>
</li>
<li><p>十六进制</p>
<p>先转二在转十六</p>
</li>
</ol>
</li>
<li><p>十六进制转换其他进制 0—-F（A&#x3D;10….F&#x3D;15)</p>
<ol>
<li><p>二进制</p>
<p>每个数看成四个位数一组的二进制</p>
</li>
<li><p>十进制</p>
<p>先转成二进制在二转十</p>
</li>
<li><p>八进制</p>
<p>先转成二进制在二转八</p>
</li>
</ol>
<p>计算机底层以补码形式存储数据，注意给的码为原码要转补码进行计算，如果最高位为0则为正数，原码反码补码都一样，若最高位为1则为负数</p>
<p>则原码除最高位字符数不懂其余取反加一为补码</p>
</li>
<li><p>补充代码：十转十六(传统方法，一般直接调用类来算)</p>
<p>int  p1 &#x3D; 60 ;</p>
<p>int  p2 &#x3D; p1&amp;15;  &#x2F;&#x2F;由于60底层是二进制存储，和15逻辑与1111，保留了前四位数</p>
<p>String j &#x3D; (p2&gt;9)?(char)(p2-10+’A’)+”” : p2+”” ;  &#x2F;&#x2F;若大于9，则用字母表示</p>
<p>int temp &#x3D; p1&gt;&gt;&gt; 4;  &#x2F;&#x2F;右移4位，将后四位移到前面</p>
<p>p2 &#x3D; temp &amp; 15;     &#x2F;&#x2F;在次保留了后四位</p>
<p>String   k &#x3D;  (p2&gt;9)?(char)(p2-10+’A’)+”” : p2+ “” ;  </p>
<p>System.out.println(k+””+j);   &#x2F;&#x2F; 3 C</p>
</li>
</ol>
<h3 id="2-5-运算符"><a href="#2-5-运算符" class="headerlink" title="2.5 运算符"></a>2.5 运算符</h3><h4 id="1-算术运算符"><a href="#1-算术运算符" class="headerlink" title="1.算术运算符"></a>1.算术运算符</h4><p>+正号-负号+加号-减号*乘号&#x2F;除号%取余号 ，++,–,</p>
<p>(前)++，先自增1，后运算</p>
<p>(后)–，先运算后，自增1</p>
<p>short s1 &#x3D; 10 ；</p>
<p>&#x2F;&#x2F;s1 &#x3D; s1 + 1 &#x2F;&#x2F;编译失败，加 2 变为整型int</p>
<p>注意：s++ 不会改变本身的数据类型</p>
<h4 id="2-赋值运算符"><a href="#2-赋值运算符" class="headerlink" title="2.赋值运算符"></a>2.赋值运算符</h4><p>&#x3D;      +&#x3D;    -&#x3D;     *&#x3D;    &#x2F;&#x3D;    %&#x3D;</p>
<ol>
<li><p>int i &#x3D; 10 ;      int  j &#x3D; 10;</p>
</li>
<li><p>int i , j ;           i&#x3D;j&#x3D;10  ;</p>
</li>
<li><p>int i&#x3D;10,j&#x3D;10;</p>
</li>
<li><p>n +&#x3D;2     &#x2F;&#x2F; n &#x3D;  n  +   2</p>
</li>
<li><p>&#x2F;&#x2F;s1 &#x3D; s1 + 2 &#x2F;&#x2F;编译失败，加 2 变为整型int</p>
<p>注意：s1 +&#x3D; 2   不会改变本身的数据类型</p>
</li>
</ol>
<h4 id="3-比较运算符（关系运算符）"><a href="#3-比较运算符（关系运算符）" class="headerlink" title="3.比较运算符（关系运算符）"></a>3.比较运算符（关系运算符）</h4><p>&#x3D;&#x3D;     !&#x3D;   &gt;    &lt;     &gt;&#x3D;     &lt;&#x3D;    instanceof</p>
<p>比较运算符的结果是 boolean 类型 </p>
<p>   &lt;  &gt;   &gt;&#x3D;     &lt;&#x3D;  ：只能使用在数值类型的数据之间</p>
<p>&#x3D;&#x3D;     !&#x3D;     ：不仅可以使用在数值类型数据之间，还可以使用在引用类型变量之间</p>
<h4 id="4-逻辑运算符"><a href="#4-逻辑运算符" class="headerlink" title="4.逻辑运算符"></a>4.逻辑运算符</h4><p>&amp; （逻辑与）&amp;&amp;（短路与）  都一样 ，遇到false为false</p>
<blockquote>
<p>&amp;：前面表达式为真时，继续执行后面的表达式</p>
<p>&amp;&amp;：遇到false 不会执行后面的表达式</p>
</blockquote>
<p>|    （逻辑或）  ||    （短路或） 都一样 ， 遇到true 为true</p>
<blockquote>
<p>|：前面表达式为真时，继续执行后面的表达式</p>
<p>||：遇到true 不会执行后面的表达式</p>
</blockquote>
<p>！ （逻辑非）   ^    （逻辑异或） 异或一样则错，不同则对</p>
<h4 id="5-三元运算符"><a href="#5-三元运算符" class="headerlink" title="5.三元运算符"></a>5.三元运算符</h4><ol>
<li>结构： （条件表达式）？ 表达式1 ： 表达式2</li>
<li>说明：<ol>
<li>条件表达式结果为boolean </li>
<li>条件表达式为真选表达式1，反之2</li>
<li>表达式1和表达式2类型要求是一致的</li>
<li>三元运算符可以嵌套使用</li>
</ol>
</li>
<li>凡是可以使用三元运算符的地方，都可以改写为if -  else  反之不成立</li>
<li>如果程序两者都可用，优先选择三元运算符，原因：简洁，执行效率高</li>
</ol>
<h4 id="6-位运算符"><a href="#6-位运算符" class="headerlink" title="6.位运算符"></a>6.位运算符</h4><ol>
<li><p>位运算符操作都是整型操作的数据,二进制形式移动</p>
</li>
<li><p>&lt;&lt; :  空位补0，被移除的高位丢弃，空缺位补0</p>
<p>在一定范围内， 每向左移一位，相当于  乘2</p>
</li>
<li><p>(&gt;&gt;) : 被位移的二进制最高位是0，右移后空位缺位补0；最高位是1，空缺补1</p>
<p> 在一定范围内，每向右移一位，相当于  除二</p>
</li>
<li><p>面试题 ： 最高效方式计算 2 *  8  ?   2&lt;&lt; 3 或者  8&lt;&lt; 1</p>
</li>
<li><p>(&gt;&gt;&gt;): 被右移二进制最高位无论是0或者是1 ，空缺位都用零补</p>
</li>
<li><p>二进制运算  &amp; 有0则都为0   | 有1则都为1      ^  同则0 不同则1   ~ 取反</p>
</li>
</ol>
<h3 id="2-6-程序流程控制"><a href="#2-6-程序流程控制" class="headerlink" title="2.6 程序流程控制"></a>2.6 程序流程控制</h3><p>注意：以下流程控制语句都是可嵌套使用的</p>
<h4 id="1-if–else"><a href="#1-if–else" class="headerlink" title="1.if–else"></a>1.if–else</h4><p>第一种</p>
<p>if（条件表达式）{</p>
<p>执行表达式</p>
<p>}</p>
<p>第二种</p>
<p>if（条件表达式）{</p>
<p>执行表达式</p>
<p>}else{</p>
<p>执行表达式2</p>
<p>}</p>
<p>第三种（满足一个则终止下面的判断）多选一</p>
<p>if（条件表达式）{</p>
<p>执行表达式1</p>
<p>}else if（条件表达式）{</p>
<p>执行表达式2</p>
<p>}else if（条件表达式）{</p>
<p>执行表达式3</p>
<p>}</p>
<p>…..</p>
<p>else {</p>
<p>​     执行表达式n</p>
<p>}</p>
<p>注意：if–else可嵌套使用</p>
<h4 id="2-java中的输入，需要使用Scanner类"><a href="#2-java中的输入，需要使用Scanner类" class="headerlink" title="2.java中的输入，需要使用Scanner类"></a>2.java中的<strong>输入，需要使用Scanner类</strong></h4><p>具体操作步骤：</p>
<ol>
<li><p>导包： import java.util.Scanner;</p>
</li>
<li><p>Scanner的实例化：Scanner scan &#x3D; new Scanner(System.in);</p>
</li>
<li><p>调用Scanner类的相关方法（next（）这是输入String类型特殊&#x2F;nextXxx（）这是输入其他类型的)</p>
</li>
<li><p>注意：需要根据相应的类型来从键盘输入指定类型的值，否则会报错</p>
</li>
<li><p>代码示范：</p>
<p><strong>import java.util.Scanner;</strong></p>
<p>class ScannerTest{</p>
<p>public static void main(String[] args){</p>
<p><strong>Scanner scan &#x3D;  new Scanner(System.in);</strong></p>
<p><strong>int test &#x3D; scan.nextInt();</strong></p>
<p>&#x2F;&#x2F;第二种</p>
<p><strong>int test&#x3D;0;</strong></p>
<p><strong>test &#x3D;  scan.nextInt();</strong></p>
<p><strong>}</strong></p>
<p>}</p>
</li>
<li><p>对于char型的获取，Scanner没有提供相应的方法。一般只用String代替。如要获取则有如下方法</p>
<p>将String字符串中取出一个字符放入char中</p>
<p>String p &#x3D; “安娜娜”；</p>
<p>char  q &#x3D; p.charAt(0);  &#x2F;&#x2F;第一个字符从零开始  q&#x3D;‘安’</p>
</li>
</ol>
<h4 id="3-switch-表达式"><a href="#3-switch-表达式" class="headerlink" title="3.switch(表达式){"></a>3.switch(表达式){</h4><p>case x：执行语句；</p>
<p>​               break；</p>
<p>case m：</p>
<p>….</p>
<p>default：执行语句；</p>
<p>​              break；</p>
<p>}</p>
<ol>
<li><p>根据switch表达式中的值，依次匹配各个case中的<strong>常量</strong>。一旦匹配成功，则进入相应case结构中，调用其执行语句。执行本语句结束后，<strong>继续向下调</strong>用其余case结构中的执行语句，直到遇到break关键字或者直到switch末尾结束。</p>
</li>
<li><p>break与default是可加可不加的，default是没有其他选择后最后的选择</p>
</li>
<li><p>switch结构中的表达式，只能是这6种数据类型之一：</p>
<p>byte、short、char、int、枚举类型JDK5.0新增、String类型JDK7.0新增</p>
</li>
<li><p>switch两种情况测试</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(constant)&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>: a=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>: a=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>: a=<span class="number">3</span>;</span><br><span class="line"><span class="keyword">default</span>:a=<span class="number">4</span>;</span><br><span class="line">&#125;<span class="comment">//输入1，遍历1 语句后没有break，向下遍历，最终a=4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span>(constant)&#123;</span><br><span class="line"><span class="keyword">default</span>:a=<span class="number">4</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>: a=<span class="number">1</span>;	</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>: a=<span class="number">2</span>;	</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>: a=<span class="number">3</span>;	</span><br><span class="line">&#125;    <span class="comment">//  输入1 ，没有break，直到末尾a=3，没有遍历default</span></span><br><span class="line">System.out.println(a);</span><br></pre></td></tr></table></figure>
</li>
<li><p>判断闰年：可以被4整除并且不可以被100整除或可以被400整除</p>
</li>
</ol>
<h4 id="4-for-循环语句"><a href="#4-for-循环语句" class="headerlink" title="4.for 循环语句"></a>4.for 循环语句</h4><ol>
<li><p>条件：</p>
<ol>
<li>初始条件</li>
<li>循环条件—–&gt;是boolean类型</li>
<li>循环体（执行语句）</li>
<li>迭代条件</li>
</ol>
</li>
<li><p>for 循环的结构:</p>
</li>
</ol>
<p>   for( 1初始条件 ;  2循环条件   ;  4迭代条件  ){</p>
<p>   ​        3循环体</p>
<p>   }</p>
<ol start="3">
<li><p>for（int i &#x3D; 1 ;  i&lt;&#x3D;5 ; i++){</p>
<p>System.out.println(“Hello,world!”);</p>
<p>}</p>
<p><strong>注意：i在for循环内有效</strong>。出了for循环就失效，无法在调用。</p>
</li>
</ol>
<h4 id="5-while循环语句"><a href="#5-while循环语句" class="headerlink" title="5.while循环语句"></a>5.while循环语句</h4><ol>
<li><p>循环结构四个要素条件：</p>
<ol>
<li>初始条件</li>
<li>循环条件—–&gt;是boolean类型</li>
<li>循环体（执行语句）</li>
<li>迭代条件</li>
</ol>
</li>
<li><p>while循环的结构</p>
<p>int i &#x3D; 1；</p>
<p>while（i&lt;&#x3D;100）</p>
<p>{</p>
<p>执行语句；……</p>
<p>迭代条件 i + +</p>
<p>}</p>
<p>由于算法要求有限性，所以要避免死循环</p>
</li>
</ol>
<h4 id="6-do-–while循环"><a href="#6-do-–while循环" class="headerlink" title="6.do –while循环"></a>6.do –while循环</h4><ol>
<li><p>循环结构四个要素条件：</p>
<ol>
<li>初始条件</li>
<li>循环条件—–&gt;是boolean类型</li>
<li>循环体（执行语句）</li>
<li>迭代条件</li>
</ol>
</li>
<li><p>do—while循环结构</p>
<p>1初始条件</p>
<p>do{</p>
<p>3循环体（执行语句）；</p>
<p>4迭代条件；</p>
<p>}while（2循环条件）；</p>
</li>
<li><p>说明：</p>
<p>do—while循环至少会执行一次循环体！</p>
<p>开发中，使用for和while更多一些，较少使用do—while</p>
</li>
</ol>
<h3 id="2-7此节的一些零碎要点"><a href="#2-7此节的一些零碎要点" class="headerlink" title="2.7此节的一些零碎要点"></a>2.7此节的一些零碎要点</h3><h5 id="1-计算程序运行时间"><a href="#1-计算程序运行时间" class="headerlink" title="1.计算程序运行时间"></a>1.计算程序运行时间</h5><p>利用System.currentTimeMillis();</p>
<p>这返回的是1970-01-01 00:00:00long型的毫秒数时间：</p>
<p>long start &#x3D; System.currentTimeMillis();</p>
<p>需要计算的程序放中间</p>
<p>long end  &#x3D; System.currentTimeMillis();</p>
<p>用end - start得到的就是运行程序所需的时间</p>
<h5 id="2-Math-sqrt-i"><a href="#2-Math-sqrt-i" class="headerlink" title="2.Math.sqrt(i);"></a>2.Math.sqrt(i);</h5><p> 对i进行开根号</p>
<h5 id="3-关键字：return"><a href="#3-关键字：return" class="headerlink" title="3.关键字：return"></a>3.关键字：return</h5><p>并非专门用于结束循环的，它的功能是结束一个方法（函数）</p>
<h5 id="4-关键字：break和continue"><a href="#4-关键字：break和continue" class="headerlink" title="4.关键字：break和continue"></a>4.关键字：break和continue</h5><table>
<thead>
<tr>
<th></th>
<th align="left">使用范围</th>
<th>循环中的不同</th>
<th>相同点</th>
</tr>
</thead>
<tbody><tr>
<td>break</td>
<td align="left">循环结构中以及switchcase</td>
<td>结束当前循环</td>
<td>关键字后面不能在写语句</td>
</tr>
<tr>
<td>continue</td>
<td align="left">循环结构中</td>
<td>结束当次循环</td>
<td>关键字后面不能在写语句</td>
</tr>
</tbody></table>
<h5 id="5-Math-random-产生随机数"><a href="#5-Math-random-产生随机数" class="headerlink" title="5.Math.random()产生随机数"></a>5.Math.random()产生随机数</h5><p><strong>Math.random()<strong>这函数</strong>产生的随机数</strong>是double类型的范围是[0.0,1.0)</p>
<p>如何获取一个随机数10-99：</p>
<p>int  value &#x3D; (int)(Math.random()*90+10)</p>
<p>乘90范围变为[0.0,90.0)，加十[10.0,100.0)，强转int后[10,99]</p>
<p>得出公式：[a,b]：(int)(Math.random()*(b-a+1)+a)</p>
<p>注意：</p>
<ol>
<li><p>默认结束包裹此关键字最近的一层循环</p>
</li>
<li><p>label:for(int i&#x3D;1; i&lt;&#x3D;4;i++)</p>
<p>if (i%4&#x3D;&#x3D;0)</p>
<p> break label  ;  结束指定标识的一层循环结构</p>
<p>continue label；结束指定标识的一层循环结构当次循环</p>
</li>
</ol>
<h5 id="6-补充：衡量一个功能代码的优劣"><a href="#6-补充：衡量一个功能代码的优劣" class="headerlink" title="6.补充：衡量一个功能代码的优劣"></a>6.补充：衡量一个功能代码的优劣</h5><ol>
<li>正确性</li>
<li>可读性</li>
<li>健壮性</li>
<li>高效率与低存储：时间复杂度、空间复杂度（衡量算法的好坏）</li>
</ol>
<h2 id="3-数组"><a href="#3-数组" class="headerlink" title="3.数组"></a>3.数组</h2><h3 id="3-1数组的概述"><a href="#3-1数组的概述" class="headerlink" title="3.1数组的概述"></a>3.1数组的概述</h3><h4 id="1-数组的理解："><a href="#1-数组的理解：" class="headerlink" title="1. 数组的理解："></a>1. 数组的理解：</h4><p>数组（Array），是多个相同类型数据按一定顺序排序的集合，并使用一个名字命名，并通过编号的方式对这些数据进行统一管理。</p>
<h4 id="2-数组的相关概念："><a href="#2-数组的相关概念：" class="headerlink" title="2.数组的相关概念："></a>2.数组的相关概念：</h4><ol>
<li>数组名</li>
<li>元素</li>
<li>角标、下标、索引</li>
<li>数组的长度：元素个数</li>
</ol>
<h4 id="3-数组的特点："><a href="#3-数组的特点：" class="headerlink" title="3.数组的特点："></a>3.数组的特点：</h4><ol>
<li>数组是有序的</li>
<li>数组属于引用数据类型的变量。数组元素，既可以是基本数据类型，也可以是引用数据类型</li>
<li>创建数组对象会存在中开辟一整块连续的空间</li>
<li>数组的长度一旦确定，就不能修改</li>
</ol>
<h4 id="4-数组的分类："><a href="#4-数组的分类：" class="headerlink" title="4.数组的分类："></a>4.数组的分类：</h4><ol>
<li>按维数：一维数组、二维数组……….</li>
<li>按照数组元素的类型，基本数据元素的数组、引用数据类型元素的数组</li>
</ol>
<h3 id="3-2一维数组的使用"><a href="#3-2一维数组的使用" class="headerlink" title="3.2一维数组的使用"></a>3.2一维数组的使用</h3><h4 id="1-一维数组的声明和初始化"><a href="#1-一维数组的声明和初始化" class="headerlink" title="1.一维数组的声明和初始化"></a>1.一维数组的声明和初始化</h4><p>1.<strong>静态</strong>初始化：数组的初始化和数组元素的赋值操作<strong>同时进行</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>)</span><br><span class="line"><span class="type">int</span>[ ]  ids;</span><br><span class="line">ids = <span class="keyword">new</span>  <span class="title class_">int</span>[ ]&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;;</span><br><span class="line">(<span class="number">2</span>)</span><br><span class="line"><span class="type">int</span>[ ]  ids= <span class="keyword">new</span>  <span class="title class_">int</span>[ ]&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;;</span><br><span class="line">(<span class="number">3</span>)</span><br><span class="line"><span class="type">int</span>[ ]  ids = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;</span><br><span class="line">(<span class="number">4</span>)语法不错误，但不建议</span><br><span class="line"><span class="type">int</span>  ids[ ] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;</span><br></pre></td></tr></table></figure>

<p>2.<strong>动态</strong>初始化：数组的初始化和数组元素的赋值操作<strong>分开进行</strong></p>
<p>String[ ]  names &#x3D; new  String [5];</p>
<h4 id="2-如何调用数组的指定位置的元素"><a href="#2-如何调用数组的指定位置的元素" class="headerlink" title="2.如何调用数组的指定位置的元素"></a>2.如何调用数组的指定位置的元素</h4><p>通过角标的方式调用。</p>
<p>角标从0开始的，到数组长度-1结束</p>
<h4 id="3-如何获取数组的长度"><a href="#3-如何获取数组的长度" class="headerlink" title="3.如何获取数组的长度"></a>3.如何获取数组的长度</h4><p>int[ ]  ids;</p>
<p>ids &#x3D; new  int[ ]{1,3,4,5,6,7};</p>
<p>长度 &#x3D;  ids.length</p>
<h4 id="4-如何遍历数组"><a href="#4-如何遍历数组" class="headerlink" title="4.如何遍历数组"></a>4.如何遍历数组</h4><p>for(int i&#x3D;0 ; i&lt;ids.length ; i++){</p>
<p>System.out,println(ids[ i ]);</p>
<p>}</p>
<h4 id="5-数组元素的默认初始化值"><a href="#5-数组元素的默认初始化值" class="headerlink" title="5.数组元素的默认初始化值"></a>5.数组元素的默认初始化值</h4><p>数组元素是整型：0</p>
<p>数组元素是浮点型：0.0</p>
<p>数组元素是char型：0，而非’0’</p>
<p>数组元素是boolean型：false</p>
<h4 id="6-数组的内存解析"><a href="#6-数组的内存解析" class="headerlink" title="6.数组的内存解析"></a>6.数组的内存解析</h4><p><img src="/2022/09/28/%E5%B0%9A%E7%A1%85%E8%B0%B7java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/img%5CSnipaste_2022-01-07_17-12-47.png" alt="Snipaste_2022-01-07_17-12-47"></p>
<p><img src="/2022/09/28/%E5%B0%9A%E7%A1%85%E8%B0%B7java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/img%5CSnipaste_2022-01-07_18-06-56.png" alt="Snipaste_2022-01-07_18-06-56"></p>
<h3 id="3-3二维数组的使用："><a href="#3-3二维数组的使用：" class="headerlink" title="3.3二维数组的使用："></a>3.3二维数组的使用：</h3><h4 id="1-理解："><a href="#1-理解：" class="headerlink" title="1.理解："></a>1.理解：</h4><p>我们可以看成是一维数组array1又作为另一个一维数组array2的元素而存在</p>
<p>其实，从数组底层的运行机制来看，其实没有多维数组</p>
<p>见解：一维数组套另外一个一维数组</p>
<h4 id="2-二维数组的声明和初始化"><a href="#2-二维数组的声明和初始化" class="headerlink" title="2.二维数组的声明和初始化"></a>2.二维数组的声明和初始化</h4><p><strong>静态初始化：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>)</span><br><span class="line"><span class="type">int</span>[ &#125;[ ] ids;</span><br><span class="line">ids = <span class="keyword">new</span>  <span class="title class_">int</span>[ &#125;[ ]&#123; &#123;<span class="number">1</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;,&#123;<span class="number">7</span>&#125; &#125;;</span><br><span class="line">(<span class="number">2</span>)</span><br><span class="line"><span class="type">int</span>[ &#125;[ ]  ids= <span class="keyword">new</span>  <span class="title class_">int</span>[ &#125;[ ]&#123; &#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>&#125;,&#123;<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125; &#125;;</span><br><span class="line">(<span class="number">3</span>)</span><br><span class="line"><span class="type">int</span>[ &#125;[ ]  ids = &#123; &#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>&#125;,&#123;<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125; &#125;;</span><br><span class="line">(<span class="number">4</span>)语法不错误，但不建议</span><br><span class="line"><span class="type">int</span> []  arr[] =<span class="keyword">new</span>  <span class="title class_">int</span>[ &#125;[ ]&#123; &#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>&#125;,&#123;<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125; &#125;;</span><br><span class="line">(<span class="number">5</span>)语法不错误，但不建议</span><br><span class="line"><span class="type">int</span> []  arr[] = [ &#125;[ ]&#123; &#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>&#125;,&#123;<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125; &#125;;</span><br></pre></td></tr></table></figure>

<p><strong>动态初始化：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>)</span><br><span class="line">String[ &#125;[ ]  names = <span class="keyword">new</span>  <span class="title class_">String</span> [<span class="number">5</span>&#125;[<span class="number">4</span>];</span><br><span class="line">(<span class="number">2</span>)</span><br><span class="line">String[ &#125;[ ]  names = <span class="keyword">new</span>  <span class="title class_">String</span> [<span class="number">5</span>&#125;[ ];<span class="comment">//不能不写左边只写右边，根据内存解析更容易理解</span></span><br><span class="line">names[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">4</span>];</span><br><span class="line"><span class="comment">//单独将第一行所指的一维数组创建出来</span></span><br></pre></td></tr></table></figure>

<h4 id="3-如何调用数组的指定位置的元素"><a href="#3-如何调用数组的指定位置的元素" class="headerlink" title="3.如何调用数组的指定位置的元素"></a>3.如何调用数组的指定位置的元素</h4><p>arr【i】【j】</p>
<h4 id="4-如何获取数组的长度"><a href="#4-如何获取数组的长度" class="headerlink" title="4.如何获取数组的长度"></a>4.如何获取数组的长度</h4><p>arr.length是行数一维数组的长度</p>
<p>arr[1].length是指定第一行所指的一维数组的长度</p>
<h4 id="5-如何遍历数组"><a href="#5-如何遍历数组" class="headerlink" title="5.如何遍历数组"></a>5.如何遍历数组</h4><p>for(int i&#x3D;0 ; i&lt;arr.length ; i++){</p>
<p>​	for(int j&#x3D;0 ; j&lt;arr[i].length ; j++)</p>
<p>​              System.out.print(arr[i}[j]);</p>
<p>}</p>
<h4 id="6-数组元素的默认初始化值"><a href="#6-数组元素的默认初始化值" class="headerlink" title="6.数组元素的默认初始化值"></a>6.数组元素的默认初始化值</h4><p>情况一：int[}[]  arr &#x3D; new int [4}[3];</p>
<p>外层元素初始化值：地址值</p>
<p>内层元素初始化值：与一维数组初始化情况相同</p>
<p>情况二：int[}[]  arr &#x3D; new int [4}[];</p>
<p>外层元素初始化：null</p>
<p>内层元素初始化值：不能调用，会报错</p>
<h4 id="7-数组的内存解析"><a href="#7-数组的内存解析" class="headerlink" title="7.数组的内存解析"></a>7.数组的内存解析</h4><p><img src="/2022/09/28/%E5%B0%9A%E7%A1%85%E8%B0%B7java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/img%5CSnipaste_2022-01-07_21-00-01.png" alt="Snipaste_2022-01-07_21-00-01"></p>
<h3 id="3-4-数组中涉及到常见算法"><a href="#3-4-数组中涉及到常见算法" class="headerlink" title="3.4 数组中涉及到常见算法"></a>3.4 数组中涉及到常见算法</h3><h4 id="1-数组元素的赋值"><a href="#1-数组元素的赋值" class="headerlink" title="1.数组元素的赋值"></a>1.数组元素的<strong>赋值</strong></h4><p>（杨辉三角、回形数等）</p>
<p>int[] array1,array2;   </p>
<p>int[]  array1 &#x3D;  new int[] {1,3,4,5,6,7,8};   </p>
<p>array2  &#x3D;   array1;</p>
<p>&#x2F;&#x2F;在栈空间中创建了两个数组类型的指针</p>
<p>&#x2F;&#x2F;new 的话，就是在堆空间创建了数组实体，array2 没有new，所以没有自己的数组实体</p>
<p>过程理解：将array1保存的数组的地址值赋给了array2，使得array1和array2共同指向堆空间中的同一个数组实体</p>
<h4 id="2-求数组中元素的最大值、最小值、平均数、总和"><a href="#2-求数组中元素的最大值、最小值、平均数、总和" class="headerlink" title="2.求数组中元素的最大值、最小值、平均数、总和"></a>2.求数组中元素的最大值、最小值、平均数、总和</h4><h4 id="3-数组的复制、反转、查找（线性查找、二分查找）"><a href="#3-数组的复制、反转、查找（线性查找、二分查找）" class="headerlink" title="3.数组的复制、反转、查找（线性查找、二分查找）"></a>3.数组的<strong>复制</strong>、反转、查找（线性查找、二分查找）</h4><p>数组的复制：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[]  array1 =  <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;;</span><br><span class="line"><span class="type">int</span>[]  array2 = <span class="keyword">new</span> <span class="title class_">int</span>[array1.length];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span> ; i&lt;array2.length ; i++)&#123;</span><br><span class="line">    		array2[i]  =  array1[i] ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>数组的反转：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span> ; i&lt;arr.length / <span class="number">2</span> ; i++)&#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">		arr[i] = arr[arr.length-<span class="number">1</span>-i];</span><br><span class="line">		arr[arr.length-<span class="number">1</span>-i] = temp;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>数组的二分查找：</p>
<h4 id="4-数组元素的排序算法"><a href="#4-数组元素的排序算法" class="headerlink" title="4.数组元素的排序算法"></a>4.数组元素的排序算法</h4><p>十大内部排序算法：</p>
<ol>
<li>选择排序：直接选择排序、<u>堆排序</u>（次要）</li>
<li>交换排序：<strong>冒泡排序、快速排序</strong>（重点了解）</li>
<li>插入排序：直接插入排序、折半插入排序、希尔shell排序</li>
<li><u>归并排序</u>（次要）</li>
<li>桶式排序</li>
<li>基数排序</li>
</ol>
<p><strong>冒泡排序：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>（<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i&lt;arr.length -<span class="number">1</span> ;  i++)&#123;</span><br><span class="line"><span class="keyword">for</span>( <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span> ;  j&lt;arr.length-<span class="number">1</span>-i  ;   j++)</span><br><span class="line">      <span class="keyword">if</span> ( arr[ j ] &gt; arr[ j + <span class="number">1</span> ])&#123;</span><br><span class="line">	<span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[ j ];</span><br><span class="line">	arr[ j ] =  arr[ j + <span class="number">1</span>] ;</span><br><span class="line">	arr[ j + <span class="number">1</span> ] = temp ;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>快速排序 时间复杂度 O(olog n )   归并和堆排序也是一样</p>
<p>冒泡排序时间复杂度 O( n^2 )</p>
<h3 id="3-5零碎知识："><a href="#3-5零碎知识：" class="headerlink" title="3.5零碎知识："></a>3.5零碎知识：</h3><h4 id="1-排序算法的分类："><a href="#1-排序算法的分类：" class="headerlink" title="1.排序算法的分类："></a>1.排序算法的分类：</h4><p>内部排序：不借助外部存储器（如磁盘），所有排序操作都在内存中完成</p>
<p>外部排序：参与排序数据非常多，数据量非常大，计算机无法把整个排序过程在内存中完成，必须借助于外部存储器（如磁盘）。最常见的是多路归并排序。可以认为外部排序是由多次内部排序组成的。</p>
<h4 id="2-算法的5大特征"><a href="#2-算法的5大特征" class="headerlink" title="2.算法的5大特征"></a>2.算法的5大特征</h4><p>输入、输出、有穷性（有限性）、确定性（明确性算法中每一步都有确定的含义）、可行性、</p>
<h4 id="3-数据结构"><a href="#3-数据结构" class="headerlink" title="3.数据结构:"></a>3.数据结构:</h4><ol>
<li><p>数据与数据之间的逻辑关系：集合、一对一、一对多、多对多</p>
</li>
<li><p>数据的存储结构;线性表、树形结构、图形结构</p>
</li>
<li><p>算法：</p>
<p>排序算法、搜索（查找）算法</p>
</li>
</ol>
<h4 id="4-小习题："><a href="#4-小习题：" class="headerlink" title="4.小习题："></a>4.小习题：</h4><p>​            声明一维数组x[]、二维数组y[}[]</p>
<ol>
<li><p>x[0] &#x3D; y  ;   no -&gt;一维数组值不能存放二维数组的地址</p>
</li>
<li><p>y[0]  &#x3D;  x ;  yes -&gt; 二维数组的外层本来就是放一维数组地址的，因此可以放x的地址</p>
</li>
<li><p>y[0}[0] &#x3D; x ; no -&gt; 二维数组的内层放的就是值，不能放地址了</p>
</li>
<li><p>x[0}[0] &#x3D;  y ;  no -&gt; x是一维数组，计算机是可以分辨的</p>
</li>
<li><p>y[0}[0]  &#x3D;  x[0]  yes -&gt; 两个都是值，可以相互赋值</p>
</li>
<li><p>x &#x3D;y ;  no -&gt; 一维数组不能指向二维数组</p>
<p>总结：创建数组过程：声明（在栈空间中创建了地址）&#x3D;&gt;有new的话（在堆空间中创建数组实体内存（栈空间的声明指向它）如果是二维数组外层一维数组存放自己对应内层一维数组的地址值</p>
</li>
</ol>
<h3 id="3-5Arrays工具类的使用"><a href="#3-5Arrays工具类的使用" class="headerlink" title="3.5Arrays工具类的使用"></a>3.5Arrays工具类的使用</h3><p><strong>需要调用这个类import java.util.Arrays;</strong></p>
<ol>
<li><p>boolean   equals(int[] a , int[] b )   前面是返回值类型&#x2F;&#x2F;判断两个数组是否相等</p>
<p>int [] arr1&#x3D;  new int[]{1,2,3,4,5};</p>
<p>int [] arr2&#x3D;  new int[]{1,2,3,4,5,6,7,8};</p>
<p>boolean  isEquals &#x3D; Arrays.equals(arr1,arr2);</p>
</li>
<li><p>String   toString(int[]  a)          输出数组信息</p>
<p>System.out.println(Arrays.toString(arr1));</p>
</li>
<li><p>void   fill(int[] a ,  int val)      将数组中的值都换成指定值</p>
<p>Arrays.fill(arr1,10);</p>
</li>
<li><p>void  sort (int[] a)              对数组进行排序（快速排序）</p>
<p>Arrays.sort(arr1);</p>
</li>
<li><p>int  binarySearch(int[]  a , int  key)    对排序后的数组进行二分法查找指定的值  ，没找到会返回一个负数</p>
<p>int [] arr2&#x3D;  new int[]{1,2,3,4,5,6,7,8};</p>
<p>int index  &#x3D;Arrays.binarySeatch(arr2,10);</p>
</li>
</ol>
<h3 id="3-6数组中常见的异常"><a href="#3-6数组中常见的异常" class="headerlink" title="3.6数组中常见的异常"></a>3.6数组中常见的异常</h3><ol>
<li><p>数组角标越界的异常：ArrayIndexOutOfBoundsEception</p>
<p>合理范围：[ 0 , arr.length - 1 ]</p>
<p>越界： arr[-1]…  ,   arr[arr.length]</p>
</li>
<li><p>空指针异常：NullPointerEception</p>
<p>int[]  arr  &#x3D;   null ; </p>
<p>arr[0];</p>
<p>二维数组的外层为空null，在调用内层时就是空指针异常</p>
<p>注意： 一旦程序出现异常，未处理时，就终止执行。</p>
</li>
</ol>
<h2 id="4-面向对象（上）"><a href="#4-面向对象（上）" class="headerlink" title="4.面向对象（上）"></a>4.面向对象（上）</h2><h3 id="4-1-Java面向对象学习三条主线（4-6章）"><a href="#4-1-Java面向对象学习三条主线（4-6章）" class="headerlink" title="4.1 Java面向对象学习三条主线（4-6章）"></a>4.1 Java面向对象学习三条主线（4-6章）</h3><ol>
<li>Java类及类的成员：属性、方法、构造器、代码块、内部类</li>
<li>面向对象的三大特性：封装性、继承性、多态性、（抽象性）</li>
<li>其他关键字：this、 super、 static、 final、 abstract、 interface、 package、 import等。</li>
</ol>
<h3 id="4-2面向过程与面向对象："><a href="#4-2面向过程与面向对象：" class="headerlink" title="4.2面向过程与面向对象："></a>4.2面向过程与面向对象：</h3><h4 id="1-面向过程："><a href="#1-面向过程：" class="headerlink" title="1.面向过程："></a>1.面向过程：</h4><p>强调的是功能行为，以函数为最小单位，考虑怎么做</p>
<p>把冰箱门打开</p>
<p>抬起大象，塞进冰箱</p>
<p>把冰箱门关闭</p>
<h4 id="2-面向对象："><a href="#2-面向对象：" class="headerlink" title="2.面向对象："></a>2.面向对象：</h4><p>强调具备了功能的对象，以类&#x2F;&#x2F;对象为最小单位，考虑谁来做。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">人&#123;</span><br><span class="line"></span><br><span class="line">	打开（冰箱）&#123;</span><br><span class="line">			冰箱.开门</span><br><span class="line">&#125;</span><br><span class="line">        抬起（大象）&#123;</span><br><span class="line">			大象.进入（冰箱）</span><br><span class="line">&#125;</span><br><span class="line">	关闭（冰箱）&#123;</span><br><span class="line">			冰箱.关门</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">冰箱&#123;</span><br><span class="line">	开门</span><br><span class="line">	关门</span><br><span class="line">&#125;</span><br><span class="line">大象&#123;</span><br><span class="line">	进入</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序员从面向过程的<strong>执行者</strong>转化成了面向对象的<strong>指挥者</strong></p>
<h4 id="3-面向对象的思想概述"><a href="#3-面向对象的思想概述" class="headerlink" title="3.面向对象的思想概述"></a>3.面向对象的思想概述</h4><p>类 &#x3D; 现实世界中抽象具有属性和行为的事物 ；对一类事物抽象的描述</p>
<p> 对象 &#x3D;  计算机世界的实体  是实际存在的该类事物的每个个体，也称为<strong>实例</strong></p>
<p>对象，是由类new( 造 )出来的</p>
<p>面向对象<strong>程序设计的重点</strong>是<strong>类的设计</strong></p>
<p>类的设计， <strong>其实就是类成员的设计</strong></p>
<h3 id="4-3-类和对象"><a href="#4-3-类和对象" class="headerlink" title="4.3 类和对象"></a>4.3 类和对象</h3><h4 id="1-JVM-内存结构"><a href="#1-JVM-内存结构" class="headerlink" title="1.JVM 内存结构"></a>1.JVM 内存结构</h4><p>编译完源程序以后，生成一个或多个字节码文件。</p>
<p>我们使用JVM中的类的加载器和解释器堆生成的字节码文件进行解释运行。意味着，需要将字节码文件对应的类的加载到内存中，涉及到内存解析。<img src="/2022/09/28/%E5%B0%9A%E7%A1%85%E8%B0%B7java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/img%5CSnipaste_2022-01-10_13-24-41.png" alt="Snipaste_2022-01-10_13-24-41"></p>
<p>虚拟机栈，即为平时提到的栈结构。我们将局部变量存储到栈结构中</p>
<p>堆，我们将new出来的结构（比如：数组、对象）加载在堆空间中 。补充：对象的属性（非static的）加载在堆空间中</p>
<p>方法区：类的加载信息、常量池、静态域</p>
<h4 id="2-关键字-return："><a href="#2-关键字-return：" class="headerlink" title="2.关键字 return："></a>2.关键字 return：</h4><ol>
<li>使用范围：使用在方法体中</li>
<li>作用： <ol>
<li>结束方法</li>
<li>针对于返回值类型的方法，使用“return   数据”方法返回所要的数据</li>
<li>注意点：return 关键字后面不可以在声明执行语句</li>
</ol>
</li>
</ol>
<h4 id="3-java类及类的成员"><a href="#3-java类及类的成员" class="headerlink" title="3.java类及类的成员"></a>3.java类及类的成员</h4><p>初识理解：<strong>类</strong>相似与C语言的结构体； 而这个结构体中有变量和函数</p>
<p>一个程序可以有很多类，只能有一个public公共类，类中基本的成员是属性（成员变量）和方法。但是只能有一个main方法（函数）也叫程序的入口。</p>
<p>属性 &#x3D; 成员变量 &#x3D;  field &#x3D;  域、字段</p>
<p>方法 &#x3D; 成员方法 &#x3D; 函数 &#x3D;  method </p>
<p>创建类的对象 &#x3D;  类的实例化 &#x3D; 实例化类</p>
<h4 id="4-类和类对象的创建和使用"><a href="#4-类和类对象的创建和使用" class="headerlink" title="4.类和类对象的创建和使用"></a>4.类和类对象的创建和使用</h4><p>（面向对象思想落地的实现）</p>
<ol>
<li><p>创建类，设计类成员</p>
<p>class  Person{</p>
<p>​	String name;</p>
<p>​	int age;           &#x2F;&#x2F;属性</p>
<p>​	public void  eat() {        &#x2F;&#x2F;行为或方法</p>
<p>​	  	System.out.print(“吃面条”)</p>
<p>​	}</p>
<p>}</p>
</li>
<li><p>创建类的对象</p>
<p>Person  p1  &#x3D;  new  Person() ; </p>
<p>Person  p2  &#x3D;  new  Person() ;   &#x2F;&#x2F;（<strong>非static的</strong>）两个是独立的个体，互不影响</p>
<p>&#x2F;&#x2F;数组类型的对象</p>
<p>Person[]   p4 &#x3D;  new Person[20];  </p>
<p>for(int i&#x3D;0 ; i &lt; p4.length ; i++){</p>
<p>​		p4[ i ] &#x3D;  new  Person(); &#x2F;&#x2F;给数组元素赋值，也是给属性new空间</p>
<p>}</p>
</li>
<li><p>通过“对象 . 属性”或“对象 . 方法”调用对象的结构</p>
<p>​            p1.name &#x3D; “Tom”;</p>
<p>​             p1. age &#x3D; 2;</p>
<p>​	     p1. eat() ;  &#x2F;&#x2F; 输出“吃面条”</p>
<p>​	     p4[ 1 ].name &#x3D;” katrina”;</p>
<p>​	     p4[ 1 ].age &#x3D; 18;</p>
<p>​            p4[ 1 ].eat() ;&#x2F;&#x2F; 输出“吃面条”</p>
</li>
<li><p>Person  p3 &#x3D; p1 ;</p>
<p>p3没有new，有new在堆空间中才有自己的实体，否则只是在栈空间中创建了一个指针</p>
<p>将p1变量保存的对象地址值赋给p3，导致p1和p3指向了堆空间中的同一个对象实体</p>
</li>
<li><p>后期补充：static  和非static</p>
<p>非static是以上提到的</p>
<p>static </p>
<p>public class newclassTest {</p>
<p>public static void main(String[] args){</p>
<p>newClass.walk();   &#x2F;&#x2F;不用new 也能用 ，类名. 方法名</p>
<p>newClass.age;&#x2F;&#x2F;错  只能调用方法，属性不能调用</p>
<p>}</p>
<p>}</p>
<p>class newClass{</p>
<p>int age &#x3D;1;</p>
<p>public static void walk(){  &#x2F;&#x2F;方法声明时加static</p>
<p>System.out.println(“走路上学！”);</p>
<p>}</p>
<p>}</p>
</li>
</ol>
<h4 id="5-对象的创建和使用：内存解析"><a href="#5-对象的创建和使用：内存解析" class="headerlink" title="5.对象的创建和使用：内存解析"></a>5.对象的创建和使用：内存解析</h4><p><img src="/2022/09/28/%E5%B0%9A%E7%A1%85%E8%B0%B7java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/Java%5Cimg%5CSnipaste_2022-01-09_17-04-02.png" alt="Snipaste_2022-01-09_17-04-02"></p>
<ol>
<li><p>创建对象：在栈空间中创建指针将可存放类的地址</p>
</li>
<li><p>创建类及类的属性：在堆空间中创建带有地址的类实体</p>
<p>​    实体中存放属性</p>
</li>
<li><p>创建对象为数组类型：</p>
<p>​	Student[] stus &#x3D; new Student[20];  &#x2F;&#x2F;在堆空间中创建数组实体，但是每个数组元素存放的是类中的属性的地址值</p>
<p>因此还需要在给每个数组元素new创建属性，也叫给数组元素赋值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span> ; i&lt;stus.length ; i++)&#123;</span><br><span class="line">	<span class="comment">//给数组元素赋值</span></span><br><span class="line">	stus[i] = <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br></pre></td></tr></table></figure>
<p><img src="/2022/09/28/%E5%B0%9A%E7%A1%85%E8%B0%B7java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/img%5CSnipaste_2022-01-10_11-52-53.png" alt="Snipaste_2022-01-10_11-52-53"></p>
</li>
</ol>
<h3 id="4-4类的结构–属性"><a href="#4-4类的结构–属性" class="headerlink" title="4.4类的结构–属性"></a>4.4类的结构–属性</h3><p>​             （属性）成员变量  VS   局部变量</p>
<ol>
<li><p>相同点：</p>
<p>定义变量的格式：数据类型  变量名  &#x3D;   变量值</p>
<p>先声明，后使用</p>
<p>变量都有对应的作用域。（只在指定范围内可用）</p>
</li>
<li><p>不同点：</p>
<ol>
<li><p>在类中声明的位置不同</p>
<p>属性：直接定义在类的一对{   }内</p>
<p>局部变量：声明在方法内、方法形参、代码块内、构造器形参、构造器内部的变量</p>
</li>
<li><p>关于权限修饰符的不同</p>
<p>属性：可以子啊声明属性时，指明其权限，使用权限修饰符</p>
<p>常用的权限修饰符：private、public、缺省（什么都不写）、protected–&gt;封装性在细讲</p>
<p>局部变量：不可以使用权限修饰符</p>
<p><strong>权限修饰符理解</strong>：允许调用的范围程度</p>
<p>private最小译为私人的，public最大译为公共</p>
</li>
<li><p>作用域：</p>
<p>属性：在类中和类中方法里</p>
<p>局部变量：方法中</p>
</li>
<li><p>初始化值</p>
<p>属性的初始值：String -null 、整型 -0、浮点型 - 0.0 、boolean - false；</p>
<p>局部变量：没默认初始化值，调用之前必须赋值。特别地，形参可以在调用时赋值即可</p>
<p>u1.talk(“中国话”)；&#x2F;&#x2F;用时赋值</p>
<p>public void talk(String  language){</p>
<p>​	int newAge &#x3D; 10；&#x2F;&#x2F;提前赋值</p>
<p>​	System.out.print(language)</p>
<p>}</p>
</li>
<li><p>内存的加载位置：</p>
<p>属性：加载到堆空间中（非static)</p>
<p>局部变量：加载到栈空间</p>
</li>
</ol>
</li>
</ol>
<h3 id="4-5类的结构–方法"><a href="#4-5类的结构–方法" class="headerlink" title="4.5类的结构–方法"></a>4.5类的结构–方法</h3><ol>
<li><p>方法的声明：</p>
<p>权限修饰符  返回值类型  方法名（形参列表）{</p>
<p>​				方法体</p>
<p>}</p>
<p>注意：至于static 、final、abstract 来修饰的方法，后面在讲</p>
</li>
<li><p>举例</p>
<p>方法：描述类应该具有的功能</p>
<p>比如：Math类：sqrt()    \random()…….</p>
<p>Scanner类：nextXxx()….</p>
<p>Arrays类：sort()  \binarySearch()  \ toString() \ equals()…….</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">(<span class="type">int</span> hour)</span>&#123;  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>  String <span class="title function_">getNmae</span><span class="params">()</span>&#123;  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getNation</span><span class="params">(String nation)</span>&#123;  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getNation</span><span class="params">(String nation , <span class="type">int</span>  key)</span>&#123;  &#125;</span><br><span class="line"></span><br><span class="line">.................</span><br></pre></td></tr></table></figure>


</li>
<li><p>返回值类型：有返回值 VS  没有返回值（void）</p>
<p>有返回值：声明方法时，必须写返回值类型。同时，在方法中，有return 数据；返回值，该值类型是对应返回值类型</p>
<p>没有返回值：声明方法是用void 。方法中，return可用可不用，仅代表结束方法 —–return；不加返回值</p>
</li>
<li><p>方法的使用中，可以调用当前类的属性或方法</p>
<p>特殊的，方法A调用方法A：递归方法</p>
<p>方法中，不可以定义方法</p>
</li>
<li><p>注意：</p>
<ol>
<li>有无返回值视题目要求而定</li>
<li>方法名：命名需要“见名知意”</li>
<li>形参可有多个</li>
<li>方法体：方法功能的体现</li>
</ol>
</li>
</ol>
<h3 id="4-6-“万事万物皆对象”"><a href="#4-6-“万事万物皆对象”" class="headerlink" title="4.6 “万事万物皆对象”"></a>4.6 “万事万物皆对象”</h3><p>在Java语言范畴中，我们都将功能、结构等封装到类中，通过类的实例化(造对象)，来调用具体的功能结构</p>
<p>&#x3D;&gt; Scanner ,String 等</p>
<p>&#x3D;&gt;文件：File</p>
<p>&#x3D;&gt;网络资源：URL</p>
<h3 id="4-6-匿名对象的使用"><a href="#4-6-匿名对象的使用" class="headerlink" title="4.6 匿名对象的使用"></a>4.6 匿名对象的使用</h3><ol>
<li><p>理解：我们创建的对象，没有显式的赋给一个变量名。即为匿名对象</p>
</li>
<li><p>特征 ：匿名对象只能调用一次</p>
</li>
<li><p>使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InstanceTest</span>&#123;</span><br><span class="line">   	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]  args)</span>&#123;</span><br><span class="line">      	<span class="type">Person</span> <span class="variable">pop</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span> ();</span><br><span class="line">       pop.name= <span class="number">10</span>;<span class="comment">//这是正常做法</span></span><br><span class="line">       <span class="keyword">new</span>  <span class="title class_">Person</span>().name = <span class="number">10</span>;<span class="comment">//匿名</span></span><br><span class="line">       <span class="comment">//匿名对象：减少简单操作去创建新的变量及内存</span></span><br><span class="line">       <span class="keyword">new</span> <span class="title class_">Person</span>().eat(<span class="number">5</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="type">int</span> name</span><br><span class="line">    <span class="type">int</span>  age </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">(<span class="type">int</span> n )</span>&#123;</span><br><span class="line">        System.out.print(n+<span class="string">&quot;碗面&quot;</span>)；</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>开发中使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    <span class="type">PhoneMall</span> <span class="variable">mall</span>  <span class="operator">=</span>  <span class="keyword">new</span>  <span class="title class_">PhoneMall</span>();</span><br><span class="line">    mall.show(<span class="keyword">new</span> <span class="title class_">Phone</span>());</span><br><span class="line"><span class="comment">//其中</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PhoneMall</span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(Phone  phone)</span>&#123;</span><br><span class="line">	phone.sendEmail();</span><br><span class="line">	phone.playGame();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h3 id="4-7-数组：基本操作代码演示"><a href="#4-7-数组：基本操作代码演示" class="headerlink" title="4.7  数组：基本操作代码演示"></a>4.7  数组：基本操作代码演示</h3><h3 id="4-8-在谈方法"><a href="#4-8-在谈方法" class="headerlink" title="4.8  在谈方法"></a>4.8  在谈方法</h3><h4 id="1-方法的重载"><a href="#1-方法的重载" class="headerlink" title="1.方法的重载"></a>1.方法的重载</h4><ol>
<li><p>定义：在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或者参数类型不同即可。</p>
<p>总结定义：<strong>“两同一不同”</strong></p>
<p>同一类、相同方法名</p>
<p>参数列表不同：参数个数不同，参数类型不同</p>
<p>其原因使计算机能够辨别那些是不同的方法</p>
</li>
<li><p>举例：</p>
<p>Arrays类中重载sort() &#x2F;binarySearch()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">add（<span class="type">int</span> i， intj）</span><br><span class="line"></span><br><span class="line">add(<span class="type">double</span> i ,<span class="type">double</span> j)</span><br><span class="line"></span><br><span class="line">add(<span class="type">int</span> i ,<span class="type">double</span> j)</span><br><span class="line"></span><br><span class="line">add(<span class="type">int</span> i ，String  j)</span><br><span class="line"></span><br><span class="line">add (String j ,<span class="type">int</span>  i)</span><br></pre></td></tr></table></figure>

<p>以上都是重载，计算机能够识别</p>
</li>
<li><p>判断是否重载：</p>
<p>只需遵从定义，跟方法权限修饰符、返回值类型、形参变量名、方法体都没关系</p>
</li>
<li><p>在通过对象调用方法时，如何确定某一个指定的方法</p>
<p>方法名，不行。则形参列表</p>
</li>
</ol>
<h4 id="2-可变形参的方法"><a href="#2-可变形参的方法" class="headerlink" title="2.可变形参的方法"></a>2.可变形参的方法</h4><ol>
<li><p>jdk  5.0 新增的内容</p>
<p>（String…形参名）</p>
</li>
<li><p>具体使用：</p>
<p>2.1 可变个数形参<strong>格式</strong> ：数据类型 . . . 变量名</p>
<p>2.2 当调用可变个数形参的方法时，传入的<strong>参数个数</strong>可以是：0,1,2,3，…</p>
<p>2.3 可变个数形参的方法与本类方法名相同，形参不同的方法之间<strong>构成重载</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span> <span class="params">(<span class="type">int</span> ... ints)</span>&#123;  &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span> <span class="params">(<span class="type">double</span>  i  )</span>&#123;  &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span> <span class="params">(String ... strs)</span>&#123;  &#125;</span><br></pre></td></tr></table></figure>

<p>2.4可变个数形参的方法与本类中方法名相同，形参类型也相同的数组之间<strong>不构成重载</strong>。换句话说，二者不能共存 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span> <span class="params">(String []   strs)</span>&#123;  &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span> <span class="params">(String ... str )</span>&#123;  &#125;<span class="comment">//错误，两者其实是一样的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//都能吸收可变个个数，计算法无法分辨</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span> <span class="params">(<span class="type">int</span> i , String ... str)</span>&#123;  &#125;<span class="comment">//正确的</span></span><br></pre></td></tr></table></figure>

<p>2.5可变个数形参方法的形参中，<strong>必须声明在末尾</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span> <span class="params">(String []   strs)</span>&#123;  &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span> <span class="params">(<span class="type">int</span> i , String ... str)</span>&#123;  &#125;<span class="comment">//正确</span></span><br></pre></td></tr></table></figure>

<p>2.6可变个数形参在方法的形参中，<strong>最多只能声明一个可变形参</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(String...strings,<span class="type">int</span>...strs)</span>&#123; &#125;</span><br></pre></td></tr></table></figure>

<p>2.7优先选择不是可变个数形参</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> val.show(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(<span class="type">int</span>  i)</span>&#123;   <span class="comment">//优先这个</span></span><br><span class="line">	System.out.print(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(<span class="type">int</span>...strs)</span>&#123;</span><br><span class="line">	System.out.print(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-方法参数的”值传递”机制"><a href="#3-方法参数的”值传递”机制" class="headerlink" title="3.方法参数的”值传递”机制"></a>3.方法参数的”值传递”机制</h4><p>方法的形参的传递机制：值传递</p>
<ol>
<li><p>形参：方法定义时，声明的小括号（）内的参数</p>
</li>
<li><p>实参：方法调用时，实际传递给形参的数据 val.show(2);&#x2F;&#x2F; 2–实参</p>
</li>
<li><p>值传递机制:</p>
<p>如果参数是基本数据类型，此时实参赋给形参的是实参真实存储的<strong>数据值</strong></p>
<p>如果参数是引用数据类型，此时实参赋给形参的是实参存储数据的<strong>地址值</strong></p>
</li>
<li><p>举例：交换数组中 下标i  和  j  的值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[]  arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="comment">//错误做法</span></span><br><span class="line">Test.swap(arr[<span class="number">1</span>],arr[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> i  , <span class="type">int</span>  j)</span>&#123;</span><br><span class="line">         <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> i ; </span><br><span class="line">                i = j   ; </span><br><span class="line">             j = temp;  </span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//正确做法</span></span><br><span class="line">Test.swap(arr, <span class="number">1</span>, <span class="number">2</span>) ;   <span class="comment">//传地址值和下标</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arrss, <span class="type">int</span> i  , <span class="type">int</span>  j)</span>&#123;</span><br><span class="line">             <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arrss[i] ; </span><br><span class="line">                    arrss[i] = arrss[ j]; </span><br><span class="line">                 arrss[ j] = temp;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="4-递归方法（了解）"><a href="#4-递归方法（了解）" class="headerlink" title="4.递归方法（了解）"></a>4.递归方法（了解）</h4><ol>
<li><p>递归方法：一个方法体内调用它自身</p>
</li>
<li><p>方法递归包含了一种隐式的循环，它的重复执行某段代码，但这种重复执行无须循环控制</p>
<p>按已知方向递归，也要有终止条件，否则会导致死循环</p>
</li>
</ol>
<h3 id="4-9面向对象特征之一：封装和隐藏"><a href="#4-9面向对象特征之一：封装和隐藏" class="headerlink" title="4.9面向对象特征之一：封装和隐藏"></a>4.9面向对象特征之一：封装和隐藏</h3><h4 id="1-概念初理解："><a href="#1-概念初理解：" class="headerlink" title="1.概念初理解："></a>1.概念初理解：</h4><p>我们程序设计追求 “ 高内聚 ” ， “ 低耦合 ”</p>
<p>高内聚：类的内部数据操作细节自己完成，不允许外部干涉</p>
<p>低耦合：仅对外暴露少量的方法用于使用</p>
<p>俗话说：把该隐藏的隐藏起来，该暴露的暴露出来。这就是封装性的设计思想。</p>
<h4 id="2-问题引入："><a href="#2-问题引入：" class="headerlink" title="2.问题引入："></a>2.问题引入：</h4><p>当我们创建一个类的对象以后，我们通过 “ 对象 . 属性 ”的方式，对对象的属性进行赋值。</p>
<p>这里，赋值操作要受到属性的数据类型和存储范围的制约。除此之外，没有其他制约条件。</p>
<p>但是，在实际问题中，我们往往需要给属性赋值加入额外的限制条件。这个就不能在属性声明时体现，我们只能通过方法进行限制条件的添加。（比如 setLegs()）</p>
<p>同时，我们需要避免用户在使用 “ 对象 . 属性 ” 的方式对属性进行赋值。则需要将属性声明为私有的（private）。</p>
<p>此时，针对–属性 –就体现了封装性。</p>
<h4 id="3-封装性的体现"><a href="#3-封装性的体现" class="headerlink" title="3.封装性的体现"></a>3.封装性的体现</h4><p>我们将类的属性xxx私有化（private）, 同时，提供公共的（public）方法来获取（getXxx）和设置（setXxx）此属性的值</p>
<p>拓展：封装性的体现：</p>
<ol>
<li>以上提到的</li>
<li>不对外暴露的私有方法</li>
<li>单例模式(私有化构造器)</li>
<li>如果不希望类在包外被调用，可以将类设置为缺省的</li>
<li>……….</li>
</ol>
<p>代码示范：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">String name ;</span><br><span class="line"><span class="keyword">private</span>  <span class="type">int</span> age ;      <span class="comment">//私有化</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> ages)</span>&#123;</span><br><span class="line">	age = ages  ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> age ; </span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="4-封装性与权限修饰符"><a href="#4-封装性与权限修饰符" class="headerlink" title="4.封装性与权限修饰符"></a>4.封装性与权限修饰符</h4><ol>
<li><p>Java规定的4 种权限（从小到大）：private、缺省、protected、public</p>
</li>
<li><p>4 种权限可以用来修饰类及类的内部结构：属性、方法、构造器、内部类</p>
</li>
<li><p>具体的使用范围</p>
<p>4 种权限，都可以用来修饰类的内部结构：属性、方法、构造器、内部类</p>
<p>修饰类，只能用：缺省、public</p>
<table>
<thead>
<tr>
<th>修饰符</th>
<th>类内部</th>
<th>同一个包</th>
<th>不同包的子类</th>
<th>同一个工程</th>
</tr>
</thead>
<tbody><tr>
<td>private</td>
<td>yes</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>缺省</td>
<td>yes</td>
<td>yes</td>
<td></td>
<td></td>
</tr>
<tr>
<td>protected（暂不考虑）</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
<td></td>
</tr>
<tr>
<td>public</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
</tr>
</tbody></table>
<p>private：出了这个类用不了</p>
<p>缺省：出了包用不了</p>
<p>public：基本都可以用</p>
</li>
</ol>
<p>总结封装性：Java提供了4 种权限修饰符来修饰类及类的内部结构，体现类及类的内部结构在被调用时的可见性的大小</p>
<h3 id="4-10-类的结构–构造器"><a href="#4-10-类的结构–构造器" class="headerlink" title="4.10 类的结构–构造器"></a>4.10 类的结构–构造器</h3><ol>
<li><p>构造器的作用（constructor）</p>
<ol>
<li>创建对象</li>
<li>初始化对象的信息</li>
</ol>
</li>
<li><p>说明：</p>
<ol>
<li><p>如果没有显式的定义类的构造器的话，则系统就默认提供一个空参的构造器</p>
<p>&#x2F;&#x2F;创建对象：new+构造器</p>
<p>Person  p  &#x3D;   new <strong>Person()</strong>;</p>
<p>加粗的为构造器的使用</p>
<p>class  Person{</p>
<p>​	此时类中并没有构造器，也能够使用，也只能使用空参的</p>
<p>}</p>
</li>
<li><p>定义构造器的格式：权限修饰符 类名（形参列表）{  }</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span>  <span class="title class_">Person</span>&#123;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">	age = n;  <span class="comment">//初始化对象的信息</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>一个类中可以定义多个构造器，彼此构成重载</p>
</li>
<li><p>一旦我们显式的定义了类的构造器之后，系统就不在提供默认的空参构造器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span>  <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(); <span class="comment">//报错，除非在造个空参的构造器</span></span><br><span class="line"><span class="type">Person</span>  <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">18</span>);<span class="comment">//正确</span></span><br><span class="line"><span class="keyword">class</span>  <span class="title class_">Person</span>&#123;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">	age = n;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>一个类中，至少会有一个构造器</p>
</li>
<li><p>关于初始化属性总结</p>
<ol>
<li><p>默认初始化</p>
</li>
<li><p>显式初始化</p>
</li>
<li><p>构造器初始化</p>
</li>
<li><p>通过 “ 对象 . 方法 ” 或 “ 对象 . 属性 ” 的方式，赋值</p>
<p>这是按先后顺序覆盖的，也一定是按这个顺序</p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="4-11-拓展：JavaBean"><a href="#4-11-拓展：JavaBean" class="headerlink" title="4.11 拓展：JavaBean"></a>4.11 拓展：JavaBean</h3><ol>
<li><p>JavaBean是一种Java语言写成的可重用组件</p>
</li>
<li><p>所谓的javaBean，是指符合如下标准的java类：</p>
<p>类是公共的</p>
<p>有一个无参的公共的构造器</p>
<p>有属性，且有对应的get、set方法</p>
<p>未完待续…..</p>
</li>
</ol>
<h3 id="4-12-关键字：this"><a href="#4-12-关键字：this" class="headerlink" title="4.12 关键字：this"></a>4.12 关键字：this</h3><h4 id="1-this的作用"><a href="#1-this的作用" class="headerlink" title="1.this的作用"></a>1.this的作用</h4><p>可以用来修饰和调用：（属性、方法、构造器）</p>
<h4 id="2-this-修饰属性和方法"><a href="#2-this-修饰属性和方法" class="headerlink" title="2.this 修饰属性和方法"></a>2.this 修饰属性和方法</h4><p>this理解为：当前对象或者当前正在创建的对象</p>
<p>1.在<strong>类的方法</strong>中，我们可以使用 “ this . 属性  ” 或 “ this . 方法” 的方式，调用当前对象属性或方法。</p>
<p>通常情况下，我们都选择省略 “this” </p>
<p>特殊情况下，如果方法的形参和类的属性同名时，我们必须显式的使用 “ this . 变量 ” 的方式，表明此变量是属性，而非形参</p>
<p>2.同理，在类的构造器也是这个道理</p>
<p>在<strong>类的构造器</strong>中，我们可以使用 “ this . 属性  ” 或 “ this . 方法” 的方式，调用当前对象属性或方法。</p>
<p>通常情况下，我们都选择省略 “this” </p>
<p>特殊情况下，如果构造器的形参和类的属性同名时，我们必须显式的使用 “ this . 变量 ” 的方式，表明此变量是属性，而非形参</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">	Stirng  name;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span>&#123;<span class="comment">//方法中</span></span><br><span class="line">		重名，使用<span class="built_in">this</span></span><br><span class="line">		<span class="built_in">this</span> . age = age ;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>  <span class="title function_">Person</span><span class="params">(String name)</span>&#123;</span><br><span class="line">		<span class="comment">//构造器中</span></span><br><span class="line">		<span class="built_in">this</span> . name = name;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="3-this-调用构造器"><a href="#3-this-调用构造器" class="headerlink" title="3.this 调用构造器"></a>3.this 调用构造器</h4><ol>
<li><p>我们在类的构造器中，可以显式的使用 “ this(形参列表) ” 方式，调用本类中指定的其他构造器</p>
<p>可能原因：每个构造器或者两个构造器间有相同代码的重复操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"></span><br><span class="line">	String name ;</span><br><span class="line">	<span class="type">int</span>  age ;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span>&#123;</span><br><span class="line">     一些操作</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span>&#123;</span><br><span class="line">	<span class="built_in">this</span>();</span><br><span class="line">	<span class="built_in">this</span>.name = name ;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>构造器中不能通过 “this (形参列表)” 方式调用自己</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"></span><br><span class="line">   	String name ;</span><br><span class="line">   	<span class="type">int</span>  age ;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span>&#123;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>(<span class="string">&quot;Tom&quot;</span>);<span class="comment">//不能调用自己</span></span><br><span class="line">  	<span class="built_in">this</span>.name = name ;</span><br><span class="line">   	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>如果一个类中有n个构造器，则最多有n-1构造器中使用了“this (形参列表)” </p>
<p>构造器间不能出现成环调用–死循环</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"></span><br><span class="line">	String name ;</span><br><span class="line">	<span class="type">int</span>  age ;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="built_in">this</span>(<span class="string">&quot;Tom&quot;</span>); <span class="comment">//你调它</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">this</span>(); <span class="comment">//它调你</span></span><br><span class="line">	<span class="built_in">this</span>.name = name ;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>规定：“this (形参列表)” 必须声明在当前构造器的首行</p>
<p>防止你调用的构造器和你下面出现的操作相同，覆盖了你的操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span>&#123;</span><br><span class="line">	<span class="built_in">this</span>(); <span class="comment">//它调你</span></span><br><span class="line">	<span class="built_in">this</span>.name = name ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>构造器内部，最多只能声明一个“this (形参列表)” ,用来调用其他的构造器</p>
<p>人呐，只能有一个女朋友</p>
</li>
</ol>
<h4 id="4-this-表示当前对象，作为实参被调用"><a href="#4-this-表示当前对象，作为实参被调用" class="headerlink" title="4.this 表示当前对象，作为实参被调用"></a>4.this 表示当前对象，作为实参被调用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span>  <span class="title class_">Boy</span>&#123;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">marry</span><span class="params">(Girl  girl)</span>&#123;</span><br><span class="line">	一些操作</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span>  <span class="title class_">Girl</span>&#123;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">marry</span><span class="params">(Boy  boy)</span>&#123;</span><br><span class="line">	Boy.marry(<span class="built_in">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>this 是当前对象，类型为Girl</strong></p>
<p><strong>补充：也可单独表示：</strong></p>
<p><strong>obj &#x3D;&#x3D; this  ：判断形参obj是否等于当前对象</strong></p>
</blockquote>
<h3 id="4-13-关键字-package"><a href="#4-13-关键字-package" class="headerlink" title="4.13 关键字 package"></a>4.13 关键字 package</h3><ol>
<li><p>为了更好的实现项目中类的管理，提供包的概念</p>
</li>
<li><p>使用package声明类或接口所属的包，声明在源文件的首行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.java2</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">xxx</span>&#123;  </span><br><span class="line">   &#125; </span><br></pre></td></tr></table></figure>

<blockquote>
<p>包，属于标识符，遵循标识符的命名规则、规范（xxxyyyzzz）、“见名知意”</p>
</blockquote>
</li>
<li><p>每点“ . ”一次，就代表一层文件目录</p>
<p>com.atguigu.java2</p>
</li>
<li><p>补充：</p>
<p>同一个包下，不能命名同名的接口、类</p>
<p>不同的包下，可以命名同名的接口、类</p>
</li>
<li><p>JDK主要包介绍</p>
<ol>
<li>java.lang–包含一些java语言的核心类，比如String、Math、Integer、System和Thread，提供常用的功能</li>
<li>java.util—包含一些实用工具类，比如系统特性、接口的集合框架类、实用与日期日历相关的函数</li>
<li>java.net</li>
<li>java.io</li>
<li>java.text</li>
<li>java.sql</li>
<li>java.awt</li>
</ol>
</li>
</ol>
<p>4.14  MVC 模式设计<img src="/2022/09/28/%E5%B0%9A%E7%A1%85%E8%B0%B7java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/img%5CSnipaste_2022-01-11_20-51-35.png" alt="Snipaste_2022-01-11_20-51-35"></p>
<h3 id="4-15-关键字-import"><a href="#4-15-关键字-import" class="headerlink" title="4.15 关键字 import"></a>4.15 关键字 import</h3><p>​    import：导入</p>
<ol>
<li><p>在源文件中显式的使用import结构导入指定包下的类、接口</p>
</li>
<li><p>声明在包的声明和类的声明之间</p>
</li>
<li><p>如果需要导入多个结构，可以并列写写出即可</p>
</li>
<li><p>如果使用的类或接口是java.lang包下定义的，则可以省略import结构</p>
</li>
<li><p>如果使用的类或接口是本包下定义的，则可以省略import</p>
</li>
<li><p>如果在源文件中，使用了不同包下同名的类，则必须至少有一个需要一全类名的方式显示</p>
<p>应在前面加上具体的文件路径(每个都可以加上路径，只是为了美观简约的去掉)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.atguigu.java2.Account</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">xxxx</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Account</span> <span class="variable">acc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Account</span> (<span class="number">100</span>);</span><br><span class="line">        com.atguigu.java5.<span class="type">Account</span> <span class="variable">acc1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Accout</span>(<span class="number">100</span>,<span class="number">0</span>,<span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用“xxx .*” 方式表明可以调用xxx包下的所有结构。但是如果使用的是xxx子包下的结构，则仍需要显式</p>
</li>
<li><p>import static ：导入指定类或接口中的静态结构;属性和方法</p>
</li>
</ol>
<h2 id="5-面向对象（中）"><a href="#5-面向对象（中）" class="headerlink" title="5.面向对象（中）"></a>5.面向对象（中）</h2><h3 id="5-1面向对象特征之二：继承性"><a href="#5-1面向对象特征之二：继承性" class="headerlink" title="5.1面向对象特征之二：继承性"></a>5.1面向对象特征之二：继承性</h3><h4 id="1-继承性的好处"><a href="#1-继承性的好处" class="headerlink" title="1.继承性的好处"></a>1.继承性的好处</h4><ol>
<li>减少代码的冗余，提高代码的复用性</li>
<li>便于功能的扩展</li>
<li>为了之后多态性的使用，提供了前提</li>
</ol>
<h4 id="2-继承性的格式"><a href="#2-继承性的格式" class="headerlink" title="2.继承性的格式"></a>2.继承性的格式</h4><p>class  A  <strong>extends</strong>  B {  }</p>
<p>A : 子类、派生类、subclass</p>
<p>B :  父类、超类、基类、superclass</p>
<h4 id="3-用处体现："><a href="#3-用处体现：" class="headerlink" title="3.用处体现："></a>3.用处体现：</h4><ol>
<li>一旦子类A继承父类B以后，<strong>子类A中就获取了父类B中声明的所有属性和方法</strong></li>
</ol>
<p>特别地，父类中声明为private的属性或方法，子类继承父类以后，仍然认为获取了私有结构。只是因为封装性的影响，使得子类不能直接调用父类此结构</p>
<ol start="2">
<li><strong>子类继承父类</strong>以后，还可以声明自己特有的属性或方法，实现功能的扩展。也就是<strong>子类有的父类没有，反之。父类有的子类都有</strong></li>
</ol>
<h4 id="4-Java中关于继承性的规定："><a href="#4-Java中关于继承性的规定：" class="headerlink" title="4.Java中关于继承性的规定："></a>4.Java中关于继承性的规定：</h4><ol>
<li><p>一个类可以被多个子类继承</p>
</li>
<li><p>Java中类的单继承性：一个类只能有一个类</p>
</li>
<li><p>子父类是相对的概念</p>
</li>
<li><p>子类直接继承的父类，称为：直接父类。间接继承的父类称为：0间接父类。</p>
<p>也就是子类有父类，父类还有父类，这样，子类继承以上的两个父类</p>
</li>
<li><p>子类继承父类以后，就获取了直接父类以及所有间接父类中声明的属性和方法</p>
</li>
</ol>
<p><strong>Object类</strong></p>
<ol>
<li>如果我们没有显式的声明一个类的父类的话，则此类继承于java.lang.Object类</li>
<li>所有的java类（除了java.lang.Object类之外）都直接或间接的继承于java.lang.Object类</li>
<li>意味着，所有的java类具有java.lang.Object类声明的功能</li>
</ol>
<h3 id="5-2-方法的重写"><a href="#5-2-方法的重写" class="headerlink" title="5.2 方法的重写"></a>5.2 方法的重写</h3><p>（overeide 、overwrite）</p>
<ol>
<li><p><strong>重写：子类继承父类以后，可以对父类中同名同参数的方法，进行覆盖</strong></p>
</li>
<li><p><strong>应用：重写以后，且当创建子类对象以后，通过子类对象调用子父类中的同名同参数的方法时，参数实际执行的是子类重写父类的方法</strong></p>
</li>
<li><p>重写的规定：约定俗称：子类中的叫重写的方法，父类中的叫被重写的方法</p>
<ol>
<li>子类重写的<strong>方法名和形参列表</strong>和父类被重写的<strong>方法名和形参列表相同</strong></li>
<li>子类重写的方法的权限修饰符不小于被重写的方法的权限修饰符</li>
</ol>
<p>​                    特殊情况：子类不能重写父类中声明为private的<strong>方法</strong></p>
</li>
<li><p>返回值类型;</p>
<ol>
<li>父类被重写的方法的返回值类型是void，则子类重写的方法的返回值类型只能是void</li>
<li>父类被重写的方法的返回值类型是A类型，则子类重写的方法的返回值类型只能是A类或A类的子类</li>
<li>父类被重写的方法的返回值类型是基本数据类型，则子类重写的方法的返回值类型只能是相同的基本数据类型</li>
<li>子类重写的方法抛出异常类型不大于父类被重写的方法抛出异常类型</li>
</ol>
</li>
<li><p><strong>由于注意事项很多，一般都写和父类的方法一样的即可</strong></p>
</li>
<li><p>补充：子类和父类的同名同参数的方法要么都声明为非static的（考虑重写），要么都声明static（不考虑重写）</p>
</li>
<li><p>面试题：区分方法的重写和重载？</p>
<ol>
<li><p>二者的概念：</p>
<p>重载：在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或者参数类型不同即可。—构造器也能重写</p>
<p>重写：子类继承父类以后，可以对父类中同名同参数的方法，进行覆盖—构造器不能重写</p>
</li>
<li><p>在谈谈二者具体规则</p>
</li>
<li><p>最后;</p>
<p>重载：不表现为多态性</p>
<p>​            调用的地址在编译期就绑定了，在方法调用之前，编译器就已经确定了所要调用的方法，称为早绑定或静态绑定</p>
<p>重写：表现为多态性</p>
<p>​           在方法调用的那一刻，解释运行器才会确定所要调用的方法，   重写称为  晚绑定 或动态绑定</p>
</li>
</ol>
</li>
</ol>
<h3 id="5-3-关键字：super"><a href="#5-3-关键字：super" class="headerlink" title="5.3 关键字：super"></a>5.3 关键字：super</h3><h4 id="1-理解和用处"><a href="#1-理解和用处" class="headerlink" title="1.理解和用处"></a>1.理解和用处</h4><p>理解：父类的（<strong>继承性提到superclass说的就是父类</strong>）</p>
<p>用处：可以用来调用：属性、方法、构造器</p>
<p><strong>与this类似，都用来区分相同名字不同内涵的代码</strong></p>
<p>this（形参列表）：本类重载的其它构造器（不能自己调自己）</p>
<p>super（形参列表）：调用父类中指定的构造器</p>
<h4 id="2-super的使用"><a href="#2-super的使用" class="headerlink" title="2.super的使用"></a>2.super的使用</h4><ol>
<li><p>我们可以在子类的方法或构造器中。通过使用 <strong>“super.属性”或“super .方法 ”</strong>的方式显式调用父类中声明的属性或方法。但是，通常情况下，我们习惯省略super.</p>
</li>
<li><p>特殊情况：当子类和父类中定义了<strong>同名的属性</strong>时，我们想要在子类中调用父类中声明的属性，则必须显式的使用 “super.属性” 的方式，表明调用的是父类中声明的属性</p>
</li>
<li><p>特殊情况：当子类<strong>重写了父类中的方法</strong>以后，我们想在子类的方法中调用父类中被重写的方法时，则必须显式的使用“super .方法 ”的方式，表明调用的是父类中被重写的方法</p>
<p>(2)(3) 代码演示</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span>&#123;   <span class="comment">//父类</span></span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">int</span> id；</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//吃饭</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span>&#123;          子类</span><br><span class="line">    String id ;</span><br><span class="line">    id = <span class="string">&quot;23456&quot;</span>;   <span class="comment">//这表示的是子类的id</span></span><br><span class="line">    <span class="built_in">super</span>.id = <span class="number">23</span>;  <span class="comment">//这是父类中声明的id</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//吃席</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">walk</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//走十公里；</span></span><br><span class="line">        eat();<span class="comment">//表明的是子类已经重写过的  </span></span><br><span class="line">        <span class="built_in">super</span>.eat( ); <span class="comment">// 表明是父类中的</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="3-super-调用构造器"><a href="#3-super-调用构造器" class="headerlink" title="3.super 调用构造器"></a>3.super 调用构造器</h4><ol>
<li><p>我们可以在子类的构造器中显式的使用 “super(形参列表)”的方式，调用父类中声明的指定的构造器</p>
</li>
<li><p>“super(形参列表)”的使用，必须声明在子类<strong>构造器的首行</strong></p>
</li>
<li><p>我们在类的构造器中，针对与 “this(形参列表)”或 “super(形参列表)”<strong>只能二选一</strong></p>
</li>
<li><p>在构造器的首行，<strong>没有显式的声明</strong> “this(形参列表)”或 “super(形参列表)”则<strong>默认用的是父类中空参的构造器</strong></p>
</li>
<li><p>在类的多个构造器中，<strong>至少有一个类的构造器中使用了 “super(形参列表)”</strong>，调用父类中的构造器</p>
</li>
<li><p>总结(1)(4)(5):</p>
<p><strong>子类必须在多个构造器中调用至少调用一次父类的构造器“super(形参列表)”</strong>（5）</p>
<p>所有类父类都是Object类</p>
<p><strong>每个构造器中都默认有super（），来调用父类的构造器空参构造器(4)</strong></p>
<p><strong>如果程序经过修改：父类使用带参构造器，则系统不在提供空参构造器，那么子类就得在构造器中调用与父类构造器匹配的super(形参列表)   (1)</strong></p>
</li>
</ol>
<h4 id="4-子类对象实例化的全过程"><a href="#4-子类对象实例化的全过程" class="headerlink" title="4.子类对象实例化的全过程"></a>4.子类对象实例化的全过程</h4><ol>
<li><p>从结果上来看（继承性）</p>
<p>子类继承父类以后，就获取了父类中声明的属性或方法</p>
<p>创建子类对象，在堆空间中，就会加载所有父类中声明的属性</p>
</li>
<li><p>从过程上来看</p>
<p>​    当我们通过子类的构造器创建子类对象时，我们一定会直接或间接的调用其父类的构造器，进而调用父类的父类的构造器，直到调用了java.lang.Object 类中空参的构造器为止。正因为加载过所有的父类的结构，所以才可以看到内存中有父类中的结构，子类对象才可以考虑进行调用</p>
</li>
<li><p>明确：虽然创建子类对象时，调用了父类的构造器，但是自始至终就创建过一个对象，即为new的子类对象</p>
</li>
</ol>
<h3 id="5-4面向对象特征之三：多态性"><a href="#5-4面向对象特征之三：多态性" class="headerlink" title="5.4面向对象特征之三：多态性"></a>5.4面向对象特征之三：多态性</h3><h4 id="1-理解"><a href="#1-理解" class="headerlink" title="1.理解"></a>1.理解</h4><ol>
<li><p>可以理解为一个事物的多种形态</p>
</li>
<li><p>对象的多态性：父类的引用指向子类对象，(或子类的对象赋给父类的引用)</p>
<p>Person  p1 &#x3D;  new Student();  &#x2F;&#x2F;person父类，student子类</p>
</li>
</ol>
<p><strong>多态的使用前提</strong></p>
<ol>
<li>有，类的继承关系</li>
<li>有，方法的重写</li>
</ol>
<h4 id="2-虚拟方法调用："><a href="#2-虚拟方法调用：" class="headerlink" title="2.虚拟方法调用："></a>2.虚拟方法调用：</h4><p>有了对象的多态性以后，我们在编译期，只能调用父类中声明的方法，但是在运行期，我们<strong>实际执行的是子类重写父类的方法</strong></p>
<p>总结：编译看左边，运行看右边</p>
<p>Person  p1 &#x3D;  new Student();  &#x2F;&#x2F;person父类，student子类</p>
<p>举例一：</p>
<p>假设Animal动物是所有动物的父类（比如 Dog 、Fish…)</p>
<p>他们是继承关系，且eat()  和  shuot () 都经过重写</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Animal</span>  <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>() ;  <span class="comment">// 虚拟方法调用   编译看左边，运行看右边</span></span><br><span class="line">func(test) ;                         <span class="comment">//编译期，test是Animal类型，满足方法形参</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span>  <span class="title function_">func</span> <span class="params">(Animal  animal)</span>&#123;</span><br><span class="line">       animal.eat();                   <span class="comment">//运行时，实际执行的是已经重写的方法</span></span><br><span class="line">       animal.shout();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>总结：方法形参写父类，利用多态性（虚拟方法调用）任意声明一个子类都可以满足此方法——多态性的好处</p>
<p>举例二：</p>
<p>public  void  method(Object  obj){ &#x2F;&#x2F;Object类是任意类的父类</p>
<p>利用虚拟调用Object  ob &#x3D; new  任意类（）；都可以调用此方法</p>
<h4 id="3-使用说明"><a href="#3-使用说明" class="headerlink" title="3.使用说明"></a>3.使用说明</h4><p>对象的多态性，只适用于方法，不适用于属性（编译和运行都看左边）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span>  <span class="variable">p1</span> <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">Student</span>();  <span class="comment">//person父类，student子类</span></span><br></pre></td></tr></table></figure>

<h4 id="4-多态性的转型"><a href="#4-多态性的转型" class="headerlink" title="4.多态性的转型"></a>4.多态性的转型</h4><h5 id="1-向上转型：即为多态"><a href="#1-向上转型：即为多态" class="headerlink" title="1.向上转型：即为多态"></a>1.向上转型：即为多态</h5><p>将 Person p1 &#x3D; new Student（）;</p>
<p>声明用父类 ，new用子类  </p>
<p>编译时认为 p1 是Person类的，所以只能调用Person类中声明的属性和方法</p>
<p>实际运行时是执行子类重写父类的方法</p>
<p>（不包括属性）</p>
<h5 id="2-向下转型：父类–-gt-子类"><a href="#2-向下转型：父类–-gt-子类" class="headerlink" title="2.向下转型：父类–&gt;子类"></a>2.向下转型：父类–&gt;子类</h5><p><strong>需求</strong>：为了在使用多态虚拟方法调用后，<strong>还能使用子类特有的属性和方法</strong></p>
<p>操作：使用强制类型转换符</p>
<p>Person p1 &#x3D; new Man（）;</p>
<p>Man  m1  &#x3D;   （Man）p1 ;</p>
<p>此时 m1 是Man类型</p>
<p>出现问题：使用强转时，可能出现ClassCastException的异常</p>
<p>Woman  w1 &#x3D; new  (Woman) p2 ;</p>
<p>此时编译不报错，但是运行报错</p>
<p>虽然他们父类都是Person，但是不能够操作</p>
<p>解决问题：使用instanceof关键字</p>
<p><strong>a  instanceof   A</strong> :判断对象a(变量名) 是否是A类(类型)的实例。如果是，返回true。如果不是，返回false。</p>
<p>使用前提：</p>
<ol>
<li><p>要求两个类必须是必须有子父类的关系，否则编译错误。</p>
</li>
<li><p>：e  instanceof  a </p>
<p>a  只能是  e  的父类 或者 是 e</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">if</span>(p2  <span class="keyword">instanceof</span>  Woman) &#123;</span><br><span class="line">	<span class="type">Woman</span>  <span class="variable">w1</span> <span class="operator">=</span> (Woman )p2;</span><br><span class="line">	w1.goShopping();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(p2  <span class="keyword">instanceof</span>  Man) &#123;</span><br><span class="line">	<span class="type">Man</span>  <span class="variable">w1</span> <span class="operator">=</span> (Man)p2;</span><br><span class="line">	w1.earnMoney();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>练习：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span>  <span class="variable">p3</span>  <span class="operator">=</span> <span class="keyword">new</span>  <span class="title class_">Woman</span>();</span><br><span class="line"><span class="type">Object</span>  <span class="variable">obj</span> <span class="operator">=</span>  <span class="keyword">new</span>  <span class="title class_">Woman</span>();</span><br><span class="line"><span class="type">Woman</span>  <span class="variable">w1</span> <span class="operator">=</span> (Woman) p3; 编译运行都通过</span><br><span class="line"><span class="type">Man</span>  <span class="variable">m1</span>  <span class="operator">=</span>  (Man) p3 ;  编译通过，运行不通过</span><br><span class="line"><span class="type">Person</span>  <span class="variable">p</span>   <span class="operator">=</span>   (Person)obj ;编译运行都通过</span><br></pre></td></tr></table></figure>

<h4 id="5-小练习"><a href="#5-小练习" class="headerlink" title="5.小练习"></a>5.小练习</h4><p>Base 是父类 ，其中有属性 count &#x3D;10 和方法 display() —调用会输出count</p>
<p>Sub 是子类 重写了count &#x3D;20 ，也重写了display，调用会输出count</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Sub</span>  <span class="variable">s</span>  <span class="operator">=</span>  <span class="keyword">new</span>  <span class="title class_">Sub</span> ();</span><br><span class="line">s.display(); <span class="comment">//20</span></span><br><span class="line"></span><br><span class="line"><span class="type">Base</span> <span class="variable">b</span> <span class="operator">=</span> s ;  <span class="comment">// 多态性，这时b是直接得到s的地址</span></span><br><span class="line">System.out.println( b ==s）; <span class="comment">//地址一样返回true</span></span><br><span class="line">b.count <span class="comment">//输出10  ，多态不适用属性</span></span><br><span class="line">b.display(); <span class="comment">//输出20   适用于方法</span></span><br></pre></td></tr></table></figure>

<h3 id="5-5-Object类使用"><a href="#5-5-Object类使用" class="headerlink" title="5.5 Object类使用"></a>5.5 Object类使用</h3><h4 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h4><p>java.lang.Object 类</p>
<ol>
<li><p>Object类是所有Java类的跟父类（想象类构成的树，它为根节点）</p>
</li>
<li><p>如果在类的声明中为使用extends 关键字指明其父类，则默认父类为java.lang.Object 类</p>
</li>
<li><p>Object 类的功能（属性、方法）就具有通用性</p>
<p>属性：无</p>
<p>方法：equals ()  &#x2F;   toString()   &#x2F;    getClass()  &#x2F;  hashCode()  &#x2F;  clone() &#x2F; finalize()  &#x2F;  wait()  、 notify()、notifyAll()</p>
</li>
<li><p>Object类只声明了一个空参构造器</p>
</li>
<li><p>补充：数组也是可以理解为Object类的子类，其可以调用Object类中声明的方法 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="type">int</span>[ ]  arr  =  <span class="keyword">new</span>  <span class="title class_">int</span>[ ]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">System.out.println(arr.toString()); </span><br><span class="line">System.out.println(arr);</span><br></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<p>两者输出都是该数组的地址</p>
</blockquote>
<h4 id="2-equals-和-x3D-x3D"><a href="#2-equals-和-x3D-x3D" class="headerlink" title="2.equals() 和 &#x3D; &#x3D;"></a>2.equals() 和 &#x3D; &#x3D;</h4><h5 id="1-x3D-x3D-运算符"><a href="#1-x3D-x3D-运算符" class="headerlink" title="1.&#x3D;&#x3D;运算符"></a>1.&#x3D;&#x3D;运算符</h5><ol>
<li><p>可以使用在基本数据类型变量和引用数据类型变量中</p>
</li>
<li><p>如果比较的是基本数据类型：比较两个变量保存的数据是否相等（不一定类型相同，但会自动类型提升）</p>
</li>
<li><p>如果比较的是引用数据类型变量：比较哦两个对象的地址值是否相同。即两个引用是否指向同一个对象实体</p>
</li>
<li><p>补充：使用 &#x3D;&#x3D;  符号时，必须保证左右两边的变量类型一致</p>
</li>
<li><p>特别关于String 类型</p>
<p>String类型赋值是放在常量池中，不像以往说的放在堆空间中，它有复用性，发现有相同的字符就只调用相同字符的地址赋给它</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span>  <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;BB&quot;</span> ;<span class="comment">//此类声明可不写new</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span>  <span class="operator">=</span> <span class="string">&quot;BB&quot;</span> ; </span><br><span class="line">System.out.println(s1==s2) ; <span class="comment">//ture</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h5 id="2-equals（）"><a href="#2-equals（）" class="headerlink" title="2.equals（）"></a>2.equals（）</h5><ol>
<li><p>是一个方法，而非运算符</p>
</li>
<li><p>只能使用于引用数据类型</p>
</li>
<li><p>Object 类中 equals() 的定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span>  <span class="title function_">equals</span><span class="params">(Object  obj)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (<span class="built_in">this</span> ==obj) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：Object类中定义的equals() 和 &#x3D;&#x3D;</p>
<p>的作用是相同的 ：</p>
<p>都是比较两个对象的地址值是否相同。即两个引用是否指向同一个对象实体</p>
</li>
<li><p>类似String 、Date、File 、包装类等都重写了Object类中equals()方法。</p>
<p>重写以后，比较的不是两个引用的地址是否相同，而是根据问题所需比较两个对象的”实体内容“ 是否相同</p>
<p>比如：首先是不是一个类声明的，其中想要比较的属性是相等</p>
</li>
<li><p>通常情况下，我们自定义的类如果使用equals() 的话，也通常是比较两个对象的“实体内容” 是否相同。 那么我们就需要堆Object类中的equals() 进行重写</p>
<p>重写的原则：比较两个对象的实体内容是否相同</p>
</li>
<li><p>补充：自己写容易出错，开发中都是自动生成的</p>
</li>
</ol>
<h4 id="3-toString-使用"><a href="#3-toString-使用" class="headerlink" title="3.toString() 使用"></a>3.toString() 使用</h4><ol>
<li><p>当我们输出一个对象的引用时，实际上就是调用当前对象的toString()</p>
</li>
<li><p>Object类中toString() 的定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> 返回的是类的名字及地址</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>类似String 、Date、File 、包装类等都重写了Object类中toString()方法。</p>
<p>我们想要调用这个方法来输出时，返回的是我们最想看到的结构，所以都会考虑重写</p>
</li>
<li><p>手动实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span>&#123;</span><br><span class="line">	reutrn  <span class="string">&quot;name=&quot;</span>+name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5.小问题</p>
<p>（1）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span>  <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">System.out.println(p1);</span><br><span class="line">System.ou.println(p1.toString());</span><br><span class="line"><span class="comment">//二者是一样的结果</span></span><br><span class="line"><span class="comment">//前者，最后还是会去调用toString</span></span><br></pre></td></tr></table></figure>

<p>（2）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span>  <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot; a b c&quot;</span> ;</span><br><span class="line">System.out.println(s);<span class="comment">//输出结果一样</span></span><br><span class="line">System.ou.println(p1.toString());</span><br></pre></td></tr></table></figure>

<p>（3）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span>  <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot; a b c&quot;</span> ;</span><br><span class="line">    s   =   <span class="literal">null</span>;</span><br><span class="line">System.out.println(s);</span><br><span class="line">System.ou.println(p1.toString());</span><br><span class="line"><span class="comment">//前者输出null，后者不输出，出现指针异常NullPointerException</span></span><br><span class="line"><span class="comment">//由于前者最后还是会去调用toString()</span></span><br><span class="line"><span class="comment">//但是途中有保护机制</span></span><br><span class="line"><span class="keyword">if</span>(s==<span class="literal">null</span>)&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;null&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>补充：自己写容易出错，开发中都是自动生成的</p>
</li>
</ol>
<h3 id="5-6-单元测试"><a href="#5-6-单元测试" class="headerlink" title="5.6 单元测试"></a>5.6 单元测试</h3><p>Java中的JUnit单元测试</p>
<ol>
<li><p>创建Java类，进行单元测试</p>
<p>此时的Java类要求是public的，并且此类提供公共的无参构造器</p>
</li>
<li><p>此单元测试方法上需要声明注释：@Test，将鼠标覆盖注释，点击出现的超链接，系统会自动为加入JUnit4和导入该类</p>
</li>
<li><p>此类中声明单元测试的方法</p>
<p>此时要求方法的权限是public，没有返回值，没有形参</p>
</li>
<li><p>声明好单元测试方法以后，就可以在方法体内测试相关的代码</p>
</li>
<li><p>写完代码以后，双击单元测试方法名，右键 run  as  – –JUnit Test</p>
</li>
<li><p>说明：</p>
<p>如果执行结果没有任何异常：绿条</p>
<p>执行结果出现异常：红条</p>
</li>
</ol>
<h3 id="5-7-包装类的使用"><a href="#5-7-包装类的使用" class="headerlink" title="5.7 包装类的使用"></a>5.7 包装类的使用</h3><h4 id="1-理解：-1"><a href="#1-理解：-1" class="headerlink" title="1.理解："></a>1.理解：</h4><p>针对八种基本数据类型定义的引用类型—-包装类（封装类）</p>
<p>有了类的特点，就可以调用类中的方法，Java才是真正的面向对象</p>
<h4 id="2-今昔对比"><a href="#2-今昔对比" class="headerlink" title="2.今昔对比"></a>2.今昔对比</h4><p>基本数据类型： byte  &#x2F;  short &#x2F;  int  &#x2F;  long &#x2F;  float &#x2F;  double  &#x2F;  boolean  &#x2F;  char</p>
<p>包装类： <strong>B</strong>yte  &#x2F;  <strong>S</strong>hort &#x2F;  Integer  &#x2F;  <strong>L</strong>ong &#x2F;  <strong>F</strong>loat &#x2F;  <strong>D</strong>ouble  &#x2F;  <strong>B</strong>oolean  &#x2F;  Character</p>
<p>除了 Boolean  &#x2F;  Character  其他的父类都是Number</p>
<h4 id="3-一般操作—1"><a href="#3-一般操作—1" class="headerlink" title="3.一般操作—1"></a>3.一般操作—1</h4><p>基本数据类型—&gt;包装类调用包装类的构造器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>  <span class="variable">p1</span>  <span class="operator">=</span>  <span class="number">10</span></span><br><span class="line"><span class="type">Itnteger</span>  <span class="variable">in1</span>  <span class="operator">=</span>  <span class="keyword">new</span>  <span class="title class_">Integer</span>(p1);</span><br><span class="line"><span class="comment">//或Itnteger  in1  =  new  Integer(10);</span></span><br><span class="line">System.out.println(in1.toString());<span class="comment">//10</span></span><br><span class="line">System.out.println(in1); <span class="comment">//这样是一样的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//可以从String中抽离数字，的那是也只能是纯数字</span></span><br><span class="line"><span class="type">Itnteger</span>  <span class="variable">in1</span>  <span class="operator">=</span>  <span class="keyword">new</span>  <span class="title class_">Integer</span>(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">System.out.println(in1.toString());<span class="comment">//123</span></span><br><span class="line"><span class="type">Itnteger</span>  <span class="variable">in1</span>  <span class="operator">=</span>  <span class="keyword">new</span>  <span class="title class_">Integer</span>(<span class="string">&quot;123abc&quot;</span>);</span><br><span class="line">System.out.println(in1.toString());<span class="comment">//这样则会报错</span></span><br><span class="line"></span><br><span class="line"><span class="type">Float</span>  <span class="variable">f1</span>  <span class="operator">=</span> <span class="keyword">new</span>  <span class="title class_">Float</span>(<span class="number">12.3f</span>);</span><br><span class="line"><span class="type">Float</span> <span class="variable">f2</span> <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">Float</span>(<span class="string">&quot;12.3&quot;</span>);<span class="comment">//两者一样</span></span><br><span class="line"></span><br><span class="line"><span class="type">Boolean</span>  <span class="variable">b1</span> <span class="operator">=</span> <span class="keyword">new</span>  <span class="title class_">Boolean</span>(<span class="literal">true</span>);</span><br><span class="line"><span class="type">Boolean</span>  <span class="variable">b2</span> <span class="operator">=</span> <span class="keyword">new</span>  <span class="title class_">Boolean</span>(<span class="string">&quot;true&quot;</span>);</span><br><span class="line"><span class="comment">//在双引号内不区分大小写，如有多余的字符，返回的也是false</span></span><br></pre></td></tr></table></figure>

<h4 id="4-一般操作–2"><a href="#4-一般操作–2" class="headerlink" title="4.一般操作–2"></a>4.一般操作–2</h4><p>包装类—&gt;基本数据类型：调用包装类Xxx的xxxValue()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Itnteger</span>  <span class="variable">in1</span>  <span class="operator">=</span>  <span class="keyword">new</span>  <span class="title class_">Integer</span>(<span class="number">10</span>);</span><br><span class="line"><span class="type">int</span>  <span class="variable">i1</span>  <span class="operator">=</span>  in1.intValue();</span><br><span class="line"></span><br><span class="line"><span class="type">Float</span>  <span class="variable">f1</span>  <span class="operator">=</span> <span class="keyword">new</span>  <span class="title class_">Float</span>(<span class="number">12.3f</span>);</span><br><span class="line"><span class="type">float</span>   <span class="variable">f2</span>  <span class="operator">=</span>  f1.floatValue();</span><br><span class="line"></span><br><span class="line"><span class="type">Boolean</span>  <span class="variable">b1</span> <span class="operator">=</span> <span class="keyword">new</span>  <span class="title class_">Boolean</span>(<span class="literal">true</span>);</span><br><span class="line"><span class="type">boolean</span>  <span class="variable">b2</span> <span class="operator">=</span> b1.booleanValue();</span><br></pre></td></tr></table></figure>

<h4 id="5-便捷操作—-1"><a href="#5-便捷操作—-1" class="headerlink" title="5.便捷操作—-1"></a>5.便捷操作—-1</h4><p>基本数据类型—&gt;包装类</p>
<p>自动装箱</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>  <span class="variable">num1</span>  <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">Integer</span>  <span class="variable">in1</span>  <span class="operator">=</span>  num2  ;</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span>  <span class="variable">b1</span>  <span class="operator">=</span>   <span class="literal">true</span>  ;</span><br><span class="line"><span class="type">Boolean</span> <span class="variable">b2</span>  <span class="operator">=</span>   b1  ;</span><br><span class="line"></span><br><span class="line"><span class="type">Float</span>  <span class="variable">f1</span>  <span class="operator">=</span> <span class="number">12.3</span> ;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>不用new了，就可以直接使用</p>
</blockquote>
<h4 id="6包装类和基本数据类型比较问题"><a href="#6包装类和基本数据类型比较问题" class="headerlink" title="6包装类和基本数据类型比较问题"></a>6包装类和基本数据类型比较问题</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span>  <span class="variable">i</span>   <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>);</span><br><span class="line"><span class="type">Integer</span>  <span class="variable">j</span>  <span class="operator">=</span> newInteger(<span class="number">1</span>);</span><br><span class="line">System.out.println(i == j);</span><br><span class="line"><span class="comment">//false 比的是地址</span></span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span>  <span class="variable">m</span> <span class="operator">=</span>  <span class="number">1</span> ;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">n</span> <span class="operator">=</span>  <span class="number">1</span> ;</span><br><span class="line">System.out.println(m == n);</span><br><span class="line"><span class="comment">//ture  地址一样</span></span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span>  <span class="variable">x</span> <span class="operator">=</span>  <span class="number">128</span> ;</span><br><span class="line"><span class="type">Integer</span>  <span class="variable">y</span> <span class="operator">=</span>  <span class="number">128</span> ;</span><br><span class="line">System.out.println(x == y);</span><br><span class="line"><span class="comment">//false 地址不一样</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>1、<strong>基本型和基本型封装型</strong>进行<strong>“&#x3D;&#x3D;”运算符的比较</strong>，<strong>基本型封装型</strong>将会<strong>自动拆箱</strong>变为<strong>基本型</strong>后再<strong>进行比较</strong>，因此Integer(0)会自动拆箱为int类型再进行比较，显然返回true；<br>2、<strong>两个Integer类型</strong>进行<strong>“&#x3D;&#x3D;”比较</strong>，如果其值在-128至127，那么返回true，否则返回false, 这跟Integer.valueOf()的缓冲对象有关，这里不进行赘述。<br>3、<strong>两个基本型的封装型进行equals()比较</strong>，首先equals()会比较类型，如果类型相同，则继续比较值，如果值也相同，返回true<br>4、基本型封装类型调用equals(),但是参数是基本类型，这时候，先会进行自动装箱，基本型转换为其封装类型，再进行3中的比较。</p>
<p>解释：new 过的空间地址不一样，Integer中存在数组存放使用频率最大的数  -128 ~~ 127 之间，在这区间内的数可以使用的是相同的地址</p>
<p>超过此范围，才会自动装箱给你new新空间来存放128</p>
</blockquote>
<h4 id="7-便捷操作—2"><a href="#7-便捷操作—2" class="headerlink" title="7.便捷操作—2"></a>7.便捷操作—2</h4><p>包装类- —&gt;基本数据类型</p>
<p>自动拆箱：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span>  <span class="variable">in1</span> <span class="operator">=</span> <span class="number">10</span> ; <span class="comment">//自动装箱</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>  <span class="variable">num1</span> <span class="operator">=</span> in1 ; <span class="comment">//自动拆箱</span></span><br></pre></td></tr></table></figure>

<h4 id="8-第三者String—1"><a href="#8-第三者String—1" class="headerlink" title="8.第三者String—1"></a>8.第三者String—1</h4><p>基本数据类型、包装类–&gt;String类型.</p>
<p>调用String重载的valueOf(Xxx  xxx)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">num1</span>  <span class="operator">=</span> <span class="number">10</span> ;</span><br><span class="line"><span class="type">Integer</span>  <span class="variable">num2</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式一：</span></span><br><span class="line"><span class="type">String</span>  <span class="variable">str1</span> <span class="operator">=</span> num1 +<span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="type">String</span>  <span class="variable">str2</span>  <span class="operator">=</span> num2 +<span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式二：</span></span><br><span class="line"><span class="type">String</span>  <span class="variable">str1</span> <span class="operator">=</span> String . valueOf(num1)；</span><br><span class="line"><span class="type">String</span>  <span class="variable">str2</span> <span class="operator">=</span> String . valueOf(num2)；</span><br></pre></td></tr></table></figure>

<h4 id="9-第三者String-–2"><a href="#9-第三者String-–2" class="headerlink" title="9.第三者String –2"></a>9.第三者String –2</h4><p>String类型—&gt;基本数据类型、包装类.</p>
<p>调用包装类的parseXxx(String   s  )</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span>  <span class="variable">str1</span>  <span class="operator">=</span>  <span class="string">&quot;123&quot;</span>;</span><br><span class="line"><span class="type">int</span>  <span class="variable">num1</span> <span class="operator">=</span> Integer . parseInt(str1)  ;</span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span>  <span class="variable">num2</span> <span class="operator">=</span> Integer . parseInt(str1)  ;</span><br></pre></td></tr></table></figure>



<h2 id="6-面向对象（下）"><a href="#6-面向对象（下）" class="headerlink" title="6. 面向对象（下）"></a>6. 面向对象（下）</h2><h3 id="6-1关键字：static"><a href="#6-1关键字：static" class="headerlink" title="6.1关键字：static"></a>6.1关键字：static</h3><h4 id="1-介绍："><a href="#1-介绍：" class="headerlink" title="1.介绍："></a>1.介绍：</h4><p>static：静态的</p>
<p>static可以用来修饰：属性、方法、代码块、内部类</p>
<h4 id="2-修饰属性："><a href="#2-修饰属性：" class="headerlink" title="2.修饰属性："></a>2.修饰属性：</h4><p>static  String  nation ;     静态变量  （或类变量）</p>
<ol>
<li><p>属性：按是否使用static修饰，分为：修饰属性 vs 非静态属性（实例变量）</p>
</li>
<li><p>实例变量</p>
<p>我们创建了类的多个对象，每个对象都独立的拥有一套类中的非静态属性。当<strong>修改其中一个对象中的非静态属性时，不会导致其中对象中同样的属性值的修改</strong></p>
</li>
<li><p>静态变量</p>
<p>我们创建了类的多个对象，多个对象共享同一个静态变量。当<strong>通过该某一个对象修改静态变量时，会导致其他对象调用此静态变量时，是修改过了的</strong></p>
</li>
<li><p>修饰属性的其他说明</p>
<ol>
<li><p>静态变量随这类的加载而加载(在方法区的静态域中)。可以通过 “ 类 . 静态变量 ” 的方式进行调用</p>
</li>
<li><p>静态变量的加载要早于对象的创建</p>
</li>
<li><p>由于类只会加载一次，则静态变量在内存汇总也只会存在一份：存在方法区的静态域中</p>
</li>
<li><p>类：可以直接调用类变量（静态变量），不能调用实例变量</p>
</li>
</ol>
<p>   对象：可以直接调用类变量（静态变量），也可以调用实例变量</p>
<p>   <strong>举例以上：</strong></p>
   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">   Person.nation  =  <span class="string">&quot;中国华人民共和国&quot;</span> ; </span><br><span class="line">   <span class="comment">//可以直接调用也可以改 </span></span><br><span class="line">   Person.name <span class="comment">//错，不能调用非静态的</span></span><br><span class="line">   <span class="type">Person</span>  <span class="variable">p1</span>  <span class="operator">=</span>  <span class="keyword">new</span>  <span class="title class_">Person</span>();</span><br><span class="line">   p1.nation  =  <span class="string">&quot;China&quot;</span> ;</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line"><span class="comment">//造完对象后可以直接调也可以改</span></span><br><span class="line">   <span class="type">Person</span>  <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">p2 . nation = <span class="string">&quot;CHN&quot;</span> ;</span><br><span class="line">   <span class="comment">//改完以后p1.nation 也是CHN</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="type">String</span>  <span class="variable">nation</span> <span class="operator">=</span> <span class="string">&quot;中国&quot;</span> ;</span><br><span class="line">   	String  name ;</span><br><span class="line">	<span class="type">int</span>   age ;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>类变量内存解析</p>
</li>
</ol>
<p><img src="/2022/09/28/%E5%B0%9A%E7%A1%85%E8%B0%B7java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/img%5CSnipaste_2022-01-16_12-18-48.png" alt="Snipaste_2022-01-16_12-18-48"></p>
<h4 id="3-修饰方法"><a href="#3-修饰方法" class="headerlink" title="3.修饰方法"></a>3.修饰方法</h4><p>静态方法</p>
<ol>
<li><p>随着类的加载而加载，可以通过 “ 类 . 静态方法” 的方式进行调用</p>
</li>
<li><p>补充：如果在本类中调用本类的静态的属性或方法可以  nation 或Person . nation    , walk() 或  Person . walk()</p>
<p>通常会省略类名</p>
</li>
<li><p><strong>静态方法中，只能调用静态的方法或属性</strong></p>
<p><strong>要想调用非静态的，只能在本方法内创建类的对象实例，进行间接调用</strong></p>
</li>
<li><p>非静态的方法中，既可以调用非静态的方法或属性，也可以调用静态的方法或属性</p>
</li>
<li><p>实例化子类对象时，涉及到父类、子类中（静态代码块、非静态代码块、构造器–也是此顺序）的加载顺序</p>
<p>由父及子，静态先行</p>
<p>代码</p>
</li>
<li><p>static 注意点</p>
<ol>
<li><p>在静态方法内，不能使用this关键字 、super关键字</p>
</li>
<li><p>关于静态属性和静态方法的使用，大家都从生命周期的角度去解释</p>
</li>
<li><p>所谓“生命周期”</p>
<p>首先程序先加载类，而静态就是跟随了类的加载。</p>
<p>其次造对象，才有非静态的（属性或方法）</p>
<p>其中可能一些对象执行程序结束被回收，而静态的始终还在</p>
<p>最后全部程序结束，静态的才被回收</p>
<p>就此看来，在一开始类就可以调用静态的属性或方法，当然这也规划了类不能调用非静态的属性或方法。</p>
<p>对象是后出现的，所以其可以调用非静态的属性或方法</p>
</li>
</ol>
</li>
<li><p>开发中应用</p>
<ol>
<li><p>开发中，如何确定一个属性是否声明为static的？</p>
<p>属性是可以被多个所共享的，不会随者对象的不同而不同的</p>
<p>类中的常量也常常声明为static  比如Math.PI</p>
</li>
<li><p>开发中，如何确定一个方法是否要声明为static的</p>
<p>操作（调用）静态属性的方法，通常也是设置为静态的</p>
<p>工具类中的方法，习惯上声明为static 的。比如：Math、Arrays 、Collections</p>
<p>都是大家通用的操作，不需要在一一造对象的</p>
</li>
<li><p>小举例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>  <span class="type">int</span>  id  ；</span><br><span class="line"><span class="keyword">private</span>  <span class="keyword">static</span>  <span class="type">int</span>  <span class="variable">inti</span> <span class="operator">=</span> <span class="number">1001</span>;<span class="comment">//编号</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Circle</span><span class="params">()</span>&#123;</span><br><span class="line">	id  =  init ++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h4 id="4-单例设计模式"><a href="#4-单例设计模式" class="headerlink" title="4.单例设计模式"></a>4.单例设计模式</h4><h5 id="1-理解-1"><a href="#1-理解-1" class="headerlink" title="1.理解"></a>1.理解</h5><p>设计模式是在大量的实践中总结和理论化之后优选的代码结构、编程风格、以及解决问题的思考方式。——-23种设计模式</p>
<p>所谓的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例</p>
<p>两种实现方式：</p>
<p>饿汉式    VS     懒汉式</p>
<h5 id="2-饿汉式"><a href="#2-饿汉式" class="headerlink" title="2.饿汉式"></a>2.饿汉式</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span>  <span class="title class_">Bank</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Bank</span><span class="params">()</span>&#123;   <span class="comment">//1.私有化构造器</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//2. 内部创建类的对象</span></span><br><span class="line">	<span class="comment">// 4. 要求此对象必须声明为静态的</span></span><br><span class="line">	<span class="keyword">private</span>  <span class="keyword">static</span>  <span class="type">Bank</span>  <span class="variable">inst</span>  <span class="operator">=</span>   <span class="keyword">new</span>  <span class="title class_">Bank</span>() ;</span><br><span class="line">	<span class="comment">// 3. 提供公共的静态的方法，返回类的对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>  Bank  <span class="title function_">getInst</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> inst ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-懒汉式"><a href="#3-懒汉式" class="headerlink" title="3.懒汉式"></a>3.懒汉式</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span>  <span class="title class_">Bank</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  <span class="title function_">Bank</span><span class="params">()</span>&#123;   <span class="comment">//1.私有化构造器</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2. 声明当前类的对象，没有初始化</span></span><br><span class="line">    <span class="comment">// 4. 要求此对象必须声明为静态的</span></span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">static</span>  <span class="type">Bank</span>  <span class="variable">inst</span>  <span class="operator">=</span>   <span class="literal">null</span> ;</span><br><span class="line">    <span class="comment">// 3. 提供公共的静态的方法，返回类的当前对象对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>  Bank  <span class="title function_">getInst</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( inst == <span class="literal">null</span> )&#123;  </span><br><span class="line">        inst  =  <span class="keyword">new</span>  <span class="title class_">Bank</span>() ;</span><br><span class="line">    	&#125;</span><br><span class="line">        <span class="keyword">return</span> inst ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="4-两种模式利弊"><a href="#4-两种模式利弊" class="headerlink" title="4.两种模式利弊"></a>4.两种模式利弊</h5><p>饿汉式：</p>
<p>好处：饿汉式是线程安全的</p>
<p>坏处：对象加载时间过长</p>
<p>懒汉式;</p>
<p>好处：延迟对象的创建</p>
<p>坏处：目前写法坏处：线程不安全–&gt;讲到多线程内容时，再修改</p>
<p>举例：你有一银行账户2000元：你同时在手机中和在ATM机中取款，这时你可能有机会同时进入并将前同时取出。</p>
<p>这里的懒汉式也是这个道理，两个操作同时进行，就有可能判断他们都为空null，继而创建出了两个对象</p>
<p>如是这样，将导致你高铁抢到的票，有三四个票是重复的</p>
<h5 id="5-应用场所"><a href="#5-应用场所" class="headerlink" title="5.应用场所"></a>5.应用场所</h5><p><img src="/2022/09/28/%E5%B0%9A%E7%A1%85%E8%B0%B7java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/img%5CSnipaste_2022-01-16_15-36-11.png" alt="Snipaste_2022-01-16_15-36-11"></p>
<h3 id="6-3-main-方法详解"><a href="#6-3-main-方法详解" class="headerlink" title="6.3 main() 方法详解"></a>6.3 main() 方法详解</h3><h4 id="1-使用说明"><a href="#1-使用说明" class="headerlink" title="1.使用说明"></a>1.使用说明</h4><ol>
<li>main( ) 方法作为程序的入口</li>
<li>main ( ) 方法也是一个普通的静态方法 </li>
<li>main ( ) 方法可以作为我们与控制台交互的方式</li>
</ol>
<h4 id="2-理解："><a href="#2-理解：" class="headerlink" title="2.理解："></a>2.理解：</h4><ol>
<li><p>格式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">( String[ ]  args )</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//是一个public 公共的，静态的，返回值为空的，形参为String[]  args 和方法名叫main的一个方法</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>小结：一叶知秋</p>
<p>public static void main( String[ ]  args ){        方法体      }</p>
<p>权限修饰符：private 、缺省、protected、public—封装性</p>
<p>修饰符：static、final、abstract、native—-可以用来修饰方法</p>
<p>返回值类型：无返回值、有返回值–return</p>
<p>方法名：“见名知意”</p>
<p>形参列表：重载    VS  重写（参数的值传递机制、体现对象的多态性</p>
<p>方法体：来体现方法的功能</p>
</li>
<li><p>注意：</p>
<ol>
<li><p>在每个类中都可以声明名字叫main的方法，在运行时，会手动区分</p>
</li>
<li><p><strong>因为是static ,所以方法内只能调用静态的属性或方法</strong></p>
<p><strong>要想调用非静态的，只能在本方法内创建类的对象，进行间接调用</strong></p>
</li>
<li><p>形参中的String类型的数组可以在控制台中传入一些值</p>
<p>右键—Run Configuration—MainDemo—Arguments</p>
<p>在Program arguments 中带双引号输入你想要传的数值或字符</p>
</li>
<li><p>cmd 控制台中</p>
<p>java  类名  。。。</p>
<p>在类名后带双引号输入你想要传的数值或字符</p>
</li>
</ol>
</li>
</ol>
<h3 id="6-4-类的结构–代码块"><a href="#6-4-类的结构–代码块" class="headerlink" title="6.4 类的结构–代码块"></a>6.4 类的结构–代码块</h3><p>或初始化块</p>
<h4 id="1-介绍：-1"><a href="#1-介绍：-1" class="headerlink" title="1.介绍："></a>1.介绍：</h4><ol>
<li><p><strong>代码块的作用：用来初始化类、对象</strong></p>
</li>
<li><p>代码块如果有修饰的话，只能使用static</p>
</li>
<li><p>分类：静态代码块 VS  非静态代码块</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//VS</span></span><br><span class="line">  &#123;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="2-静态代码块"><a href="#2-静态代码块" class="headerlink" title="2.静态代码块"></a>2.静态代码块</h4><ol>
<li>内部可以有输出语句</li>
<li><strong>随着类的加载而执行，而且只执行一次</strong></li>
<li><strong>作用：初始化类的信息</strong></li>
<li>如果一个类中定义了多个静态代码块，则按声明的先后顺序执行</li>
<li><strong>静态代码块的执行要优先于非静态代码块的执行</strong></li>
<li><strong>静态代码块内只能调用静态的属性、静态的方法，</strong>不能调用非静态的结构</li>
</ol>
<h4 id="3-非静态代码块"><a href="#3-非静态代码块" class="headerlink" title="3.非静态代码块"></a>3.非静态代码块</h4><ol>
<li><p>内部可以有输出语句</p>
</li>
<li><p><strong>随着对象的创建而执行</strong></p>
</li>
<li><p><strong>每创建一个对象，就执行一次非静态代码块</strong></p>
</li>
<li><p>作用：可以在创建对象时，对对象的属性等进行初始化</p>
</li>
<li><p>如果一个类中定义了多个非静态代码块，则按声明的先后顺序执行</p>
</li>
<li><p><strong>非静态代码块内可以调用静态的属性、静态的方法，或非静态的属性、非静态的方法</strong></p>
</li>
<li><p>顺序说明</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span><span class="number">1</span>; <span class="comment">//---------------A</span></span><br><span class="line">    &#123;<span class="comment">//--------------B</span></span><br><span class="line">    	age =<span class="number">2</span>;</span><br><span class="line">    &#125;<span class="comment">//这两个是按先后顺序执行的结果age=2，B 和A</span></span><br><span class="line">    	<span class="comment">//反过来，age=1</span></span><br><span class="line">    &#125;</span><br><span class="line">    	<span class="comment">//static的也一样</span></span><br><span class="line">    <span class="keyword">static</span>  <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">    age  =<span class="number">2</span> ;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h4 id="4-属性可以赋值的位置"><a href="#4-属性可以赋值的位置" class="headerlink" title="4.属性可以赋值的位置"></a>4.属性可以赋值的位置</h4><ol>
<li>默认初始化</li>
<li>显式初始化、代码块初始化</li>
<li>构造器初始化</li>
<li>有了对象以后，通过 “对象 . 属性”或“对象  . 方法” 的方式，进行赋值</li>
</ol>
<p>执行先后顺序也是这个顺序，至于2 . 中，因上述顺序代码说明，他们执行是有先后顺序的，</p>
<h3 id="6-5-关键字：f-inal"><a href="#6-5-关键字：f-inal" class="headerlink" title="6.5 关键字：f inal"></a>6.5 关键字：f inal</h3><h4 id="1-介绍-1"><a href="#1-介绍-1" class="headerlink" title="1.介绍"></a>1.介绍</h4><p>译为：最终的             在这表：最终的形态</p>
<p>final 可以用来修饰的结构：类、方法、变量</p>
<h4 id="2-修饰一个类："><a href="#2-修饰一个类：" class="headerlink" title="2.修饰一个类："></a>2.修饰一个类：</h4><p>此类不能被其他类所继承</p>
<p>后面没有子类了，没有儿子了</p>
<p>比如：String类、System类、StringBuffer类</p>
<h4 id="3-修饰方法："><a href="#3-修饰方法：" class="headerlink" title="3.修饰方法："></a>3.修饰方法：</h4><p>表明此方法不可以被重写了（也是最终的形态了）</p>
<p>比如：Object类中getClass() ;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="keyword">static</span>  <span class="keyword">void</span>  <span class="title function_">eat</span> <span class="params">()</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-修饰变量："><a href="#4-修饰变量：" class="headerlink" title="4.修饰变量："></a>4.修饰变量：</h4><p>此时的“变量” 就称为是一个常量。(最终的形态，数据不能在被修改)</p>
<ol>
<li><p>final修饰属性：</p>
<p>可以考虑赋值的位置有：显式初始化、代码块中的初始化、构造器中的初始化（按优先级排的序，有了显式初始化，代码块就不能在初始化了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式一：</span></span><br><span class="line">    <span class="keyword">final</span>  <span class="type">int</span>  <span class="variable">AGE</span> <span class="operator">=</span> <span class="number">1</span> ;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式二：</span></span><br><span class="line">	<span class="keyword">final</span>  <span class="type">int</span>  GG;</span><br><span class="line">	&#123;</span><br><span class="line">		GG=<span class="number">3</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式三：</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Person</span>&#123;       </span><br><span class="line">	<span class="keyword">final</span> <span class="type">int</span> <span class="variable">AGE</span> <span class="operator">=</span><span class="number">1</span>;</span><br><span class="line">	<span class="keyword">final</span> <span class="type">int</span> AA;</span><br><span class="line">        </span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span>&#123;</span><br><span class="line">		AA =<span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>final 修饰局部变量：</p>
<p>尤其是使用final 修饰形参时，表明此形参是一个常量。当我们调用此方法时，给常量形参赋一个实参，一旦赋值以后，就只能在方法体内使用此形参，但不能进行赋值或修改该值了</p>
</li>
</ol>
<h4 id="5-全局变量"><a href="#5-全局变量" class="headerlink" title="5.全局变量"></a>5.全局变量</h4><p>全局变量（成员变量）：包含类属性和实例属性</p>
<p>static final  用来修饰属性：全局变量</p>
<h3 id="6-6关键字：abstract"><a href="#6-6关键字：abstract" class="headerlink" title="6.6关键字：abstract"></a>6.6关键字：abstract</h3><h4 id="1-介绍-2"><a href="#1-介绍-2" class="headerlink" title="1.介绍"></a>1.介绍</h4><p>abstract :  抽象的</p>
<p>abstract 可以用来修饰的结构：类、方法</p>
<p>此类不能实例化（不能new对象）</p>
<h4 id="2-修饰类"><a href="#2-修饰类" class="headerlink" title="2.修饰类"></a>2.修饰类</h4><ol>
<li>此类不能实例化（不能new对象）</li>
<li>抽象类中一定有构造器，便于子类实例化时调用（子类还是要调用父类的构造器）</li>
<li>开发中，都会提供抽象类的子类，让子类对象实例化，完成相关的操作。</li>
<li>abstract  class   类名{  }</li>
</ol>
<h4 id="3-修饰方法-1"><a href="#3-修饰方法-1" class="headerlink" title="3.修饰方法"></a>3.修饰方法</h4><ol>
<li><p>抽象方法只有方法的声明，没有方法体,用分号结尾</p>
<p>比如： public  abstract  void  eat() ;</p>
</li>
<li><p>包含抽象方法的类，一定是一个抽象类。反之，抽象类中不一定有抽象方法</p>
</li>
<li><p>子类要想实例化，需要重写父类中的所有的抽象方法</p>
</li>
<li><p>若子类没有重写父类中的所有的抽象方法，则此子类也是一个抽象类，需要加上abstract进行修饰</p>
</li>
</ol>
<h4 id="4-使用注意点"><a href="#4-使用注意点" class="headerlink" title="4.使用注意点"></a>4.使用注意点</h4><ol>
<li>abstract不能用来修饰：属性、构造器等结构</li>
<li>abstract 不能用来修饰私有方法、静态方法、final 的方法、final 的类</li>
<li>好处：有继承关系，父类为抽象类，且有抽象方法不提供实现，此抽象方法是由于每个子类公有的但是具体方法体不同，所以必须得重写。<strong>提供抽象类，就是为了提醒所有子类用时必须重写抽象方法</strong></li>
</ol>
<h4 id="5-匿名子类的对象"><a href="#5-匿名子类的对象" class="headerlink" title="5.匿名子类的对象"></a>5.匿名子类的对象</h4><ol>
<li><p>一般有类的匿名和不匿名、对象的匿名和不匿名</p>
</li>
<li><p>非匿名类非匿名对象： Person  p &#x3D; new  Student()</p>
</li>
<li><p>非匿名类匿名对象： new  Student()</p>
</li>
<li><p>匿名类非匿名对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假设Person类是一个抽象类 </span></span><br><span class="line"><span class="type">Person</span>  <span class="variable">p</span>  <span class="operator">=</span>  <span class="keyword">new</span>   <span class="title class_">Person</span> () &#123;</span><br><span class="line">  <span class="comment">//这里面，重写抽象类中的所有抽象方法</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">Person</span>  <span class="variable">p</span>  <span class="operator">=</span>  <span class="keyword">new</span>   <span class="title class_">Person</span> () &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span>  <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;吃饭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//此时完成了创建匿名子类非匿名对象</span></span><br><span class="line"><span class="comment">//对象名是知道的p，父类是Person(抽象类)，但是子类的类名不知道。</span></span><br><span class="line"><span class="comment">//假设有一个方法：</span></span><br><span class="line"><span class="keyword">public</span>  <span class="keyword">void</span>  <span class="title function_">method</span><span class="params">(Person  per)</span>&#123;</span><br><span class="line">	per.eat();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//此时调用该方法 method (p) ;</span></span><br><span class="line"><span class="comment">//这里体现了多态，实际执行的是匿名子类中的重写的方法</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>匿名类匿名对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">method(<span class="keyword">new</span>   <span class="title class_">Person</span> () &#123;</span><br><span class="line">  <span class="comment">//这里面，重写抽象类中的所有抽象方法</span></span><br><span class="line">&#125; ) ;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="6-模板方法的设计模式"><a href="#6-模板方法的设计模式" class="headerlink" title="6.模板方法的设计模式"></a>6.模板方法的设计模式</h4><p>多态以及abstract 的应用</p>
<p>抽象类体现的就是一种模板模式的设计，抽象类作为多个子类的通用模板，子类在抽象类的基础上进行扩展、改造，但子类总体上会保留抽象类的行为方式。</p>
<p>解决的问题： </p>
<p> 当功能内部一部分实现是确定的，一部分实现是不确定的。这时可以把不确定的部分暴露出去，让子类去实现。 </p>
<p>换句话说，在软件开发中实现一个算法时，整体步骤很固定、通用，这些步骤已经在父类中写好了。但是某些部分易变，易变部分可以抽象出来，供不同子类实现。这就是一种模板模式</p>
<p>代码举例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Template</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">getTime</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">		code();</span><br><span class="line">		<span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">		System.out.println(<span class="string">&quot;执行时间是：&quot;</span> + (end - start));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">code</span><span class="params">()</span>;   <span class="comment">//抽象方法</span></span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubTemplate</span> <span class="keyword">extends</span> <span class="title class_">Template</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">code</span><span class="params">()</span> &#123;    <span class="comment">//重写抽象方法</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">			System.out.println(i);</span><br><span class="line">		&#125; </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个子类想要想要计算运行时间就只需重写抽象方法即可</p>
<p>还有一种银行举例：抽象类中写有抽象方法和非抽象方法，抽象方法因为子类的此方法体各不相同，所以需要子类重写。</p>
<p>取号  干什么事    排队</p>
<p>取号和排队非抽象方法，干什么事是抽象方法</p>
<p>将这个流程封装为一个方法，当不同子类调用时，输出–干什么事–也不同</p>
<h3 id="6-8-interface-接口"><a href="#6-8-interface-接口" class="headerlink" title="6.8 interface 接口"></a>6.8 interface 接口</h3><h4 id="1-介绍-3"><a href="#1-介绍-3" class="headerlink" title="1.介绍"></a>1.介绍</h4><ol>
<li><p>接口使用interface 来定义</p>
</li>
<li><p>Java中，接口和类是并列的两个结构</p>
</li>
<li><p>不能实例化</p>
</li>
</ol>
<h4 id="2-定义接口"><a href="#2-定义接口" class="headerlink" title="2.定义接口"></a>2.定义接口</h4><p>定义接口中的成员</p>
<ol>
<li><p><strong>JDK 7 及以前，只能定义全局常量和抽象方法</strong><br><strong>全局常量：public  static  final</strong> </p>
<p>全局常量：包含类属性和实例属性</p>
<p><strong>抽象方法：public abstract</strong> </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">AAA</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">static</span>  <span class="keyword">final</span> <span class="type">int</span> <span class="variable">AGE</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">AGE</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">static</span>  <span class="keyword">final</span> <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">    <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();  <span class="comment">//public  static  final在接口中书写时可以省略不写</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;   &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;    &#125;  <span class="comment">//在接口中书写时可以省略不写</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>JDK 8 除了定义全局常量和抽象方法之外，还可以定义静态方法、默认方法（暂时先不考虑）</strong></p>
<p>  接口中不能定义构造器，意味者不能实例化</p>
</li>
</ol>
<h4 id="3-使用方式"><a href="#3-使用方式" class="headerlink" title="3.使用方式"></a>3.使用方式</h4><ol>
<li>Java开发中，接口通过让类去实现（implement）的方式来使用</li>
<li>如果实现类覆盖（重写）了接口中所有抽象方法，则此实现类就可以实例化</li>
<li>如果实现类没有覆盖接口中所有的抽象方法，则此实现类仍为一个抽象类（要么重写所有抽象方法，要么加上abstract）</li>
</ol>
<p>​              格式：假设CC为接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span>  <span class="title class_">AA</span>  <span class="keyword">implements</span> <span class="title class_">CC</span>,EE,DD&#123;   &#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p>接口可以作为声明使用，但不能够new对象(声明在类中和方法形参中)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">USB</span>  <span class="variable">usb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Flash</span>();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">(USB  usb)</span>&#123;</span><br><span class="line">    usb.start();</span><br><span class="line">    usb.stop();</span><br><span class="line">&#125;   <span class="comment">// USB是接口， Flash是实现类  ，方法内调用的实际是实现类重写的方法----类似于子父类关系--体现了多态性</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="4-体现继承性"><a href="#4-体现继承性" class="headerlink" title="4.体现继承性"></a>4.体现继承性</h4><ol>
<li><p>Java类中可以实现多个接口—&gt;弥补了Java单继承性的局限性</p>
</li>
<li><p>格式：        </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span>  <span class="title class_">AA</span> <span class="keyword">extends</span>  <span class="title class_">BB</span> <span class="keyword">implements</span>  <span class="title class_">CC</span>,DD,EE&#123;    &#125; </span><br></pre></td></tr></table></figure>

<p>AA继承了BB ，还实现了很多接口</p>
</li>
<li><p>AA得重写所有实现的接口中的抽象方法</p>
</li>
<li><p>接口与接口之间可以继承，而且还可以多继承</p>
</li>
</ol>
<p>​     </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">AA</span>&#123;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">BB</span>&#123;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">CC</span>  <span class="keyword">extends</span> <span class="title class_">AA</span>,BB&#123;</span><br><span class="line">    <span class="comment">//接口内东西可写可不写</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果有个EE去实现CC，得重写AA，BB，CC中所有的抽象方法</span></span><br></pre></td></tr></table></figure>

<h4 id="5-接口是一种规范"><a href="#5-接口是一种规范" class="headerlink" title="5.接口是一种规范"></a>5.接口是一种规范</h4><p>接口，实际上可以看做一种规范</p>
<p>USB接口全球同一口径、人就要会思考、鸟就会飞、鱼就会游等等</p>
<p>将口径、思考、飞、游，都可作为接口</p>
<h4 id="6-体现多态性"><a href="#6-体现多态性" class="headerlink" title="6.体现多态性"></a>6.体现多态性</h4><ol>
<li><p>接口指定具体使用，体现多态性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">USB</span> &#123;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span>;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span>  <span class="title class_">BB</span>  <span class="keyword">implements</span> <span class="title class_">USB</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;开始工作&quot;</span>)； &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;停止工作&quot;</span>)； &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">USBTest</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[ ]  args)</span>&#123;</span><br><span class="line">        <span class="type">USBTest</span> <span class="variable">com</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">USBTest</span>();</span><br><span class="line">        <span class="type">BB</span>  <span class="variable">bb</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BB</span>();</span><br><span class="line">        com.Computer(bb);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span>  <span class="title function_">Computer</span><span class="params">(USB  usb)</span> &#123;</span><br><span class="line">        usb.start();</span><br><span class="line">        <span class="comment">//调用其他方法进行操作</span></span><br><span class="line">        usb.stop();      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//此时体现多态性</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="7-匿名子类的对象"><a href="#7-匿名子类的对象" class="headerlink" title="7.匿名子类的对象"></a>7.匿名子类的对象</h4><ol>
<li><p>创建了接口的匿名实现类的非匿名对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">USB</span>  <span class="variable">p</span>  <span class="operator">=</span>  <span class="keyword">new</span>   <span class="title class_">USB</span> () &#123;</span><br><span class="line">  <span class="comment">//这里面，重写接口中的抽象方法</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">USB</span>  <span class="variable">p</span>  <span class="operator">=</span>  <span class="keyword">new</span>   <span class="title class_">USB</span> () &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span>  <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;吃饭&quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对象名是知道的p，接口名，但是实现类的类名不知道。</span></span><br><span class="line"><span class="comment">//假设有一个方法：</span></span><br><span class="line"><span class="keyword">public</span>  <span class="keyword">void</span>  <span class="title function_">method</span><span class="params">(USB  per)</span>&#123;</span><br><span class="line">	per.eat();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时调用该方法 method (p) ;<br>这里体现了多态，实际执行的是匿名实现类中的重写的方法</p>
</li>
<li><p>匿名类匿名对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">method( <span class="keyword">new</span>   <span class="title class_">USB</span> () &#123;  <span class="comment">/*这里面，重写接口中的抽象方法*/</span>  &#125; ) ;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="8-接口实例化在说明"><a href="#8-接口实例化在说明" class="headerlink" title="8.接口实例化在说明"></a>8.接口实例化在说明</h4><p>接口到底能不能实例化？</p>
<p>接口不可以实例化，因为它没有构造器（它需要通过实现类进行实例化，不能new</p>
<p>除了，在匿名内部类可以new＋接口&#x3D;实现类，其实是接口的子类，只是名字(类名)和接口一样）类似于抽象类</p>
<h4 id="9-JDK-8新增"><a href="#9-JDK-8新增" class="headerlink" title="9.JDK 8新增"></a>9.JDK 8新增</h4><h5 id="1-介绍-4"><a href="#1-介绍-4" class="headerlink" title="1.介绍"></a>1.介绍</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="keyword">interface</span> <span class="title class_">CompareA</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span>&#123;      方法体    &#125; <span class="comment">//--------静态方法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123; 方法体   &#125;  <span class="comment">//--------默认方法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>  <span class="keyword">void</span>  <span class="title function_">method3</span><span class="params">()</span>&#123;      方法体     &#125;  <span class="comment">//----修饰符都为public可省略</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-使用细节："><a href="#2-使用细节：" class="headerlink" title="2.使用细节："></a>2.使用细节：</h5><ol>
<li><p>接口中定义的静态方法，只能通过接口来调用</p>
<p>CompareA . method1();</p>
</li>
<li><p>通过实现类的对象，可以调用接口中的默认方法。</p>
</li>
<li><p>如果实现类重写了接口中的默认方法，调用时，仍然调用的是重写以后的方法</p>
</li>
<li><p>如果子类（或实现类）继承的父类和实现的接口中声明了同名同参数的方法，那么子类在没有重写此方法的情况下，默认调用的是父类中同名同参数的默认方法——&gt;类优先原则（只针对于方法，属性不考虑，如果父类和接口属性重名就会报错，别重名。）</p>
</li>
<li><p>如果实现类实现的两个接口中存在同名同参数的默认方法，则必须要在实现类中进行重写。</p>
</li>
<li><p>如何咋子类（或实现类）的方法中调用父类、接口中被重写的方法</p>
<ol>
<li><p>调用自已定义的重写的方法：method3();</p>
</li>
<li><p>调用的是父类中声明的：super . method3() ;</p>
</li>
<li><p>调用接口中的默认方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CompareA . <span class="built_in">super</span> . method3() ;</span><br><span class="line"></span><br><span class="line">CompareB . <span class="built_in">super</span> . method3() ;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h3 id="6-9-类的结构–内部类"><a href="#6-9-类的结构–内部类" class="headerlink" title="6.9 类的结构–内部类"></a>6.9 类的结构–内部类</h3><h4 id="1-介绍-5"><a href="#1-介绍-5" class="headerlink" title="1.介绍"></a>1.介绍</h4><ol>
<li>Java中允许将一个类A声明在另一个类B中，则类A结合水内部类，类B称为外部类</li>
<li>内部类的分类：成员内部类（静态、非静态）  VS  局部内部类（方法内、代码块内、构造器内）</li>
</ol>
<h4 id="2-成员内部"><a href="#2-成员内部" class="headerlink" title="2.成员内部"></a>2.成员内部</h4><ol>
<li><p>首先它是作为外部类的成员</p>
<ol>
<li>调用外部类的结构</li>
<li>可以被static 的修饰</li>
<li>可以被4种不同的修饰</li>
</ol>
</li>
<li><p>另外：作为一个类</p>
<ol>
<li>类内可以定义属性、方法、构造器等</li>
<li>可以被final 修饰，表示此类不能被继承。言外之意，不使用final，就可以被继承</li>
<li>可以被abstract 修饰</li>
</ol>
</li>
<li><p>格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">class</span> <span class="title class_">Animal</span>&#123;   </span><br><span class="line">   </span><br><span class="line">        <span class="keyword">class</span>  <span class="title class_">Dog</span>&#123;    </span><br><span class="line">   			<span class="keyword">public</span>  <span class="title function_">Dog</span><span class="params">()</span>&#123;   &#125;		</span><br><span class="line">			<span class="keyword">public</span> <span class="keyword">void</span>  <span class="title function_">display</span><span class="params">( String  name )</span>&#123;   &#125; </span><br><span class="line">   				&#125;	</span><br><span class="line">   </span><br><span class="line">   	<span class="keyword">public</span>  <span class="keyword">static</span>  <span class="keyword">class</span>  <span class="title class_">Bird</span>&#123;       &#125;	</span><br><span class="line">	<span class="keyword">public</span>   <span class="keyword">final</span> <span class="keyword">class</span>  <span class="title class_">Cat</span>&#123;       &#125;	</span><br><span class="line">   	<span class="keyword">public</span>   <span class="keyword">abstract</span> <span class="keyword">class</span>  <span class="title class_">Cat</span>&#123;       &#125;	</span><br><span class="line">   </span><br><span class="line">   &#125;	</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### <span class="number">3.</span>关注如下的<span class="number">3</span>个问题</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 如何实例化成员内部类的对象</span><br><span class="line"></span><br><span class="line">   ```java</span><br><span class="line">   <span class="comment">//创建Dog实例（静态的成员内部类）</span></span><br><span class="line">   Person . <span class="type">Dog</span>  <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span> . Dog() ;</span><br><span class="line">   dog . show() ;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//创建Bird实例（非静态的实例成员内部类）</span></span><br><span class="line">   <span class="type">Person</span>  <span class="variable">p</span>  <span class="operator">=</span>   <span class="keyword">new</span>   <span class="title class_">Person</span>() ;</span><br><span class="line">   Person . <span class="type">Bird</span>  <span class="variable">bird</span> <span class="operator">=</span>  p . <span class="keyword">new</span> . Bird() ;</span><br><span class="line">   bird . sing();</span><br></pre></td></tr></table></figure>


</li>
<li><p>如何在成员内部类中区分调用外部类的结构</p>
<p>调用属性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">class</span> <span class="title class_">Animal</span>&#123;    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;动物&quot;</span> ;</span><br><span class="line">   </span><br><span class="line">           <span class="keyword">class</span>  <span class="title class_">Dog</span>&#123;    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;狗&quot;</span> ;</span><br><span class="line">   				<span class="keyword">public</span> <span class="keyword">void</span>  <span class="title function_">display</span><span class="params">( String  name )</span>&#123;</span><br><span class="line">   </span><br><span class="line">   					System.out.println(name);  <span class="comment">//形参</span></span><br><span class="line">   					System.out.println(<span class="built_in">this</span> . name);  <span class="comment">//内部类的</span></span><br><span class="line">   					System.out.println(Person . <span class="built_in">this</span> . name);  <span class="comment">//外部类的</span></span><br><span class="line">   				&#125;</span><br><span class="line"></span><br><span class="line">   调用内部类和外部类方法也是如此，不重名时，可省略</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> 开发中局部内部类的使用---匿名</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line"><span class="comment">//返回一个实现了Comparable 接口的类的对象</span></span><br><span class="line"><span class="keyword">public</span> Comparable  <span class="title function_">getComparable</span><span class="params">( )</span> &#123;</span><br><span class="line">		<span class="comment">//方式一：创建一个实现了Comparable接口的类：局部内部类</span></span><br><span class="line">		<span class="keyword">class</span> <span class="title class_">MyComparable</span> implement Comparable &#123;</span><br><span class="line">			<span class="comment">//重写接口抽象方法</span></span><br><span class="line">			<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Object  o )</span>&#123;   方法体  &#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span>  <span class="keyword">new</span> <span class="title class_">MyComparable</span> ;</span><br><span class="line">    </span><br><span class="line">		<span class="comment">//方式二：	</span></span><br><span class="line">    	<span class="keyword">return</span>  <span class="keyword">new</span> <span class="title class_">Comparable</span>( ) &#123;</span><br><span class="line">			<span class="keyword">public</span>  <span class="type">int</span>  <span class="title function_">compareTo</span><span class="params">(Object  o )</span>&#123;   方法体  &#125;</span><br><span class="line">		&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<p>方式一：有类名，没有对象名</p>
<p>方式二：没有类名，没有对象名</p>
</blockquote>
<h2 id="7-异常处理"><a href="#7-异常处理" class="headerlink" title="7. 异常处理"></a>7. 异常处理</h2><h3 id="1-异常"><a href="#1-异常" class="headerlink" title="1.异常"></a>1.异常</h3><h4 id="1-异常的体系结构"><a href="#1-异常的体系结构" class="headerlink" title="1.异常的体系结构"></a>1.异常的体系结构</h4><ul>
<li><p>java.lang.Throwable</p>
<ul>
<li>java.lang.Error:一般不编写针对性的代码进行处理。<br>* java.lang.Exception:可以进行异常的处理</li>
</ul>
<pre><code>* **编译时异常**(checked)

   * 	IOException
      * 	FileNotFoundException
         * ClassNotFoundException

          * **运行时异常**(unchecked,RuntimeException)
          * NullPointerException
          * ArrayIndexOutOfBoundsException
           * ClassCastException
           * NumberFormatException
           * InputMismatchException
           * ArithmeticException
</code></pre>
</li>
</ul>
<h4 id="2-从程序执行过程"><a href="#2-从程序执行过程" class="headerlink" title="2.从程序执行过程"></a>2.从程序执行过程</h4><p>看编译时异常和运行时异常</p>
<p>编译时异常：执行javac.exe命名时，可能出现的异常<br>运行时异常：执行java.exe命名时，出现的异常</p>
<h4 id="3-常见的异常类型"><a href="#3-常见的异常类型" class="headerlink" title="3.常见的异常类型"></a>3.常见的异常类型</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">                 <span class="comment">//******************以下是运行时异常***************************</span></span><br><span class="line"><span class="comment">//ArithmeticException</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test6</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	System.out.println(a / b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//InputMismatchException</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test5</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">	<span class="type">int</span> <span class="variable">score</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">	System.out.println(score);</span><br><span class="line">	</span><br><span class="line">	scanner.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//NumberFormatException</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;123&quot;</span>;</span><br><span class="line">	str = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">	<span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> Integer.parseInt(str);	</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ClassCastException</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">	<span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> (String)obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//IndexOutOfBoundsException</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="comment">//ArrayIndexOutOfBoundsException</span></span><br><span class="line">	<span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">	System.out.println(arr[<span class="number">10</span>]);</span><br><span class="line">	<span class="comment">//StringIndexOutOfBoundsException</span></span><br><span class="line">	<span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">	System.out.println(str.charAt(<span class="number">3</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//NullPointerException</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span>[] arr = <span class="literal">null</span>;</span><br><span class="line">	System.out.println(arr[<span class="number">3</span>]);</span><br><span class="line">	</span><br><span class="line">	<span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">	str = <span class="literal">null</span>;</span><br><span class="line">	System.out.println(str.charAt(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">//******************以下是编译时异常***************************</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test7</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line">	<span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> fis.read();</span><br><span class="line">	<span class="keyword">while</span>(data != -<span class="number">1</span>)&#123;</span><br><span class="line">		System.out.print((<span class="type">char</span>)data);</span><br><span class="line">		data = fis.read();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	fis.close();</span><br><span class="line">	</span><br><span class="line">&#125;                       </span><br></pre></td></tr></table></figure>



<h3 id="2-异常处理"><a href="#2-异常处理" class="headerlink" title="2.异常处理"></a>2.异常处理</h3><h4 id="1-java异常处理的抓抛模型"><a href="#1-java异常处理的抓抛模型" class="headerlink" title="1.java异常处理的抓抛模型"></a>1.java异常处理的抓抛模型</h4><p>过程一：”抛”：程序在正常执行的过程中，一旦出现异常，就会在异常代码处生成一个对应异常类的对象。</p>
<ol>
<li>并将此对象抛出。</li>
<li>一旦抛出对象以后，其后的代码就不再执行。</li>
</ol>
<p>关于异常对象的产生：</p>
<p>① 系统自动生成的异常对象</p>
<p>② 手动的生成一个异常对象，并抛出（<strong>throw</strong>）</p>
<p>过程二：”抓”：可以理解为异常的处理方式：</p>
<p>① try-catch-finally  </p>
<p>② throws</p>
<h4 id="2-异常处理方式一"><a href="#2-异常处理方式一" class="headerlink" title="2.异常处理方式一"></a>2.异常处理方式一</h4><p><strong>try-catch-finally</strong></p>
<h5 id="1-使用说明："><a href="#1-使用说明：" class="headerlink" title="1. 使用说明："></a>1. 使用说明：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line">	 <span class="comment">//可能出现异常的代码</span></span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">1</span> 变量名<span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//处理异常的方式1</span></span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">2</span> 变量名<span class="number">2</span>)&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//处理异常的方式2</span></span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">3</span> 变量名<span class="number">3</span>)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理异常的方式3</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">	....</span><br><span class="line"></span><br><span class="line"><span class="keyword">finally</span>&#123;</span><br><span class="line">	<span class="comment">//一定会执行的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  <strong>代码演示：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="keyword">try</span>&#123;</span><br><span class="line">		<span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line">		<span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line">		</span><br><span class="line">		<span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> fis.read();</span><br><span class="line">		<span class="keyword">while</span>(data != -<span class="number">1</span>)&#123;</span><br><span class="line">			System.out.print((<span class="type">char</span>)data);</span><br><span class="line">			data = fis.read();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		fis.close();</span><br><span class="line">	&#125;<span class="keyword">catch</span>(FileNotFoundException e)&#123;</span><br><span class="line">		e.printStackTrace(); <span class="comment">//输出异常</span></span><br><span class="line">	&#125;<span class="keyword">catch</span>(IOException e)&#123;   <span class="comment">//子类在它上面</span></span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-说明及解释"><a href="#2-说明及解释" class="headerlink" title="2.说明及解释"></a>2.说明及解释</h5><p><strong>finally是可选的</strong>，可有，可没有。</p>
<ol>
<li>使用try将可能出现异常代码包装起来，在执行过程中，一旦出现异常，就会生成一个对应异常类的对象，根据此对象的类型，去catch中进行匹配</li>
<li><strong>一旦try中的异常对象匹配到某一个catch时，就进入catch中进行异常的处理。一旦处理完成，就跳出当前的try-catch结构（在没写finally的情况。继续执行其后的代码）</strong></li>
<li>catch中的异常类型如果没子父类关系，则谁声明在上，谁声明在下无所谓。</li>
<li>catch中的异常类型如果满足子父类关系，则要求子类一定声明在父类的上面。否则，报错</li>
<li><strong>常用的异常对象处理的方式： ① String  getMessage()    ② printStackTrace()</strong></li>
<li>在try结构中声明的变量，再出了try结构以后，就不能再被调用</li>
<li><strong>try-catch-finally结构可以嵌套</strong></li>
</ol>
<p>​    <strong>代码演示</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testMethod</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> method();</span><br><span class="line">	System.out.println(num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">try</span>&#123;</span><br><span class="line">		<span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">		System.out.println(arr[<span class="number">10</span>]);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>; <span class="comment">//如果没异常，在执行这之前会执行finally</span></span><br><span class="line">	&#125;<span class="keyword">catch</span>(ArrayIndexOutOfBoundsException e)&#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">		<span class="keyword">return</span> <span class="number">2</span>;  <span class="comment">//在执行这之前会执行finally</span></span><br><span class="line">	&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;我一定会被执行&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">3</span>;  <span class="comment">//到这直接退出了</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-小结："><a href="#3-小结：" class="headerlink" title="3.小结："></a>3.小结：</h4><h5 id="1-如何看待代码中的编译时异常和运行时异常？"><a href="#1-如何看待代码中的编译时异常和运行时异常？" class="headerlink" title="1.如何看待代码中的编译时异常和运行时异常？"></a>1.如何看待代码中的编译时异常和运行时异常？</h5><p>体会1：使用try-catch-finally处理编译时异常，是得程序在编译时就不再报错，但是运行时仍可能报错。相当于我们使用try-catch-finally将一个编译时可能出现的异常，延迟到运行时出现。</p>
<p>体会2：开发中，由于运行时异常比较常见，所以我们通常就不针对运行时异常编写try-catch-finally了。针对于编译时异常，我们说一定要考虑异常的处理。</p>
<h5 id="2-finally的再说明："><a href="#2-finally的再说明：" class="headerlink" title="2.finally的再说明："></a>2.finally的再说明：</h5><p>1.finally是可选的</p>
<p>2.<strong>finally中声明的是一定会被执行的代码。即使catch中又出现异常了，try中return语句，catch中return语句等情况。</strong></p>
<p>3.像数据库连接、输入输出流、网络编程Socket等资源，JVM是不能自动的回收的，我们需要自己手动的进行资源的释放。此时的资源释放，就需要声明在finally中。</p>
<h4 id="4-面试题"><a href="#4-面试题" class="headerlink" title="4.面试题"></a>4.面试题</h4><p>final、finally、finalize三者的区别？</p>
<p>类似：<br>throw 和 throws<br>Collection 和 Collections<br>String 、StringBuffer、StringBuilder<br>ArrayList 、 LinkedList<br>HashMap 、LinkedHashMap<br>重写、重载</p>
<p>结构不相似的：<br>抽象类、接口<br>&#x3D;&#x3D; 、 equals()<br>sleep()、wait()</p>
<h4 id="5-异常处理方式二"><a href="#5-异常处理方式二" class="headerlink" title="5.异常处理方式二"></a>5.异常处理方式二</h4><ol>
<li>“throws + 异常类型”写在方法的声明处。指明此方法执行时，可能会抛出的异常类型。</li>
<li>一旦当方法体执行时，出现异常，仍会在异常代码处生成一个异常类的对象，此对象满足throws后异常类型时，就会被抛出。异常代码后续的代码，就不再执行！</li>
</ol>
<p><strong>代码演示：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionTest2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            method2();  <span class="comment">//抛出异常,用try-catch-finally解决</span></span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//		method3();//解决后在调用也不报错</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method3</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            method2(); <span class="comment">//抛出异常,用try-catch-finally解决</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> <span class="keyword">throws</span> IOException&#123;<span class="comment">//抛出异常</span></span><br><span class="line">        method1(); <span class="comment">//method1抛出异常,如果在method2不解决可以在向上抛出</span></span><br><span class="line">                    <span class="comment">//，直到被解决才不报错</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException,IOException&#123;  <span class="comment">//可能会抛出的异常类型，抛出                                      //异常</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;hello1.txt&quot;</span>);</span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> fis.read();</span><br><span class="line">        <span class="keyword">while</span>(data != -<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.print((<span class="type">char</span>)data);</span><br><span class="line">            data = fis.read();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fis.close();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;hahaha!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="6-对比两种处理方式"><a href="#6-对比两种处理方式" class="headerlink" title="6.对比两种处理方式"></a><strong>6</strong>.对比两种处理方式</h4><ol>
<li>try-catch-finally:真正的将异常给处理掉了。</li>
<li>throws的方式只是将异常抛给了方法的调用者。并没真正将异常处理掉。</li>
</ol>
<h4 id="7-开发中如何选择两种处理方式？"><a href="#7-开发中如何选择两种处理方式？" class="headerlink" title="7.开发中如何选择两种处理方式？"></a>7.开发中如何选择两种处理方式？</h4><ol>
<li>如果父类中被重写的方法没throws方式处理异常，则子类重写的方法也不能使用throws，意味着如果子类重写的方法中异常，必须使用try-catch-finally方式处理。</li>
<li>执行的方法a中，先后又调用了另外的几个方法，这几个方法是递进关系执行的。我们建议这几个方法使用throws的方式进行处理。而执行的方法a可以考虑使用try-catch-finally方式进行处理。（也就是都向上抛调用上抛，最后都在一个方法内统一处理）</li>
</ol>
<h4 id="8-补充"><a href="#8-补充" class="headerlink" title="8.补充"></a>8.补充</h4><p>方法重写的规则之一：<br>子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型</p>
<h3 id="3-手动抛出异常对象"><a href="#3-手动抛出异常对象" class="headerlink" title="3.手动抛出异常对象"></a>3.手动抛出异常对象</h3><h4 id="1-使用说明-1"><a href="#1-使用说明-1" class="headerlink" title="1.使用说明"></a>1.使用说明</h4><p>在程序执行中，除了自动抛出异常对象的情况之外，我们还可以手动的throw一个异常类的对象。</p>
<h4 id="2-面试题"><a href="#2-面试题" class="headerlink" title="2.面试题"></a>2.面试题</h4><p>throw 和  throws区别：</p>
<ol>
<li>throw 表示抛出一个异常类的对象，生成异常对象的过程。声明在方法体内。</li>
<li>throws 属于异常处理的一种方式，声明在方法的声明处。</li>
</ol>
<h4 id="3-典型例题"><a href="#3-典型例题" class="headerlink" title="3.典型例题"></a>3.典型例题</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentTest</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">			s.regist(-<span class="number">1001</span>);</span><br><span class="line">			System.out.println(s);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="comment">//			e.printStackTrace();</span></span><br><span class="line">			System.out.println(e.getMessage());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">regist</span><span class="params">(<span class="type">int</span> id)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">	<span class="keyword">if</span>(id &gt; <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">this</span>.id = id;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="comment">//手动抛出异常对象</span></span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;您输入的数据非法！&quot;</span>);</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;您输入的数据非法！&quot;</span>);</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MyException</span>(<span class="string">&quot;不能输入负数&quot;</span>);</span><br><span class="line">		<span class="comment">//这些提示文字最后可以通过getMassage()获取并输出</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;Student [id=&quot;</span> + id + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-自定义异常类"><a href="#4-自定义异常类" class="headerlink" title="4.自定义异常类"></a>4.自定义异常类</h3><h4 id="1-如何自定义异常类？"><a href="#1-如何自定义异常类？" class="headerlink" title="1.如何自定义异常类？"></a>1.如何自定义异常类？</h4><ol>
<li>继承于现的异常结构：RuntimeException 、Exception</li>
<li>提供全局常量：serialVersionUID（相当于一个编号，可以自己写）</li>
<li>提供重载的构造器</li>
</ol>
<h4 id="2-代码演示"><a href="#2-代码演示" class="headerlink" title="2.代码演示"></a>2.代码演示</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">7034897193246939L</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyException</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyException</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Qinghai2021</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2022/09/28/%E5%B0%9A%E7%A1%85%E8%B0%B7java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/">http://example.com/2022/09/28/%E5%B0%9A%E7%A1%85%E8%B0%B7java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">Qinghai2021·博客</a>！</span></div></div><div class="tag_share"><div class="post_share"><div class="social-share" data-image="/images/background.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://fastly.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2022/09/27/java%E8%80%83%E8%AF%95/"><img class="next-cover" src="/images/background.jpg" onerror="onerror=null;src='https://api.ixiaowai.cn/gqapi/gqapi.php'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Java考试</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E5%8F%8A%E5%B7%A5%E5%85%B7"><span class="toc-number">1.</span> <span class="toc-text">项目及工具</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-eclipse"><span class="toc-number">1.1.</span> <span class="toc-text">1.eclipse</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-eclipse-1"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.eclipse</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-eclipse%E5%BF%AB%E6%8D%B7%E9%94%AE"><span class="toc-number">1.1.2.</span> <span class="toc-text">2.eclipse快捷键</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Debug-%E8%B0%83%E8%AF%95"><span class="toc-number">1.1.3.</span> <span class="toc-text">3.Debug  调试</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E9%A1%B9%E7%9B%AE%E8%A6%81%E6%B1%82"><span class="toc-number">1.2.</span> <span class="toc-text">2.项目要求</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%AE%A2%E6%88%B7%E4%BF%A1%E6%81%AF%E7%AE%A1%E7%90%86%E8%BD%AF%E4%BB%B6"><span class="toc-number">1.3.</span> <span class="toc-text">3.客户信息管理软件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%88%86%E4%B8%BA%E4%B8%89%E5%A4%A7%E7%B1%BB"><span class="toc-number">1.3.1.</span> <span class="toc-text">1.分为三大类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Customer%E7%B1%BB%E7%9A%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.3.2.</span> <span class="toc-text">2.Customer类的设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-CustomerList%E7%B1%BB%E7%9A%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.3.3.</span> <span class="toc-text">3.CustomerList类的设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-CustomerView%E7%B1%BB%E7%9A%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.3.4.</span> <span class="toc-text">4.CustomerView类的设计</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E9%94%99%E9%A2%98%E4%BA%8B%E4%BB%B6"><span class="toc-number">1.4.</span> <span class="toc-text">4.错题事件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%B8%89%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.4.1.</span> <span class="toc-text">1.三元运算符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A"><span class="toc-number">1.5.</span> <span class="toc-text">5.面试题：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%A4%9A%E6%80%81%E6%80%A7"><span class="toc-number">1.5.0.1.</span> <span class="toc-text">1.多态性</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80"><span class="toc-number">2.</span> <span class="toc-text">Java编程基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-java%E6%A6%82%E8%BF%B0"><span class="toc-number">2.1.</span> <span class="toc-text">1.java概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-Java%E9%80%9A%E8%AF%86%E4%BB%8B%E7%BB%8D"><span class="toc-number">2.1.1.</span> <span class="toc-text">1.1 Java通识介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2%E5%B8%B8%E7%94%A8%E7%9A%84DOS%E5%91%BD%E4%BB%A4"><span class="toc-number">2.1.2.</span> <span class="toc-text">1.2常用的DOS命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E7%BC%96%E5%86%99HelloWorld"><span class="toc-number">2.1.3.</span> <span class="toc-text">1.3 编写HelloWorld</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-%E6%B3%A8%E9%87%8A%EF%BC%88comment%EF%BC%89"><span class="toc-number">2.1.4.</span> <span class="toc-text">1.4 注释（comment）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95"><span class="toc-number">2.2.</span> <span class="toc-text">2.java基础语法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1%E5%85%B3%E9%94%AE%E5%AD%97%E4%B8%8E%E4%BF%9D%E7%95%99%E5%AD%97"><span class="toc-number">2.2.1.</span> <span class="toc-text">2.1关键字与保留字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E6%A0%87%E8%AF%86%E7%AC%A6"><span class="toc-number">2.2.2.</span> <span class="toc-text">2.2 标识符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3%E5%8F%98%E9%87%8F"><span class="toc-number">2.2.3.</span> <span class="toc-text">2.3变量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%8F%98%E9%87%8F%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">2.2.3.1.</span> <span class="toc-text">1.变量的概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BD%BF%E7%94%A8%E5%8F%98%E9%87%8F%E6%B3%A8%E6%84%8F%EF%BC%9A"><span class="toc-number">2.2.3.2.</span> <span class="toc-text">2.使用变量注意：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.2.3.3.</span> <span class="toc-text">3.基本数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E6%95%B4%E5%9E%8B%EF%BC%9A"><span class="toc-number">2.2.3.3.1.</span> <span class="toc-text">1.整型：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E6%B5%AE%E7%82%B9%E5%9E%8B%EF%BC%9A"><span class="toc-number">2.2.3.3.2.</span> <span class="toc-text">2. 浮点型：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E5%AD%97%E7%AC%A6%E5%9E%8B%EF%BC%9A"><span class="toc-number">2.2.3.3.3.</span> <span class="toc-text">3.字符型：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E5%B8%83%E5%B0%94%E5%9E%8B%EF%BC%9A"><span class="toc-number">2.2.3.3.4.</span> <span class="toc-text">4.布尔型：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.2.3.4.</span> <span class="toc-text">4.引用数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E7%B1%BB%EF%BC%9Aclass"><span class="toc-number">2.2.3.4.1.</span> <span class="toc-text">1.类：class</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E6%8E%A5%E5%8F%A3%EF%BC%9Ainterface"><span class="toc-number">2.2.3.4.2.</span> <span class="toc-text">2.接口：interface</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E6%95%B0%E7%BB%84%EF%BC%9Aarray"><span class="toc-number">2.2.3.4.3.</span> <span class="toc-text">3.数组：array</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-String%E7%B1%BB%E5%9E%8B%E5%8F%98%E9%87%8F"><span class="toc-number">2.2.3.4.4.</span> <span class="toc-text">4.String类型变量</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2"><span class="toc-number">2.2.4.</span> <span class="toc-text">2.4进制转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">2.2.5.</span> <span class="toc-text">2.5 运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">2.2.5.1.</span> <span class="toc-text">1.算术运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">2.2.5.2.</span> <span class="toc-text">2.赋值运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%88%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%89"><span class="toc-number">2.2.5.3.</span> <span class="toc-text">3.比较运算符（关系运算符）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">2.2.5.4.</span> <span class="toc-text">4.逻辑运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E4%B8%89%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">2.2.5.5.</span> <span class="toc-text">5.三元运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">2.2.5.6.</span> <span class="toc-text">6.位运算符</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-number">2.2.6.</span> <span class="toc-text">2.6 程序流程控制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-if%E2%80%93else"><span class="toc-number">2.2.6.1.</span> <span class="toc-text">1.if–else</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-java%E4%B8%AD%E7%9A%84%E8%BE%93%E5%85%A5%EF%BC%8C%E9%9C%80%E8%A6%81%E4%BD%BF%E7%94%A8Scanner%E7%B1%BB"><span class="toc-number">2.2.6.2.</span> <span class="toc-text">2.java中的输入，需要使用Scanner类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-switch-%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">2.2.6.3.</span> <span class="toc-text">3.switch(表达式){</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-for-%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5"><span class="toc-number">2.2.6.4.</span> <span class="toc-text">4.for 循环语句</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-while%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5"><span class="toc-number">2.2.6.5.</span> <span class="toc-text">5.while循环语句</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-do-%E2%80%93while%E5%BE%AA%E7%8E%AF"><span class="toc-number">2.2.6.6.</span> <span class="toc-text">6.do –while循环</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7%E6%AD%A4%E8%8A%82%E7%9A%84%E4%B8%80%E4%BA%9B%E9%9B%B6%E7%A2%8E%E8%A6%81%E7%82%B9"><span class="toc-number">2.2.7.</span> <span class="toc-text">2.7此节的一些零碎要点</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E8%AE%A1%E7%AE%97%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E6%97%B6%E9%97%B4"><span class="toc-number">2.2.7.0.1.</span> <span class="toc-text">1.计算程序运行时间</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-Math-sqrt-i"><span class="toc-number">2.2.7.0.2.</span> <span class="toc-text">2.Math.sqrt(i);</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%9Areturn"><span class="toc-number">2.2.7.0.3.</span> <span class="toc-text">3.关键字：return</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%9Abreak%E5%92%8Ccontinue"><span class="toc-number">2.2.7.0.4.</span> <span class="toc-text">4.关键字：break和continue</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-Math-random-%E4%BA%A7%E7%94%9F%E9%9A%8F%E6%9C%BA%E6%95%B0"><span class="toc-number">2.2.7.0.5.</span> <span class="toc-text">5.Math.random()产生随机数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-%E8%A1%A5%E5%85%85%EF%BC%9A%E8%A1%A1%E9%87%8F%E4%B8%80%E4%B8%AA%E5%8A%9F%E8%83%BD%E4%BB%A3%E7%A0%81%E7%9A%84%E4%BC%98%E5%8A%A3"><span class="toc-number">2.2.7.0.6.</span> <span class="toc-text">6.补充：衡量一个功能代码的优劣</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%95%B0%E7%BB%84"><span class="toc-number">2.3.</span> <span class="toc-text">3.数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1%E6%95%B0%E7%BB%84%E7%9A%84%E6%A6%82%E8%BF%B0"><span class="toc-number">2.3.1.</span> <span class="toc-text">3.1数组的概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%95%B0%E7%BB%84%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9A"><span class="toc-number">2.3.1.1.</span> <span class="toc-text">1. 数组的理解：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%95%B0%E7%BB%84%E7%9A%84%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5%EF%BC%9A"><span class="toc-number">2.3.1.2.</span> <span class="toc-text">2.数组的相关概念：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%95%B0%E7%BB%84%E7%9A%84%E7%89%B9%E7%82%B9%EF%BC%9A"><span class="toc-number">2.3.1.3.</span> <span class="toc-text">3.数组的特点：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E6%95%B0%E7%BB%84%E7%9A%84%E5%88%86%E7%B1%BB%EF%BC%9A"><span class="toc-number">2.3.1.4.</span> <span class="toc-text">4.数组的分类：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">2.3.2.</span> <span class="toc-text">3.2一维数组的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%A3%B0%E6%98%8E%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">2.3.2.1.</span> <span class="toc-text">1.一维数组的声明和初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%A6%82%E4%BD%95%E8%B0%83%E7%94%A8%E6%95%B0%E7%BB%84%E7%9A%84%E6%8C%87%E5%AE%9A%E4%BD%8D%E7%BD%AE%E7%9A%84%E5%85%83%E7%B4%A0"><span class="toc-number">2.3.2.2.</span> <span class="toc-text">2.如何调用数组的指定位置的元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E6%95%B0%E7%BB%84%E7%9A%84%E9%95%BF%E5%BA%A6"><span class="toc-number">2.3.2.3.</span> <span class="toc-text">3.如何获取数组的长度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%A6%82%E4%BD%95%E9%81%8D%E5%8E%86%E6%95%B0%E7%BB%84"><span class="toc-number">2.3.2.4.</span> <span class="toc-text">4.如何遍历数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%9A%84%E9%BB%98%E8%AE%A4%E5%88%9D%E5%A7%8B%E5%8C%96%E5%80%BC"><span class="toc-number">2.3.2.5.</span> <span class="toc-text">5.数组元素的默认初始化值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E6%95%B0%E7%BB%84%E7%9A%84%E5%86%85%E5%AD%98%E8%A7%A3%E6%9E%90"><span class="toc-number">2.3.2.6.</span> <span class="toc-text">6.数组的内存解析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%9A"><span class="toc-number">2.3.3.</span> <span class="toc-text">3.3二维数组的使用：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%90%86%E8%A7%A3%EF%BC%9A"><span class="toc-number">2.3.3.1.</span> <span class="toc-text">1.理解：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%A3%B0%E6%98%8E%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">2.3.3.2.</span> <span class="toc-text">2.二维数组的声明和初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%A6%82%E4%BD%95%E8%B0%83%E7%94%A8%E6%95%B0%E7%BB%84%E7%9A%84%E6%8C%87%E5%AE%9A%E4%BD%8D%E7%BD%AE%E7%9A%84%E5%85%83%E7%B4%A0"><span class="toc-number">2.3.3.3.</span> <span class="toc-text">3.如何调用数组的指定位置的元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E6%95%B0%E7%BB%84%E7%9A%84%E9%95%BF%E5%BA%A6"><span class="toc-number">2.3.3.4.</span> <span class="toc-text">4.如何获取数组的长度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E5%A6%82%E4%BD%95%E9%81%8D%E5%8E%86%E6%95%B0%E7%BB%84"><span class="toc-number">2.3.3.5.</span> <span class="toc-text">5.如何遍历数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%9A%84%E9%BB%98%E8%AE%A4%E5%88%9D%E5%A7%8B%E5%8C%96%E5%80%BC"><span class="toc-number">2.3.3.6.</span> <span class="toc-text">6.数组元素的默认初始化值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E6%95%B0%E7%BB%84%E7%9A%84%E5%86%85%E5%AD%98%E8%A7%A3%E6%9E%90"><span class="toc-number">2.3.3.7.</span> <span class="toc-text">7.数组的内存解析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E6%95%B0%E7%BB%84%E4%B8%AD%E6%B6%89%E5%8F%8A%E5%88%B0%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95"><span class="toc-number">2.3.4.</span> <span class="toc-text">3.4 数组中涉及到常见算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%9A%84%E8%B5%8B%E5%80%BC"><span class="toc-number">2.3.4.1.</span> <span class="toc-text">1.数组元素的赋值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%B1%82%E6%95%B0%E7%BB%84%E4%B8%AD%E5%85%83%E7%B4%A0%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC%E3%80%81%E6%9C%80%E5%B0%8F%E5%80%BC%E3%80%81%E5%B9%B3%E5%9D%87%E6%95%B0%E3%80%81%E6%80%BB%E5%92%8C"><span class="toc-number">2.3.4.2.</span> <span class="toc-text">2.求数组中元素的最大值、最小值、平均数、总和</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%95%B0%E7%BB%84%E7%9A%84%E5%A4%8D%E5%88%B6%E3%80%81%E5%8F%8D%E8%BD%AC%E3%80%81%E6%9F%A5%E6%89%BE%EF%BC%88%E7%BA%BF%E6%80%A7%E6%9F%A5%E6%89%BE%E3%80%81%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%EF%BC%89"><span class="toc-number">2.3.4.3.</span> <span class="toc-text">3.数组的复制、反转、查找（线性查找、二分查找）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="toc-number">2.3.4.4.</span> <span class="toc-text">4.数组元素的排序算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5%E9%9B%B6%E7%A2%8E%E7%9F%A5%E8%AF%86%EF%BC%9A"><span class="toc-number">2.3.5.</span> <span class="toc-text">3.5零碎知识：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E5%88%86%E7%B1%BB%EF%BC%9A"><span class="toc-number">2.3.5.1.</span> <span class="toc-text">1.排序算法的分类：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%AE%97%E6%B3%95%E7%9A%845%E5%A4%A7%E7%89%B9%E5%BE%81"><span class="toc-number">2.3.5.2.</span> <span class="toc-text">2.算法的5大特征</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">2.3.5.3.</span> <span class="toc-text">3.数据结构:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%B0%8F%E4%B9%A0%E9%A2%98%EF%BC%9A"><span class="toc-number">2.3.5.4.</span> <span class="toc-text">4.小习题：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5Arrays%E5%B7%A5%E5%85%B7%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">2.3.6.</span> <span class="toc-text">3.5Arrays工具类的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6%E6%95%B0%E7%BB%84%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E5%BC%82%E5%B8%B8"><span class="toc-number">2.3.7.</span> <span class="toc-text">3.6数组中常见的异常</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%8A%EF%BC%89"><span class="toc-number">2.4.</span> <span class="toc-text">4.面向对象（上）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%AD%A6%E4%B9%A0%E4%B8%89%E6%9D%A1%E4%B8%BB%E7%BA%BF%EF%BC%884-6%E7%AB%A0%EF%BC%89"><span class="toc-number">2.4.1.</span> <span class="toc-text">4.1 Java面向对象学习三条主线（4-6章）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E4%B8%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%9A"><span class="toc-number">2.4.2.</span> <span class="toc-text">4.2面向过程与面向对象：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%EF%BC%9A"><span class="toc-number">2.4.2.1.</span> <span class="toc-text">1.面向过程：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%9A"><span class="toc-number">2.4.2.2.</span> <span class="toc-text">2.面向对象：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%80%9D%E6%83%B3%E6%A6%82%E8%BF%B0"><span class="toc-number">2.4.2.3.</span> <span class="toc-text">3.面向对象的思想概述</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.4.3.</span> <span class="toc-text">4.3 类和对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-JVM-%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84"><span class="toc-number">2.4.3.1.</span> <span class="toc-text">1.JVM 内存结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%85%B3%E9%94%AE%E5%AD%97-return%EF%BC%9A"><span class="toc-number">2.4.3.2.</span> <span class="toc-text">2.关键字 return：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-java%E7%B1%BB%E5%8F%8A%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98"><span class="toc-number">2.4.3.3.</span> <span class="toc-text">3.java类及类的成员</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E7%B1%BB%E5%92%8C%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E4%BD%BF%E7%94%A8"><span class="toc-number">2.4.3.4.</span> <span class="toc-text">4.类和类对象的创建和使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E4%BD%BF%E7%94%A8%EF%BC%9A%E5%86%85%E5%AD%98%E8%A7%A3%E6%9E%90"><span class="toc-number">2.4.3.5.</span> <span class="toc-text">5.对象的创建和使用：内存解析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4%E7%B1%BB%E7%9A%84%E7%BB%93%E6%9E%84%E2%80%93%E5%B1%9E%E6%80%A7"><span class="toc-number">2.4.4.</span> <span class="toc-text">4.4类的结构–属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5%E7%B1%BB%E7%9A%84%E7%BB%93%E6%9E%84%E2%80%93%E6%96%B9%E6%B3%95"><span class="toc-number">2.4.5.</span> <span class="toc-text">4.5类的结构–方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-%E2%80%9C%E4%B8%87%E4%BA%8B%E4%B8%87%E7%89%A9%E7%9A%86%E5%AF%B9%E8%B1%A1%E2%80%9D"><span class="toc-number">2.4.6.</span> <span class="toc-text">4.6 “万事万物皆对象”</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">2.4.7.</span> <span class="toc-text">4.6 匿名对象的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-7-%E6%95%B0%E7%BB%84%EF%BC%9A%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA"><span class="toc-number">2.4.8.</span> <span class="toc-text">4.7  数组：基本操作代码演示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-8-%E5%9C%A8%E8%B0%88%E6%96%B9%E6%B3%95"><span class="toc-number">2.4.9.</span> <span class="toc-text">4.8  在谈方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E8%BD%BD"><span class="toc-number">2.4.9.1.</span> <span class="toc-text">1.方法的重载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%8F%AF%E5%8F%98%E5%BD%A2%E5%8F%82%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">2.4.9.2.</span> <span class="toc-text">2.可变形参的方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0%E7%9A%84%E2%80%9D%E5%80%BC%E4%BC%A0%E9%80%92%E2%80%9D%E6%9C%BA%E5%88%B6"><span class="toc-number">2.4.9.3.</span> <span class="toc-text">3.方法参数的”值传递”机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E9%80%92%E5%BD%92%E6%96%B9%E6%B3%95%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="toc-number">2.4.9.4.</span> <span class="toc-text">4.递归方法（了解）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-9%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%89%B9%E5%BE%81%E4%B9%8B%E4%B8%80%EF%BC%9A%E5%B0%81%E8%A3%85%E5%92%8C%E9%9A%90%E8%97%8F"><span class="toc-number">2.4.10.</span> <span class="toc-text">4.9面向对象特征之一：封装和隐藏</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%A6%82%E5%BF%B5%E5%88%9D%E7%90%86%E8%A7%A3%EF%BC%9A"><span class="toc-number">2.4.10.1.</span> <span class="toc-text">1.概念初理解：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%97%AE%E9%A2%98%E5%BC%95%E5%85%A5%EF%BC%9A"><span class="toc-number">2.4.10.2.</span> <span class="toc-text">2.问题引入：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%B0%81%E8%A3%85%E6%80%A7%E7%9A%84%E4%BD%93%E7%8E%B0"><span class="toc-number">2.4.10.3.</span> <span class="toc-text">3.封装性的体现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%B0%81%E8%A3%85%E6%80%A7%E4%B8%8E%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">2.4.10.4.</span> <span class="toc-text">4.封装性与权限修饰符</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-10-%E7%B1%BB%E7%9A%84%E7%BB%93%E6%9E%84%E2%80%93%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-number">2.4.11.</span> <span class="toc-text">4.10 类的结构–构造器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-11-%E6%8B%93%E5%B1%95%EF%BC%9AJavaBean"><span class="toc-number">2.4.12.</span> <span class="toc-text">4.11 拓展：JavaBean</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-12-%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%9Athis"><span class="toc-number">2.4.13.</span> <span class="toc-text">4.12 关键字：this</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-this%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">2.4.13.1.</span> <span class="toc-text">1.this的作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-this-%E4%BF%AE%E9%A5%B0%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95"><span class="toc-number">2.4.13.2.</span> <span class="toc-text">2.this 修饰属性和方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-this-%E8%B0%83%E7%94%A8%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-number">2.4.13.3.</span> <span class="toc-text">3.this 调用构造器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-this-%E8%A1%A8%E7%A4%BA%E5%BD%93%E5%89%8D%E5%AF%B9%E8%B1%A1%EF%BC%8C%E4%BD%9C%E4%B8%BA%E5%AE%9E%E5%8F%82%E8%A2%AB%E8%B0%83%E7%94%A8"><span class="toc-number">2.4.13.4.</span> <span class="toc-text">4.this 表示当前对象，作为实参被调用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-13-%E5%85%B3%E9%94%AE%E5%AD%97-package"><span class="toc-number">2.4.14.</span> <span class="toc-text">4.13 关键字 package</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-15-%E5%85%B3%E9%94%AE%E5%AD%97-import"><span class="toc-number">2.4.15.</span> <span class="toc-text">4.15 关键字 import</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%AD%EF%BC%89"><span class="toc-number">2.5.</span> <span class="toc-text">5.面向对象（中）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%89%B9%E5%BE%81%E4%B9%8B%E4%BA%8C%EF%BC%9A%E7%BB%A7%E6%89%BF%E6%80%A7"><span class="toc-number">2.5.1.</span> <span class="toc-text">5.1面向对象特征之二：继承性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%BB%A7%E6%89%BF%E6%80%A7%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-number">2.5.1.1.</span> <span class="toc-text">1.继承性的好处</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%BB%A7%E6%89%BF%E6%80%A7%E7%9A%84%E6%A0%BC%E5%BC%8F"><span class="toc-number">2.5.1.2.</span> <span class="toc-text">2.继承性的格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E7%94%A8%E5%A4%84%E4%BD%93%E7%8E%B0%EF%BC%9A"><span class="toc-number">2.5.1.3.</span> <span class="toc-text">3.用处体现：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-Java%E4%B8%AD%E5%85%B3%E4%BA%8E%E7%BB%A7%E6%89%BF%E6%80%A7%E7%9A%84%E8%A7%84%E5%AE%9A%EF%BC%9A"><span class="toc-number">2.5.1.4.</span> <span class="toc-text">4.Java中关于继承性的规定：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E5%86%99"><span class="toc-number">2.5.2.</span> <span class="toc-text">5.2 方法的重写</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%9Asuper"><span class="toc-number">2.5.3.</span> <span class="toc-text">5.3 关键字：super</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%90%86%E8%A7%A3%E5%92%8C%E7%94%A8%E5%A4%84"><span class="toc-number">2.5.3.1.</span> <span class="toc-text">1.理解和用处</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-super%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">2.5.3.2.</span> <span class="toc-text">2.super的使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-super-%E8%B0%83%E7%94%A8%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-number">2.5.3.3.</span> <span class="toc-text">3.super 调用构造器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%AD%90%E7%B1%BB%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B%E5%8C%96%E7%9A%84%E5%85%A8%E8%BF%87%E7%A8%8B"><span class="toc-number">2.5.3.4.</span> <span class="toc-text">4.子类对象实例化的全过程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%89%B9%E5%BE%81%E4%B9%8B%E4%B8%89%EF%BC%9A%E5%A4%9A%E6%80%81%E6%80%A7"><span class="toc-number">2.5.4.</span> <span class="toc-text">5.4面向对象特征之三：多态性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%90%86%E8%A7%A3"><span class="toc-number">2.5.4.1.</span> <span class="toc-text">1.理解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%99%9A%E6%8B%9F%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%EF%BC%9A"><span class="toc-number">2.5.4.2.</span> <span class="toc-text">2.虚拟方法调用：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E"><span class="toc-number">2.5.4.3.</span> <span class="toc-text">3.使用说明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%A4%9A%E6%80%81%E6%80%A7%E7%9A%84%E8%BD%AC%E5%9E%8B"><span class="toc-number">2.5.4.4.</span> <span class="toc-text">4.多态性的转型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B%EF%BC%9A%E5%8D%B3%E4%B8%BA%E5%A4%9A%E6%80%81"><span class="toc-number">2.5.4.4.1.</span> <span class="toc-text">1.向上转型：即为多态</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%90%91%E4%B8%8B%E8%BD%AC%E5%9E%8B%EF%BC%9A%E7%88%B6%E7%B1%BB%E2%80%93-gt-%E5%AD%90%E7%B1%BB"><span class="toc-number">2.5.4.4.2.</span> <span class="toc-text">2.向下转型：父类–&gt;子类</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E5%B0%8F%E7%BB%83%E4%B9%A0"><span class="toc-number">2.5.4.5.</span> <span class="toc-text">5.小练习</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-Object%E7%B1%BB%E4%BD%BF%E7%94%A8"><span class="toc-number">2.5.5.</span> <span class="toc-text">5.5 Object类使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BB%8B%E7%BB%8D"><span class="toc-number">2.5.5.1.</span> <span class="toc-text">1.介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-equals-%E5%92%8C-x3D-x3D"><span class="toc-number">2.5.5.2.</span> <span class="toc-text">2.equals() 和 &#x3D; &#x3D;</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-x3D-x3D-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">2.5.5.2.1.</span> <span class="toc-text">1.&#x3D;&#x3D;运算符</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-equals%EF%BC%88%EF%BC%89"><span class="toc-number">2.5.5.2.2.</span> <span class="toc-text">2.equals（）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-toString-%E4%BD%BF%E7%94%A8"><span class="toc-number">2.5.5.3.</span> <span class="toc-text">3.toString() 使用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-6-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95"><span class="toc-number">2.5.6.</span> <span class="toc-text">5.6 单元测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-7-%E5%8C%85%E8%A3%85%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">2.5.7.</span> <span class="toc-text">5.7 包装类的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%90%86%E8%A7%A3%EF%BC%9A-1"><span class="toc-number">2.5.7.1.</span> <span class="toc-text">1.理解：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BB%8A%E6%98%94%E5%AF%B9%E6%AF%94"><span class="toc-number">2.5.7.2.</span> <span class="toc-text">2.今昔对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%B8%80%E8%88%AC%E6%93%8D%E4%BD%9C%E2%80%941"><span class="toc-number">2.5.7.3.</span> <span class="toc-text">3.一般操作—1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E4%B8%80%E8%88%AC%E6%93%8D%E4%BD%9C%E2%80%932"><span class="toc-number">2.5.7.4.</span> <span class="toc-text">4.一般操作–2</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E4%BE%BF%E6%8D%B7%E6%93%8D%E4%BD%9C%E2%80%94-1"><span class="toc-number">2.5.7.5.</span> <span class="toc-text">5.便捷操作—-1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6%E5%8C%85%E8%A3%85%E7%B1%BB%E5%92%8C%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%AF%94%E8%BE%83%E9%97%AE%E9%A2%98"><span class="toc-number">2.5.7.6.</span> <span class="toc-text">6包装类和基本数据类型比较问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E4%BE%BF%E6%8D%B7%E6%93%8D%E4%BD%9C%E2%80%942"><span class="toc-number">2.5.7.7.</span> <span class="toc-text">7.便捷操作—2</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-%E7%AC%AC%E4%B8%89%E8%80%85String%E2%80%941"><span class="toc-number">2.5.7.8.</span> <span class="toc-text">8.第三者String—1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-%E7%AC%AC%E4%B8%89%E8%80%85String-%E2%80%932"><span class="toc-number">2.5.7.9.</span> <span class="toc-text">9.第三者String –2</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%8B%EF%BC%89"><span class="toc-number">2.6.</span> <span class="toc-text">6. 面向对象（下）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%9Astatic"><span class="toc-number">2.6.1.</span> <span class="toc-text">6.1关键字：static</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BB%8B%E7%BB%8D%EF%BC%9A"><span class="toc-number">2.6.1.1.</span> <span class="toc-text">1.介绍：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BF%AE%E9%A5%B0%E5%B1%9E%E6%80%A7%EF%BC%9A"><span class="toc-number">2.6.1.2.</span> <span class="toc-text">2.修饰属性：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%BF%AE%E9%A5%B0%E6%96%B9%E6%B3%95"><span class="toc-number">2.6.1.3.</span> <span class="toc-text">3.修饰方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.6.1.4.</span> <span class="toc-text">4.单例设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E7%90%86%E8%A7%A3-1"><span class="toc-number">2.6.1.4.1.</span> <span class="toc-text">1.理解</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E9%A5%BF%E6%B1%89%E5%BC%8F"><span class="toc-number">2.6.1.4.2.</span> <span class="toc-text">2.饿汉式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E6%87%92%E6%B1%89%E5%BC%8F"><span class="toc-number">2.6.1.4.3.</span> <span class="toc-text">3.懒汉式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E4%B8%A4%E7%A7%8D%E6%A8%A1%E5%BC%8F%E5%88%A9%E5%BC%8A"><span class="toc-number">2.6.1.4.4.</span> <span class="toc-text">4.两种模式利弊</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%89%80"><span class="toc-number">2.6.1.4.5.</span> <span class="toc-text">5.应用场所</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-main-%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3"><span class="toc-number">2.6.2.</span> <span class="toc-text">6.3 main() 方法详解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E"><span class="toc-number">2.6.2.1.</span> <span class="toc-text">1.使用说明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%90%86%E8%A7%A3%EF%BC%9A"><span class="toc-number">2.6.2.2.</span> <span class="toc-text">2.理解：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-%E7%B1%BB%E7%9A%84%E7%BB%93%E6%9E%84%E2%80%93%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-number">2.6.3.</span> <span class="toc-text">6.4 类的结构–代码块</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BB%8B%E7%BB%8D%EF%BC%9A-1"><span class="toc-number">2.6.3.1.</span> <span class="toc-text">1.介绍：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-number">2.6.3.2.</span> <span class="toc-text">2.静态代码块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E9%9D%9E%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-number">2.6.3.3.</span> <span class="toc-text">3.非静态代码块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%B1%9E%E6%80%A7%E5%8F%AF%E4%BB%A5%E8%B5%8B%E5%80%BC%E7%9A%84%E4%BD%8D%E7%BD%AE"><span class="toc-number">2.6.3.4.</span> <span class="toc-text">4.属性可以赋值的位置</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-5-%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%9Af-inal"><span class="toc-number">2.6.4.</span> <span class="toc-text">6.5 关键字：f inal</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BB%8B%E7%BB%8D-1"><span class="toc-number">2.6.4.1.</span> <span class="toc-text">1.介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BF%AE%E9%A5%B0%E4%B8%80%E4%B8%AA%E7%B1%BB%EF%BC%9A"><span class="toc-number">2.6.4.2.</span> <span class="toc-text">2.修饰一个类：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%BF%AE%E9%A5%B0%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="toc-number">2.6.4.3.</span> <span class="toc-text">3.修饰方法：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E4%BF%AE%E9%A5%B0%E5%8F%98%E9%87%8F%EF%BC%9A"><span class="toc-number">2.6.4.4.</span> <span class="toc-text">4.修饰变量：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F"><span class="toc-number">2.6.4.5.</span> <span class="toc-text">5.全局变量</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-6%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%9Aabstract"><span class="toc-number">2.6.5.</span> <span class="toc-text">6.6关键字：abstract</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BB%8B%E7%BB%8D-2"><span class="toc-number">2.6.5.1.</span> <span class="toc-text">1.介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BF%AE%E9%A5%B0%E7%B1%BB"><span class="toc-number">2.6.5.2.</span> <span class="toc-text">2.修饰类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%BF%AE%E9%A5%B0%E6%96%B9%E6%B3%95-1"><span class="toc-number">2.6.5.3.</span> <span class="toc-text">3.修饰方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E7%82%B9"><span class="toc-number">2.6.5.4.</span> <span class="toc-text">4.使用注意点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E5%8C%BF%E5%90%8D%E5%AD%90%E7%B1%BB%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.6.5.5.</span> <span class="toc-text">5.匿名子类的对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.6.5.6.</span> <span class="toc-text">6.模板方法的设计模式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-8-interface-%E6%8E%A5%E5%8F%A3"><span class="toc-number">2.6.6.</span> <span class="toc-text">6.8 interface 接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BB%8B%E7%BB%8D-3"><span class="toc-number">2.6.6.1.</span> <span class="toc-text">1.介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%AE%9A%E4%B9%89%E6%8E%A5%E5%8F%A3"><span class="toc-number">2.6.6.2.</span> <span class="toc-text">2.定义接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">2.6.6.3.</span> <span class="toc-text">3.使用方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E4%BD%93%E7%8E%B0%E7%BB%A7%E6%89%BF%E6%80%A7"><span class="toc-number">2.6.6.4.</span> <span class="toc-text">4.体现继承性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E6%8E%A5%E5%8F%A3%E6%98%AF%E4%B8%80%E7%A7%8D%E8%A7%84%E8%8C%83"><span class="toc-number">2.6.6.5.</span> <span class="toc-text">5.接口是一种规范</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E4%BD%93%E7%8E%B0%E5%A4%9A%E6%80%81%E6%80%A7"><span class="toc-number">2.6.6.6.</span> <span class="toc-text">6.体现多态性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E5%8C%BF%E5%90%8D%E5%AD%90%E7%B1%BB%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.6.6.7.</span> <span class="toc-text">7.匿名子类的对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-%E6%8E%A5%E5%8F%A3%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%9C%A8%E8%AF%B4%E6%98%8E"><span class="toc-number">2.6.6.8.</span> <span class="toc-text">8.接口实例化在说明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-JDK-8%E6%96%B0%E5%A2%9E"><span class="toc-number">2.6.6.9.</span> <span class="toc-text">9.JDK 8新增</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E4%BB%8B%E7%BB%8D-4"><span class="toc-number">2.6.6.9.1.</span> <span class="toc-text">1.介绍</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E4%BD%BF%E7%94%A8%E7%BB%86%E8%8A%82%EF%BC%9A"><span class="toc-number">2.6.6.9.2.</span> <span class="toc-text">2.使用细节：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-9-%E7%B1%BB%E7%9A%84%E7%BB%93%E6%9E%84%E2%80%93%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">2.6.7.</span> <span class="toc-text">6.9 类的结构–内部类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BB%8B%E7%BB%8D-5"><span class="toc-number">2.6.7.1.</span> <span class="toc-text">1.介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%88%90%E5%91%98%E5%86%85%E9%83%A8"><span class="toc-number">2.6.7.2.</span> <span class="toc-text">2.成员内部</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">2.7.</span> <span class="toc-text">7. 异常处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%BC%82%E5%B8%B8"><span class="toc-number">2.7.1.</span> <span class="toc-text">1.异常</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%BC%82%E5%B8%B8%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-number">2.7.1.1.</span> <span class="toc-text">1.异常的体系结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BB%8E%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-number">2.7.1.2.</span> <span class="toc-text">2.从程序执行过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%B8%B8%E8%A7%81%E7%9A%84%E5%BC%82%E5%B8%B8%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.7.1.3.</span> <span class="toc-text">3.常见的异常类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">2.7.2.</span> <span class="toc-text">2.异常处理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%9A%84%E6%8A%93%E6%8A%9B%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.7.2.1.</span> <span class="toc-text">1.java异常处理的抓抛模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F%E4%B8%80"><span class="toc-number">2.7.2.2.</span> <span class="toc-text">2.异常处理方式一</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E%EF%BC%9A"><span class="toc-number">2.7.2.2.1.</span> <span class="toc-text">1. 使用说明：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E8%AF%B4%E6%98%8E%E5%8F%8A%E8%A7%A3%E9%87%8A"><span class="toc-number">2.7.2.2.2.</span> <span class="toc-text">2.说明及解释</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%B0%8F%E7%BB%93%EF%BC%9A"><span class="toc-number">2.7.2.3.</span> <span class="toc-text">3.小结：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%A6%82%E4%BD%95%E7%9C%8B%E5%BE%85%E4%BB%A3%E7%A0%81%E4%B8%AD%E7%9A%84%E7%BC%96%E8%AF%91%E6%97%B6%E5%BC%82%E5%B8%B8%E5%92%8C%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BC%82%E5%B8%B8%EF%BC%9F"><span class="toc-number">2.7.2.3.1.</span> <span class="toc-text">1.如何看待代码中的编译时异常和运行时异常？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-finally%E7%9A%84%E5%86%8D%E8%AF%B4%E6%98%8E%EF%BC%9A"><span class="toc-number">2.7.2.3.2.</span> <span class="toc-text">2.finally的再说明：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">2.7.2.4.</span> <span class="toc-text">4.面试题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F%E4%BA%8C"><span class="toc-number">2.7.2.5.</span> <span class="toc-text">5.异常处理方式二</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E5%AF%B9%E6%AF%94%E4%B8%A4%E7%A7%8D%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-number">2.7.2.6.</span> <span class="toc-text">6.对比两种处理方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E5%BC%80%E5%8F%91%E4%B8%AD%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E4%B8%A4%E7%A7%8D%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-number">2.7.2.7.</span> <span class="toc-text">7.开发中如何选择两种处理方式？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-%E8%A1%A5%E5%85%85"><span class="toc-number">2.7.2.8.</span> <span class="toc-text">8.补充</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%89%8B%E5%8A%A8%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.7.3.</span> <span class="toc-text">3.手动抛出异常对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E-1"><span class="toc-number">2.7.3.1.</span> <span class="toc-text">1.使用说明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">2.7.3.2.</span> <span class="toc-text">2.面试题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%85%B8%E5%9E%8B%E4%BE%8B%E9%A2%98"><span class="toc-number">2.7.3.3.</span> <span class="toc-text">3.典型例题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8%E7%B1%BB"><span class="toc-number">2.7.4.</span> <span class="toc-text">4.自定义异常类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%A6%82%E4%BD%95%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8%E7%B1%BB%EF%BC%9F"><span class="toc-number">2.7.4.1.</span> <span class="toc-text">1.如何自定义异常类？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA"><span class="toc-number">2.7.4.2.</span> <span class="toc-text">2.代码演示</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Qinghai2021</div><div class="author-info__description">阳光宅男💛</div></div><div class="card-info-social-icons is-center"><a class="social-icon" href="//github.com/Qinghai2021?tab=repositories" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:xxxxxx@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">来的都是大哥！</div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/09/28/%E5%B0%9A%E7%A1%85%E8%B0%B7java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/" title="Java基础">Java基础</a><time datetime="2022-09-28T09:45:41.000Z" title="发表于 2022-09-28 17:45:41">2022-09-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/09/27/java%E8%80%83%E8%AF%95/" title="Java考试">Java考试</a><time datetime="2022-09-27T09:45:41.000Z" title="发表于 2022-09-27 17:45:41">2022-09-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/09/07/Linux%E9%9D%99%E6%80%81%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/" title="Linux静态网络配置">Linux静态网络配置</a><time datetime="2022-09-07T13:22:52.000Z" title="发表于 2022-09-07 21:22:52">2022-09-07</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/09/07/Linux%E5%85%8B%E9%9A%86%E5%90%8E%E6%97%A0%E6%B3%95%E9%87%8D%E5%90%AF%E7%BD%91%E7%BB%9C/" title="Linux克隆后无法重启网络">Linux克隆后无法重启网络</a><time datetime="2022-09-07T13:04:31.000Z" title="发表于 2022-09-07 21:04:31">2022-09-07</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/08/30/Java%E9%AB%98%E7%BA%A7-%E9%9B%86%E5%90%88-%E6%B3%9B%E5%9E%8B-IO%E6%B5%81/" title="集合">集合</a><time datetime="2022-08-30T09:45:41.000Z" title="发表于 2022-08-30 17:45:41">2022-08-30</time></div></div></div></div></div></div></main><footer id="footer" style="background: #FFFFFF"><div id="footer-wrap"><div class="copyright">&copy;2022 By Qinghai2021</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/chenxz21/hexo-theme-bcxm">Bcxm</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://fastly.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><div class="js-pjax"></div><script type="text/javascript" src="https://fastly.jsdelivr.net/npm/leancloud-storage@4.10.0/dist/av-min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://fastly.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script id="click-heart" src="https://fastly.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>