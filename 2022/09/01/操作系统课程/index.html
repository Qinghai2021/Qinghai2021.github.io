<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>操作系统笔记</title><meta name="author" content="Qinghai2021"><meta name="copyright" content="Qinghai2021"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="一、操作系统概述1、课程导读课程地址操作系统 - 清华大学 - 学堂在线 (xuetangx.com)  预备知识计算机结构原理（lntel80386+）C与汇编程序设计数据结构 操作系统实验实验0：实验环境准备实验1：系统启动及中断实验2：物理内存管理实验3：虚拟内存管理实验4：内核线程管理 实验5：用户进程管理实验6：CPU调度实验7：同步与互序实验8：文件系统 2、什么是操作系统操作系统定义">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统笔记">
<meta property="og:url" content="http://example.com/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/index.html">
<meta property="og:site_name" content="Qinghai2021·博客">
<meta property="og:description" content="一、操作系统概述1、课程导读课程地址操作系统 - 清华大学 - 学堂在线 (xuetangx.com)  预备知识计算机结构原理（lntel80386+）C与汇编程序设计数据结构 操作系统实验实验0：实验环境准备实验1：系统启动及中断实验2：物理内存管理实验3：虚拟内存管理实验4：内核线程管理 实验5：用户进程管理实验6：CPU调度实验7：同步与互序实验8：文件系统 2、什么是操作系统操作系统定义">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/images/background.jpg">
<meta property="article:published_time" content="2022-08-31T16:00:00.000Z">
<meta property="article:modified_time" content="2022-10-05T10:40:19.511Z">
<meta property="article:author" content="Qinghai2021">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/images/background.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":500},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: Qinghai2021","link":"链接: ","source":"来源: Qinghai2021·博客","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://fastly.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://fastly.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '操作系统笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-10-05 18:40:19'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.2.0"><link rel="alternate" href="/atom.xml" title="Qinghai2021·博客" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Qinghai2021</div><div class="author-info__description">阳光宅男💛</div></div><div class="card-info-social-icons is-center"><a class="social-icon" href="//github.com/Qinghai2021?tab=repositories" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:xxxxxx@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-clock"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://www.bilibili.com/blackboard/fe/activity-HQjQSdd3L8.html"><i class="fa-fw fas fa-gamepad"></i><span> 游戏</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-tools"></i><span> 工具</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" target="_blank" rel="noopener" href="https://draw.xbyzs.cf"><span> Draw画布</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Qinghai2021·博客</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-clock"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://www.bilibili.com/blackboard/fe/activity-HQjQSdd3L8.html"><i class="fa-fw fas fa-gamepad"></i><span> 游戏</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-tools"></i><span> 工具</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" target="_blank" rel="noopener" href="https://draw.xbyzs.cf"><span> Draw画布</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">操作系统笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2022-08-31T16:00:00.000Z" title="发表于 2022-09-01 00:00:00">2022-09-01</time></span></div><div class="meta-secondline"></div></div></div><article class="post-content" id="article-container"><h1 id="一、操作系统概述"><a href="#一、操作系统概述" class="headerlink" title="一、操作系统概述"></a>一、操作系统概述</h1><h2 id="1、课程导读"><a href="#1、课程导读" class="headerlink" title="1、课程导读"></a>1、课程导读</h2><h4 id="课程地址"><a href="#课程地址" class="headerlink" title="课程地址"></a>课程地址</h4><p><a target="_blank" rel="noopener" href="https://www.xuetangx.com/learn/THU08091000267/THU08091000267/10322317/video/17399395?channel=i.area.recent_search">操作系统 - 清华大学 - 学堂在线 (xuetangx.com)</a></p>
<p><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220517170805637.png" alt="image-20220517170805637"></p>
<h4 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h4><p>计算机结构原理（lntel80386+）<br>C与汇编程序设计<br>数据结构</p>
<h4 id="操作系统实验"><a href="#操作系统实验" class="headerlink" title="操作系统实验"></a>操作系统实验</h4><p>实验0：实验环境准备<br>实验1：系统启动及中断<br>实验2：物理内存管理<br>实验3：虚拟内存管理<br>实验4：内核线程管理</p>
<p>实验5：用户进程管理<br>实验6：CPU调度<br>实验7：同步与互序<br>实验8：文件系统</p>
<h2 id="2、什么是操作系统"><a href="#2、什么是操作系统" class="headerlink" title="2、什么是操作系统"></a>2、什么是操作系统</h2><h4 id="操作系统定义"><a href="#操作系统定义" class="headerlink" title="操作系统定义"></a>操作系统定义</h4><p>没有公认的精确定义</p>
<p>操作系统是一个控制程序</p>
<ul>
<li>一个系统软件</li>
<li>控制程序执行过程，防止错误和计算机的不当使用</li>
<li>执行用户程序，给用户程序提供各种服务</li>
<li>方便用户使用计算机系统</li>
</ul>
<p>操作系统是一个资源管理器</p>
<ul>
<li>应用程序与硬件之间的中间层</li>
<li>管理各种计算机软硬件资源</li>
<li>提供访问计算机软硬件资源的高效手段</li>
<li>解决资源访问冲突，确保资源公平使用</li>
</ul>
<h4 id="操作系统的地位"><a href="#操作系统的地位" class="headerlink" title="操作系统的地位"></a>操作系统的地位</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220517174205883.png" alt="image-20220517174205883" style="zoom:50%;">

<img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220517174245022.png" alt="image-20220517174245022" style="zoom:50%;">

<h4 id="操作系统软件的分类"><a href="#操作系统软件的分类" class="headerlink" title="操作系统软件的分类"></a>操作系统软件的分类</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220517174342359.png" alt="image-20220517174342359" style="zoom:50%;">

<h4 id="操作系统软件的组成"><a href="#操作系统软件的组成" class="headerlink" title="操作系统软件的组成"></a>操作系统软件的组成</h4><ul>
<li><p>&#x3D;&#x3D;Shell&#x3D;&#x3D;–命令行接口</p>
<ul>
<li>通过键盘操纵。</li>
<li>方便用户进行命令输入</li>
</ul>
</li>
<li><p>&#x3D;&#x3D;GUI&#x3D;&#x3D;–图形用户接口</p>
</li>
<li><p>WIMP<br>（视窗（Window）、图标（Icon）、选单（Menu）、指标（Point)</p>
</li>
<li><p>直接操作和所见即所得</p>
</li>
<li><p>&#x3D;&#x3D;Kernel&#x3D;&#x3D;–操作系统的内部</p>
<ul>
<li>执行各种资源管理等功能</li>
</ul>
</li>
</ul>
<img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220517174524837.png" alt="image-20220517174524837" style="zoom:50%;">

<h4 id="ucore教学操作系统内核"><a href="#ucore教学操作系统内核" class="headerlink" title="ucore教学操作系统内核"></a>ucore教学操作系统内核</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220517174733933.png" alt="image-20220517174733933" style="zoom:50%;">

<h4 id="操作系统内核特征"><a href="#操作系统内核特征" class="headerlink" title="操作系统内核特征"></a>操作系统内核特征</h4><ul>
<li><p>并发</p>
<ul>
<li>计算机系统中同时存在多个运行的程序，需要OS管理和调度</li>
</ul>
</li>
<li><p>共享</p>
<ul>
<li>“同时”访问</li>
<li>互斥共享</li>
</ul>
</li>
<li><p>虚拟</p>
<ul>
<li>利用多道程序设计技术，让每个用户</li>
<li>都觉得有一个计算机专门为他服务</li>
</ul>
</li>
<li><p>异步</p>
<ul>
<li>程序的执行不是一贯到底，而是走走停停，向前推进的速度不可预知</li>
<li>只要运行环境相同，OS需要保证程序运行的结果也要相同</li>
</ul>
</li>
</ul>
<h2 id="3、操作系统实例"><a href="#3、操作系统实例" class="headerlink" title="3、操作系统实例"></a>3、操作系统实例</h2><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220517180634316.png" alt="image-20220517180634316" style="zoom: 33%;">

<img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220517180603555.png" alt="image-20220517180603555" style="zoom:33%;">

<img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220517180526360.png" alt="image-20220517180526360" style="zoom: 50%;">

<h2 id="4、操作系统的演变"><a href="#4、操作系统的演变" class="headerlink" title="4、操作系统的演变"></a>4、操作系统的演变</h2><h4 id="单用户系统"><a href="#单用户系统" class="headerlink" title="单用户系统"></a>单用户系统</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220517181011338.png" alt="image-20220517181011338" style="zoom:50%;">



<p>目的是仅为用户提供运算，但是通过用户自己输入，输入输出效率很差</p>
<h4 id="批处理系统"><a href="#批处理系统" class="headerlink" title="批处理系统"></a>批处理系统</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220517181231026.png" alt="image-20220517181231026" style="zoom:50%;">

<p>提前输入很多任务，CPU一个接一个执行</p>
<h4 id="多道程序"><a href="#多道程序" class="headerlink" title="多道程序"></a>多道程序</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220517181529161.png" alt="image-20220517181529161" style="zoom:50%;">

<p>为了提高CPU利用率，例如程序A占用CPU，之后需要一段IO，这时则调度程序B进行占用CPU</p>
<h4 id="分时系统"><a href="#分时系统" class="headerlink" title="分时系统"></a>分时系统</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220517201307650.png" alt="image-20220517201307650" style="zoom:50%;">

<p>多道程序系统基础上，将CPU使用时间分为一个个时间片，即程序执行过程中加了个时钟中断</p>
<p>好处：</p>
<ul>
<li>改善了程序执行的公平性</li>
<li>对短作业的好处很大，即时响应用户</li>
</ul>
<p>坏处：每次中断加上了调度程序，开销也会增大</p>
<h4 id="个人电脑操作系统"><a href="#个人电脑操作系统" class="headerlink" title="个人电脑操作系统"></a>个人电脑操作系统</h4><p>个人电脑系统</p>
<ul>
<li>单用户</li>
<li>利用率已不再是关注点</li>
<li>重点是用户界面和多媒体功能</li>
<li>很多老的服务和功能不存在</li>
</ul>
<p>演变</p>
<ul>
<li>最初：操作系统作为一个简单的服务提供者（简单库）</li>
<li>现在：支持协调和沟通的多应用系统</li>
<li>越来越多的安全问题（如，电子商务、医疗记录）</li>
</ul>
<h4 id="分布式操作系统"><a href="#分布式操作系统" class="headerlink" title="分布式操作系统"></a>分布式操作系统</h4><ul>
<li>网络支持成为一个重要的功能</li>
<li>通常支持分布式服务<ul>
<li>跨多系统的数据共享和协调</li>
</ul>
</li>
<li>可能使用多个处理器<ul>
<li>松、紧耦合系统</li>
</ul>
</li>
<li>高可用性与可靠性的要求</li>
</ul>
<img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220517202037841.png" alt="image-20220517202037841" style="zoom:50%;">

<h4 id="操作系统演变中的计算机系统"><a href="#操作系统演变中的计算机系统" class="headerlink" title="操作系统演变中的计算机系统"></a>操作系统演变中的计算机系统</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220517202335641.png" alt="image-20220517202335641" style="zoom:50%;">

<h2 id="5、操作系统的结构"><a href="#5、操作系统的结构" class="headerlink" title="5、操作系统的结构"></a>5、操作系统的结构</h2><h4 id="简单结构"><a href="#简单结构" class="headerlink" title="简单结构"></a>简单结构</h4><p>MS-DOS-在最小的空间，设计用于提供大部分功能（1981~1994）</p>
<ul>
<li>没有拆分为模块</li>
<li>虽然MS-DOS在接口和功能水平没有很好地分离，主要用汇编编写</li>
</ul>
<img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220906082720949.png" alt="image-20220906082720949" style="zoom: 67%;">

<blockquote>
<p>此时操作系统移植性不强，只是针对特定硬件编写的操作系统</p>
</blockquote>
<h4 id="分层结构"><a href="#分层结构" class="headerlink" title="分层结构"></a>分层结构</h4><p>操作系统分为很多层（levels）</p>
<ul>
<li>每层建立在低层之上</li>
<li>最底层（layer0），是硬件</li>
<li>最高层（layerN）是用户界面</li>
</ul>
<p>使用模块化，每一层仅使用更低一层的功能（操作）和服务。</p>
<img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220906082957746.png" alt="image-20220906082957746" style="zoom: 80%;">

<blockquote>
<p>分层过后移植性得到提升</p>
</blockquote>
<h4 id="微内核结构"><a href="#微内核结构" class="headerlink" title="微内核结构"></a>微内核结构</h4><ul>
<li><p>尽可能把内核功能移到用户空间</p>
</li>
<li><p>用户模块间的通信使用消息传递</p>
</li>
<li><p>好处：灵活&#x2F;安全..</p>
</li>
<li><p>缺点：性能</p>
</li>
</ul>
<img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220906083148675.png" alt="image-20220906083148675" style="zoom:50%;">

<blockquote>
<p>随着分层越来越多，出现微内核结构，将其分为内核态和用户态</p>
<p>好处是：安全性和可扩展性提高</p>
<p>缺点是：性能下降了</p>
</blockquote>
<h4 id="外核结构"><a href="#外核结构" class="headerlink" title="外核结构"></a>外核结构</h4><ul>
<li>让内核分配机器的物理资源给多个应用程序，并让每个程序决定如何处理这些资源</li>
<li>程序能链接到操作系统库（libos）实现了操作系统抽象保护与控制分离</li>
</ul>
<img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220906083256065.png" alt="image-20220906083256065" style="zoom:67%;">

<blockquote>
<p>对内核结构的进一步改善，在内核里放更少的东西，起到资源的保护和隔离的作用，把资源的管理的任务交给应用态的代码去完成，而原来的操作系统的功能有用户的态的函数库提供</p>
<p>安全绑定：规定那些资源归那些系统使用，系统负责管理这些资源</p>
<p>这种情况下，一个系统上能够运行多个操作系统服务，这就是早期虚拟机的原型</p>
</blockquote>
<h4 id="VMM（虚拟机管理）"><a href="#VMM（虚拟机管理）" class="headerlink" title="VMM（虚拟机管理）"></a>VMM（虚拟机管理）</h4><p>虚拟机管理器将单独的机器接口转换成很多的虚拟机，每个虚拟机都是一个原始计算机系统的有效副本，并能完成所有的处理器指令。</p>
<img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220906083603592.png" alt="image-20220906083603592" style="zoom:50%;">

<blockquote>
<p>虚拟机管理器直接接触硬件，将硬件虚拟为若干个虚拟硬件共上层操作系统使用</p>
<p>虚拟机管理器负责资源的隔离，操作系统负责资源的管理</p>
</blockquote>
<img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220517204720298.png" alt="image-20220517204720298" style="zoom:50%;">

<h2 id="6、实验课程设计"><a href="#6、实验课程设计" class="headerlink" title="6、实验课程设计"></a>6、实验课程设计</h2><h4 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h4><p>方便且利用理解细节</p>
<ul>
<li>大量采用开源软件</li>
<li>实验环境：Windows&#x2F;Linux</li>
<li>源码阅读工具：understand</li>
<li>源码文档自动生成工具：Doxygen</li>
<li>编译环境：gcc，make，Binutils</li>
<li>真实&#x2F;虚拟运行环境：X86机器或QEMU</li>
<li>调试工具：改进的QEMU+（GDB O.R.IDE）</li>
<li>IDE工具：Eclipse-CDT</li>
</ul>
<h4 id="实验内容及涉及代码量"><a href="#实验内容及涉及代码量" class="headerlink" title="实验内容及涉及代码量"></a>实验内容及涉及代码量</h4><p>1 0S启动、中断与设备管理  0200<del>1800行<br>2 物理内存管理 1800</del>2500行<br>3 虚拟内存管理  2500<del>3200行<br>4 内核线程管理  3200-3600行<br>5 用户进程管理 3600</del>4300行<br>6 处理器调度  4300<del>5100行<br>7 同步互序  5100</del>6400行<br>8 文件系统  6400~9999行</p>
<img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220517210630490.png" alt="image-20220517210630490" style="zoom:50%;">

<img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220517210827324.png" alt="image-20220517210827324" style="zoom: 67%;">

<h4 id="使用工具简单介绍"><a href="#使用工具简单介绍" class="headerlink" title="使用工具简单介绍"></a>使用工具简单介绍</h4><p>安装实验环境</p>
<ul>
<li>在虚拟机上使用安装好的ubuntu实验环境</li>
</ul>
<p>使用实验工具</p>
<ul>
<li>shell命令：Is、cd、rm、pwd…</li>
<li>系统维护工具：apt、git</li>
<li>源码阅读与编辑工具：eclipse-CDT、understand、gedit、vim</li>
<li>源码比较工具：diff、meld</li>
<li>开发编译调试工具：gcc、gdb、make</li>
<li>硬件模拟器：qemu</li>
</ul>
<p>系统维护工具：apt、git</p>
<ul>
<li>apt：安装管理各种软件</li>
<li>git：开发版本维护软件</li>
</ul>
<p>源码编辑工具：Eclipse-CDT、understand、gedit、vim</p>
<ul>
<li><p>Eclipse-CDT：基于Eclipse的C&#x2F;C++集成开发环境</p>
<p>跨平台、丰富的分析理解代码的功能</p>
<p>可与qemu结合，联机源码级Debug ucore OS</p>
</li>
<li><p>Understand：跨平台、丰富的分析理解代码的功能</p>
<p>Windows上有类似的sourceinsigh饮件</p>
</li>
<li><p>gedit：Linux中的常用文本编辑</p>
<p>Windows上有类似的notepad</p>
</li>
<li><p>vim:Linux&#x2F;unix中的传统编辑器</p>
<p>类似有emacs等</p>
<p>可通过exuberant-ctags、cscope等实现代码定位</p>
</li>
</ul>
<p>源码比较工具：diff、meld</p>
<ul>
<li>比较不同目录或不同文件的区别</li>
<li>diff是命令行工具，使用简单</li>
<li>meld是图形界面的工具，功能相对直观和方便</li>
</ul>
<p>开发编译调试工具：gcc、gdb、make</p>
<ul>
<li>gcc：C语言编译器</li>
<li>gdb：执行程序调试器</li>
<li>make：软件工程管理工具</li>
<li>make命令执行时，需要一个makefile文件，以告诉</li>
<li>make命令如何去编译和链接程序</li>
</ul>
<p>硬件模拟器：qemu</p>
<ul>
<li>qemu可模拟多种CPU硬件环境，本实验中，用于</li>
<li>模拟一台intelx86-32的计算机系统</li>
</ul>
<h2 id="7、X86-32硬件架构了解"><a href="#7、X86-32硬件架构了解" class="headerlink" title="7、X86-32硬件架构了解"></a>7、X86-32硬件架构了解</h2><h4 id="四种运行模式"><a href="#四种运行模式" class="headerlink" title="四种运行模式"></a>四种运行模式</h4><p>80386有四种运行模式:</p>
<ul>
<li>实模式、保护模式、SMM模式和虚拟8086模式</li>
</ul>
<p>实模式：</p>
<ul>
<li>80386加电启动后处于实模式运行状态，在这种状态下软件可访问的物理内存空间不能超过1MB，且无法发挥Intel80386以上级别的32位CPU的4GB内存管理能力。</li>
</ul>
<p>保护模式：</p>
<ul>
<li>支持内存分页机制，提供了对虚拟内存的良好支持。保护模式下80386支持多任务，还支持优先级机制，不同的程序可以运行在不同的优先级上。<br>优先级一共分0~34个级别，操作系统运行在最高的优先级0上，应用程序则运行在比较低的级别上；配合良好的检查机制后，既可以在任务间实现数据的安全共享也可以很好地隔离各个任务。</li>
</ul>
<h4 id="内存架构"><a href="#内存架构" class="headerlink" title="内存架构"></a>内存架构</h4><ul>
<li>地址是访问内存空间的索引</li>
<li>80386是32位的处理器，即可以寻址的物理内存地址空间为232&#x3D;4G字节</li>
<li>物理内存地址空间是处理器提交到总线上用于访问计算机系统中的内存和外设的最终地址。一个计算机系统中只有一个物理地址空间</li>
<li>线性地址空间是在操作系统的虚存管理之下每个运行的应用程序能访问的地址空间。每个运行的应用程序都认为自己独享整个计算机系统的地址空间，这样可让多个运行的应用程序之间相互隔离</li>
<li><strong>逻辑地址空间是应用程序直接使用的地址空间。</strong><br>段机制启动、页机制未启动：逻辑地址-&gt;&#x3D;&#x3D;段机制处理&#x3D;&#x3D;-&gt;线性地址&#x3D;物理地址<br>段机制和页机制都启动：逻辑地址-&gt;&#x3D;&#x3D;段机制处理&#x3D;&#x3D;-&gt;线性地址-&gt;&#x3D;&#x3D;页机制处理&#x3D;&#x3D;-&gt;物理地址</li>
</ul>
<h4 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h4><p>80386的寄存器可以分为8组：</p>
<ul>
<li>通用寄存器</li>
<li>段寄存器</li>
<li>指令指针寄存器</li>
<li>标志寄存器</li>
<li>控制寄存器</li>
<li>系统地址寄存器，调试寄存器，测试寄存器</li>
</ul>
<p>通用寄存器</p>
<ul>
<li>EAX：累加器</li>
<li>EBX：基址寄存器</li>
<li>ECX：计数器</li>
<li>EDX：数据寄存器</li>
<li>ESI：源地址指针寄存器</li>
<li>EDI：目的地址指针寄存器</li>
<li>EBP：基址指针寄存器</li>
<li>ESP：堆栈指针寄存器</li>
</ul>
<p>段寄存器</p>
<ul>
<li>CS：代码段（Code Segment）</li>
<li>DS：数据段（Data Segment）</li>
<li>ES：附加数据段（Extra Segment）</li>
<li>SS：堆栈段（Stack Segment）</li>
<li>FS：附加段</li>
<li>GS：附加段</li>
</ul>
<blockquote>
<p>段寄存器是用来寻址，CS里面的值，在实模式下和保护模式下含义是不一样的</p>
</blockquote>
<p>指令寄存器和标志寄存器</p>
<ul>
<li><p>&#x3D;&#x3D;EIP：指令寄存器&#x3D;&#x3D;</p>
<p>EIP的低16位就是8086的IP，它存储的是下一条要执行指令的内存地址，在分段地址转换中，表示指令的段内偏移地址</p>
</li>
<li><p>EFLAGS：标志寄存器</p>
<p>lF（InterruptFlag）：中断允许标志位，由CLI，STI两条指令来控制；设置IF使CPU可识别外部（可屏蔽）中断请求。复位IF则禁止中断。IF对不可屏蔽外部中断和故障中断的识别没有任何作用。CF,PF，ZF，…</p>
</li>
</ul>
<h1 id="二、启动-中断-异常和系统调用"><a href="#二、启动-中断-异常和系统调用" class="headerlink" title="二、启动.中断.异常和系统调用"></a>二、启动.中断.异常和系统调用</h1><h2 id="1、BIOS"><a href="#1、BIOS" class="headerlink" title="1、BIOS"></a>1、BIOS</h2><h4 id="RAM和ROM"><a href="#RAM和ROM" class="headerlink" title="RAM和ROM"></a>RAM和ROM</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220519160931485.png" alt="image-20220519160931485" style="zoom:33%;">

<p>CPU在加电之后进行读取的第一条指令在内存(ROM)中</p>
<p>内存分为：</p>
<ul>
<li>RAM：随机访问存储 (断电时数据会随之消失)，随机储存器 ，就是电脑的内存条。用于存放动态数据。(也叫运行内存)系统运行的时候，需要把操作系统从ROM中读取出来，放在RAM中运行。</li>
<li>ROM：只读储存器 ，对于电脑来讲就是硬盘，对于手机来讲就是内置储存，对于单片机来讲就是Flash。用于存放操作系统的软件。</li>
</ul>
<h4 id="启动时计算机内存和磁盘布局"><a href="#启动时计算机内存和磁盘布局" class="headerlink" title="启动时计算机内存和磁盘布局"></a>启动时计算机内存和磁盘布局</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220519161508124.png" alt="image-20220519161508124" style="zoom:50%;">

<p>计算系统加电后，CPU将CS左移四位：IP两段地址拼接，跳转BIOS启动固件</p>
<p>BIOS启动固件有基本功能</p>
<ul>
<li>基本输入输出：从磁盘读数据，从键盘上读用户的输入，在显示器输出</li>
<li>系统配置信息：例如决定从硬盘，网络，光盘启动</li>
</ul>
<h4 id="加载程序的内存地址空间"><a href="#加载程序的内存地址空间" class="headerlink" title="加载程序的内存地址空间"></a>加载程序的内存地址空间</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220519163623584.png" alt="image-20220519163623584" style="zoom: 50%;">

<p>BIOS完成相关初始化后，将加载程序从磁盘的引导扇区加载到进内存，将控制权交给加载程序</p>
<p>加载程序将操作系统的代码和数据从硬盘加载到内存中，控制权在交给操作系统内核，就此计算机就运行起来了</p>
<p>为什么不直接从BIOS直接读取操作系统进内存呢？</p>
<p>因为有文件系统，如果有多个文件系统，BIOS得存放多种数据，显然BIOS空间大小不允许，这呢还需要多了解</p>
<h4 id="BIOS系统调用"><a href="#BIOS系统调用" class="headerlink" title="BIOS系统调用"></a>BIOS系统调用</h4><p>BIOS以中断调用的方式 提供了基本的I&#x2F;O功能</p>
<ul>
<li>INT10h:字符显示</li>
<li>INT13h:磁盘扇区读写心</li>
<li>INT15h:检测内存大小</li>
<li>INT16h:键盘输入</li>
</ul>
<p>只能在×86的实模式下访问</p>
<h2 id="2、系统启动流程"><a href="#2、系统启动流程" class="headerlink" title="2、系统启动流程"></a>2、系统启动流程</h2><h4 id="系统启动流程"><a href="#系统启动流程" class="headerlink" title="系统启动流程"></a>系统启动流程</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220519164628886.png" alt="image-20220519164628886" style="zoom:50%;">

<p>现在计算磁盘不只是有唯一 的分区，而是多个分区，所以需要有主引导记录，记录每一个分区的位置，当用户选择时，跳转到响应的活动分区读取对应加载程序</p>
<h4 id="CPU初始化"><a href="#CPU初始化" class="headerlink" title="CPU初始化"></a>CPU初始化</h4><p>CPU加电稳定后从OXFFFF0读第一条指令</p>
<ul>
<li>CS:IP&#x3D;0xf000:fff0</li>
<li>第一条指令是跳转指令</li>
</ul>
<p>CPU初始状态为16位实模式</p>
<ul>
<li>CS：IP是16位寄存器</li>
<li>指令指针PC&#x3D;16*CS+IP</li>
<li>最大地址空间是1MB</li>
</ul>
<blockquote>
<p>实模式地址20位，最大地址空间2^20&#x3D;1MB</p>
</blockquote>
<h4 id="BIOS的初始化"><a href="#BIOS的初始化" class="headerlink" title="BIOS的初始化"></a>BIOS的初始化</h4><ul>
<li>硬件自检POST</li>
<li>检测系统中内存和显卡等关键部件的存在和工作状态</li>
<li>查找并执行显卡等接口卡BIOS，进行设备初始化；</li>
<li>执行系统BIOS，进行系统检测；<ul>
<li>检测和配置系统中安装的即插即用设备；</li>
</ul>
</li>
<li>更新CMOS中的扩展系统配置数据ESCD</li>
<li>按指定启动顺序从软盘、硬盘或光驱启动</li>
</ul>
<blockquote>
<p>硬件自检：例如你的内容地址可能出错，进行设备初始化</p>
<p>ESCD：计算当前检测到的硬件的硬件表</p>
</blockquote>
<h4 id="主引导记录MBR格式"><a href="#主引导记录MBR格式" class="headerlink" title="主引导记录MBR格式"></a>主引导记录MBR格式</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220906104246721.png" alt="image-20220906104246721" style="zoom:50%;">

<p>启动代码：446字节</p>
<ul>
<li>检查分区表正确性</li>
<li>加载并跳转到磁盘上的引导程序</li>
</ul>
<p>硬盘分区表：64字节</p>
<ul>
<li>描述分区状态和位置</li>
<li>每个分区描述信息占据16字节</li>
</ul>
<p>结束标志字：2字节（55AA）</p>
<ul>
<li>主引导记录的有效标志</li>
</ul>
<blockquote>
<p>MBR一般是在第一个分区，将512字节划分出64字节来作为分区表，446字节来作为启动代码</p>
</blockquote>
<h4 id="分区引导扇区格式"><a href="#分区引导扇区格式" class="headerlink" title="分区引导扇区格式"></a>分区引导扇区格式</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220906092323911.png" alt="image-20220906092323911" style="zoom:50%;">

<p>跳转指令：跳转到启动代码</p>
<ul>
<li>与平台相关代码</li>
</ul>
<p>文件卷头：文件系统描述信息</p>
<p>启动代码：跳转到加载程序</p>
<p>结束标志：55AA</p>
<h4 id="加载程序（bootloader）"><a href="#加载程序（bootloader）" class="headerlink" title="加载程序（bootloader）"></a>加载程序（bootloader）</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220519170741257.png" alt="image-20220519170741257" style="zoom: 50%;">

<blockquote>
<p>每个操作系统的文件系统都不一样，所以bootloader加载程序也有不同</p>
<p>启动菜单：例如你要以什么模式进入系统，安全模式、普通模式、调试模式等，不同模式内核也会有些出入</p>
</blockquote>
<h4 id="系统启动规范"><a href="#系统启动规范" class="headerlink" title="系统启动规范"></a>系统启动规范</h4><p>BIOS</p>
<ul>
<li>固化到计算机主板上的程序</li>
<li>包括系统设置、自检程序和系统自启动程序</li>
<li>BIOS-MBR、BIOS-GPT、PXE</li>
</ul>
<p>UEFI</p>
<ul>
<li>接口标准</li>
<li>在所有平台上一致的操作系统启动服务</li>
</ul>
<blockquote>
<p>BIOS-MBR：主引导记录，分出64字节来记录四个分区的位置</p>
<p>BIOS-GPT：全局分区唯一标识符表，由于MBR只能记录四个分区，衍生出了GPT能记录四个以上的分区</p>
<p>PXE：网络启动，从服务器上下载镜像内核进行启动</p>
<p>UEFI ：</p>
<ul>
<li>统一可扩展固定接口</li>
<li>可信度检查：在分区中加上可信签名，有签名才会将控制权交给该分区</li>
</ul>
</blockquote>
<h2 id="3、中断-异常和系统调用的比较"><a href="#3、中断-异常和系统调用的比较" class="headerlink" title="3、中断.异常和系统调用的比较"></a>3、中断.异常和系统调用的比较</h2><h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>为什么需要中断、异常和系统调用</p>
<ul>
<li>在计算机运行中，内核是被信任的第三方</li>
<li>只有内核可以执行特权指令</li>
<li>方便应用程序</li>
</ul>
<p>为什么需要中断、异常和系统调用</p>
<ul>
<li>当外设连接计算机时，会出现什么现象？</li>
<li>当应用程序处理意想不到的行为时，会出现什么现象？</li>
</ul>
<p>系统调用希望解决的问题</p>
<ul>
<li>用户应用程序是如何得到系统服务？</li>
<li>系统调用和功能调用的不同之处是什么？</li>
</ul>
<h4 id="内核的进入与退出"><a href="#内核的进入与退出" class="headerlink" title="内核的进入与退出"></a>内核的进入与退出</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220519173405688.png" alt="image-20220519173405688" style="zoom: 50%;">

<p>外界内核打交道基本是通过中断</p>
<p>外部设备：例如键盘打字，打印机缺纸或者完成，都会发出中断，内核收到后进行处理</p>
<p>应用进程：应用进程发出中断或调用系统调用接口来进行与内核的交互，中断有时会被检查是异常，进行处理</p>
<p>函数库：可以通过系统调用交互，例如文件的读写</p>
<h4 id="中断、异常和系统调用定义"><a href="#中断、异常和系统调用定义" class="headerlink" title="中断、异常和系统调用定义"></a>中断、异常和系统调用定义</h4><p>系统调用（system call）</p>
<ul>
<li>应用程序&#x3D;&#x3D;主动&#x3D;&#x3D;向操作系统发出的服务请求</li>
</ul>
<p>异常（exception）</p>
<ul>
<li><p>非法指令或者其他原因导致当前&#x3D;&#x3D;指令执行失败&#x3D;&#x3D;</p>
<p>（如：内存出错）后的处理请求</p>
</li>
</ul>
<p>中断（hardware interrupt）</p>
<ul>
<li>来自硬件设备的处理请求</li>
</ul>
<h4 id="中断、异常和系统调用的比较"><a href="#中断、异常和系统调用的比较" class="headerlink" title="中断、异常和系统调用的比较"></a>中断、异常和系统调用的比较</h4><p>三者大致能按这三种方式进行分类</p>
<ul>
<li><p>源头</p>
<ul>
<li>中断：外设</li>
<li>异常：应用程序意想不到的行为</li>
<li>系统调用：应用程序请求操作提供服务</li>
</ul>
</li>
<li><p>响应方式</p>
<ul>
<li>异步</li>
<li>同步</li>
<li>异步或同步</li>
</ul>
</li>
<li><p>处理机制</p>
<ul>
<li>&#x3D;&#x3D;中断：持续，对用户应用程序是透明的&#x3D;&#x3D;</li>
<li>异常：杀死或者重新执行意想不到的应用程序指令</li>
<li>&#x3D;&#x3D;系统调用：等待和持续&#x3D;&#x3D;</li>
</ul>
</li>
</ul>
<img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220519173405688.png" alt="image-20220519173405688" style="zoom: 50%;">

<blockquote>
<p>响应方式：</p>
<p>同步：发生异常，应用程序等待异常处理，处理完再去做别的事情</p>
<p>异步：发生中断请求，应用程序可以去干别的事情，等到处理完在回来</p>
</blockquote>
<h4 id="中断和异常的处理机制"><a href="#中断和异常的处理机制" class="headerlink" title="中断和异常的处理机制"></a>中断和异常的处理机制</h4><h5 id="硬件处理"><a href="#硬件处理" class="headerlink" title="硬件处理"></a>硬件处理</h5><ul>
<li>在CPU初始化时设置中断使能标志<ul>
<li>依据内部或外部事件设置中断标志</li>
<li>依据中断向量调用相应中断服务例程</li>
</ul>
</li>
</ul>
<p>这些都是由硬件完成的：</p>
<blockquote>
<p>中断使能标志：在CPU初始化时不接收任何中断请求</p>
<p>中断标志：标志外部事件或内部事件</p>
<p>中断类型（中断向量）：提供相应服务</p>
</blockquote>
<h5 id="软件处理"><a href="#软件处理" class="headerlink" title="软件处理"></a>软件处理</h5><ul>
<li>现场保存（编译器）</li>
<li>中断服务处理（服务例程）</li>
<li>清除中断标记（服务例程）</li>
<li>现场恢复（编译器）</li>
</ul>
<p><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220519175800417.png" alt="image-20220519175800417"></p>
<h4 id="中断嵌套"><a href="#中断嵌套" class="headerlink" title="中断嵌套"></a>中断嵌套</h4><p>硬件中断服务例程可被打断</p>
<ul>
<li>不同硬件中断源可能硬件中断处理时出现</li>
<li>硬件中断服务例程中需要临时禁止中断请求</li>
<li>中断请求会保持到CPU做出响应</li>
</ul>
<p>异常服务例程可被打断</p>
<ul>
<li>异常服务例程执行时可能出现硬件中断</li>
</ul>
<p>异常服务例程可嵌套</p>
<ul>
<li>异常服务例程可能出现缺页</li>
</ul>
<blockquote>
<p>中断的优先级判断打断当前中断处理</p>
<p>在执行中断有一段时间里要禁止中断请求（关中断）</p>
</blockquote>
<h2 id="4、系统调用"><a href="#4、系统调用" class="headerlink" title="4、系统调用"></a>4、系统调用</h2><h4 id="标准C库例子"><a href="#标准C库例子" class="headerlink" title="标准C库例子"></a>标准C库例子</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220519180746448.png" alt="image-20220519180746448" style="zoom:50%;">

<h4 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h4><ul>
<li>操作系统服务的编程接口</li>
<li>通常由高级语言编写（C或者C++）</li>
<li>程序访问通常是通过高层次的API接口而不是直接进行系统调用</li>
<li>三种最常用的应用程序编程接口（API）<ul>
<li>Win32 API用于Windows</li>
<li>POSIX API用于POSIX-based systems（包括UNIX，LINUX，Mac OS X的所有版本）</li>
<li>Java API用于JAVA虚拟机（JVM）</li>
</ul>
</li>
</ul>
<h4 id="系统调用的实现"><a href="#系统调用的实现" class="headerlink" title="系统调用的实现"></a>系统调用的实现</h4><p>每个系统调用对应一个系统调用号</p>
<ul>
<li>系统调用接口根据系统调用号来维护表的索引</li>
</ul>
<p>系统调用接口调用内核态中的系统调用功能实现，并返回系统调用的状态和结果</p>
<p>用户不需要知道系统调用的实现</p>
<ul>
<li>需要设置调用参数和获取返回结果</li>
<li>操作系统接口的细节大部分都隐藏在应用编程接口后，&#x3D;&#x3D;通过运行程序支持的库来管理&#x3D;&#x3D;</li>
</ul>
<img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220519173405688.png" alt="image-20220519173405688" style="zoom: 50%;">

<blockquote>
<p>系统调用号：用来查找系统调用表上对应号的系统调用</p>
</blockquote>
<h4 id="函数调用和系统调用的不同处"><a href="#函数调用和系统调用的不同处" class="headerlink" title="函数调用和系统调用的不同处"></a>函数调用和系统调用的不同处</h4><p>系统调用</p>
<ul>
<li><p>INT和IRET指令用于系统调用</p>
<p>&#x3D;&#x3D;系统调用时，堆栈切换和特权级的转换&#x3D;&#x3D;</p>
</li>
</ul>
<p>函数调用</p>
<ul>
<li><p>CALL和RET用于常规调用</p>
<p>&#x3D;&#x3D;常规调用时没有堆栈切换&#x3D;&#x3D;</p>
</li>
</ul>
<p>Intel 64 and IA-32 Architectures Software Developer(英特尔 64 位和 IA-32 架构软件开发人员手册)</p>
<blockquote>
<p>Manuals <a target="_blank" rel="noopener" href="http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html">http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html</a></p>
</blockquote>
<img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220519173405688.png" alt="image-20220519173405688" style="zoom: 50%;">

<blockquote>
<p>系统调用：</p>
<ul>
<li>需要堆栈的切换，内核态和用户态不能共用一个堆栈来存取信息，不安全</li>
<li>切换到内核态后拥有特权去完成响应工作</li>
</ul>
<p>函数调用：</p>
<ul>
<li>一直在用户态没有堆栈切换</li>
</ul>
</blockquote>
<h4 id="中断、异常和系统调用的开销"><a href="#中断、异常和系统调用的开销" class="headerlink" title="中断、异常和系统调用的开销"></a>中断、异常和系统调用的开销</h4><ul>
<li><p>超过函数调用</p>
</li>
<li><p>中断、异常和系统调用</p>
<ul>
<li><p>引导机制</p>
</li>
<li><p>建立内核堆栈</p>
</li>
<li><p>验证参数</p>
</li>
<li><p>内核态映射到用户态的地址空间</p>
<p>&#x3D;&#x3D;更新页面映射权限&#x3D;&#x3D;</p>
</li>
</ul>
</li>
<li><p>内核态独立地址空间</p>
<p>&#x3D;&#x3D;TLB&#x3D;&#x3D;</p>
</li>
</ul>
<blockquote>
<p>用户态切换到内核态的开销大</p>
<p>TLB（快表） TLB价值：<strong>能够有效减少寻找物理地址所消耗时间</strong>。TLB(Translation Lookaside Buffer)转换检测缓冲区是一个内存管理单元,用于改进虚拟地址到物理地址转换速度的缓存。</p>
</blockquote>
<h2 id="5、系统调用示例"><a href="#5、系统调用示例" class="headerlink" title="5、系统调用示例"></a>5、系统调用示例</h2><h4 id="文件复制过程中的系统调用序列"><a href="#文件复制过程中的系统调用序列" class="headerlink" title="文件复制过程中的系统调用序列"></a>文件复制过程中的系统调用序列</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220519191756545.png" alt="image-20220519191756545" style="zoom:50%;">

<blockquote>
<p>各种设备在文件系统中都被抽象为文件，例如键盘、显示器</p>
</blockquote>
<h4 id="系统调用示例"><a href="#系统调用示例" class="headerlink" title="系统调用示例"></a>系统调用示例</h4><p>在ucore中库函数read()的功能是读文件</p>
<ul>
<li>user&#x2F;libs&#x2F;file.h:int read(int fd, void * buf ,int length)</li>
</ul>
<p>库函数read()的参数和返回值</p>
<ul>
<li>int fd—文件句柄</li>
<li>void * buf—数据缓冲区指针</li>
<li>int length一数据缓冲区长度</li>
<li>int return_value:返回读出数据长度</li>
</ul>
<p>库函数read()使用示例</p>
<ul>
<li>in sfs filetestl.c: ret &#x3D; read(fd，data，len）；</li>
</ul>
<h4 id="系统调用库的接口示例"><a href="#系统调用库的接口示例" class="headerlink" title="系统调用库的接口示例"></a>系统调用库的接口示例</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220519192343705.png" alt="image-20220519192343705" style="zoom:50%;">

<blockquote>
<p>第一部分是将各种元素压栈，之后调用函数调用，int是系统调用指令</p>
</blockquote>
<h4 id="ucore系统调用read-fd-buffer-length-的实现"><a href="#ucore系统调用read-fd-buffer-length-的实现" class="headerlink" title="ucore系统调用read(fd , buffer , length)的实现"></a>ucore系统调用read(fd , buffer , length)的实现</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220519193732177.png" alt="image-20220519193732177" style="zoom: 50%;">

<p>1、进入到内核态的中断（软中断），都会转到一段汇编程序，alltraps程序，在这里你会得到中断的相关信息组成的数据结构，即 tf 这个数据结构</p>
<p>2、查看中断向量trapno ，跳转到系统调用的函数中</p>
<p>3、读取eax，即系统调用编号，跳转到响应的系统调用函数</p>
<p>4、读取sp，那三个参数</p>
<p>5、调用硬件驱动设备开始执行</p>
<p>6、返回读取长度到用户态，执行结束</p>
<h1 id="三、物理内存管理-连续内存分配"><a href="#三、物理内存管理-连续内存分配" class="headerlink" title="三、物理内存管理::连续内存分配"></a>三、物理内存管理::连续内存分配</h1><h2 id="1、计算机体系结构和内存层次"><a href="#1、计算机体系结构和内存层次" class="headerlink" title="1、计算机体系结构和内存层次"></a>1、计算机体系结构和内存层次</h2><h4 id="计算机体系结构"><a href="#计算机体系结构" class="headerlink" title="计算机体系结构"></a>计算机体系结构</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220519160931485.png" alt="image-20220519160931485" style="zoom:50%;">

<img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220519200008560.png" alt="image-20220519200008560" style="zoom:50%;">

<blockquote>
<p>高速缓存：将常用的数据、要用的数据、等等提前放入高速缓存中，不需要在到内存中取</p>
</blockquote>
<h4 id="内存层次"><a href="#内存层次" class="headerlink" title="内存层次"></a>内存层次</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220519200327222.png" alt="image-20220519200327222" style="zoom:50%;">

<h4 id="操作系统的内存管理"><a href="#操作系统的内存管理" class="headerlink" title="操作系统的内存管理"></a>操作系统的内存管理</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220519201100008.png" alt="image-20220519201100008" style="zoom:50%;">

<blockquote>
<p>外存：例如磁盘</p>
<p>所有的进程他们地址空间中都有一段相同的地址，即操作系统内核</p>
<p>MMU：其作用是逻辑地址和物理地址之间的转换</p>
<p>抽象：将线性的物理地址转化为逻辑地址</p>
<p>保护：进程间，逻辑地址一样，但是拥有独立的地址空间，互不干扰</p>
<p>共享：访问相同的内存</p>
<p>逻辑地址一样，存入内存中实际的物理是不一样的</p>
</blockquote>
<h4 id="操作系统的内存管理方式"><a href="#操作系统的内存管理方式" class="headerlink" title="操作系统的内存管理方式"></a>操作系统的内存管理方式</h4><p>操作系统中采用的内存管理方式</p>
<ul>
<li><p>重定位（relocation）</p>
</li>
<li><p>分段（segmentation）</p>
</li>
<li><p>分页（paging）</p>
</li>
<li><p>虚拟存储（virtual memory）</p>
<p>目前多数系统（如Linux）采用按需页式虚拟存储</p>
</li>
</ul>
<p>实现高度依赖硬件</p>
<ul>
<li>与计算机存储架构紧耦合</li>
<li>MMU（内存管理单元）：处理CPU存储访问请求的硬件</li>
</ul>
<blockquote>
<p>重定位：将逻辑地址重定位到真正的物理地址</p>
<p>分段：由于分页式虚拟存储器中，页面大小固定，可能遇到一个数据包含在不同的页面，因此引入段式虚拟存储方式</p>
<p>分页：把内存分成若干个页，页是存储的基本单位</p>
</blockquote>
<h2 id="2、地址空间和地址生成"><a href="#2、地址空间和地址生成" class="headerlink" title="2、地址空间和地址生成"></a>2、地址空间和地址生成</h2><h4 id="地址空间的定义"><a href="#地址空间的定义" class="headerlink" title="地址空间的定义"></a>地址空间的定义</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220519204116358.png" alt="image-20220519204116358" style="zoom: 50%;">

<blockquote>
<p>物理地址空间，最大值&#x3D;2^地址总线位数</p>
<p>逻辑地址空间，正在运行的进程所看到的，在寻址时，会将逻辑地址转换为物理地址</p>
</blockquote>
<h4 id="逻辑地址的生成"><a href="#逻辑地址的生成" class="headerlink" title="逻辑地址的生成"></a>逻辑地址的生成</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220519204836338.png" alt="image-20220519204836338" style="zoom:50%;">

<h4 id="地址的生成和限制"><a href="#地址的生成和限制" class="headerlink" title="地址的生成和限制"></a>地址的生成和限制</h4><p>这里说的地址是实际的地址，物理地址</p>
<p>编译时</p>
<ul>
<li>假设起始地址已知</li>
<li>如果起始地址改变，必须重新编译</li>
</ul>
<p>加载时</p>
<ul>
<li>如编译时起始位置未知，编译器需生成可重定位的代码（relocatable code）</li>
<li>加载时，生成绝对地址</li>
</ul>
<p>执行时</p>
<ul>
<li>执行时代码可移动</li>
<li>需地址转换（映射）硬件支持</li>
</ul>
<blockquote>
<p>编译时生成，例如老人机，里面的程序都是写死的，地址开始就生成，也不会变</p>
<p>加载时生成，不灵活，可能在执行时地址被占用</p>
</blockquote>
<h4 id="地址生成过程"><a href="#地址生成过程" class="headerlink" title="地址生成过程"></a>地址生成过程</h4><p>CPU</p>
<ul>
<li>ALU：需要逻辑地址的内存内容</li>
<li>MMU：进行逻辑地址和物理地址的转换</li>
<li>CPU控制逻辑：给总线发送物理地址请求</li>
</ul>
<p>内存</p>
<ul>
<li>发送物理地址的内容给CPU</li>
<li>或接收CPU数据到物理地址</li>
</ul>
<p>操作系统</p>
<ul>
<li>建立逻辑地址LA和物理地址PA的映射</li>
</ul>
<img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220906095538812.png" alt="image-20220906095538812" style="zoom: 80%;">

<blockquote>
<p>物理地址的生成是靠硬件MMU完成，操作系统给提供<strong>页表</strong>帮助地址映射的转换</p>
</blockquote>
<h4 id="地址检查"><a href="#地址检查" class="headerlink" title="地址检查"></a>地址检查</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220519210731187.png" alt="image-20220519210731187" style="zoom: 50%;">

<blockquote>
<p>查看访问的起始位置是不是合法范围内，合法之后加上你的段基址，得到物理地址</p>
</blockquote>
<h2 id="3、连续内存分配"><a href="#3、连续内存分配" class="headerlink" title="3、连续内存分配"></a>3、连续内存分配</h2><h4 id="连续内存分配和内存碎片"><a href="#连续内存分配和内存碎片" class="headerlink" title="连续内存分配和内存碎片"></a>连续内存分配和内存碎片</h4><p>计算机体系结构&#x2F;内存层次</p>
<ul>
<li>给进程分配一块不小于指定大小的连续的物理内存区域</li>
</ul>
<p>内存碎片</p>
<ul>
<li>空闲内存不能被利用</li>
</ul>
<p>外部碎片</p>
<ul>
<li>分配单元之间的未被使用内存</li>
</ul>
<p>内部碎片</p>
<ul>
<li>分配单元内部的未被使用内存</li>
<li>取决于分配单元大小是否要取整</li>
</ul>
<img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220906095800541.png" alt="image-20220906095800541" style="zoom:67%;">

<blockquote>
<p>碎片会造成内存的浪费</p>
</blockquote>
<h4 id="动态分区分配"><a href="#动态分区分配" class="headerlink" title="动态分区分配"></a>动态分区分配</h4><p>动态分区分配</p>
<ul>
<li>当程序被加载执行时，分配一个进程指定大小可变的分区（块、内存块）</li>
<li>分区的地址是连续的</li>
</ul>
<p>操作系统需要维护的数据结构</p>
<ul>
<li>当所有进程的已分配分区</li>
<li>空闲分区（Empty-blocks）</li>
</ul>
<p>动态分区分配策略</p>
<ul>
<li>最先匹配（First-fit）</li>
<li>最佳匹配（Best-fit）</li>
<li>最差匹配（Worst-fit）</li>
</ul>
<img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220906095957720.png" alt="image-20220906095957720" style="zoom: 67%;">

<h4 id="最先匹配策略"><a href="#最先匹配策略" class="headerlink" title="最先匹配策略"></a>最先匹配策略</h4><p>思路：<br>分配n个字节，使用第一个可用的空间比n大的空闲块<br>示例：<br>分配400字节，使用第一个1KB的空闲块。</p>
<img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220906100032876.png" alt="image-20220906100032876" style="zoom:50%;">

<blockquote>
<p>按地址顺序找空闲分区，只要找到第一个大于他所需的分区即可</p>
<p>例如需要400字节，则按地址顺序找，则第一个找到1k字节，分配后表明是哪个进程使用的，剩余在600字节表明空闲分区</p>
</blockquote>
<p>&#x3D;&#x3D;原理和实现&#x3D;&#x3D;</p>
<ul>
<li>空闲分区列表按地址顺序排序</li>
<li>分配过程时，搜索一个合适的分区</li>
<li>释放分区时，检查是否可与临近的空闲分区合并</li>
</ul>
<p>&#x3D;&#x3D;优点&#x3D;&#x3D;</p>
<ul>
<li>简单</li>
<li>在高地址空间有大块的空闲分区</li>
</ul>
<p>&#x3D;&#x3D;缺点&#x3D;&#x3D;</p>
<ul>
<li>外部碎片</li>
<li>分配大块时较慢</li>
</ul>
<blockquote>
<p>优点：都是先找前面，后面有大块还没被分配，如果进程需要大块分区，也可满足</p>
<p>缺点：不是按需分配，所以会有更多的碎片；在分配大块时，向后找时间也会更慢</p>
</blockquote>
<h4 id="最佳匹配策略"><a href="#最佳匹配策略" class="headerlink" title="最佳匹配策略"></a>最佳匹配策略</h4><p>思路：<br>分配n字节分区时，查找并使用不小于n的最小空闲分区<br>示例：<br>分配400字节，使用第3个空闲块（最小）</p>
<img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220906100243804.png" alt="image-20220906100243804" style="zoom:50%;">

<blockquote>
<p>将空闲分区按大小排序，找比需求大的少的进行分配</p>
</blockquote>
<p>&#x3D;&#x3D;原理和实现&#x3D;&#x3D;</p>
<ul>
<li>空闲分区列表按照大小排序</li>
<li>分配时，查找一个合适的分区</li>
<li>释放时，查找并且合并临近的空闲分区（如果找到）</li>
</ul>
<p>&#x3D;&#x3D;优点&#x3D;&#x3D;</p>
<ul>
<li><p>大部分分配的尺寸较小时，效果很好</p>
<p>可避免大的空闲分区被拆分</p>
<p>可减小外部碎片的大小</p>
<p>相对简单</p>
</li>
</ul>
<p>&#x3D;&#x3D;缺点&#x3D;&#x3D;</p>
<ul>
<li>外部碎片</li>
<li>释放分区较慢</li>
<li>容易产生很多无用的小碎片</li>
</ul>
<blockquote>
<p>小碎片基本没用</p>
</blockquote>
<h4 id="最差匹配策略"><a href="#最差匹配策略" class="headerlink" title="最差匹配策略"></a>最差匹配策略</h4><p>思路：<br>分配n字节，使用尺寸不小于n的最大空闲分区<br>示例：<br>分配400字节，使用第2个空闲块（最大）</p>
<img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220906100456573.png" alt="image-20220906100456573" style="zoom:50%;">



<blockquote>
<p>空闲分区按由大到小进行排序，找最大的分区进行分配</p>
</blockquote>
<p>&#x3D;&#x3D;原理和实现&#x3D;&#x3D;</p>
<ul>
<li>空闲分区列表按由大到小排序</li>
<li>分配时，选最大的分区</li>
<li>释放时，检查是否可与临近的空闲分区合并，进行可能的合并</li>
<li>并调整空闲分区列表顺序</li>
</ul>
<p>&#x3D;&#x3D;优点&#x3D;&#x3D;</p>
<ul>
<li>中等大小的分配较多时，效果最好</li>
<li>避免出现太多的小碎片</li>
</ul>
<p>&#x3D;&#x3D;缺点&#x3D;&#x3D;</p>
<ul>
<li>释放分区较慢</li>
<li>外部碎片</li>
<li>容易破坏大的空闲分区，因此后续难以分配大的分区</li>
</ul>
<blockquote>
<p>释放分区慢：释放时，进行搜索空闲分区表，查看是否有与自己相近的空闲分区进行合并，然后合并过后在放入空闲分区表中，过程开销大</p>
</blockquote>
<h2 id="4、碎片整理"><a href="#4、碎片整理" class="headerlink" title="4、碎片整理"></a>4、碎片整理</h2><h4 id="碎片紧凑"><a href="#碎片紧凑" class="headerlink" title="碎片紧凑"></a>碎片紧凑</h4><p>碎片整理</p>
<ul>
<li>通过调整进程占用的分区位置来减少或避免分区碎片</li>
</ul>
<p>碎片紧凑</p>
<ul>
<li><p>通过移动分配给进程的内存分区，以合并外部碎片</p>
</li>
<li><p>碎片紧凑的条件</p>
<p>所有的应用程序可动态重定位</p>
</li>
<li><p>需要解决的问题</p>
<p>什么时候移动？</p>
<p>开销</p>
</li>
</ul>
<img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220906100818444.png" alt="image-20220906100818444" style="zoom:50%;">

<blockquote>
<p>条件：</p>
<ul>
<li>静态加载地址：程序在装入内存前就已经生成绝对地址了，如果进行碎片紧凑，则会导致一些地址找不到而无法执行，需要&#x3D;&#x3D;动态的重定位&#x3D;&#x3D;</li>
<li>动态重定位：即程序在执行期间生成绝对地址，因此在碎片紧凑时只需要将程序的首地址更换为紧凑后的新地址即可</li>
</ul>
<p>什么时候移动：</p>
<ul>
<li>当进程处于等待状态时，进行移动</li>
</ul>
<p>开销：</p>
<ul>
<li>如果为了大一点空闲空间移动所有进程，开销会很大，应按需移动</li>
</ul>
<p>静态装入是指在编程阶段就把物理地址计算好。</p>
<p>可重定位是指在装入时把逻辑地址转换成物理地址，但装入后不能改变</p>
<p>动态重定位是指在执行时再决定装入的地址并装入，装入后有可能会换出，所以同一个模块在内存中的物理地址是可能改变的。</p>
<p>动态重定位是指在作业运行过程中执行到一条访存指令时，再把逻辑地址转换为主存中的物理地址，实际中是通过硬件地址转换机制实现的。</p>
</blockquote>
<h4 id="对换分区"><a href="#对换分区" class="headerlink" title="对换分区"></a>对换分区</h4><p>通过抢占并回收处于等待状态进程的分区，以增大可用内存空间</p>
<img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220906100937826.png" alt="image-20220906100937826" style="zoom: 67%;">

<p>将处于等待状态的进程放入外存，空出内存空间让给新进来的进程</p>
<img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220520113237056.png" alt="image-20220520113237056" style="zoom:50%;">

<img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220520113648224.png" alt="image-20220520113648224" style="zoom:50%;">

<blockquote>
<p>对换分区方式，例如Linux下的swap分区，这使得内存的利用得到很大提升</p>
<p>由于内存和外存的速度差异大，进行交换时开销也会大，还要考虑交换拿些程序比较合适</p>
</blockquote>
<h2 id="5、伙伴系统"><a href="#5、伙伴系统" class="headerlink" title="5、伙伴系统"></a>5、伙伴系统</h2><h4 id="伙伴系统"><a href="#伙伴系统" class="headerlink" title="伙伴系统"></a>伙伴系统</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220520114705657.png" alt="image-20220520114705657" style="zoom:50%;">

<p>把可分配的分区看成2^u，如果你需要的分区大小比2^u的一般还大，则就把这块分区给你，否则继续分割一半在与你所需的分区比较</p>
<p>最大内碎片：可能你刚到比它的一半大1个字节，那么它就将这块分区分配给你，内碎片就比你小一个字节</p>
<h4 id="伙伴系统的实现"><a href="#伙伴系统的实现" class="headerlink" title="伙伴系统的实现"></a>伙伴系统的实现</h4><p>数据结构</p>
<ul>
<li>空闲块按大小和起始地址组织成二维数组</li>
<li>初始状态：只有一个大小为2^u的空闲块</li>
</ul>
<p>分配过程</p>
<ul>
<li>由小到大在空闲块数组中找最小的可用空闲块</li>
<li>如空闲块过大，对可用空闲块进行二等分，直到得到合适的可用空闲块</li>
</ul>
<h4 id="伙伴系统中的分配内存"><a href="#伙伴系统中的分配内存" class="headerlink" title="伙伴系统中的分配内存"></a>伙伴系统中的分配内存</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220520115854076.png" alt="image-20220520115854076" style="zoom: 80%;">

<p>释放合并时，合并起来的块得是2的幂次方，否则不能合并</p>
<img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220520120628423.png" alt="image-20220520120628423" style="zoom:50%;">

<blockquote>
<p>在Linux、Unix中都用伙伴系统的实现，主要用于内核的存储管理</p>
</blockquote>
<h4 id="ucore中的物理内存管理"><a href="#ucore中的物理内存管理" class="headerlink" title="ucore中的物理内存管理"></a>ucore中的物理内存管理</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220520121111878.png" alt="image-20220520121111878" style="zoom:50%;">

<h4 id="ucore中伙伴系统的实现"><a href="#ucore中伙伴系统的实现" class="headerlink" title="ucore中伙伴系统的实现"></a>ucore中伙伴系统的实现</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220520121032645.png" alt="image-20220520121032645" style="zoom:50%;">



<h1 id="四、物理内存管理-非连续存储分配"><a href="#四、物理内存管理-非连续存储分配" class="headerlink" title="四、物理内存管理::非连续存储分配"></a>四、物理内存管理::非连续存储分配</h1><h2 id="1、非连续存储分配的需求背景"><a href="#1、非连续存储分配的需求背景" class="headerlink" title="1、非连续存储分配的需求背景"></a>1、非连续存储分配的需求背景</h2><h4 id="连续分配的缺点"><a href="#连续分配的缺点" class="headerlink" title="连续分配的缺点"></a>连续分配的缺点</h4><ul>
<li>分配给程序的物理内存必须连续</li>
<li>存在外碎片和内碎片</li>
<li>内存分配的动态修改困难</li>
<li>&#x3D;&#x3D;内存利用率较低&#x3D;&#x3D;</li>
</ul>
<h4 id="非连续分配的设计目标"><a href="#非连续分配的设计目标" class="headerlink" title="非连续分配的设计目标"></a>非连续分配的设计目标</h4><ul>
<li><p>连续分配的缺点</p>
</li>
<li><p>非连续分配的设计目标：提高内存利用效率和管理灵活性</p>
<ul>
<li>允许一个程序的使用非连续的物理地址空间</li>
<li>允许共享代码与数据</li>
<li>支持动态加载和动态链接</li>
</ul>
</li>
</ul>
<blockquote>
<p>允许共享代码与数据：很多程序可能用到的同一个函数库，那么可以通过共享这些代码和数据，减少内存的占用</p>
<p>支持动态加载和动态链接：当分配的内存小了，可以动态的进行链接和加载</p>
</blockquote>
<h4 id="非连续分配需要解决的问题"><a href="#非连续分配需要解决的问题" class="headerlink" title="非连续分配需要解决的问题"></a>非连续分配需要解决的问题</h4><p>如何实现虚拟地址和物理地址的转换</p>
<ul>
<li>软件实现（灵活，开销大）</li>
<li>硬件实现（够用，开销小）</li>
</ul>
<blockquote>
<p>地址转换：虚拟地址是连续的，转换为物理地址又不连续了</p>
<p>软件实现：例如你的程序代码非常大，可设计一些数据结构，先将当前要执行一部分代码装入内存，计算好后在拿出在放入另一部分要执行的代码装入内存</p>
<p>硬件实现：地址转换过于频繁，用硬件实现效果更好</p>
</blockquote>
<h4 id="非连续分配的硬件辅助机制"><a href="#非连续分配的硬件辅助机制" class="headerlink" title="非连续分配的硬件辅助机制"></a>非连续分配的硬件辅助机制</h4><p>如何选择非连续分配中的内存分块大小</p>
<ul>
<li>段式存储管理（segmentation）</li>
<li>页式存储管理（paging）</li>
</ul>
<blockquote>
<p>段式存储：以一个段为基本单位，段的单位比较大，在段内的内容物理地址是连续的</p>
<p>页式存储：以一个页为基本单位，页与页之间的物理地址是不连续的</p>
</blockquote>
<h2 id="2、段式存储管理"><a href="#2、段式存储管理" class="headerlink" title="2、段式存储管理"></a>2、段式存储管理</h2><h4 id="段地址空间"><a href="#段地址空间" class="headerlink" title="段地址空间"></a>段地址空间</h4><p>进程的段地址空间由多个段组成</p>
<ul>
<li>主代码段</li>
<li>子模块代码段</li>
<li>公用库代码段</li>
<li>堆栈段（stack）</li>
<li>堆数据（heap）</li>
<li>初始化数据段</li>
<li>符号表等</li>
</ul>
<p>段式存储管理的目的</p>
<ul>
<li>&#x3D;&#x3D;更细粒度和灵活的分离与共享&#x3D;&#x3D;</li>
</ul>
<img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220906101523811.png" alt="image-20220906101523811" style="zoom: 67%;">

<img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220521170136268.png" alt="image-20220521170136268" style="zoom:50%;">

<blockquote>
<p>段内地址是连续的，可以通过偏移量来进行访问，段与段之间很少有进行跨段访问的</p>
</blockquote>
<h4 id="段地址空间的逻辑视图"><a href="#段地址空间的逻辑视图" class="headerlink" title="段地址空间的逻辑视图"></a>段地址空间的逻辑视图</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220521170355171.png" alt="image-20220521170355171" style="zoom:50%;">

<blockquote>
<p>段与段之间，逻辑地址是连续的，分配段物理地址空间可以是不连续的</p>
</blockquote>
<h4 id="段的概念和段访问机制"><a href="#段的概念和段访问机制" class="headerlink" title="段的概念和段访问机制"></a>段的概念和段访问机制</h4><p>段的概念</p>
<ul>
<li>段表示访问方式和存储数据等属性相同的一段地址空间</li>
<li>对应一个连续的内存“块”</li>
<li>若干个段组成进程逻辑地址空间</li>
</ul>
<p>段访问：逻辑地址由二元组（s，addr）表示</p>
<ul>
<li>s — 段号</li>
<li>addr — 段内偏移</li>
</ul>
<img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220906101815077.png" alt="image-20220906101815077" style="zoom: 67%;">

<h4 id="段访问的硬件实现"><a href="#段访问的硬件实现" class="headerlink" title="段访问的硬件实现"></a>段访问的硬件实现</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220521170912527.png" alt="image-20220521170912527" style="zoom: 67%;">

<blockquote>
<p>同段号查询对应段描述符，得到段基址和段长度，将硬件MMU将段内偏移与段长度比较判断是否存在访问越界，则加上段基址得到物理地址</p>
</blockquote>
<h2 id="3、页式存储管理"><a href="#3、页式存储管理" class="headerlink" title="3、页式存储管理"></a>3、页式存储管理</h2><h4 id="页帧和页面"><a href="#页帧和页面" class="headerlink" title="页帧和页面"></a>页帧和页面</h4><p>页帧（帧、物理页面，Frame，Page Frame）</p>
<ul>
<li>把物理地址空间划分为大小相同的基本分配单位</li>
<li>2的n次方，如512，4096，8192</li>
</ul>
<p>页面（页、逻辑页面，Page）</p>
<ul>
<li>把逻辑地址空间也划分为相同大小的基本分配单位</li>
<li>帧和页的大小必须是相同的</li>
</ul>
<blockquote>
<p>页帧为2的n次方：便于地址的快速转换，因为在计算机中二进制移位是快速乘法的一种方式</p>
<p>页帧是：描述物理页帧；页面是：描述逻辑页面</p>
</blockquote>
<p>页面到页顿</p>
<ul>
<li>逻辑地址到物理地址的转换</li>
<li>页表</li>
<li>&#x3D;&#x3D;MMU &#x2F; TLB&#x3D;&#x3D;</li>
</ul>
<h4 id="帧（frame）"><a href="#帧（frame）" class="headerlink" title="帧（frame）"></a>帧（frame）</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220521172040190.png" alt="image-20220521172040190" style="zoom: 67%;">

<h4 id="基于页帧的物理地址计算实例"><a href="#基于页帧的物理地址计算实例" class="headerlink" title="基于页帧的物理地址计算实例"></a>基于页帧的物理地址计算实例</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220521172331127.png" alt="image-20220521172331127" style="zoom: 50%;">

<h4 id="页（page）"><a href="#页（page）" class="headerlink" title="页（page）"></a>页（page）</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220521172558657.png" alt="image-20220521172558657" style="zoom: 67%;">

<h4 id="页表：页式存储中的地址映射"><a href="#页表：页式存储中的地址映射" class="headerlink" title="页表：页式存储中的地址映射"></a>页表：页式存储中的地址映射</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220521172823206.png" alt="image-20220521172823206" style="zoom:67%;">

<p>页表作为地址映射，可使得内存分配的页帧是不连续的</p>
<p><strong>页表</strong></p>
<img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220521173039900.png" alt="image-20220521173039900" style="zoom: 50%;">

<p>页表：逻辑页号到物理帧号之间的转换</p>
<h2 id="4、页表概述"><a href="#4、页表概述" class="headerlink" title="4、页表概述"></a>4、页表概述</h2><h4 id="页表的结构"><a href="#页表的结构" class="headerlink" title="页表的结构"></a>页表的结构</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220521173543107.png" alt="image-20220521173543107" style="zoom: 67%;">

<p>存在位：是否存在一个逻辑页面对应的物理页面</p>
<p>修改位：该页内容是否被修改</p>
<p>引用位：该页最近是否有被引用</p>
<h4 id="页表地址转换示例"><a href="#页表地址转换示例" class="headerlink" title="页表地址转换示例"></a>页表地址转换示例</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220521174043826.png" alt="image-20220521174043826" style="zoom:67%;">

<h4 id="页式存储管理机制的性能问题"><a href="#页式存储管理机制的性能问题" class="headerlink" title="页式存储管理机制的性能问题"></a>页式存储管理机制的性能问题</h4><p>内存访问性能问题</p>
<ul>
<li>访问一个内存单元需要2次内存访问</li>
<li>第一次访问：获取页表项</li>
<li>第二次访问：访问数据</li>
</ul>
<p>页表大小问题：</p>
<ul>
<li>页表可能非常大</li>
<li>64位机器如果每页1024字节，那么一个页表的大小会是多少？</li>
</ul>
<p>如何处理？</p>
<ul>
<li>&#x3D;&#x3D;缓存（Caching）&#x3D;&#x3D;</li>
<li>间接（Indirection）访问</li>
</ul>
<blockquote>
<p>页表大小问题：假设64位机器每页1024，就有2^54个页，假设每个页表项大小只有64位，8字节，那么所以会占用2^57的空间</p>
<p>如何处理：</p>
<p>缓存：由于访问有相邻性，可以一次取出相邻数据或者可能下一次会用的数据放在缓存中，后面会将到的快表</p>
<p>间接访问：页表很大，将页表在分为子表，后面会讲的多级页表</p>
</blockquote>
<h2 id="5、快表和多级页表"><a href="#5、快表和多级页表" class="headerlink" title="5、快表和多级页表"></a>5、快表和多级页表</h2><h4 id="快表（TLB）"><a href="#快表（TLB）" class="headerlink" title="快表（TLB）"></a>快表（TLB）</h4><p>缓存近期访问的页表项</p>
<ul>
<li>TLB使用关联存储（associative memory）实现，具备快速访问性能</li>
<li>如果TLB命中，物理页号可以很快被获取</li>
<li>如果TLB未命中，对应的表项被更新到TLB中</li>
</ul>
<img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220906102239585.png" alt="image-20220906102239585" style="zoom: 80%;">

<h4 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220521185452168.png" alt="image-20220521185452168" style="zoom: 50%;">

<blockquote>
<p>多级页表并未减少页表的大小，但是在实际运行期间，有许多页表是用不到的，那么我们通过存在位判断并将其删除，这就达到大幅度减少页表大小的效果</p>
</blockquote>
<h4 id="二级页表实例"><a href="#二级页表实例" class="headerlink" title="二级页表实例"></a>二级页表实例</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220521185911680.png" alt="image-20220521185911680" style="zoom:50%;">

<blockquote>
<p>一级页表的首地址存在CR3寄存器中，首地址 + p1（页内偏移）得到二级页表的首地址 ，再将其加p2得到内存中页的首地址加偏移量o得到访问位置</p>
</blockquote>
<h2 id="6、反置页表"><a href="#6、反置页表" class="headerlink" title="6、反置页表"></a>6、反置页表</h2><h4 id="大地址空间问题"><a href="#大地址空间问题" class="headerlink" title="大地址空间问题"></a>大地址空间问题</h4><p>对于大地址空间（64-bits）系统，多级页表变得&#x3D;&#x3D;繁琐&#x3D;&#x3D;</p>
<ul>
<li>比如：5级页表</li>
<li>逻辑（虚拟）地址空间增长速度快于物理地址空间</li>
</ul>
<p>页寄存器和反置页面的思路</p>
<ul>
<li>不让页表与逻辑地址空间的大小相对应</li>
<li>让页表与物理地址空间的大小相对应</li>
</ul>
<h4 id="页寄存器"><a href="#页寄存器" class="headerlink" title="页寄存器"></a>页寄存器</h4><p>每个帧与一个页寄存器（Page Register）关联，寄存器内容也括</p>
<ul>
<li>使用位（Residence bit）:此是否被进程占用</li>
<li>占用页号（Occupier）：对应的页号p</li>
<li>保护位（Protection bits）</li>
</ul>
<p>页寄存器示例</p>
<ul>
<li>物理内存大小：4096 * 4096&#x3D;4K * 4KB&#x3D;16MB</li>
<li>页面大小：4096bytes&#x3D;4KB</li>
<li>页顿数：4096&#x3D;4K</li>
<li>页寄存器使用的空间（假设每个页寄存器占8字节）<ul>
<li>N8 * 4096&#x3D;32 Kbytes</li>
</ul>
</li>
<li>页寄存器带来的额外开销<ul>
<li>32K &#x2F; 16M&#x3D;0.2%（大约）</li>
</ul>
</li>
<li>虚拟内存的大小：任意</li>
</ul>
<h4 id="页寄存器方案的特征"><a href="#页寄存器方案的特征" class="headerlink" title="页寄存器方案的特征"></a>页寄存器方案的特征</h4><p>优点</p>
<ul>
<li>页表大小相对于物理内存而言很小</li>
<li>页表大小与逻辑地址空间大小无关</li>
</ul>
<p>缺点</p>
<ul>
<li>页表信息对调后，需要依据帧号可找页号</li>
<li>在页寄存器中搜索逻辑地址中的页号</li>
</ul>
<h4 id="页寄存器中的地址转换"><a href="#页寄存器中的地址转换" class="headerlink" title="页寄存器中的地址转换"></a>页寄存器中的地址转换</h4><p>CPU生成的逻辑地址如何找对应的物理地址？</p>
<ul>
<li>对逻辑地址进行Hash映射，以减少搜索范围</li>
<li>需要解决可能的冲突</li>
</ul>
<p>用快表缓存页表项后的页寄存器搜索步骤</p>
<ul>
<li>对逻辑地址进行Hash变换</li>
<li>在快表中查找对应页表项</li>
<li>有冲突时遍历冲突项链表</li>
<li>查找失败时，产生异常</li>
</ul>
<p>快表的限制</p>
<ul>
<li>快表的容量限制</li>
<li>快表的功耗限制（Strong ARM上快表功耗占27%）</li>
</ul>
<h4 id="反置页表"><a href="#反置页表" class="headerlink" title="反置页表"></a>反置页表</h4><p>基于Hash映射值查找对应页表项中的帧号</p>
<ul>
<li>进程标识与页号的Hash值可能有冲突</li>
<li>页表项中包括保护位、修改位、访问位和存在位等标识</li>
</ul>
<img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220906102650576.png" alt="image-20220906102650576" style="zoom:67%;">

<p>反置页表的背景：</p>
<ul>
<li>为了减少页表所占用的空间，因为每个进程都要分配一个页表，当同时存在多个进程时，页表在内存中的占用会很多，造成内存资源的浪费</li>
</ul>
<p>反置页表的实现：</p>
<p>反置页表不依据进程的逻辑页号来生成页表，而是依据进程在内存的物理页号来组织的，即一个系统中大多数情况下都只存在一个反向页表，通过<strong>逻辑页号+进程ID</strong>进行HASH，通过链接指针来得到对应的帧号（物理页号）</p>
<h4 id="反置页表的hash冲突"><a href="#反置页表的hash冲突" class="headerlink" title="反置页表的hash冲突"></a>反置页表的hash冲突</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220521192158418.png" alt="image-20220521192158418" style="zoom: 50%;">

<p>逻辑地址+进程ID进行hash后，找到hash值对应的反向页表的索引项，PID和页号与hash前的一样则不冲突，不一样则产生冲突，根据链接指针跳转，继续比较，直到找到为至。</p>
<h2 id="7、段页式存储管理"><a href="#7、段页式存储管理" class="headerlink" title="7、段页式存储管理"></a>7、段页式存储管理</h2><h4 id="段页式存储管理"><a href="#段页式存储管理" class="headerlink" title="段页式存储管理"></a>段页式存储管理</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220521193539938.png" alt="image-20220521193539938" style="zoom:67%;">

<p>段式存储在内存保护方面有优势，页式存储在内存利用和优化转移到后备存储方面有优势</p>
<h4 id="段页式存储管理中内存共享"><a href="#段页式存储管理中内存共享" class="headerlink" title="段页式存储管理中内存共享"></a>段页式存储管理中内存共享</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220521194247188.png" alt="image-20220521194247188" style="zoom:67%;">

<p>非连续的存储引入页和页表，随着页表的引入也带来了很多问题，又引入快表、多级页表、反置页表、来解决了这些问题</p>
<h1 id="五、虚拟存储概念"><a href="#五、虚拟存储概念" class="headerlink" title="五、虚拟存储概念"></a>五、虚拟存储概念</h1><h2 id="1、虚拟存储的需求背景"><a href="#1、虚拟存储的需求背景" class="headerlink" title="1、虚拟存储的需求背景"></a>1、虚拟存储的需求背景</h2><h4 id="虚拟存储的概述"><a href="#虚拟存储的概述" class="headerlink" title="虚拟存储的概述"></a>虚拟存储的概述</h4><p>前面讲的存储管理方式都是将一个进程内容全部装入内存才去运行</p>
<ul>
<li><p>当作业占用的空间很大时，超过了内存的空间，致使该作业无法运行</p>
</li>
<li><p>当有大量作业需要运行时，内存容量不足以容纳所有作业，只能将少数作业装入内存运行，将其他大量作业驻留外存中等待</p>
</li>
</ul>
<p>解决方法：</p>
<ul>
<li>扩大内存容量</li>
<li>从逻辑上扩充内存容量，即虚拟存储技术</li>
</ul>
<h4 id="增长迅速的存储需求"><a href="#增长迅速的存储需求" class="headerlink" title="增长迅速的存储需求"></a>增长迅速的存储需求</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220521200506021.png" alt="image-20220521200506021" style="zoom:50%;">

<h4 id="存储层次结构"><a href="#存储层次结构" class="headerlink" title="存储层次结构"></a>存储层次结构</h4><p>理想中的存储器</p>
<ul>
<li>容量更大、速度更快、价格更便宜的非易失性存储器</li>
</ul>
<p>实际中的存储器</p>
<img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220906102801235.png" alt="image-20220906102801235" style="zoom: 67%;">

<h4 id="操作系统的存储抽象"><a href="#操作系统的存储抽象" class="headerlink" title="操作系统的存储抽象"></a>操作系统的存储抽象</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220521200923911.png" alt="image-20220521200923911" style="zoom: 50%;">

<p>存储介质是多种多样的，如果直接让用户使用这里存储介质的话，那么写出来的程序通用性就会很受限制，所以使用操作系统进行抽象，这种映射关系由操作系统自动来做，用户见到的空间就是上面抽象到的地址空间，这样通用性就会不错</p>
<h4 id="虚拟存储的需求"><a href="#虚拟存储的需求" class="headerlink" title="虚拟存储的需求"></a>虚拟存储的需求</h4><p>计算机系统时常出现&#x3D;&#x3D;内存空间不够用&#x3D;&#x3D;</p>
<ul>
<li><p>覆盖（overlay）</p>
<p>应用程序&#x3D;&#x3D;手动&#x3D;&#x3D;把需要的指令和数据保存在内存中</p>
</li>
<li><p>交换（swapping）</p>
<p>操作系统&#x3D;&#x3D;自动&#x3D;&#x3D;把暂时不能执行的程序保存到外存中</p>
</li>
<li><p>虚拟存储</p>
<p>在有限容量的内存中，以页为单位&#x3D;&#x3D;自动&#x3D;&#x3D;装入&#x3D;&#x3D;更多更大&#x3D;&#x3D;的程序</p>
</li>
</ul>
<h2 id="2、覆盖和交换"><a href="#2、覆盖和交换" class="headerlink" title="2、覆盖和交换"></a>2、覆盖和交换</h2><h4 id="覆盖技术"><a href="#覆盖技术" class="headerlink" title="覆盖技术"></a>覆盖技术</h4><p>目标</p>
<ul>
<li>在较小的可用内存中运行较大的程序</li>
</ul>
<p>方法</p>
<ul>
<li><p>依据程序逻辑结构，将程序划分为&#x3D;&#x3D;若干功能相对独立&#x3D;&#x3D;<br>的模块</p>
</li>
<li><p>将不会同时执行的模块&#x3D;&#x3D;共享同一块内存&#x3D;&#x3D;区域</p>
<p>必要部分（常用功能）的代码和数据常驻内存</p>
<p>可选部分（不常用功能）放在其他程序模块中，只在需要用到时装入内存</p>
<p>不存在调用关系的模块可相互覆盖，共用同一块内存区域</p>
</li>
</ul>
<h4 id="覆盖技术实例"><a href="#覆盖技术实例" class="headerlink" title="覆盖技术实例"></a>覆盖技术实例</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220521203255864.png" alt="image-20220521203255864" style="zoom:50%;">

<h4 id="覆盖技术的不足"><a href="#覆盖技术的不足" class="headerlink" title="覆盖技术的不足"></a>覆盖技术的不足</h4><p>增加编程困难</p>
<ul>
<li>需程序员划分功能模块，并确定模块间的覆盖关系</li>
<li>增加了编程的复杂度</li>
</ul>
<p>增加执行时间</p>
<ul>
<li>从外存装入覆盖模块</li>
<li>时间换空间</li>
</ul>
<img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220906103209555.png" alt="image-20220906103209555" style="zoom:67%;">

<h4 id="交换技术"><a href="#交换技术" class="headerlink" title="交换技术"></a>交换技术</h4><p>目标</p>
<ul>
<li>增加正在运行或需要运行的程序的内存</li>
</ul>
<p>实现方法</p>
<ul>
<li><p>可将暂时不能运行的程序放到外存</p>
</li>
<li><p>换入换出的基本单位</p>
<p>整个进程的地址空间</p>
</li>
<li><p>换出（swapout）</p>
<p>把一个进程的整个地址空间保存到外存</p>
</li>
<li><p>换入（swapin）</p>
<p>将外存中某进程的地址空间读入到内存</p>
</li>
</ul>
<blockquote>
<p>以进程为单位的交换技术</p>
</blockquote>
<h4 id="交换技术面临的问题"><a href="#交换技术面临的问题" class="headerlink" title="交换技术面临的问题"></a>交换技术面临的问题</h4><p>交换时机：何时需要发生交换？</p>
<ul>
<li>只当内存空间不够或有不够的可能时换出</li>
</ul>
<p>交换区大小</p>
<ul>
<li>存放所有用户进程的所有内存映像的接贝</li>
</ul>
<p>程序换入时的重定位：换出后再换入时要放在原处吗？</p>
<ul>
<li>采用动态地址映射的方法</li>
</ul>
<h3 id="覆盖和交换技术的比较"><a href="#覆盖和交换技术的比较" class="headerlink" title="覆盖和交换技术的比较"></a>覆盖和交换技术的比较</h3><p>覆盖</p>
<ul>
<li>只能发生在没有调用关系的模块间</li>
<li>程序员须给出模块间的逻辑覆盖结构</li>
<li>发生在运行程序的内部模块间</li>
</ul>
<p>交换</p>
<ul>
<li>以进程为单位</li>
<li>不需要模块间的逻辑覆盖结构</li>
<li>发生在内存进程间</li>
</ul>
<blockquote>
<p>交换技术是可以由操作系统来做的，覆盖技术对于操作系统来说还是有一定难度</p>
</blockquote>
<h2 id="3、局部性原理"><a href="#3、局部性原理" class="headerlink" title="3、局部性原理"></a>3、局部性原理</h2><h4 id="虚拟存储技术的目标"><a href="#虚拟存储技术的目标" class="headerlink" title="虚拟存储技术的目标"></a>虚拟存储技术的目标</h4><p><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220906103436316.png" alt="image-20220906103436316"></p>
<p>只把部分程序放到内存中，从而运行比物理内存大的程序</p>
<ul>
<li>由操作系统自动完成，无需程序员的干涉</li>
</ul>
<p>实现进程在内存与外存之间的交换，从而获得更多的空闲内存空间</p>
<ul>
<li>在内存和外存之间只交换进程的部分内容</li>
</ul>
<h4 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h4><p>程序在执行过程中的一个较短时期，所执行的指令地址和指令的操作数地址，分别局限于一定区域</p>
<ul>
<li><p>时间局部性</p>
<p>一条指令的一次执行和下次执行，一个数据的一次访问和下次访问都集中在一个较短时期内</p>
</li>
<li><p>空间局部性</p>
<p>当前指令和邻近的几条指令，当前访问的数据和邻近的几个数据都集中在一个较小区域内</p>
</li>
<li><p>分支局部性</p>
<p>一条跳转指令的两次执行，很可能跳到相同的内存位置</p>
</li>
<li><p>局部性原理的意义</p>
<p>从理论上来说，虚拟存储技术是能够实现的，而且可取得满意的效果</p>
</li>
</ul>
<h4 id="局部性特征举例"><a href="#局部性特征举例" class="headerlink" title="局部性特征举例"></a>局部性特征举例</h4><p>例子：页面大小为4K，分配给每个进程的物理页面数为1。在一个进程中，定义了如下的二维数组<br>int A [ 1024 ] [ 1024 ]，该数组按行存放在内存，<br>每一行放在一个页面中。</p>
<img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220906103712904.png" alt="image-20220906103712904" style="zoom:67%;">

<img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220521210317046.png" alt="image-20220521210317046" style="zoom:50%;">

<h2 id="4、虚拟存储概念"><a href="#4、虚拟存储概念" class="headerlink" title="4、虚拟存储概念"></a>4、虚拟存储概念</h2><h4 id="虚拟存储的基本概念"><a href="#虚拟存储的基本概念" class="headerlink" title="虚拟存储的基本概念"></a>虚拟存储的基本概念</h4><p>思路</p>
<ul>
<li>将不常用的部分内存块暂存到外存</li>
</ul>
<p>原理</p>
<ul>
<li><p>装载程序时</p>
<p>&#x3D;&#x3D;只将当前指令执行需要的部分页面或段装入内存&#x3D;&#x3D;</p>
</li>
<li><p>指令执行中需要的指令或数据不在内存（称为缺页或缺段）时</p>
<p>&#x3D;&#x3D;处理器通知操作系统将相应的页面或段调入内存&#x3D;&#x3D;</p>
</li>
<li><p>操作系统将内存中暂时不用的页面或段保存到外存</p>
</li>
</ul>
<p>实现方式</p>
<ul>
<li>虚拟页式存储</li>
<li>虚拟段式存储</li>
</ul>
<blockquote>
<p>后面讲的置换算法研究操作系统怎么讲内存中暂时不用的页面或段保存到外存</p>
</blockquote>
<h4 id="虚拟存储的基本特征"><a href="#虚拟存储的基本特征" class="headerlink" title="虚拟存储的基本特征"></a>虚拟存储的基本特征</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220906103436316.png" alt="image-20220906103436316" style="zoom:67%;">

<p>不连续性</p>
<ul>
<li>物理内存分配非连续</li>
<li>虚拟地址空间使用非连续</li>
</ul>
<p>大用户空间</p>
<ul>
<li>提供给用户的虚拟内存可大于实际的物理内存</li>
</ul>
<p>部分交换</p>
<ul>
<li>虚拟存储只对部分虚拟地址空间进行调入和调出</li>
</ul>
<blockquote>
<p>虚拟存储改进了原来的覆盖和交换技术</p>
<p>改进交换技术：允许部分虚拟地址换进换出，而不是整个作业</p>
</blockquote>
<h4 id="虚拟存储的支持技术"><a href="#虚拟存储的支持技术" class="headerlink" title="虚拟存储的支持技术"></a>虚拟存储的支持技术</h4><p>硬件</p>
<ul>
<li>页式或短时存储中的地址转换机制</li>
</ul>
<p>操作系统</p>
<ul>
<li>管理内存和外存间页面或段的换入和换出</li>
</ul>
<h2 id="5、虚拟页式存储"><a href="#5、虚拟页式存储" class="headerlink" title="5、虚拟页式存储"></a>5、虚拟页式存储</h2><h4 id="虚拟页式存储管理"><a href="#虚拟页式存储管理" class="headerlink" title="虚拟页式存储管理"></a>虚拟页式存储管理</h4><p>在页式存储管理的基础上，增加请求调页和页面置换</p>
<p>思路:</p>
<ul>
<li>当用户程序要装载到内存运行时，只装入部分页面，就启动程序运行</li>
<li>进程在运行中发现有需要的代码或数据不在内存时，则向系统发出缺页异常请求</li>
<li>操作系统在处理缺页异常时，将外存中相应的页面调入内存，使得进程能继续运行</li>
</ul>
<h4 id="虚拟页式存储中的地址转换"><a href="#虚拟页式存储中的地址转换" class="headerlink" title="虚拟页式存储中的地址转换"></a>虚拟页式存储中的地址转换</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220522131245170.png" alt="image-20220522131245170" style="zoom: 50%;">

<blockquote>
<p>不同于之前的存储管理，这里加上了标志位，表示该页号是否存在内存中，不存在则发生缺页异常，有操作系统接管进行处理，即将该页从外存中调入，将标志位设置为有效</p>
</blockquote>
<h4 id="虚拟页式存储中的页表项结构"><a href="#虚拟页式存储中的页表项结构" class="headerlink" title="虚拟页式存储中的页表项结构"></a>虚拟页式存储中的页表项结构</h4><p><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220906104152938.png" alt="image-20220906104152938"></p>
<p>驻留位：表示该页是否在内存</p>
<p>修改位：表示在内存中的该页是否被修改过</p>
<p>访问位：表示该页面是否被访问过（读或写）</p>
<p>保护位：表示该页的允许访问方式</p>
<ul>
<li>只读、可读写、可执行等</li>
</ul>
<blockquote>
<p>修改位：是否被修改，判断将该页替换后是否要写回内存还是删除</p>
</blockquote>
<h4 id="虚拟页式存储示例"><a href="#虚拟页式存储示例" class="headerlink" title="虚拟页式存储示例"></a>虚拟页式存储示例</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220522132449138.png" alt="image-20220522132449138" style="zoom:50%;">

<h4 id="X86页表结构"><a href="#X86页表结构" class="headerlink" title="X86页表结构"></a>X86页表结构</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220522132756973.png" alt="image-20220522132756973" style="zoom:50%;">

<p>这里的访问方式和页式存储没有差别，差别在于页表项多了许多标志位</p>
<h4 id="X86页表项结构"><a href="#X86页表项结构" class="headerlink" title="X86页表项结构"></a>X86页表项结构</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220522133259935.png" alt="image-20220522133259935" style="zoom:67%;">

<h2 id="6、缺页异常"><a href="#6、缺页异常" class="headerlink" title="6、缺页异常"></a>6、缺页异常</h2><h4 id="缺页异常（缺页中断）的处理流程"><a href="#缺页异常（缺页中断）的处理流程" class="headerlink" title="缺页异常（缺页中断）的处理流程"></a>缺页异常（缺页中断）的处理流程</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220522133943566.png" alt="image-20220522133943566" style="zoom:67%;">

<h4 id="虚拟页式存储中的外存管理"><a href="#虚拟页式存储中的外存管理" class="headerlink" title="虚拟页式存储中的外存管理"></a>虚拟页式存储中的外存管理</h4><p>在何处保存未被映射的页？</p>
<ul>
<li><p>应能方便地找到在外存中的页面内容</p>
</li>
<li><p>交换空间（磁盘或者文件）</p>
<p>&#x3D;&#x3D;采用特殊格式存储未被映射的页面&#x3D;&#x3D;</p>
</li>
</ul>
<p>虚拟页式存储中的外存选择</p>
<ul>
<li>代码段：可执行二进制文件</li>
<li>动态加载的共享库程序段：动态调用的库文件</li>
<li>其它段：交换空间</li>
</ul>
<blockquote>
<p>在外存以两种方式来存放文件：</p>
<ul>
<li>专门做一个分区来进行存放（文件区）</li>
<li>用一个特殊格式的文件来进行存放（对换区）</li>
</ul>
<p>文件区采用离散分配方式，对换区采用连续分配方式，所以对换区数据存取（磁盘I&#x2F;O）速度比文件区高。</p>
<p>外存的存储选择：</p>
<ul>
<li><p>可能会被修改的文件放到对换区，不会被修改的文件放到文件区</p>
</li>
<li><p>代码段和动态加载的共享库程序段都是直接指向对应的文件，一般不会去修改它，不用复制到交换空间去</p>
</li>
</ul>
</blockquote>
<h4 id="虚拟页式存储管理的性能"><a href="#虚拟页式存储管理的性能" class="headerlink" title="虚拟页式存储管理的性能"></a>虚拟页式存储管理的性能</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220522162531222.png" alt="image-20220522162531222" style="zoom: 50%;">



<h1 id="六、页面置换算法"><a href="#六、页面置换算法" class="headerlink" title="六、页面置换算法"></a>六、页面置换算法</h1><h2 id="1、页面置换算法的概念"><a href="#1、页面置换算法的概念" class="headerlink" title="1、页面置换算法的概念"></a>1、页面置换算法的概念</h2><h4 id="置换算法的功能、目标和页面锁定"><a href="#置换算法的功能、目标和页面锁定" class="headerlink" title="置换算法的功能、目标和页面锁定"></a>置换算法的功能、目标和页面锁定</h4><p>功能</p>
<ul>
<li>当出现缺页异常，需调入新页面而内存已满时，置换算法&#x3D;&#x3D;选择被置换的物理页面&#x3D;&#x3D;</li>
</ul>
<p>设计目标</p>
<ul>
<li>尽可能&#x3D;&#x3D;减少页面的调入调出次数&#x3D;&#x3D;</li>
<li>把未来不再访问或短期内不访问的页面调出</li>
</ul>
<p>页面锁定（frame locking）</p>
<ul>
<li>描述必须常驻内存的逻辑页面</li>
<li>操作系统的关键部分</li>
<li>要求响应速度的代码和数据</li>
<li>页表中的锁定标志位（lock bit）</li>
</ul>
<h4 id="置换算法的评价方法"><a href="#置换算法的评价方法" class="headerlink" title="置换算法的评价方法"></a>置换算法的评价方法</h4><p>记录进程访问内存的页面轨迹</p>
<ul>
<li>举例：虚拟地址访问用（页号，位移）表示<br>（3,0），（1,9），（4,1），（2,1），（5,3），（2,0），（1,9）（2,4)，（3,1），（4.8）</li>
<li>对应的页面轨迹<br>3,1,4,2,5,2,1,2,3.4<br>替换如c，a，d，b，e，b，a，b，c，d</li>
</ul>
<p>评价方法</p>
<ul>
<li>模拟页面置换行为，记录产生缺页的次数</li>
<li>更少的缺页，更好的性能</li>
</ul>
<h4 id="页面置换算法分类"><a href="#页面置换算法分类" class="headerlink" title="页面置换算法分类"></a>页面置换算法分类</h4><p>局部页面置换算法</p>
<ul>
<li>置换页面的选择范围仅限于当前进程占用的物理页面内</li>
<li>最优算法、先进先出算法、最近最久未使用算法</li>
<li>时钟算法、最不常用算法</li>
</ul>
<p>全局页面置换算法</p>
<ul>
<li>置换页面的选择范围是所有可换出的物理页面</li>
<li>工作集算法、缺页率算法</li>
</ul>
<h2 id="2、最优算法、先进先出算法和最近最久未使用算法"><a href="#2、最优算法、先进先出算法和最近最久未使用算法" class="headerlink" title="2、最优算法、先进先出算法和最近最久未使用算法"></a>2、最优算法、先进先出算法和最近最久未使用算法</h2><h4 id="最优页面置换算法OPT"><a href="#最优页面置换算法OPT" class="headerlink" title="最优页面置换算法OPT"></a>最优页面置换算法OPT</h4><p>基本思路：</p>
<ul>
<li>置换在未来最长时间不访问的页面</li>
</ul>
<p>算法实现：</p>
<ul>
<li>缺页时，计算内存中每个逻辑页面的下一次访问时间</li>
<li>选择未来最长时间不访问页面</li>
</ul>
<p>算法特征：</p>
<ul>
<li>缺页最少，是理想情况</li>
<li>实际系统中<strong>无法实现</strong></li>
<li>无法预知每个页面在下次访问前的等待时间</li>
<li>作为置换算法的性能评价依据<ul>
<li>在模拟器上运行某个程序，并记录每一次的页面访问情况</li>
<li>第二遍运行时使用最优算法</li>
</ul>
</li>
</ul>
<blockquote>
<p>该算法在实际系统时无法实现的，但可以作为评判置换算法性能的依据</p>
</blockquote>
<h4 id="OPT算法示例"><a href="#OPT算法示例" class="headerlink" title="OPT算法示例"></a>OPT算法示例</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220522170323499.png" alt="image-20220522170323499" style="zoom: 67%;">

<h4 id="先进先出算法FIFO"><a href="#先进先出算法FIFO" class="headerlink" title="先进先出算法FIFO"></a>先进先出算法FIFO</h4><p>思路</p>
<ul>
<li>选择<strong>在内存驻留时间最长</strong>的页面进行置换</li>
</ul>
<p>实现</p>
<ul>
<li>维护一个记录所有位于内存中的逻辑页面链表</li>
<li>链表元素<strong>按驻留内存的时间排序</strong>，链首最长，链尾最短</li>
<li>出现缺页时，选择链首页面进行置换，新页面加到链尾</li>
</ul>
<p>特征</p>
<ul>
<li>实现简单</li>
<li>性能较差，调出的页面可能是经常访问的</li>
<li>进程分配物理页面数增加时，缺页并不一定减少（Belady现象）</li>
<li>很少单独使用</li>
</ul>
<h4 id="FIFO算法示例"><a href="#FIFO算法示例" class="headerlink" title="FIFO算法示例"></a>FIFO算法示例</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220522171550635.png" alt="image-20220522171550635" style="zoom: 67%;">

<h4 id="最近最未被使用算法LRU"><a href="#最近最未被使用算法LRU" class="headerlink" title="最近最未被使用算法LRU"></a>最近最未被使用算法LRU</h4><p>思路</p>
<ul>
<li><p>选择<strong>最长时间没有被引用</strong>的页面进行置换</p>
</li>
<li><p>如某些页面长时间未被访问，则它们在将来还可能会长时间不<br>会访问</p>
</li>
</ul>
<p>实现</p>
<ul>
<li>缺页时，计算内存中每个逻辑页面的<strong>上一次</strong>访问时间</li>
<li>选择<strong>上一次使用到当前时间最长的页面</strong></li>
</ul>
<p>特征</p>
<ul>
<li>最优置换算法的一种近似</li>
</ul>
<h4 id="LRU算法示例"><a href="#LRU算法示例" class="headerlink" title="LRU算法示例"></a>LRU算法示例</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220522172233044.png" alt="image-20220522172233044" style="zoom:67%;">

<h4 id="LRU算法的可能实现方法"><a href="#LRU算法的可能实现方法" class="headerlink" title="LRU算法的可能实现方法"></a>LRU算法的可能实现方法</h4><p>页面链表</p>
<ul>
<li><p>系统维护一个按最近一次访问时间排序的页面链表</p>
<ul>
<li>&#x3D;&#x3D;链表首节点是最近刚刚使用过的页面&#x3D;&#x3D;</li>
<li>&#x3D;&#x3D;链表尾节点是最久未使用的页面&#x3D;&#x3D;</li>
</ul>
</li>
<li><p>访问内存时，找到相应页面，并把它移到链表之首</p>
</li>
<li><p>缺页时，置换链表尾节点的页面</p>
</li>
</ul>
<p>活动页面栈</p>
<ul>
<li>访问页面时，将此页号压入栈顶，并栈内相同的页号抽出</li>
<li>缺页时，置换栈底的页面</li>
</ul>
<p>特征</p>
<ul>
<li>开销比较大</li>
</ul>
<h4 id="用栈实现LRU算法"><a href="#用栈实现LRU算法" class="headerlink" title="用栈实现LRU算法"></a>用栈实现LRU算法</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220522173120350.png" alt="image-20220522173120350" style="zoom:67%;">

<h2 id="3、时钟置换算法和最不常用算法"><a href="#3、时钟置换算法和最不常用算法" class="headerlink" title="3、时钟置换算法和最不常用算法"></a>3、时钟置换算法和最不常用算法</h2><h4 id="时钟置换算法Clock"><a href="#时钟置换算法Clock" class="headerlink" title="时钟置换算法Clock"></a>时钟置换算法Clock</h4><p>思路</p>
<ul>
<li>仅对页面的访问情况进行大致统计</li>
</ul>
<p>数据结构</p>
<ul>
<li>在页表项中增加<strong>访问位</strong>，描述页面在过去一段时间的内访问情况</li>
<li>各页面组织成<strong>环形链表</strong></li>
<li>*指针**指向最先调入的页面</li>
</ul>
<p>算法</p>
<ul>
<li>访问页面时，在页表项记录页面访问情况</li>
<li>缺页时，从指针处开始顺序查找未被访问的页面进行置换</li>
</ul>
<p>特征</p>
<ul>
<li>时钟算法是LRU和FIFO的折中</li>
</ul>
<blockquote>
<p>时钟算法是LRU和FIFO的折中，考虑过去使用情况没有LRU那么全面，但又不像FIFO不考虑</p>
<p>置换是将<strong>过去一段时间</strong>未被访问的进行置换，如果都没被访问就变成了FIFO</p>
</blockquote>
<h4 id="时钟置换算法的实现"><a href="#时钟置换算法的实现" class="headerlink" title="时钟置换算法的实现"></a>时钟置换算法的实现</h4><ul>
<li>页面装入内存时，访问位初始化为0</li>
<li>访问页面（读&#x2F;写）时，访问位置1</li>
<li>缺页时，从指针当前位置顺序检查环形链表<ul>
<li>访问位为0，则置换该页</li>
<li>访问位为1，则访问位置0，并指针移动到下一个页面，直到找到可置换的页思路<br>D减少修改页的缺页处理开销<br>算法<br>在页面中增加修改位，并在访问时进行相应修改<br>缺页时，修改页面标志位，以跳过有修改的页面</li>
<li>面</li>
</ul>
</li>
</ul>
<h4 id="时钟页面置换示例"><a href="#时钟页面置换示例" class="headerlink" title="时钟页面置换示例"></a>时钟页面置换示例</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220522175356749.png" alt="image-20220522175356749" style="zoom:67%;">

<p>第六步的图错误：b应该是1</p>
<p>思路：</p>
<p>未缺页时，将该页置为1，指针向前移动一格</p>
<p>缺页时，从当前指针寻找0，途径1时将其置为0，找到0后将其置换并置为1，指针向前移动一格</p>
<h4 id="改进的时钟置换算法"><a href="#改进的时钟置换算法" class="headerlink" title="改进的时钟置换算法"></a>改进的时钟置换算法</h4><p>思路</p>
<ul>
<li>减少修改页的缺页处理开销</li>
</ul>
<p>算法</p>
<ul>
<li>在页面中增加修改位，并在访问时进行相应修改</li>
<li>缺页时，修改页面标志位，以跳过有修改的页面</li>
</ul>
<p><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220904094125613.png" alt="image-20220904094125613"></p>
<blockquote>
<p>不同于之前的置换页时，换进写出的开销，增加修改位，减少换进写出的开销</p>
<p>用修改位和访问位表示读写</p>
<ul>
<li>访问位为0，修改位为0时在将其置换</li>
<li>当访问位为1，修改位为1时，将访问位改0，修改位不变，不写出不置换，指针后移</li>
<li>当访问位为0，修改位为1时，将其修改位置为0，同时写出不置换，指针后移</li>
</ul>
</blockquote>
<h4 id="改进的时钟置换算法示例"><a href="#改进的时钟置换算法示例" class="headerlink" title="改进的时钟置换算法示例"></a>改进的时钟置换算法示例</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220522180910733.png" alt="image-20220522180910733" style="zoom: 67%;">

<h4 id="最不常用算法LFU"><a href="#最不常用算法LFU" class="headerlink" title="最不常用算法LFU"></a>最不常用算法LFU</h4><p>思路</p>
<ul>
<li>缺页时，置换访问次数最少的页面</li>
</ul>
<p>实现</p>
<ul>
<li>每个页面设置一个访问计数</li>
<li><strong>访问页面时，访问计数加1</strong></li>
<li>缺页时，置换计数最小的页面</li>
</ul>
<p>特征</p>
<ul>
<li>算法开销大</li>
<li>开始时频繁使用，但以后不使用的页面很难置换<ul>
<li><strong>解决方法：计数定期右移</strong></li>
</ul>
</li>
</ul>
<p>LRU和LFU的区别</p>
<ul>
<li>LRU关注<strong>多久未访问</strong>，时间越短越好</li>
<li>LFU关注<strong>访问次数</strong>，次数越多越好</li>
</ul>
<h4 id="LFU算法示例"><a href="#LFU算法示例" class="headerlink" title="LFU算法示例"></a>LFU算法示例</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220522182312066.png" alt="image-20220522182312066" style="zoom: 67%;">

<h2 id="4、Belady现象和局部置换算法比较"><a href="#4、Belady现象和局部置换算法比较" class="headerlink" title="4、Belady现象和局部置换算法比较"></a>4、Belady现象和局部置换算法比较</h2><h4 id="Belady现象"><a href="#Belady现象" class="headerlink" title="Belady现象"></a>Belady现象</h4><p>现象</p>
<ul>
<li>采用FIFO等算法时，可能出现分配的物理页面数增加，缺页次数反而升高的异常现象</li>
</ul>
<p>原因</p>
<ul>
<li><p>FIFO算法的置换特征与进程访问内存的动态特征矛盾</p>
</li>
<li><p>被它置换出去的页面并不一定是进程近期不会访问的</p>
</li>
</ul>
<p>思考</p>
<ul>
<li>哪些置换算法没有Belady现象？</li>
</ul>
<h4 id="FIFO算法有Belady现象"><a href="#FIFO算法有Belady现象" class="headerlink" title="FIFO算法有Belady现象"></a>FIFO算法有Belady现象</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220522183010772.png" alt="image-20220522183010772" style="zoom: 50%;">

<img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220522183049507.png" alt="image-20220522183049507" style="zoom: 50%;">

<h4 id="LRU算法没有Belady现象"><a href="#LRU算法没有Belady现象" class="headerlink" title="LRU算法没有Belady现象"></a>LRU算法没有Belady现象</h4><p><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220522183217511.png" alt="image-20220522183217511"></p>
<h4 id="LRU、FIFO和Clock算法比较"><a href="#LRU、FIFO和Clock算法比较" class="headerlink" title="LRU、FIFO和Clock算法比较"></a>LRU、FIFO和Clock算法比较</h4><p>1）LRU算法和FIFO本质上都是先进先出的思路</p>
<ul>
<li>LRU依据页面的最近访问时间排序</li>
<li>LRU需要动态地调整顺序</li>
<li>FIFO依据页面进入内存的时间排序</li>
<li>FIFO的页面进入时间是固定不变的</li>
</ul>
<p>2）LRU可退化成FIFO</p>
<ul>
<li>如页面进入内存后没有被访问，最近访问时间与进入内存的时间相同</li>
<li>例如：给进程分配3个物理页面，逻辑页面的访问顺序为 1、2、3、4、5、6、1、2、3…</li>
</ul>
<p>3）LRU算法性能较好，但系统开销较大</p>
<p>4）FIFO算法系统开销较小，会发生Belady现象</p>
<p>5）Clock算法是它们的折中</p>
<ul>
<li>页面访问时，不动态调整页面在链表中的顺序，仅做标记</li>
<li>缺页时，再把它移动到链表末尾</li>
</ul>
<p>6）对于未被访问的页面，Clock和LRU算法的表现一样好</p>
<p>7）对于被访问过的页面，Clock算法不能记录准确访问顺序，而LRU算法可以</p>
<h2 id="5、工作集置换算法"><a href="#5、工作集置换算法" class="headerlink" title="5、工作集置换算法"></a>5、工作集置换算法</h2><h4 id="CPU利用率和并发进程数的关系"><a href="#CPU利用率和并发进程数的关系" class="headerlink" title="CPU利用率和并发进程数的关系"></a>CPU利用率和并发进程数的关系</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220904100513096.png" alt="image-20220904100513096" style="zoom:50%;">

<p>CPU利用率与并发进程数存在相互促进和制约的关系</p>
<ul>
<li>进程数少时，提高并发进程数，可提高CPU利用率</li>
<li>并发进程导致内存访问增加</li>
<li>并发进程的内存访问会降低了访存的局部性特征</li>
<li>局部性特征的下降会导致缺页率上升和CPU利用率下降</li>
</ul>
<blockquote>
<p>当并发进程数量足够多时，局部性特征就会减少，导致进程频繁的换进换出，CPU效率下降</p>
</blockquote>
<h4 id="全局置换算法"><a href="#全局置换算法" class="headerlink" title="全局置换算法"></a>全局置换算法</h4><p>思路</p>
<ul>
<li>全局置换算法为进程分配<strong>可变数目</strong>的物理页面</li>
</ul>
<p>全局置换算法要解决的问题</p>
<ul>
<li>进程在不同阶段的内存需求是变化的</li>
<li>分配给进程的内存也需要在不同阶段有所变化</li>
<li>全局置换算法需要确定分配给进程的物理页面数</li>
</ul>
<blockquote>
<p>由于缺页率和进程所获得的物理页面成反比关系，但是当进程获得的物理页面到达一定数目，在增加1时缺页率不在明显，所以我们要动态分配给进程合适的物理页面数</p>
</blockquote>
<h4 id="工作集"><a href="#工作集" class="headerlink" title="工作集"></a>工作集</h4><p>一个进程当前正在使用的逻辑页面集合，可表示为二元函数W（t,△)</p>
<ul>
<li>t是当前的执行时刻</li>
<li>A称为工作集窗口（working-setwindow），即一个定长的页面访问时间窗口</li>
<li>W（t,△)是指在当前时刻t 前的△时间窗口中的所有访问页面所组成的集合</li>
<li>|W（t,△)|指工作集的大小，即页面数目</li>
</ul>
<blockquote>
<p>工作集：是指在某段时间间隔里，进程实际所要访问页面的集合</p>
</blockquote>
<h4 id="进程的工作集示例"><a href="#进程的工作集示例" class="headerlink" title="进程的工作集示例"></a>进程的工作集示例</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220522193632984.png" alt="image-20220522193632984" style="zoom:50%;">

<h4 id="工作集变化"><a href="#工作集变化" class="headerlink" title="工作集变化"></a>工作集变化</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220904101713948.png" alt="image-20220904101713948" style="zoom:50%;">

<ul>
<li>进程开始执行后，随着访问新页面逐步建立较稳定的工作集</li>
<li>当内存访问的局部性区域的位置<strong>大致稳定</strong>时，工作集大小也大致稳定</li>
<li>局部性区域的位置改变时，工作集<strong>快速扩张和收缩过渡</strong>到下一个稳定值</li>
</ul>
<h4 id="常驻集"><a href="#常驻集" class="headerlink" title="常驻集"></a>常驻集</h4><p>在当前时刻，进程实际驻留在内存当中的页面集合</p>
<ul>
<li>工作集与常驻集的关系<ul>
<li>工作集是进程在运行过程中固有的性质</li>
<li>常驻集取决于系统分配给进程的物理页面数目和页面置换算法</li>
</ul>
</li>
<li>缺页率与常驻集的关系<ul>
<li>常驻集 &gt;&#x3D; 工作集时，缺页较少</li>
<li>工作集发生剧烈变动（过渡）时，缺页较多</li>
<li>进程常驻集大小达到一定数目后，缺页率也不会明显下降</li>
</ul>
</li>
</ul>
<h4 id="工作集置换算法"><a href="#工作集置换算法" class="headerlink" title="工作集置换算法"></a>工作集置换算法</h4><p>思路</p>
<ul>
<li>换出不在工作集中的页面（在一段时间内，最久未被访问的页面）</li>
</ul>
<p>窗口大小</p>
<ul>
<li>当前时刻前T个内存访问的页引用是工作集，被称为窗口大小</li>
</ul>
<p>实现方法</p>
<ul>
<li>访存链表：维护窗口内的访存页面链表</li>
<li>每次访存时，换出不在工作集的页面：更新访存链表</li>
<li><strong>缺页时，换入页面；更新访存链表</strong></li>
</ul>
<h3 id="工作集置换算法示例"><a href="#工作集置换算法示例" class="headerlink" title="工作集置换算法示例"></a>工作集置换算法示例</h3><p><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220522200710250.png" alt="image-20220522200710250"></p>
<blockquote>
<p>窗口大小为4，t表示最近访问时间，假设开始之前就有三个页面并有相应的 t，当最近访问时间t为4时将其移出或换出</p>
<p>在每次访存时都要去维护链表数据结构，开销还是很大的</p>
</blockquote>
<h2 id="6、缺页率置换算法"><a href="#6、缺页率置换算法" class="headerlink" title="6、缺页率置换算法"></a>6、缺页率置换算法</h2><h4 id="缺页率"><a href="#缺页率" class="headerlink" title="缺页率"></a>缺页率</h4><p>缺页次数 &#x2F; 内存访问次数 或 缺页平均时间间隔的倒数</p>
<ul>
<li>影响缺页率的因素<ul>
<li>页面置换算法</li>
<li>分配给进程的物理页面数目</li>
<li>页面大小</li>
<li>程序的编写方法</li>
</ul>
</li>
</ul>
<h4 id="缺页率置换算法"><a href="#缺页率置换算法" class="headerlink" title="缺页率置换算法"></a>缺页率置换算法</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220904103828611.png" alt="image-20220904103828611" style="zoom:50%;">

<p>通过调节常驻集大小，使每个进程的缺页率保持在一个合理的范围内</p>
<ul>
<li>若进程缺页率过高，则增加常驻集以分配更多的物理页</li>
<li>若进程缺页率过低，则减少常驻集以减少它的物理页面</li>
</ul>
<blockquote>
<p>缺页率过高，CPU大多执行换进换出，CPU效率降低</p>
<p>缺页率过低，并发度降低，CPU利用率降低</p>
</blockquote>
<h4 id="缺页率置换算法的实现"><a href="#缺页率置换算法的实现" class="headerlink" title="缺页率置换算法的实现"></a>缺页率置换算法的实现</h4><ul>
<li>访存时，设置引用位标志</li>
<li>缺页时，计算从上次缺页时间 t_last 到现在 t_current 的时间间隔（T为窗口大小）<ul>
<li>如果 t_current - t_last &gt; T，则增加缺失页到常驻集中，置换常驻集中所有在 [ t_last , t_current  ] 时间内没有被引用的页</li>
<li>如果 t_current - t_last &lt;&#x3D; T，则只增加缺失页到常驻集中</li>
</ul>
</li>
</ul>
<h4 id="缺页率置换算法示例"><a href="#缺页率置换算法示例" class="headerlink" title="缺页率置换算法示例"></a>缺页率置换算法示例</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220522202824545.png" alt="image-20220522202824545" style="zoom: 67%;">

<blockquote>
<p>1到4间隔大于2，减少间隔内未被引用的页面，4到6间隔等于2，加上该页面</p>
<p>缺页率置换算法和工作集置换算法的区别：</p>
<p>工作集算法在每一次访存时都判断该淘汰哪一个，开销较大</p>
<p>缺页率算法在缺页中断时在进行淘汰判断，缺页间隔足够大时，其中的页面相当于可以在加进去的，所以该算法更接近于工作集的那条曲线的</p>
</blockquote>
<h2 id="7、抖动和负载控制"><a href="#7、抖动和负载控制" class="headerlink" title="7、抖动和负载控制"></a>7、抖动和负载控制</h2><h4 id="抖动问题"><a href="#抖动问题" class="headerlink" title="抖动问题"></a>抖动问题</h4><p>抖动</p>
<ul>
<li>进程物理页面太少，不能包含工作集</li>
<li>造成大量缺页，频繁置换</li>
<li>进程运行速度变慢</li>
</ul>
<p>产生抖动的原因</p>
<ul>
<li>随着驻留内存的进程数目增加，分配给每个进程的物理页<br>面数不断减小，缺页率不断上升</li>
</ul>
<p>操作系统需在并发水平和缺页率之间达到一个平衡</p>
<ul>
<li>选择一个适当的进程数目和进程需要的物理页面数</li>
</ul>
<h4 id="负载控制"><a href="#负载控制" class="headerlink" title="负载控制"></a>负载控制</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220522204507588.png" alt="image-20220522204507588" style="zoom:50%;">

<blockquote>
<p>找到合适并发进程数，即Nmax，但是找它是很麻烦的，通过平均缺页间隔时间除以缺页异常处理时间&#x3D;1，找到接近的一个并发进程数</p>
</blockquote>
<h1 id="七、进程和线程"><a href="#七、进程和线程" class="headerlink" title="七、进程和线程"></a>七、进程和线程</h1><h2 id="1、进程的概念"><a href="#1、进程的概念" class="headerlink" title="1、进程的概念"></a>1、进程的概念</h2><h4 id="实际操作系统中的进程"><a href="#实际操作系统中的进程" class="headerlink" title="实际操作系统中的进程"></a>实际操作系统中的进程</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220523115539251.png" alt="image-20220523115539251" style="zoom:50%;">

<h4 id="进程的定义"><a href="#进程的定义" class="headerlink" title="进程的定义"></a>进程的定义</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220523115716354.png" alt="image-20220523115716354" style="zoom:50%;">

<blockquote>
<p>进程利于程序在运行时操作系统的维护</p>
</blockquote>
<h4 id="内存中的进程"><a href="#内存中的进程" class="headerlink" title="内存中的进程"></a>内存中的进程</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220904110448599.png" alt="image-20220904110448599" style="zoom: 67%;">

<blockquote>
<p>相对于程序而言，进程将其分为数据段、代码段和堆栈段，分段便于维护</p>
<p>堆栈段是在这两段之间，堆栈段能存放函数调用的地址和返回地址</p>
</blockquote>
<h3 id="进程的组成"><a href="#进程的组成" class="headerlink" title="进程的组成"></a>进程的组成</h3><p>进程包含了正在运行的一个程序的<strong>所有状态</strong>信息</p>
<ul>
<li>代码</li>
<li>数据</li>
<li>状态寄存器<ul>
<li>CPU状态CRO、指令指针IP</li>
</ul>
</li>
<li>通用寄存器<ul>
<li>AX、BX、CX….</li>
</ul>
</li>
<li>进程占用系统资源<ul>
<li>打开文件、已分配内存….</li>
</ul>
</li>
</ul>
<h4 id="进程的特点"><a href="#进程的特点" class="headerlink" title="进程的特点"></a>进程的特点</h4><p>动态性：</p>
<ul>
<li>可动态地创建、结束进程</li>
</ul>
<p>并发性：</p>
<ul>
<li>进程可以被独立调度并占用处理机执行</li>
</ul>
<p>独立性：</p>
<ul>
<li>不同进程的工作不互相影响</li>
</ul>
<p>制约性：</p>
<ul>
<li>因访问共享数据 &#x2F; 资源 或 进程间同步而产生制约</li>
</ul>
<img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220523121151891.png" alt="image-20220523121151891" style="zoom:50%;">

<blockquote>
<p>处理机一个时间点上只能执行一个进程，而从宏观上来看，一段时间间隔里他们是并发执行的</p>
</blockquote>
<h4 id="进程与程序的联系"><a href="#进程与程序的联系" class="headerlink" title="进程与程序的联系"></a>进程与程序的联系</h4><p>进程是操作系统处于执行状态程序的抽象</p>
<ul>
<li>程序&#x3D;文件（静态的可执行文件）</li>
<li>进程&#x3D;执行中的程序&#x3D;程序+执行状态</li>
</ul>
<p>同一个程序的多次执行过程对应为不同进程</p>
<ul>
<li>如命令“Is”的多次执行对应多个进程</li>
</ul>
<p>进程执行需要的资源</p>
<ul>
<li>内存：保存代码和数据</li>
<li>CPU：执行指令</li>
</ul>
<h3 id="进程与程序的区别"><a href="#进程与程序的区别" class="headerlink" title="进程与程序的区别"></a>进程与程序的区别</h3><p>进程是动态的，程序是静态的</p>
<ul>
<li>程序是有序代码的集合</li>
<li>进程是程序的执行，进程有核心态&#x2F;用户态</li>
</ul>
<p>进程是暂时的，程序的永久的</p>
<ul>
<li>进程是一个状态变化的过程</li>
<li>程序可长久保存</li>
</ul>
<p>进程与程序的组成不同</p>
<ul>
<li>进程的组成包括程序、数据和进程控制块</li>
</ul>
<h2 id="2、进程控制块"><a href="#2、进程控制块" class="headerlink" title="2、进程控制块"></a>2、进程控制块</h2><h4 id="进程控制块PCB"><a href="#进程控制块PCB" class="headerlink" title="进程控制块PCB"></a>进程控制块PCB</h4><p>操作系统管理控制进程运行所用的信息集合</p>
<ul>
<li>操作系统用PCB来描述进程的基本情况以及运行变化的过程</li>
<li>PCB是进程存在的唯一标志<ul>
<li>每个进程都在操作系统中有一个对应的PCB</li>
</ul>
</li>
</ul>
<h4 id="进程控制块的使用"><a href="#进程控制块的使用" class="headerlink" title="进程控制块的使用"></a>进程控制块的使用</h4><ul>
<li>进程创建<ul>
<li>生成该进程的PCB</li>
</ul>
</li>
<li>进程终止<ul>
<li>回收它的PCB</li>
</ul>
</li>
<li>进程的组织管理<ul>
<li>通过对PCB的组织管理来实现</li>
</ul>
</li>
</ul>
<blockquote>
<p>PCB具体包含什么信息？如何组织的？</p>
<p>进程的状态转换…..？</p>
</blockquote>
<h4 id="进程控制块"><a href="#进程控制块" class="headerlink" title="进程控制块"></a>进程控制块</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220523122613499.png" alt="image-20220523122613499" style="zoom:50%;">

<h4 id="进程控制的信息"><a href="#进程控制的信息" class="headerlink" title="进程控制的信息"></a>进程控制的信息</h4><ul>
<li>调度和状态信息<ul>
<li>进程和处理机使用情况调链表<br>同一状态的进程其PCB成一链表，多个状态对应多个不<br>同的链表<br>D各状态的进程形成不同的链表：就绪链表、阻塞链表<br>索引表<br>同一状态的进程归入一个索引表（由索引指向PCB）<br>多个状态对应多个不同的索引表<br>D各状态的进行形成不同的索引表：就绪索引表、阻塞索引表</li>
<li>度</li>
</ul>
</li>
<li>进程间通信信息<ul>
<li>进程间通信相关的各种标识</li>
</ul>
</li>
<li>存储管理信息<ul>
<li>指向进程映像存储空间数据结构</li>
</ul>
</li>
<li>进程所用资源<ul>
<li>进程使用的系统资源，如打开文件等</li>
</ul>
</li>
<li>有关数据结构连接信息<ul>
<li>与PCB相关的进程队列</li>
</ul>
</li>
</ul>
<h4 id="进程控制块的组织"><a href="#进程控制块的组织" class="headerlink" title="进程控制块的组织"></a>进程控制块的组织</h4><p><strong>链表</strong></p>
<ul>
<li>同一状态的进程其PCB成一链表，多个状态对应多个不同的链表<ul>
<li>各状态的进程形成不同的链表：就绪链表、阻塞链表</li>
</ul>
</li>
</ul>
<p><strong>索引表</strong></p>
<ul>
<li>同一状态的进程归入一个索引表（由索引指向PCB），多个状态对应多个不同的索引表<ul>
<li>各状态的进行形成不同的索引表：就绪索引表、阻塞索引表</li>
</ul>
</li>
</ul>
<p><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220904112139628.png" alt="image-20220904112139628"></p>
<h2 id="3、进程状态"><a href="#3、进程状态" class="headerlink" title="3、进程状态"></a>3、进程状态</h2><h4 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220523123425476.png" alt="image-20220523123425476" style="zoom: 67%;">

<blockquote>
<p>生成该进程的PCB，加入到就绪队列</p>
</blockquote>
<h4 id="进程的执行"><a href="#进程的执行" class="headerlink" title="进程的执行"></a>进程的执行</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220523123529729.png" alt="image-20220523123529729" style="zoom:67%;">

<blockquote>
<p>如何选择：处理机调度算法会讲，如何调度处理机资源给进程</p>
</blockquote>
<h4 id="进程等待"><a href="#进程等待" class="headerlink" title="进程等待"></a>进程等待</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220523123823473.png" alt="image-20220523123823473" style="zoom: 50%;">

<h4 id="进程抢占"><a href="#进程抢占" class="headerlink" title="进程抢占"></a>进程抢占</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220523123949348.png" alt="image-20220523123949348" style="zoom:50%;">

<h4 id="进程唤醒"><a href="#进程唤醒" class="headerlink" title="进程唤醒"></a>进程唤醒</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220523124120141.png" alt="image-20220523124120141" style="zoom: 67%;">

<h4 id="进程结束"><a href="#进程结束" class="headerlink" title="进程结束"></a>进程结束</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220523124248358.png" alt="image-20220523124248358" style="zoom:50%;">

<h4 id="进程的切换"><a href="#进程的切换" class="headerlink" title="进程的切换"></a>进程的切换</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220523124953557.png" alt="image-20220523124953557" style="zoom: 50%;">

<h2 id="4、三状态进程模型及进程的变迁"><a href="#4、三状态进程模型及进程的变迁" class="headerlink" title="4、三状态进程模型及进程的变迁"></a>4、三状态进程模型及进程的变迁</h2><h4 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h4><p>三种<strong>最核心</strong>的状态：就绪、运行和等待，创建和退出都是辅助过渡的过程</p>
<p>运行状态：</p>
<ul>
<li>进程正在处理机上运行</li>
</ul>
<p>就绪状态：</p>
<ul>
<li>进程获得了除处理机之外的所需资源，得到处理机即可运行</li>
</ul>
<p>等待状态：</p>
<ul>
<li>进程正在等待某一事件的出现而暂停运行</li>
</ul>
<p>创建状态：</p>
<ul>
<li>一个进程正在被创建，还没被转到就绪状态之前的状态</li>
</ul>
<p>结束状态：</p>
<ul>
<li>一个进程正在从系统中消失时的状态，这是因为进程结束或由于其他原因所导致</li>
</ul>
<img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220523153143325.png" alt="image-20220523153143325" style="zoom: 50%;">

<h4 id="一个进程的变迁"><a href="#一个进程的变迁" class="headerlink" title="一个进程的变迁"></a>一个进程的变迁</h4><p>NULL –&gt; 创建：</p>
<ul>
<li>一个新进程被产生出来执行一个程序</li>
</ul>
<p>创建 –&gt; 就绪：</p>
<ul>
<li>当进程被创建完成并初始化后，一切就绪准备运行时，变为就绪状态</li>
</ul>
<p>就绪  –&gt; 运行：</p>
<ul>
<li>处于就绪状态被进程调度程序选中后，就分配搭配处理机上来运行</li>
</ul>
<p>运行 –&gt; 结束：</p>
<ul>
<li>当进程表示它已经完成或者因为出错，当前运行进程会由操作系统结束处理</li>
</ul>
<p>运行  –&gt; 就绪：</p>
<ul>
<li>处于运行状态的进程在其运行过程中，由于分配给它的处理机时间片用完而让出处理机</li>
</ul>
<p>运行 –&gt; 等待：</p>
<ul>
<li>当进程请求某资源且必须等待时</li>
</ul>
<p>等待 –&gt; 就绪：</p>
<ul>
<li>当进程要等待某事件到来时，它从阻塞状态编导就绪状态</li>
</ul>
<h2 id="5、挂起进程模型"><a href="#5、挂起进程模型" class="headerlink" title="5、挂起进程模型"></a>5、挂起进程模型</h2><h4 id="进程挂起"><a href="#进程挂起" class="headerlink" title="进程挂起"></a>进程挂起</h4><p>处在挂起状态的进程映像在磁盘上，目的是减少进程占用内存，让出更多内存给其他进程执行，与虚拟存储相关联</p>
<h4 id="挂起进程模型"><a href="#挂起进程模型" class="headerlink" title="挂起进程模型"></a>挂起进程模型</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220523160724812.png" alt="image-20220523160724812" style="zoom: 50%;">

<h4 id="挂起状态"><a href="#挂起状态" class="headerlink" title="挂起状态"></a>挂起状态</h4><p>等待挂起状态：</p>
<ul>
<li>进程在外存并等待事件的出现</li>
</ul>
<p>就绪挂起状态：</p>
<ul>
<li>进程在外存，但只要进入内存，即可运行</li>
</ul>
<h4 id="与挂起相关的状态转换"><a href="#与挂起相关的状态转换" class="headerlink" title="与挂起相关的状态转换"></a>与挂起相关的状态转换</h4><p>&#x3D;&#x3D;挂起：把一个进程从内存转到外存&#x3D;&#x3D;</p>
<p>等待到等待挂起：</p>
<ul>
<li>没有进程处于就绪状态或就绪进程要求更多内存资源</li>
</ul>
<p>就绪到就绪挂起：</p>
<ul>
<li>当有高优先级等待（系统人会会很多就绪的）进程和低优先级就绪进程，将低优先级就绪进程转为就绪挂起，使高优先级等待进程进入就绪状态</li>
</ul>
<p>运行到就绪挂起：</p>
<ul>
<li>对抢占式分时系统，当有高优先级等待挂起进程因事件出现而进入就绪挂起</li>
</ul>
<p>&#x3D;&#x3D;在外存时的状态转换&#x3D;&#x3D;</p>
<p>等待挂起到就绪挂起：</p>
<ul>
<li>当有等待挂起进程因相关事件出现</li>
</ul>
<p>&#x3D;&#x3D;激活：把一个进程从外存转到内存&#x3D;&#x3D;</p>
<p>就绪挂起到就绪：</p>
<ul>
<li>没有就绪进程或挂起就绪进程优先级高于就绪进程</li>
</ul>
<p>等待挂起到等待：</p>
<ul>
<li>当有一个进程释放足够内存并有高优先级等待挂起进程</li>
</ul>
<h4 id="状态队列"><a href="#状态队列" class="headerlink" title="状态队列"></a>状态队列</h4><ul>
<li>由操作系统来维护一组队列，表示系统中所有进程的当前状态</li>
<li>不同队列表示不同状态<ul>
<li>就绪队列、各种等待队列</li>
</ul>
</li>
<li>根据进程状态不同，进程PCB加入相应队列<ul>
<li>进程状态变化时，它所在的PCB会从一个队列换到另一个</li>
</ul>
</li>
</ul>
<h4 id="进程状态的队列表现"><a href="#进程状态的队列表现" class="headerlink" title="进程状态的队列表现"></a>进程状态的队列表现</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220523162343983.png" alt="image-20220523162343983" style="zoom: 50%;">

<blockquote>
<p>状态之间的变迁，变成了队列之间的变迁</p>
</blockquote>
<h2 id="6、线程的概念"><a href="#6、线程的概念" class="headerlink" title="6、线程的概念"></a>6、线程的概念</h2><h4 id="举例：为什么引入线程"><a href="#举例：为什么引入线程" class="headerlink" title="举例：为什么引入线程"></a>举例：为什么引入线程</h4><p>【案例】编写一个MP3播放软件。核心功能模块有三个<br>（1）从MP3音频文件当中读取数据<br>（2）对数据进行解压缩<br>（3）把解压缩后的音频数据播放出来</p>
<h4 id="单进程的实现方法"><a href="#单进程的实现方法" class="headerlink" title="单进程的实现方法"></a>单进程的实现方法</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220904113641052.png" alt="image-20220904113641052" style="zoom:50%;">

<p>问题：<br>1.播放出来的声音能否连贯<br>2.各个函数之间不是并发执行，影响资源的使用效率</p>
<blockquote>
<p>函数不是并发执行的，都是一个个执行，资源的连贯性就会有问题，如读的很慢，CPU压缩的很快，这会导致播放的视频不连续</p>
</blockquote>
<h4 id="多进程的实现方法"><a href="#多进程的实现方法" class="headerlink" title="多进程的实现方法"></a>多进程的实现方法</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220904113907524.png" alt="image-20220904113907524" style="zoom:50%;">

<p>存在的问题<br>1.进程之间如何通信，共享数据？<br>2.系统开销较大：创建进程、进程结束、进程切换</p>
<blockquote>
<p>多进程的实现方法，当你在读数据的等待阶段，操作系统可以让你CPU去执行解压</p>
</blockquote>
<h4 id="多线程的解决思路"><a href="#多线程的解决思路" class="headerlink" title="多线程的解决思路"></a>多线程的解决思路</h4><p>在进程内部增加一类实体，满足以下特性：</p>
<p>（1）实体之间可以并发执行</p>
<p>（2）实体之间共享相同的地址空间</p>
<p>这种实体就是线程（Thread）</p>
<h4 id="线程的概念"><a href="#线程的概念" class="headerlink" title="线程的概念"></a>线程的概念</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220523164454110.png" alt="image-20220523164454110" style="zoom:50%;">

<blockquote>
<p>有了多个指令执行流，产生多个线程控制块，线程控制块是在进程控制块当中的</p>
</blockquote>
<h4 id="进程和线程的关系"><a href="#进程和线程的关系" class="headerlink" title="进程和线程的关系"></a>进程和线程的关系</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220523164734484.png" alt="image-20220523164734484" style="zoom: 67%;">

<blockquote>
<p>将寄存器和堆栈分配多份给多线程使用</p>
</blockquote>
<h4 id="线程-x3D-进程-共享资源"><a href="#线程-x3D-进程-共享资源" class="headerlink" title="线程 &#x3D; 进程 - 共享资源"></a>线程 &#x3D; 进程 - 共享资源</h4><p>即各个线程共享进程中的资源</p>
<ul>
<li>线程的优点：<ul>
<li>一个进程中可以同时存在多个线程</li>
<li>各个线程之间可以并发地执行</li>
<li>各个线程之间可以共享地址空间和文件等资源</li>
</ul>
</li>
<li>线程的缺点：<ul>
<li>一个线程崩溃，会导致其所属进程的所有线程崩溃</li>
</ul>
</li>
</ul>
<h4 id="不同操作系统支持的线程"><a href="#不同操作系统支持的线程" class="headerlink" title="不同操作系统支持的线程"></a>不同操作系统支持的线程</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220523165528038.png" alt="image-20220523165528038" style="zoom: 67%;">

<h4 id="线程和进程的比较"><a href="#线程和进程的比较" class="headerlink" title="线程和进程的比较"></a>线程和进程的比较</h4><ul>
<li>进程是资源分配单位，线程是CPU调度单位</li>
<li>进程拥有一个完整的资源平台，而线程只独享指令流执行的必要资源，如寄存器和栈</li>
<li>线程具有就绪、等待和运行三种基本状态和状态间的转换关系</li>
<li>线程能减少并发执行的时间和空间开销<ul>
<li>线程的创建时间比进程短</li>
<li>线程的终止时间比进程短</li>
<li>同一进程内的线程切换时间比进程短</li>
<li>由于同一进程的各线程间共享内存和文件资源，可不通过内核进行直接通信</li>
</ul>
</li>
</ul>
<h2 id="7、用户线程"><a href="#7、用户线程" class="headerlink" title="7、用户线程"></a>7、用户线程</h2><h4 id="线程的三种实现方式"><a href="#线程的三种实现方式" class="headerlink" title="线程的三种实现方式"></a>线程的三种实现方式</h4><ul>
<li>用户线程：在用户空间实现<br>POSIX Pthreads，Mach C-threads，Solaris threads</li>
<li>内核线程：在内核中实现<br>Windows，Solaris，Linux</li>
<li>轻量级进程：在内核中实现，支持用户线程<br>Solaris（LightWeight Process）</li>
</ul>
<h4 id="用户线程"><a href="#用户线程" class="headerlink" title="用户线程"></a>用户线程</h4><p>由一组用户级的线程库函数来完成线程的管理，包括线程的创建、终止、同步和调度等</p>
<img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220904115049212.png" alt="image-20220904115049212" style="zoom:50%;">

<h4 id="用户线程的特征"><a href="#用户线程的特征" class="headerlink" title="用户线程的特征"></a>用户线程的特征</h4><ul>
<li>不依赖于操作系统的内核<ul>
<li>内核不了解用户线程的存在</li>
<li>可用于不支持线程的多进程操作系统</li>
</ul>
</li>
<li>在用户空间实现的线程机制<ul>
<li>每个进程有私有的线程控制块（TCB）列表</li>
<li>TCB由线程库函数维护</li>
</ul>
</li>
<li>同一进程内的用户线程切换速度快<ul>
<li>无需用户态&#x2F;核心态切换</li>
</ul>
</li>
<li>允许每个进程拥有自已的线程调度算法</li>
</ul>
<h4 id="用户线程的不足"><a href="#用户线程的不足" class="headerlink" title="用户线程的不足"></a>用户线程的不足</h4><ul>
<li>线程发起系统调用而阻塞时，则整个进程进入等待</li>
<li>不支持基于线程的处理机抢占<ul>
<li>除非当前运行线程主动放弃，它所在进程的其他线程无法抢占CPU</li>
</ul>
</li>
<li>线程只能按进程分配CPU时间<ul>
<li>多个线程进程中，每个线程的时间片较少</li>
</ul>
</li>
</ul>
<h2 id="8、内核线程"><a href="#8、内核线程" class="headerlink" title="8、内核线程"></a>8、内核线程</h2><h4 id="内核线程"><a href="#内核线程" class="headerlink" title="内核线程"></a>内核线程</h4><p>由内核通过系统调用实现的线程机制，由内核完成线程的创建、终止和管理</p>
<img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220904115513447.png" alt="image-20220904115513447" style="zoom: 50%;">

<h4 id="内核线程的特征"><a href="#内核线程的特征" class="headerlink" title="内核线程的特征"></a>内核线程的特征</h4><ul>
<li>由内核维护PCB和TCB</li>
<li>线程执行系统调用而被阻塞不影响其他线程</li>
<li>线程的创建、终止和切换相对较大<ul>
<li>通过系统调用&#x2F;内核函数，在内核实现</li>
</ul>
</li>
<li>以线程为单位进行CPU时间分配<ul>
<li>多线程的进程可获得更多CPU时间</li>
</ul>
</li>
</ul>
<blockquote>
<p>在内核中维护线程的创建、终止和切换开销相对较大</p>
</blockquote>
<h4 id="轻权进程"><a href="#轻权进程" class="headerlink" title="轻权进程"></a>轻权进程</h4><p>内核支持的用户线程。一个进程可有一个或多个轻量级进程，每个轻权进程由一个单独的内核线程来支持。（Solaris&#x2F;Linux）</p>
<img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220904115728161.png" alt="image-20220904115728161" style="zoom:50%;">

<blockquote>
<p>是用户线程和内核线程的一种很好的结合，即有一个或多个的内核线程支持，它可为一个进程多个用户线程服务，可是在实际的系统中实现的不理想</p>
</blockquote>
<h4 id="用户线程和内核线程的对应关系"><a href="#用户线程和内核线程的对应关系" class="headerlink" title="用户线程和内核线程的对应关系"></a>用户线程和内核线程的对应关系</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220523172632051.png" alt="image-20220523172632051" style="zoom:50%;">



<h1 id="八、进程控制"><a href="#八、进程控制" class="headerlink" title="八、进程控制"></a>八、进程控制</h1><h2 id="1、进程切换"><a href="#1、进程切换" class="headerlink" title="1、进程切换"></a>1、进程切换</h2><h4 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h4><p>进程切换（上下文切换）</p>
<ul>
<li>暂停当前运行进程，从运行状态变成其他状态</li>
<li>调度另一个进程从就绪状态变成运行状态</li>
</ul>
<p>进程切换的要求</p>
<ul>
<li><p>切换前，保存进程上下文</p>
</li>
<li><p>切换后，恢复进程上下文</p>
</li>
<li><p>快速切换</p>
</li>
</ul>
<p>进程生命周期的信息</p>
<ul>
<li>寄存器（PC,SP….）</li>
<li>CPU状态</li>
<li>内存地址空间</li>
</ul>
<blockquote>
<p>保存进程信息（现场）：寄存器信息，CPU状态，内存地址空间</p>
</blockquote>
<h4 id="上下文切换图示"><a href="#上下文切换图示" class="headerlink" title="上下文切换图示"></a>上下文切换图示</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220524103401438.png" alt="image-20220524103401438" style="zoom: 67%;">

<h4 id="进程控制块PCB-内核的进程状态记录"><a href="#进程控制块PCB-内核的进程状态记录" class="headerlink" title="进程控制块PCB::内核的进程状态记录"></a>进程控制块PCB::内核的进程状态记录</h4><p>1）内核为每个进程维护了对应的进程控制块（PCB）</p>
<p>2）内核将相同状态的进程的PCB放置在同一队列</p>
<ul>
<li>就绪队列</li>
<li>I&#x2F;O等待队列<ul>
<li>每个设备一个队列</li>
</ul>
</li>
<li>I&#x2F;O等待队列</li>
</ul>
<img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220905090449594.png" alt="image-20220905090449594" style="zoom:67%;">

<h4 id="ucore的进程控制块结构proc-struct"><a href="#ucore的进程控制块结构proc-struct" class="headerlink" title="ucore的进程控制块结构proc_struct"></a>ucore的进程控制块结构proc_struct</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220524104825663.png" alt="image-20220524104825663" style="zoom:50%;">

<h4 id="ucore的内存地址空间结构mm-struct"><a href="#ucore的内存地址空间结构mm-struct" class="headerlink" title="ucore的内存地址空间结构mm_struct"></a>ucore的内存地址空间结构mm_struct</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220524105318617.png" alt="image-20220524105318617" style="zoom: 50%;">

<h4 id="ucore-的进程队列"><a href="#ucore-的进程队列" class="headerlink" title="ucore+的进程队列"></a>ucore+的进程队列</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220524105507567.png" alt="image-20220524105507567" style="zoom:50%;">

<h4 id="ucore-进程-x2F-线程切换流程"><a href="#ucore-进程-x2F-线程切换流程" class="headerlink" title="ucore+进程&#x2F;线程切换流程"></a>ucore+进程&#x2F;线程切换流程</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220524105853681.png" alt="image-20220524105853681" style="zoom:50%;">

<h4 id="ucore-的进程切换"><a href="#ucore-的进程切换" class="headerlink" title="ucore+的进程切换"></a>ucore+的进程切换</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220524110023449.png" alt="image-20220524110023449" style="zoom:50%;">

<blockquote>
<p>由于各种事件如中断，信号量，CPU空闲等等，大致会经过schedule在去proc_run，然后到switch_to切换代码</p>
</blockquote>
<h4 id="switch-to-实现"><a href="#switch-to-实现" class="headerlink" title="switch_to 实现"></a>switch_to 实现</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220524110216643.png" alt="image-20220524110216643" style="zoom:50%;">

<blockquote>
<p>切换代码和你的平台相关，每个CPU平台上所需要保存的寄存器是不一样的，而为了保存的速度比较快，代码使用汇编进进行编写的</p>
<p>大致过程是，前半段保存，后半段恢复</p>
</blockquote>
<h2 id="2、进程创建"><a href="#2、进程创建" class="headerlink" title="2、进程创建"></a>2、进程创建</h2><h4 id="创建进程的系统调用接口"><a href="#创建进程的系统调用接口" class="headerlink" title="创建进程的系统调用接口"></a>创建进程的系统调用接口</h4><p>系统调用接口操作系统提供给用户使用的系统调用，在不同的操作系统，系统调用的接口是不一样的</p>
<ul>
<li><p>Windows进程创建API：CreateProcess(fileliame）</p>
<ul>
<li><p>创建时关闭所有在子进程里的文件描述符<br>CreateProcess(filename，CLOSE FD）函数用于创建一个新进程，该进程独立于创建进程运行</p>
</li>
<li><p>创建时改变子进程的环境</p>
<p>CreateProcess(filename，CLOSE FD，new_envp）</p>
</li>
<li><p>等等</p>
</li>
</ul>
</li>
<li><p>Unix进程创建系统调用：fork&#x2F;exec</p>
<ul>
<li>forkO把一个进程复制成二个进程，parent (old PID)，child (new PID）</li>
<li>exec() 用新程序来重写当前进程，PID没有改变</li>
</ul>
</li>
</ul>
<h4 id="创建新进程"><a href="#创建新进程" class="headerlink" title="创建新进程"></a>创建新进程</h4><p>用fork和exec创建进程的示例</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> pid = fork()；		<span class="comment">// 创建子进程</span></span><br><span class="line"><span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;			<span class="comment">// 子进程在这里继续</span></span><br><span class="line">     <span class="comment">// Do anything (unmap memory, close net connections…)</span></span><br><span class="line">	<span class="built_in">exec</span>(“program”, argc, argv0, argv1, …);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>fork() 创建一个继承的子进程</p>
<ul>
<li>复制父进程的所有变量和内存</li>
<li>复制父进程的所有CPU寄存器(有一个寄存器例外)</li>
</ul>
<p>fork()的返回值</p>
<ul>
<li>子进程的fork()返回0</li>
<li>父进程的fork()返回子进程标识符</li>
<li>fork() 返回值可方便后续使用，子进程可使用getpid()获取PID</li>
</ul>
<blockquote>
<p>fork复制一个完成一样的子进程，但是PID不同来区别于这两个进程，在用exec将程序加载到内存覆盖重写当前进程整个地址空间</p>
</blockquote>
<h4 id="fork-的地址空间复制"><a href="#fork-的地址空间复制" class="headerlink" title="fork()的地址空间复制"></a>fork()的地址空间复制</h4><p>fork（执行过程对于子进程而言是在调用时间灯交递程地址空间的一次复制</p>
<ul>
<li>对于父进程fork（）返回child PID，对于子进程返回值为0</li>
</ul>
<img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220905092234655.png" alt="image-20220905092234655" style="zoom:67%;">

<blockquote>
<p>复制完全一样的进程，但是PID不一样，导致后续的它就是一个不一样的进程</p>
</blockquote>
<h4 id="程序的加载和执行"><a href="#程序的加载和执行" class="headerlink" title="程序的加载和执行"></a>程序的加载和执行</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220524112723422.png" alt="image-20220524112723422" style="zoom:50%;">

<h4 id="在shell中调用fork-后加载计算器的图示"><a href="#在shell中调用fork-后加载计算器的图示" class="headerlink" title="在shell中调用fork()后加载计算器的图示"></a>在shell中调用fork()后加载计算器的图示</h4><p>fork()复制完全一样的进程，地址空间的内容一样，即数据、代码和堆栈完全一样</p>
<img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220524113245129.png" alt="image-20220524113245129" style="zoom:50%;">

<p>exec()加载过程，将复制的进程重写，即将整个地址空间里的内容全部换掉，变成完全不一样的新进程</p>
<img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220524113515537.png" alt="image-20220524113515537" style="zoom:50%;">

<h4 id="空闲进程的创建"><a href="#空闲进程的创建" class="headerlink" title="空闲进程的创建"></a>空闲进程的创建</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220524123602410.png" alt="image-20220524123602410" style="zoom:50%;">

<blockquote>
<p>在用户没有代码需要执行时，CPU也不会处于空闲状态，这时CPU会执行空闲进程中的指令</p>
<p>空闲进程的优先级最低，当没有其他进程时，它就会执行</p>
</blockquote>
<h4 id="创建第一个内核线程"><a href="#创建第一个内核线程" class="headerlink" title="创建第一个内核线程"></a>创建第一个内核线程</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220524124444783.png" alt="image-20220524124444783" style="zoom:50%;">

<blockquote>
<p>进程创建与线程创建fork的参数信息不一样，线程只需要拷贝所需要的现场信息，初始化控制块，初始化堆栈，共享堆栈，将其放入就绪队列，当开始被调度执行，就可以创建第一个用户态的进程了</p>
</blockquote>
<h4 id="fork-的开销"><a href="#fork-的开销" class="headerlink" title="fork()的开销"></a>fork()的开销</h4><p>fork() 的实现开销</p>
<ul>
<li>对子进程分配内存</li>
<li>复制父进程的内存和CPU寄存器到子进程里</li>
<li>&#x3D;&#x3D;开销昂贵！！&#x3D;&#x3D;</li>
</ul>
<p>在99%的情况里，我们在调用fork() 之后调用exec()</p>
<ul>
<li>在fork() 操作中内存复制是没有作用的</li>
<li>子进程将可能关闭打开的文件和连接</li>
<li>为什么不能结合它们在一个调用中？</li>
</ul>
<p>vfork()</p>
<ul>
<li>创建进程时，不再创建一个同样的内存映像</li>
<li>一些时候称为轻量级fork()</li>
<li>子进程应该几乎立即调用exec()</li>
<li>现在使用Copy on Write（COW）技术</li>
</ul>
<h2 id="3、进程加载"><a href="#3、进程加载" class="headerlink" title="3、进程加载"></a>3、进程加载</h2><h4 id="程序加载和执行系统调用exec"><a href="#程序加载和执行系统调用exec" class="headerlink" title="程序加载和执行系统调用exec( )"></a>程序加载和执行系统调用exec( )</h4><ul>
<li>允许进程“加载一个完全不同的程序，并从main开始执行（即_start）</li>
<li>允许进程加载时指定启动参数（argc，argv）</li>
<li>exec调用成功时<ul>
<li>它是相同的进程….</li>
<li>但是运行了不同的程序</li>
</ul>
</li>
<li>代码段、堆栈和堆（heap）等完全重写</li>
</ul>
<h2 id="4、进程等待与退出"><a href="#4、进程等待与退出" class="headerlink" title="4、进程等待与退出"></a>4、进程等待与退出</h2><h4 id="父进程等待子进程wait"><a href="#父进程等待子进程wait" class="headerlink" title="父进程等待子进程wait()"></a>父进程等待子进程wait()</h4><ul>
<li>Wait（）系统调用用于父进程等待子进程的结束<ul>
<li>子进程结束时通过exit（）向父进程返回一个值</li>
<li>父进程通过wait（）接受并处理返回值</li>
</ul>
</li>
<li>wait（）系统调用的功能<ul>
<li>子进程存活时，父进程进入等待状态，等待子进程的返回结果</li>
<li>当某子进程调用exit（）时，唤醒父进程，将exit（）返回值作为父进程中wait的返回值</li>
<li>有僵尸子进程等待时，wait（）立即返回其中一个值</li>
<li>无子进程存活时，wait（）立刻返回</li>
</ul>
</li>
</ul>
<h4 id="进程的有序终止exit"><a href="#进程的有序终止exit" class="headerlink" title="进程的有序终止exit()"></a>进程的有序终止exit()</h4><ul>
<li>进程结束执行时调用&#x3D;&#x3D;exit（）&#x3D;&#x3D;，完成进程资源回收</li>
<li>exit（）系统调用的功能<ul>
<li>将调用参数作为进程的 “结果“</li>
<li>关闭所有打开的文件等占用资源</li>
<li>释放内存</li>
<li>释放大部分进程相关的内核数据结构</li>
<li>检查是否父进程是存活着的<ul>
<li>如存活，保留结果的值直到父进程需要它，进入僵尸（zombie&#x2F;defunct）状态</li>
<li>如果没有，它释放所有的数据结构，进程结果</li>
</ul>
</li>
<li>清理所有等待的僵尸进程</li>
</ul>
</li>
<li>进程终止是最终的垃圾收集（资源回收）</li>
</ul>
<h4 id="其他进程控制系统调用"><a href="#其他进程控制系统调用" class="headerlink" title="其他进程控制系统调用"></a>其他进程控制系统调用</h4><ul>
<li>优先级控制<ul>
<li>nice（）指定进程的初始优先级</li>
<li>Unix系统中进程优先级会随执行时间而衰减</li>
</ul>
</li>
<li>进程调试支持<ul>
<li>ptrace（）允许一个进程控制另一个进程的执行</li>
<li>设置断点和查看寄存器等</li>
</ul>
</li>
<li>定时<ul>
<li>sleep（）可以让进程在定时器的等待队列中等待指定</li>
</ul>
</li>
</ul>
<h4 id="进程控制和进程状态"><a href="#进程控制和进程状态" class="headerlink" title="进程控制和进程状态"></a>进程控制和进程状态</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220524161300142.png" alt="image-20220524161300142" style="zoom: 67%;">

<blockquote>
<p>exec( ) : 在加载可执行文件过程中，它还会有相应的状态的变化</p>
</blockquote>
<h1 id="九、处理机调度"><a href="#九、处理机调度" class="headerlink" title="九、处理机调度"></a>九、处理机调度</h1><h2 id="1、处理机调度的概念"><a href="#1、处理机调度的概念" class="headerlink" title="1、处理机调度的概念"></a>1、处理机调度的概念</h2><h4 id="CPU资源的时分复用"><a href="#CPU资源的时分复用" class="headerlink" title="CPU资源的时分复用"></a>CPU资源的时分复用</h4><ul>
<li>进程切换：CPU资源的当前占用者切换<ul>
<li>保存当前进程在PCB中的执行上下文（CPU状态）</li>
<li>恢复下一个进程的执行上下文</li>
</ul>
</li>
<li>处理机调度<ul>
<li>从就绪队列中&#x3D;&#x3D;挑选&#x3D;&#x3D;下一个占用CPU运行的&#x3D;&#x3D;进程&#x3D;&#x3D;</li>
<li>从多个可用CPU中&#x3D;&#x3D;挑选&#x3D;&#x3D;就绪进程可使用的CPU&#x3D;&#x3D;资源&#x3D;&#x3D;</li>
</ul>
</li>
<li>调度程序：挑选就绪进程的内核函数<ul>
<li>调度策略<ul>
<li>依据什么原则挑选进程&#x2F;线程？</li>
</ul>
</li>
<li>调度时机<ul>
<li>什么时候进行调度？</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="调度时机"><a href="#调度时机" class="headerlink" title="调度时机"></a>调度时机</h4><p>内核运行调度程序的条件</p>
<ul>
<li>进程被终结了</li>
</ul>
<p>&#x3D;&#x3D;非抢占系统&#x3D;&#x3D;</p>
<ul>
<li>当前进程主动放弃CPU时</li>
</ul>
<p>&#x3D;&#x3D;可抢占系统&#x3D;&#x3D;</p>
<ul>
<li>中断请求被服务例程响应完成时</li>
<li>当前进程被抢占<ul>
<li>进程时间片用完</li>
<li>进程从等待切换到就绪</li>
</ul>
</li>
</ul>
<img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220905095543111.png" alt="image-20220905095543111" style="zoom:50%;">

<h2 id="2、调度准则"><a href="#2、调度准则" class="headerlink" title="2、调度准则"></a>2、调度准则</h2><h4 id="处理机资源的使用模式"><a href="#处理机资源的使用模式" class="headerlink" title="处理机资源的使用模式"></a>处理机资源的使用模式</h4><p>进程在CPU计算和I&#x2F;O操作间交替</p>
<ul>
<li>每次调度决定在下一个CPU计算时将哪个工作交给CPU</li>
<li>在时间片机制下，进程可能在结束当前CPU计算前被迫放弃CPU</li>
</ul>
<img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220905095844146.png" alt="image-20220905095844146" style="zoom: 67%;">

<blockquote>
<p>根据CPU计算频率与每次计算事件关系图，选择合适的时间片分配使用CPU资源</p>
</blockquote>
<h4 id="比较调度算法的准则"><a href="#比较调度算法的准则" class="headerlink" title="比较调度算法的准则"></a>比较调度算法的准则</h4><ul>
<li>CPU使用率<ul>
<li>CPU处于忙状态的&#x3D;&#x3D;时间百分比&#x3D;&#x3D;</li>
</ul>
</li>
<li>吞吐量<ul>
<li>单位时间内完成的&#x3D;&#x3D;进程数量&#x3D;&#x3D;</li>
</ul>
</li>
<li>周转时间<ul>
<li>进程从初始化到结束（包括等待）的&#x3D;&#x3D;总时间&#x3D;&#x3D;</li>
</ul>
</li>
<li>等待时间<ul>
<li>进程在就绪队列中的&#x3D;&#x3D;总时间&#x3D;&#x3D;</li>
</ul>
</li>
<li>响应时间<ul>
<li>从提交请求到产生响应所花费的&#x3D;&#x3D;总时间&#x3D;&#x3D;</li>
</ul>
</li>
</ul>
<h4 id="吞吐量与响应延迟"><a href="#吞吐量与响应延迟" class="headerlink" title="吞吐量与响应延迟"></a>吞吐量与响应延迟</h4><p>调度算法的要求</p>
<ul>
<li>希望 &#x3D;&#x3D;“更快”&#x3D;&#x3D; 的服务</li>
</ul>
<p>什么是更快？</p>
<ul>
<li>传输文件时的&#x3D;&#x3D;高带宽&#x3D;&#x3D;，调度算法的&#x3D;&#x3D;高吞吐量&#x3D;&#x3D;</li>
<li>玩游戏时的&#x3D;&#x3D;低延迟&#x3D;&#x3D;，调度算法的&#x3D;&#x3D;低响应延迟&#x3D;&#x3D;</li>
<li>这两个因素是独立的</li>
</ul>
<p>与&#x3D;&#x3D;水管&#x3D;&#x3D;的类比</p>
<ul>
<li>低延迟：&#x3D;&#x3D;喝水&#x3D;&#x3D;的时候想要一打开水龙头水就流出来</li>
<li>高带宽：&#x3D;&#x3D;给游泳池充水&#x3D;&#x3D;时希望从水龙头里同时流出大量的水，并且不介意是否存在延</li>
</ul>
<h4 id="处理机调度策略的响应时间目标"><a href="#处理机调度策略的响应时间目标" class="headerlink" title="处理机调度策略的响应时间目标"></a>处理机调度策略的响应时间目标</h4><p>&#x3D;&#x3D;减少响应时间&#x3D;&#x3D;</p>
<ul>
<li>及时处理用户的输入请求，尽快将输出反馈给用户</li>
</ul>
<p>&#x3D;&#x3D;减少平均响应时间的波动&#x3D;&#x3D;</p>
<ul>
<li>在交互系统中，可预测性比高差异低平均更重要</li>
</ul>
<p>低延退调度改善了用户的交互体验</p>
<ul>
<li>如果移动鼠标时，屏幕中的光标没动，用户可能会重启电脑</li>
</ul>
<p>响应时间是操作系统的计算延迟</p>
<h4 id="处理调度策略的吞吐量目标"><a href="#处理调度策略的吞吐量目标" class="headerlink" title="处理调度策略的吞吐量目标"></a>处理调度策略的吞吐量目标</h4><p>&#x3D;&#x3D;增加吞吐量&#x3D;&#x3D;</p>
<ul>
<li>减少开销（操作系统开销，上下文切换）</li>
<li>系统资源的高效利用（CPU，0设备）</li>
</ul>
<p>&#x3D;&#x3D;减少等待时间&#x3D;&#x3D;</p>
<ul>
<li>减少每个进程的等待时间</li>
</ul>
<p>操作系统需要保证吞吐量不受用户交互的影响</p>
<ul>
<li>操作系统必须不时进行调度，即使存在许多交互任务</li>
</ul>
<p>吞吐量是操作系统的计算带宽</p>
<blockquote>
<p>吞吐量目标：希望在单位时间内尽可能能够执行更多的进程</p>
</blockquote>
<h4 id="处理机调度的公平性目标"><a href="#处理机调度的公平性目标" class="headerlink" title="处理机调度的公平性目标"></a>处理机调度的公平性目标</h4><p>公平的定义</p>
<ul>
<li>保证每个进程占用相同的CPU时间</li>
<li>保证每个进程的等待时间相同</li>
</ul>
<p>公平通常会增加平均响应时间</p>
<h2 id="3、先来先服务、短进程优先和最高响应比优先调度算法"><a href="#3、先来先服务、短进程优先和最高响应比优先调度算法" class="headerlink" title="3、先来先服务、短进程优先和最高响应比优先调度算法"></a>3、先来先服务、短进程优先和最高响应比优先调度算法</h2><h4 id="先来先服务算法FCFS"><a href="#先来先服务算法FCFS" class="headerlink" title="先来先服务算法FCFS"></a>先来先服务算法FCFS</h4><p><code>First Come First Served</code></p>
<p>依据进程进入就绪状态的先后顺序排列</p>
<ul>
<li>进程进入等待或结束状态时，就绪队列中的下一个进程占用CPU</li>
</ul>
<p>FCFS算法的周转时间</p>
<img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220905101256452.png" alt="image-20220905101256452" style="zoom:67%;">

<blockquote>
<p>计算周转时间，假设进程几乎同时到达，这里忽略了到达时间</p>
<p>如果大作业先到了，周转时间会变得更长，不利于小作业，作业等待时间会长</p>
</blockquote>
<h4 id="先来先服务算法特征"><a href="#先来先服务算法特征" class="headerlink" title="先来先服务算法特征"></a>先来先服务算法特征</h4><p>优点</p>
<ul>
<li>简单</li>
</ul>
<p>缺点</p>
<ul>
<li>平均等待时间波动较大<ul>
<li>短进程可能排在长进程后面</li>
</ul>
</li>
<li>I&#x2F;O资源和CPU资源的利用率较低<ul>
<li>CPU密集型进程会导致I&#x2F;O设备闲置时，I&#x2F;O密集型进程也等待</li>
</ul>
</li>
</ul>
<h4 id="短进程优先算法SPN"><a href="#短进程优先算法SPN" class="headerlink" title="短进程优先算法SPN"></a>短进程优先算法SPN</h4><p>选择就绪队列中执行时间最短进程占用CPU进入运行状态</p>
<ul>
<li>就绪队列按预期的执行时间来排序</li>
</ul>
<img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220905102016758.png" alt="image-20220905102016758" style="zoom:50%;">

<p>短剩余时间优先算法&#x3D;&#x3D;（SRT）&#x3D;&#x3D;</p>
<ul>
<li>DSPN算法的可抢占改进</li>
</ul>
<blockquote>
<p>短剩余时间优先算法，即当前进程已经执行了一段时间，新来了个进程，执行时间比当前进程剩余的执行时间短，那么它可以抢占当前进程</p>
</blockquote>
<h4 id="短进程优先算法具有最优平均周转时间"><a href="#短进程优先算法具有最优平均周转时间" class="headerlink" title="短进程优先算法具有最优平均周转时间"></a>短进程优先算法具有最优平均周转时间</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220525173950667.png" alt="image-20220525173950667" style="zoom:50%;">

<h4 id="短进程优先算法的特征：缺点"><a href="#短进程优先算法的特征：缺点" class="headerlink" title="短进程优先算法的特征：缺点"></a>短进程优先算法的特征：缺点</h4><p>可能导致机饿</p>
<ul>
<li>连续的短进程流会使长进程无法获得CPU资源</li>
</ul>
<p>&#x3D;&#x3D;需要预知未来&#x3D;&#x3D;</p>
<ul>
<li>如何预估下一个CPU计算的持续时间？</li>
<li>简单的解决办法：询问用户<ul>
<li>用户欺骗就杀死相应进程</li>
<li>用户不知道怎么办？</li>
</ul>
</li>
</ul>
<h4 id="短进程优先算法执行时间预估"><a href="#短进程优先算法执行时间预估" class="headerlink" title="短进程优先算法执行时间预估"></a>短进程优先算法执行时间预估</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220525174709991.png" alt="image-20220525174709991" style="zoom:50%;">

<p>加权计算，最近一次的计算时间权重最大，越久远的计算时间权重越小</p>
<h4 id="预估执行时间"><a href="#预估执行时间" class="headerlink" title="预估执行时间"></a>预估执行时间</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220525174951615.png" alt="image-20220525174951615" style="zoom:50%;">

<p>实际和预估能够有一个比较好的拟合效果</p>
<h4 id="最高响应比优先算法HRRN"><a href="#最高响应比优先算法HRRN" class="headerlink" title="最高响应比优先算法HRRN"></a>最高响应比优先算法HRRN</h4><p>选择就绪队列中响应比R值最高的进程</p>
<table>
<thead>
<tr>
<th>R&#x3D;（w+s)&#x2F;s</th>
</tr>
</thead>
<tbody><tr>
<td>w：等待时间（waiting time）</td>
</tr>
<tr>
<td>S：执行时间（service time）</td>
</tr>
</tbody></table>
<ul>
<li>在短进程优先算法的基础上改进</li>
<li>不可抢占</li>
<li>关注进程的等待时间</li>
<li>防止无限期推</li>
</ul>
<h2 id="4、时间片轮转、多级反馈队列、公平共享调度算法和ucore调度框架"><a href="#4、时间片轮转、多级反馈队列、公平共享调度算法和ucore调度框架" class="headerlink" title="4、时间片轮转、多级反馈队列、公平共享调度算法和ucore调度框架"></a>4、时间片轮转、多级反馈队列、公平共享调度算法和ucore调度框架</h2><h4 id="时间片轮转算法RR"><a href="#时间片轮转算法RR" class="headerlink" title="时间片轮转算法RR"></a>时间片轮转算法RR</h4><p>时间片</p>
<ul>
<li>分配处理机资源的基本时间单元</li>
</ul>
<p>算法思路</p>
<ul>
<li>时间片结束时，按FCFS算法切换到下一个就绪进程</li>
<li>每隔（n-1）个时间片进程执行一个时间片q</li>
</ul>
<img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220906125705199.png" alt="image-20220906125705199" style="zoom: 67%;">

<blockquote>
<p>采用先来先服务算法  +  时间片。</p>
<p>执行完一个时间片后，如未完成则加入到就绪队列末尾，执行下一个就绪队列的头进程</p>
</blockquote>
<h4 id="时间片为20的RR算法示例"><a href="#时间片为20的RR算法示例" class="headerlink" title="时间片为20的RR算法示例"></a>时间片为20的RR算法示例</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220604134104994.png" alt="image-20220604134104994" style="zoom: 67%;">

<h4 id="时间片轮转算法中的时间片长度"><a href="#时间片轮转算法中的时间片长度" class="headerlink" title="时间片轮转算法中的时间片长度"></a>时间片轮转算法中的时间片长度</h4><p>RR算法开销</p>
<ul>
<li>额外的上下文切换</li>
</ul>
<p>时间片太大</p>
<ul>
<li>等待时间过长</li>
<li>极限情况退化成FCFS</li>
</ul>
<p>时间片太小</p>
<ul>
<li>反应迅速，但产生大量上下文切换</li>
<li>大量上下文切换开销影响到系统吞吐量</li>
</ul>
<p>时间片长度选择目标</p>
<ul>
<li>选择一个合适的时间片长度</li>
<li>经验规则：维持上下文切换开销处于1%以内</li>
</ul>
<h4 id="比较FCFS和RR"><a href="#比较FCFS和RR" class="headerlink" title="比较FCFS和RR"></a>比较FCFS和RR</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220604134807497.png" alt="image-20220604134807497" style="zoom: 67%;">

<blockquote>
<p>先来先服务算法有两种极端，长进程优先和短进程优先，进程如果以从小到大的顺序到达，则出现最好情况，否则就是最差情况，而时间片轮转算法的平均等待时间是在则两者的平均等待时间之间</p>
</blockquote>
<h4 id="多级队列调度算法（MQ）"><a href="#多级队列调度算法（MQ）" class="headerlink" title="多级队列调度算法（MQ）"></a>多级队列调度算法（MQ）</h4><p>就绪队列被划分成多个独立的子队列</p>
<ul>
<li>如：前台（交互）、后台（批处理）</li>
</ul>
<p>每个队列拥有自己的调度策略</p>
<ul>
<li>如：前台-RR、后台-FCFS</li>
</ul>
<p>队列间的调度</p>
<ul>
<li>固定优先级<ul>
<li>先处理前台，然后处理后台</li>
<li>可能导致饥饿</li>
</ul>
</li>
<li>时间片轮转<ul>
<li>每个队列都能得到一个确定的能够调度其进程的CPU总时间</li>
<li>如：80%CPU时间用于前台，20%CPU时间用于后台</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>此算法，不同队列间没有交互，即进程不能在不同队列间移动</strong></p>
</blockquote>
<h4 id="多级反馈队列算法（MLFQ）"><a href="#多级反馈队列算法（MLFQ）" class="headerlink" title="多级反馈队列算法（MLFQ）"></a>多级反馈队列算法（MLFQ）</h4><p>进程可在不同队列间&#x3D;&#x3D;移动&#x3D;&#x3D;的多级队列算法</p>
<ul>
<li>时间片大小随优先级级别增加而增加</li>
<li>如进程在当前的时间片没有完成，则降到下一个优先级</li>
</ul>
<p>MLFQ算法的特征</p>
<ul>
<li>CPU密集型进程的优先级下降很快</li>
<li>I&#x2F;O密集型进程停留在高优先级</li>
</ul>
<img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220604140648217.png" alt="image-20220604140648217" style="zoom: 67%;">

<h4 id="公平共享调度算法FSS"><a href="#公平共享调度算法FSS" class="headerlink" title="公平共享调度算法FSS"></a>公平共享调度算法FSS</h4><p>FSS控制用户对系统资源的访问</p>
<ul>
<li>一些用户组比其他用户组更重要</li>
<li>保证不重要的组无法垄断资源<br>未使用的资源按比例分配<br>没有达到资源使用率目标的组获得更高的优先级</li>
</ul>
<img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220906130411629.png" alt="image-20220906130411629" style="zoom:67%;">

<h4 id="传统调度算法的总结"><a href="#传统调度算法的总结" class="headerlink" title="传统调度算法的总结"></a>传统调度算法的总结</h4><p>先来先服务算法</p>
<ul>
<li>不公平，平均等待时间较差</li>
</ul>
<p>短进程优先算法</p>
<ul>
<li>不公平，平均周转时间最小</li>
<li>需要精确的预测计算时间</li>
<li>可能导致饥饿</li>
</ul>
<p>最高响应比优先算法（看重进程等段时间）</p>
<ul>
<li>基于短进程优先算法SPN调度</li>
<li>不可抢占</li>
</ul>
<p>时间片轮转算法</p>
<ul>
<li>公平，但是平均等待时间较差</li>
</ul>
<p>多级反馈队列</p>
<ul>
<li>多种算法的集成</li>
</ul>
<p>公平共享调度</p>
<ul>
<li>公平是第一要素</li>
</ul>
<h4 id="ucore的调度时机和进程切换"><a href="#ucore的调度时机和进程切换" class="headerlink" title="ucore的调度时机和进程切换"></a>ucore的调度时机和进程切换</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220604143050363.png" alt="image-20220604143050363" style="zoom:50%;">

<p>进程遇到中断，从用户态进入到内核态进行中断处理，完成后根据调度算法调度另外的进程或本进程</p>
<p>调度时机是在内核态切换回用户态之前就调度了</p>
<h2 id="5、实时调度和多处理机调度"><a href="#5、实时调度和多处理机调度" class="headerlink" title="5、实时调度和多处理机调度"></a>5、实时调度和多处理机调度</h2><h4 id="实时操作系统"><a href="#实时操作系统" class="headerlink" title="实时操作系统"></a>实时操作系统</h4><p>实时操作系统的定义</p>
<ul>
<li>正确性依赖于其&#x3D;&#x3D;时间&#x3D;&#x3D;和&#x3D;&#x3D;功能&#x3D;&#x3D;两方面的操作系统</li>
</ul>
<p>实时操作系统的性能指标</p>
<ul>
<li>&#x3D;&#x3D;时间约束的及时性（deadlines）&#x3D;&#x3D;</li>
<li>速度和平均性能相对不重要</li>
</ul>
<p>实时操作系统的特性</p>
<ul>
<li>时间约束的&#x3D;&#x3D;可预测性&#x3D;&#x3D;</li>
</ul>
<h4 id="实时任务"><a href="#实时任务" class="headerlink" title="实时任务"></a>实时任务</h4><p>任务（工作单元）</p>
<ul>
<li>一次计算，一次文件读取，一次信息传递等等</li>
</ul>
<p>任务属性</p>
<ul>
<li>完成任务所需要的资源</li>
<li>定时参数</li>
</ul>
<img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220906130704508.png" alt="image-20220906130704508" style="zoom: 67%;">

<h4 id="周期实时任务"><a href="#周期实时任务" class="headerlink" title="周期实时任务"></a>周期实时任务</h4><p>周期实时任务：一系列相似的任务</p>
<ul>
<li>任务有规律地重复</li>
<li>周期 p &#x3D; 任务请求时间间隔（0 &lt; p）</li>
<li>执行时间 e &#x3D; 最大执行时间（0 &lt; e &lt; p）</li>
<li>使用率U&#x3D;e &#x2F; p</li>
</ul>
<img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220906130755301.png" alt="image-20220906130755301" style="zoom:67%;">

<h4 id="硬时限和软时限"><a href="#硬时限和软时限" class="headerlink" title="硬时限和软时限"></a>硬时限和软时限</h4><p>硬时限（Hard deadline）</p>
<ul>
<li>错过任务时限会导致灾难性或非常严重的后果</li>
<li>必须验证，在最坏情况下能够满足时限</li>
</ul>
<p>软时限（Soft deadline）</p>
<ul>
<li>通常能满足任务时限<ul>
<li>如有时不能满足，则降低要求</li>
</ul>
</li>
<li>尽力保证满足任务时限</li>
</ul>
<h4 id="可调度性"><a href="#可调度性" class="headerlink" title="可调度性"></a>可调度性</h4><p>可调度表示一个实时操作系统能够满足任务时限要求</p>
<ul>
<li>需要确定实时任务的执行顺序</li>
<li>静态优先级调度</li>
<li>动态优先级调度</li>
</ul>
<img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220907105051196.png" alt="image-20220907105051196" style="zoom:50%;">

<h4 id="实时调度"><a href="#实时调度" class="headerlink" title="实时调度"></a>实时调度</h4><p>速率单调调度算法（RM，Rate Monotonic）</p>
<ul>
<li>通过&#x3D;&#x3D;周期&#x3D;&#x3D;安排优先级</li>
<li>周期越短优先级越高</li>
<li>执行周期最短的任务</li>
</ul>
<p>最早截止时间优先算法（EDF，Earliest Deadline First）</p>
<ul>
<li>截止时间越早优先级越高</li>
<li>执行截止时间最早的任务</li>
</ul>
<blockquote>
<p>这两种算法在一定条件下，满足可调度性</p>
</blockquote>
<h4 id="多处理机调度"><a href="#多处理机调度" class="headerlink" title="多处理机调度"></a>多处理机调度</h4><p>多处理机调度的特征</p>
<ul>
<li>多个处理机组成一个多处理机系统</li>
<li>处理机间可负载共享</li>
</ul>
<p>对称多处理器（SMP，Symmetric multiprocessing）调度</p>
<ul>
<li>截止时间越早优先级越高，每个处理器运行自己的调度程序</li>
<li>调度程序对共享资源的访问需要进行同步</li>
</ul>
<img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220907105304753.png" alt="image-20220907105304753" style="zoom: 67%;">

<blockquote>
<p>共享资源同步是多处理机调度最大的问题</p>
</blockquote>
<h4 id="对称多处理器的进程分配"><a href="#对称多处理器的进程分配" class="headerlink" title="对称多处理器的进程分配"></a>对称多处理器的进程分配</h4><p>静态进程分配</p>
<ul>
<li>进程从开始到结束都被分配到一个固定的处理机上执行</li>
<li>每个处理机有自己的就绪队列</li>
<li>调度开销小</li>
<li>各处理机可能忙闲不均</li>
</ul>
<p>动态进程分配</p>
<ul>
<li>进程在执行中可分配到任意空闲处理机执行</li>
<li>所有处理机共享一个公共的就绪队列</li>
<li>调度开销大</li>
<li>各处理机的负载是均衡的</li>
</ul>
<h2 id="6、优先级反置"><a href="#6、优先级反置" class="headerlink" title="6、优先级反置"></a>6、优先级反置</h2><h4 id="优先级反置"><a href="#优先级反置" class="headerlink" title="优先级反置"></a>优先级反置</h4><p>操作系统中出现高优先级进程长时间等待低优先级进程所占用资源的现象</p>
<p>基于优先级的可抢占调度算法存在优先级反置</p>
<img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220907105613987.png" alt="image-20220907105613987" style="zoom:67%;">

<blockquote>
<p>优先级反置：在优先级可抢占调度算法下，高优先级T2由于T1占用L1资源，没有进行抢占CPU，而是申请L1资源后进入阻塞状态，之后T3高优先级资源满足，进行抢占CPU，导致T1进入阻塞状态无法执行，T1不释放资源导致更高的优先级T2长时间的等待</p>
</blockquote>
<h4 id="优先级继承"><a href="#优先级继承" class="headerlink" title="优先级继承"></a>优先级继承</h4><p>占用资源的低优先级进程继承申请资源的高优先级进程的优先级</p>
<ul>
<li>只在占有资源的低优先级进程被阻塞时，才提高占有资源进程的优先级</li>
</ul>
<blockquote>
<p>你优先级高，我被阻塞了，借你的优先级给我用用，一会儿释放资源给你</p>
</blockquote>
<img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220907110140370.png" alt="image-20220907110140370" style="zoom: 67%;">

<p>首先T3执行占用资源s，T1抢占CPU执行而T3被阻塞，之后T1需要资源s，所以T3继承T1优先级，T1等待T3执行完后释放资源，T1才能获得资源s进行执行</p>
<h4 id="优先级天花板协议"><a href="#优先级天花板协议" class="headerlink" title="优先级天花板协议"></a>优先级天花板协议</h4><p>占用资源进程的优先级和所有可能申请该资源的进程的最高优先级相同</p>
<ul>
<li>不管是否发生等待，都提升占用资源进程的优先级</li>
<li>优先级高于系统中所有被锁定的资源的优先级上限，任务执行临界区时就不会被阻塞</li>
</ul>
<blockquote>
<p>你的优先级那么高，你赶紧先吃，一会儿我们在吃</p>
</blockquote>
<h1 id="十、同步互斥"><a href="#十、同步互斥" class="headerlink" title="十、同步互斥"></a>十、同步互斥</h1><h2 id="1、背景"><a href="#1、背景" class="headerlink" title="1、背景"></a>1、背景</h2><h4 id="并发进程的正确性"><a href="#并发进程的正确性" class="headerlink" title="并发进程的正确性"></a>并发进程的正确性</h4><p>独立进程</p>
<ul>
<li>不和其他进程共享资源或状态</li>
<li>&#x3D;&#x3D;确定性&#x3D;&#x3D;  –&gt; 输入状态决定结果</li>
<li>&#x3D;&#x3D;可重现&#x3D;&#x3D;  –&gt; 能够重现起始条件</li>
<li>调度顺序不重要</li>
</ul>
<p>并发进程</p>
<ul>
<li>在多个进程间有资源共享</li>
<li>不确定性</li>
<li>不可重现</li>
</ul>
<p>并发进程的正确性</p>
<ul>
<li>执行过程是不确定性和不可重现的</li>
<li>程序错误可能是间歇性发生的</li>
</ul>
<h4 id="进程并发执行的好处"><a href="#进程并发执行的好处" class="headerlink" title="进程并发执行的好处"></a>进程并发执行的好处</h4><p>进程需要与计算机中的其他进程和设备进行协作</p>
<ul>
<li>好处1：共享资源<ul>
<li>多个用户使用同一台计算机</li>
<li>银行账号存款余额在多台ATM机操作</li>
<li>机器人上的嵌入式系统协调手臂和手的动作</li>
</ul>
</li>
<li>好处2：加速<ul>
<li>I&#x2F;O 操作和CPU计算可在重叠（并行）</li>
<li>程序可划分成多个模块放在多个处理器上并行执行</li>
</ul>
</li>
<li>好处3：模块化<ul>
<li>将大程序分解成小程序<ul>
<li>以编译为例，gcc会调用cpp、cc1、cc2、as、ld等编译链接函数</li>
</ul>
</li>
<li>使系统易于复用和扩展</li>
</ul>
</li>
</ul>
<h4 id="并发创建新进程时的标识分配"><a href="#并发创建新进程时的标识分配" class="headerlink" title="并发创建新进程时的标识分配"></a>并发创建新进程时的标识分配</h4><p>程序可以调用函数fork（）来创建一个新的进程</p>
<ul>
<li>操作系统需要分配一个新的并且&#x3D;&#x3D;唯一的进程ID&#x3D;&#x3D;</li>
<li>在内核中，这个系统调用会运行</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new_pid = next_pid ++</span><br></pre></td></tr></table></figure>

<ul>
<li>翻译成机器指令</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LOAD next_pid Reg1</span><br><span class="line">STORE Reg1 new_pid</span><br><span class="line">INC Reg1</span><br><span class="line">STORE  Reg1 next_pid</span><br></pre></td></tr></table></figure>

<p>两个进程并发执行时的预期结果（假定next_pid &#x3D;100）</p>
<ul>
<li>一个进程得到的ID应该是100</li>
<li>另一个进程的ID应该是101</li>
<li>next_pid 应该增加到102</li>
</ul>
<h4 id="新进程分配标识的可能错误"><a href="#新进程分配标识的可能错误" class="headerlink" title="新进程分配标识的可能错误"></a>新进程分配标识的可能错误</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220605115703062.png" alt="image-20220605115703062" style="zoom:50%;">

<blockquote>
<p>为新进程分配标识，四条汇编代码应该一块执行，即赋值id，之后加1写回去，但是这里执行赋值之后被中断了，导致出现两个相同的id</p>
</blockquote>
<h4 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h4><p>原子操作是指一次不存在任何中断或失败的操作</p>
<ul>
<li>要么操作成功完成</li>
<li>或者操作没有执行</li>
<li>不会出现部分执行的状态</li>
</ul>
<p>操作系统需要利用同步机制在并发执行的同时保证一些操作是原子操作</p>
<h2 id="2、现实生活中的同步问题"><a href="#2、现实生活中的同步问题" class="headerlink" title="2、现实生活中的同步问题"></a>2、现实生活中的同步问题</h2><h4 id="现实生活中的同步问题"><a href="#现实生活中的同步问题" class="headerlink" title="现实生活中的同步问题"></a>现实生活中的同步问题</h4><p>操作系统和现实生活的问题类比</p>
<ul>
<li>利用现实生活问题帮助理解操作系统同步问题</li>
<li>同时注意，计算机与人的差异</li>
</ul>
<p>例如：家庭采购协调</p>
<img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220907111604848.png" alt="image-20220907111604848" style="zoom:67%;">

<h4 id="家庭采购协调问题分析"><a href="#家庭采购协调问题分析" class="headerlink" title="家庭采购协调问题分析"></a>家庭采购协调问题分析</h4><p>如何保证家庭采购协调的成功和高效</p>
<ul>
<li><p>有人去买</p>
<p>需要采购时，有人去买面包</p>
</li>
<li><p>最多只有一个人去买面包</p>
</li>
</ul>
<p>可能的解决方法</p>
<ul>
<li>在冰箱上设置一个&#x3D;&#x3D;锁和钥匙（lock&amp;key）&#x3D;&#x3D;</li>
<li>去买面包之前锁住冰箱并且拿走钥匙</li>
</ul>
<p>加锁导致的新问题</p>
<ul>
<li>冰箱中还有其他食品时，别人无法取到</li>
</ul>
<h4 id="解决方案一"><a href="#解决方案一" class="headerlink" title="解决方案一"></a>解决方案一</h4><p>使用&#x3D;&#x3D;便签&#x3D;&#x3D;来避免购买太多面包</p>
<ul>
<li>购买之前留下一张便签</li>
<li>买完后移除该便签</li>
<li>别人看到便签时，就不去购买面包</li>
</ul>
<img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220907111937734.png" alt="image-20220907111937734" style="zoom:50%;">

<p><strong>方案一分析</strong></p>
<p>偶尔会购买太多面包</p>
<ul>
<li>检查面包和便签后帖便签前，有其他人检查面包和便签</li>
</ul>
<img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220907112038696.png" alt="image-20220907112038696" style="zoom: 67%;">

<p>对于生活中两人几乎同时来检查有没有面包和有没有便签，之后不可能发生买重的问题，但是在计算机中就会出现此问题</p>
<p>解决方案只是间歇性地失败</p>
<ul>
<li>问题难以调试</li>
<li>必须考虑调度器所做的事情</li>
</ul>
<h4 id="解决方案2"><a href="#解决方案2" class="headerlink" title="解决方案2"></a>解决方案2</h4><p>&#x3D;&#x3D;先留便签，后检查面包和便签&#x3D;&#x3D;</p>
<img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220907112148209.png" alt="image-20220907112148209" style="zoom:50%;">

<p>不会有人买面包</p>
<h4 id="解决方案3"><a href="#解决方案3" class="headerlink" title="解决方案3"></a>解决方案3</h4><p>&#x3D;&#x3D;为便签增加标记，以区别不同人的便签&#x3D;&#x3D;</p>
<ul>
<li>现在可在检查之前留便签</li>
</ul>
<img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220907112305482.png" alt="image-20220907112305482" style="zoom: 50%;">

<blockquote>
<p>最后导致谁都没有检查有没有面包，都以为另外一个人会去买</p>
</blockquote>
<h4 id="解决方案4"><a href="#解决方案4" class="headerlink" title="解决方案4"></a>解决方案4</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220605122616182.png" alt="image-20220605122616182" style="zoom:50%;">

<p><strong>方案4分析</strong></p>
<p>它有效，但太复杂</p>
<ul>
<li>很难验证它的有效性</li>
</ul>
<p>A和B的代码不同</p>
<ul>
<li>每个进程的代码也会略有不同</li>
<li>如果进程更多，怎么办？</li>
</ul>
<p>&#x3D;&#x3D;当A在等待时，它不能做其他事&#x3D;&#x3D;</p>
<ul>
<li>忙等待（busy-waiting）</li>
</ul>
<h4 id="解决方案5"><a href="#解决方案5" class="headerlink" title="解决方案5"></a>解决方案5</h4><p>&#x3D;&#x3D;利用两个原子操作实现一个锁（lock）&#x3D;&#x3D;</p>
<ul>
<li>Lock.Acquire( )<ul>
<li>在锁被释放前一直等待，然后获得锁</li>
<li>如果两个线程都在等待同一个锁，并且同时发现锁被释放了，那么只有一个能够获得锁</li>
</ul>
</li>
<li>Lock.Release( )<ul>
<li>解锁并唤醒任何等待中的进程</li>
</ul>
</li>
</ul>
<p>基于原子锁的解决方案：</p>
<p><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220605122939306.png" alt="image-20220605122939306"></p>
<h4 id="进程的交互关系：相互感知程度"><a href="#进程的交互关系：相互感知程度" class="headerlink" title="进程的交互关系：相互感知程度"></a>进程的交互关系：相互感知程度</h4><table>
<thead>
<tr>
<th>相互感知的程度</th>
<th>交互关系</th>
<th>进程间的影响</th>
</tr>
</thead>
<tbody><tr>
<td>相互不感知（完全不了解其它进程的存在）</td>
<td>独立</td>
<td>一个进程的操作对其他进程的结果无影响</td>
</tr>
<tr>
<td>&#x3D;&#x3D;间接感知（双方都与第三方交互，如共享资源）&#x3D;&#x3D;</td>
<td>&#x3D;&#x3D;通过共享进行协作&#x3D;&#x3D;</td>
<td>&#x3D;&#x3D;一个进程的结果依赖于共享资源的状态&#x3D;&#x3D;</td>
</tr>
<tr>
<td>直接感知（双方直接交互，如通信）</td>
<td>通过通信进行协作</td>
<td>一个进程的结果依赖于从其他进程获得的信息</td>
</tr>
</tbody></table>
<p>互斥</p>
<ul>
<li>一个进程占用资源，其他进程不能使用</li>
</ul>
<p>死锁</p>
<ul>
<li>多个进程各占用部分资源，形成循环等待</li>
</ul>
<p>饥饿</p>
<ul>
<li>其他进程可能轮流占用资源，一个进程一直得不到资源</li>
</ul>
<h2 id="3、临界区"><a href="#3、临界区" class="headerlink" title="3、临界区"></a>3、临界区</h2><h4 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">entry section</span><br><span class="line">	critical section</span><br><span class="line">exit section</span><br><span class="line">	remainder section</span><br></pre></td></tr></table></figure>

<p>进入区</p>
<ul>
<li>检查可否进入临界区的一段代码</li>
<li>如可进入，设置相应“正在访问临界区”标志</li>
</ul>
<p>临界区</p>
<ul>
<li>进程中访问临界资源的一段需要互斥执行的代码</li>
</ul>
<p>退出区</p>
<ul>
<li>清除”正在访问临界区“标志</li>
</ul>
<p>剩余区</p>
<ul>
<li>代码中的其余部分（如执行一些返回地址或跳转等）</li>
</ul>
<h4 id="临界区的访问规则"><a href="#临界区的访问规则" class="headerlink" title="临界区的访问规则"></a>临界区的访问规则</h4><p>空闲则入</p>
<ul>
<li>没有进程在临界区时，任何进程可进入</li>
</ul>
<p>忙则等待</p>
<ul>
<li>有进程在临界区时，其他进程均不能进入临界区</li>
</ul>
<p>优先等待</p>
<ul>
<li>等待进入临界区的进程不能无限期等待</li>
</ul>
<p>让权等待（可选）</p>
<ul>
<li>不能进入临界区的进程，应释放CPU（如转换到阻塞状态）</li>
</ul>
<h4 id="临界区的实现方法"><a href="#临界区的实现方法" class="headerlink" title="临界区的实现方法"></a>临界区的实现方法</h4><ul>
<li>禁用中断</li>
<li>软件方法</li>
<li>更高级的抽象方法</li>
<li>不同的临界区实现机制的比较<ul>
<li>性能：并发级别</li>
</ul>
</li>
</ul>
<h2 id="4、禁用硬件中断同步方法"><a href="#4、禁用硬件中断同步方法" class="headerlink" title="4、禁用硬件中断同步方法"></a>4、禁用硬件中断同步方法</h2><h4 id="禁用硬件中断"><a href="#禁用硬件中断" class="headerlink" title="禁用硬件中断"></a>禁用硬件中断</h4><p>没有中断，没有上下文切换，因此没有并发</p>
<ul>
<li>硬件将中断处理延迟到中断被启用之后</li>
<li>现代计算机体系结构都提供指令来实现禁用中断</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">local_irg_save(<span class="type">unsigned</span> <span class="type">long</span> flags);</span><br><span class="line">critical section</span><br><span class="line"><span class="title function_">local_irq_restore</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> flags)</span>;</span><br></pre></td></tr></table></figure>

<p>进入临界区</p>
<ul>
<li>禁止所有中断，并保存标志</li>
</ul>
<p>离开临界区</p>
<ul>
<li>使能所有中断，并恢复标志</li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li><p>禁用中断后，进程无法被停止</p>
<ul>
<li>整个系统都会为此停下来</li>
<li>可能导致其他进程处于机饿状态</li>
</ul>
</li>
<li><p>临界区可能很长</p>
<ul>
<li>无法确定响应中断所需的时间（可能存在硬件影响）</li>
</ul>
</li>
<li><p>要小心使用</p>
</li>
</ul>
<h2 id="5、基于软件的同步方法"><a href="#5、基于软件的同步方法" class="headerlink" title="5、基于软件的同步方法"></a>5、基于软件的同步方法</h2><h4 id="基于软件的同步解决方法"><a href="#基于软件的同步解决方法" class="headerlink" title="基于软件的同步解决方法"></a>基于软件的同步解决方法</h4><p>两个线程，T0和T1 </p>
<ul>
<li>线程Ti的代码</li>
</ul>
<img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220907114142843.png" alt="image-20220907114142843" style="zoom:67%;">

<p>线程可通过共享一些共有变量来同步它们的行为</p>
<h4 id="第一次尝试"><a href="#第一次尝试" class="headerlink" title="第一次尝试"></a>第一次尝试</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220907114632391.png" alt="image-20220907114632391" style="zoom: 67%;">

<p>满足“忙则等待”，但是有时不满足“空闲则入</p>
<ul>
<li>Ti 不在临界区，Ti 想要继续运行，但是必须等待Ti 进入过临界区后</li>
</ul>
<h4 id="第二种尝试"><a href="#第二种尝试" class="headerlink" title="第二种尝试"></a>第二种尝试</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220907114701720.png" alt="image-20220907114701720" style="zoom: 67%;">

<p>不满足 “忙则等待“</p>
<h4 id="第三种尝试"><a href="#第三种尝试" class="headerlink" title="第三种尝试"></a>第三种尝试</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220907114817566.png" alt="image-20220907114817566" style="zoom: 67%;">

<p>满足 “忙则等待”，但是不满足 “空闲则入“</p>
<h4 id="Peterson算法"><a href="#Peterson算法" class="headerlink" title="Peterson算法"></a>Peterson算法</h4><p>满足线程Ti 和 Tj 之间互斥的经典的基于软件的解决方法</p>
<img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220907114921534.png" alt="image-20220907114921534" style="zoom: 67%;">

<h4 id="Peterson算法实现"><a href="#Peterson算法实现" class="headerlink" title="Peterson算法实现"></a>Peterson算法实现</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220606104800654.png" alt="image-20220606104800654" style="zoom: 67%;">



<h4 id="Dekkers算法"><a href="#Dekkers算法" class="headerlink" title="Dekkers算法"></a>Dekkers算法</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220828101840870.png" alt="image-20220828101840870" style="zoom:67%;">

<h4 id="N线程的软件方法（Eisenberg和McGuire）"><a href="#N线程的软件方法（Eisenberg和McGuire）" class="headerlink" title="N线程的软件方法（Eisenberg和McGuire）"></a>N线程的软件方法（Eisenberg和McGuire）</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220828114647192.png" alt="image-20220828114647192" style="zoom:67%;">

<h4 id="基于软件的解决方法的分析"><a href="#基于软件的解决方法的分析" class="headerlink" title="基于软件的解决方法的分析"></a>基于软件的解决方法的分析</h4><p>复杂</p>
<ul>
<li>需要两个进程间的共享数据项</li>
</ul>
<p>需要忙等待</p>
<ul>
<li>浪费CPU时间</li>
</ul>
<h2 id="6、高级抽象的同步方法"><a href="#6、高级抽象的同步方法" class="headerlink" title="6、高级抽象的同步方法"></a>6、高级抽象的同步方法</h2><h4 id="高级抽象的同步方法"><a href="#高级抽象的同步方法" class="headerlink" title="高级抽象的同步方法"></a>高级抽象的同步方法</h4><p>硬件提供了一些同步原语</p>
<ul>
<li>中断禁用，原子操作指令等</li>
</ul>
<p>操作系统提供更高级的编程抽象来简化进程同步</p>
<ul>
<li>例如：锁、信号量</li>
<li>用硬件原语来构建</li>
</ul>
<h4 id="锁（Lock）"><a href="#锁（Lock）" class="headerlink" title="锁（Lock）"></a>锁（Lock）</h4><p>锁是一个抽象的数据结构</p>
<ul>
<li>一个二进制变量（锁定&#x2F;&#x2F;解锁）</li>
<li>Lock :: Acquire()<ul>
<li>锁被释放前一直等待，然后得到锁</li>
</ul>
</li>
<li>Lock :: Release()<ul>
<li>释放锁，唤醒任何等待的进程</li>
</ul>
</li>
</ul>
<p>使用锁来控制临界区访问</p>
<p><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220828115632639.png" alt="image-20220828115632639"></p>
<h4 id="原子操作指令"><a href="#原子操作指令" class="headerlink" title="原子操作指令"></a>原子操作指令</h4><ul>
<li>现代CPU体系结构都提供一些特殊的原子操作指令</li>
<li>测试和置位（Test-and-Set）指令<ul>
<li>从内存单元中读取值</li>
<li>测试该值是否为1（然后返回真或假）</li>
<li>内存单元值设置为1</li>
</ul>
</li>
</ul>
<img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220907115409189.png" alt="image-20220907115409189" style="zoom: 67%;">

<ul>
<li>交换指令（exchange）<ul>
<li>交换内存中的两个值</li>
</ul>
</li>
</ul>
<p><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220907115459925.png" alt="image-20220907115459925"></p>
<h4 id="使用TS指令实现自旋锁（spinlock）"><a href="#使用TS指令实现自旋锁（spinlock）" class="headerlink" title="使用TS指令实现自旋锁（spinlock）"></a>使用TS指令实现自旋锁（spinlock）</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220828120418593.png" alt="image-20220828120418593" style="zoom: 67%;">

<blockquote>
<p>特点：线程在等待的时候消耗CPU时间</p>
</blockquote>
<h4 id="无忙等待锁"><a href="#无忙等待锁" class="headerlink" title="无忙等待锁"></a>无忙等待锁</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220828120731407.png" alt="image-20220828120731407" style="zoom:67%;">

<blockquote>
<p>如锁是关时，当前进程加入等待队列，schedule()CPU执行调度程序，如果该锁释放，唤醒等待队列，队列中的进程在去查看锁的状态</p>
</blockquote>
<h4 id="原子操作指令特征锁"><a href="#原子操作指令特征锁" class="headerlink" title="原子操作指令特征锁"></a>原子操作指令特征锁</h4><p>优点</p>
<ul>
<li>适用于单处理器或者共享主存的&#x3D;&#x3D;多处理器&#x3D;&#x3D;中&#x3D;&#x3D;任意数量的进程同步&#x3D;&#x3D;</li>
<li>简单并且容易证明</li>
<li>支持多临界区</li>
</ul>
<p>缺点</p>
<ul>
<li>忙等待消耗处理器时间</li>
<li>可能导致机饿</li>
<li>进程离开临界区时有多个等待进程的情况</li>
<li>死锁<ul>
<li>拥有临界区的低优先级进程</li>
<li>请求访问临界区的高优先级进程获得处理器并等待临界区</li>
</ul>
</li>
</ul>
<h4 id="同步方法总结"><a href="#同步方法总结" class="headerlink" title="同步方法总结"></a>同步方法总结</h4><p>锁是一种高级的同步抽象方法</p>
<ul>
<li>互斥可以使用锁来实现</li>
<li>需要硬件支持</li>
</ul>
<p>常用的三种同步实现方法</p>
<ul>
<li>禁用中断（仅限于单处理器）</li>
<li>软件方法（复杂）</li>
<li>原子操作指令（单处理器或多处理器均可）</li>
</ul>
<h2 id="7、信号量（semaphore）"><a href="#7、信号量（semaphore）" class="headerlink" title="7、信号量（semaphore）"></a>7、信号量（semaphore）</h2><h4 id="回顾并发和同步"><a href="#回顾并发和同步" class="headerlink" title="回顾并发和同步"></a>回顾并发和同步</h4><p>并发问题</p>
<ul>
<li>多线程并发导致资源竞争</li>
</ul>
<p>同步概念</p>
<ul>
<li>协调多线程对共享数据的访问</li>
<li>任何时刻只能有一个线程执行临界区代码</li>
</ul>
<p>确保同步正确的方法</p>
<ul>
<li>底层硬件支持</li>
<li>高层次的编程抽象</li>
</ul>
<img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220908083815091.png" alt="image-20220908083815091" style="zoom: 67%;">





<h4 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h4><ul>
<li>信号量是操作系统提供的一种协调共享资源访问的方法<ul>
<li>软件同步是平等线程间的一种同步协商机制</li>
<li>OS是管理者，地位高于进程</li>
<li>用信号量表示&#x3D;&#x3D;系统资源的数量&#x3D;&#x3D;</li>
</ul>
</li>
<li>由Dijkstra在20世纪60年代提出</li>
<li>早期的操作系统的主要同步机制<ul>
<li>现在很少用（但还是非常重要在计算机科学研究）</li>
</ul>
</li>
</ul>
<h4 id="信号量的类比示例"><a href="#信号量的类比示例" class="headerlink" title="信号量的类比示例"></a>信号量的类比示例</h4><p>信号是一种抽象数据类型</p>
<ul>
<li>由一个整型（sem）变量和两个原子操作组成</li>
<li>P( ) （Prolaag）荷兰语尝试减少<ul>
<li>sem减少1</li>
<li>如 sem&lt; 0 ，进入等待，否则继续</li>
</ul>
</li>
<li>V( ) <ul>
<li>sem加1</li>
<li>如sem&lt;&#x3D;0，唤醒一个等待进程</li>
</ul>
</li>
<li>信号量与铁路的类比<ul>
<li>2个站台的车站</li>
<li>2个资源的信号量</li>
</ul>
</li>
</ul>
<p><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220828221403975.png" alt="image-20220828221403975"></p>
<h4 id="信号量的特性"><a href="#信号量的特性" class="headerlink" title="信号量的特性"></a>信号量的特性</h4><ul>
<li>信号量是&#x3D;&#x3D;被保护&#x3D;&#x3D;的&#x3D;&#x3D;整数&#x3D;&#x3D;变量<ul>
<li>初始化完成后，只能通过P（）和V（）操作修改</li>
<li>由操作系统保证，PV操作是原子操作</li>
</ul>
</li>
<li>&#x3D;&#x3D;P（）可能阻塞&#x3D;&#x3D;，V（）不会阻塞</li>
<li>通常假定信号量是“公平的“<ul>
<li>线程不会被无限期阻塞在P（）操作</li>
<li>假定信号量等待按先进先出排队</li>
</ul>
</li>
</ul>
<blockquote>
<p>自旋锁能否实现先进先出？</p>
<p>不能实现先进先出，当释放锁时，各个等待的进程需要抢占CPU去检查锁开关状态</p>
</blockquote>
<h4 id="信号量的发展"><a href="#信号量的发展" class="headerlink" title="信号量的发展"></a>信号量的发展</h4><ul>
<li>整型信号量（重点了解）<ul>
<li>在整型信号量机制中的wait操作，只要是信号量S≤0般会&#x3D;&#x3D;不断地测试&#x3D;&#x3D;</li>
</ul>
</li>
<li>记录型信号量（重点了解）<ul>
<li>整型信号量并未遵循“让权等待”的准则，而是使进程处于“忙等”的状态</li>
<li>记录型信号量机制则是一种不存在“忙等”现象的进程同步机制。但在采取了“让权等待”的策略后，又会出现多个进程等待访问同一临界资源的情况。为此，在信号量机制中，除了需要一个用于代表&#x3D;&#x3D;资源数目的整型变量value&#x3D;&#x3D;外，还应增加一个&#x3D;&#x3D;进程链表指针list&#x3D;&#x3D;，用于&#x3D;&#x3D;链接上述的所有等待进程&#x3D;&#x3D;。</li>
</ul>
</li>
<li>AND信号量</li>
<li>信号量集</li>
</ul>
<h4 id="记录型信号量的实现"><a href="#记录型信号量的实现" class="headerlink" title="记录型信号量的实现"></a>记录型信号量的实现</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220829091238213.png" alt="image-20220829091238213" style="zoom: 67%;">

<blockquote>
<p>这段代码由操作系统内核执行，保证其原子性，避免以往中断带来的同步问题</p>
</blockquote>
<h4 id="信号量的分类和使用"><a href="#信号量的分类和使用" class="headerlink" title="信号量的分类和使用"></a>信号量的分类和使用</h4><p>可分为两种信号量</p>
<ul>
<li>&#x3D;&#x3D;二进制信号量&#x3D;&#x3D;：资源数目为0或1</li>
<li>&#x3D;&#x3D;资源信号量&#x3D;&#x3D;：资源数目为任何非负值</li>
<li>两者等价<ul>
<li>基于一个可以实现另一个</li>
</ul>
</li>
</ul>
<p>信号量的使用</p>
<ul>
<li>互斥访问<ul>
<li>临界区的互斤访问控制</li>
</ul>
</li>
<li>条件同步<ul>
<li>线程间的事件等待</li>
</ul>
</li>
</ul>
<h4 id="信号量实现临界区的互斥访问"><a href="#信号量实现临界区的互斥访问" class="headerlink" title="信号量实现临界区的互斥访问"></a>信号量实现临界区的互斥访问</h4><p>每类资源设置一个信号量，其初值为1</p>
<img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220908085239025.png" alt="image-20220908085239025" style="zoom: 67%;">

<p>必须&#x3D;&#x3D;成对使用&#x3D;&#x3D;P（）操作和V（）操作</p>
<ul>
<li>P（）操作保证互后访问临界资源</li>
<li>V（）操作在使用后释放临界资源</li>
<li>PV操作&#x3D;&#x3D;不能次序错误、重复或遗漏&#x3D;&#x3D;</li>
</ul>
<h4 id="信号量实现条件同步"><a href="#信号量实现条件同步" class="headerlink" title="信号量实现条件同步"></a>信号量实现条件同步</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220829092314216.png" alt="image-20220829092314216" style="zoom: 80%;">

<blockquote>
<p>假设线程A要实现N，要等待线程B实现完X，使用信号量实现这种条件同步，即线程A实现完M将信号量减一，线程B实现完X将信号量加一,线程A发现信号量恢复0，可执行N,线程B也继续执行Y。</p>
</blockquote>
<h4 id="生产者-消费者问题"><a href="#生产者-消费者问题" class="headerlink" title="生产者-消费者问题"></a>生产者-消费者问题</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220908085653163.png" alt="image-20220908085653163" style="zoom:80%;">

<p>有界缓冲区的生产者-消费者问题描述</p>
<ul>
<li>一个或多个&#x3D;&#x3D;生产者&#x3D;&#x3D;在生成数据后放在一个缓冲区里</li>
<li>单个&#x3D;&#x3D;消费者&#x3D;&#x3D;从缓冲区取出数据处理</li>
<li>任何时刻&#x3D;&#x3D;只能有一个&#x3D;&#x3D;生产者或消费者可访问缓冲区</li>
</ul>
<h4 id="信号量解决生产者-消费者问题"><a href="#信号量解决生产者-消费者问题" class="headerlink" title="信号量解决生产者-消费者问题"></a>信号量解决生产者-消费者问题</h4><p>问题分析</p>
<ul>
<li>任何时刻只能有一个线程操作缓冲区（互兵访问）</li>
<li>缓冲区空时，消费者必须等待生产者（条件同步</li>
<li>缓冲区满时，生产者必须等待消费者（条件同步）</li>
</ul>
<p>用信号量描述每个约束</p>
<ul>
<li>二进制信号量mutex</li>
<li>资源信号量fullBuffers</li>
<li>资源信号量emptyBuffers</li>
</ul>
<p><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220829093616763.png" alt="image-20220829093616763"></p>
<h4 id="信号量的缺点"><a href="#信号量的缺点" class="headerlink" title="信号量的缺点"></a>信号量的缺点</h4><p>读&#x2F;开发代码比较困难</p>
<ul>
<li>程序员需要能运用信号量机制</li>
</ul>
<p>容易出错</p>
<ul>
<li>使用的信号量已经被另一个线程占用</li>
<li>忘记释放信号量</li>
</ul>
<p>不能够处理死锁问题</p>
<blockquote>
<p>不能解决死锁：因为一个线程进入到临界区后，如果执行的所需资源被占用，该线程不会自动放弃临界区资源，对方如果也想用临界区，这将导致严重的死锁问题</p>
</blockquote>
<h2 id="8、管程"><a href="#8、管程" class="headerlink" title="8、管程"></a>8、管程</h2><h4 id="基本同步方法"><a href="#基本同步方法" class="headerlink" title="基本同步方法"></a>基本同步方法</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220829100524485.png" alt="image-20220829100524485" style="zoom: 67%;">

<h4 id="管程（Moniter）"><a href="#管程（Moniter）" class="headerlink" title="管程（Moniter）"></a>管程（Moniter）</h4><p>管程是一种用于多线程互斥访问共享资源的程序结构</p>
<ul>
<li>采用面向对象方法，简化了线程间的同步控制</li>
<li>任一时刻最多只有一个线程执行管程代码</li>
<li>正在管程中的线程可临时放弃管程的互斥访问，等待事件出现时恢复</li>
</ul>
<p>管程的使用</p>
<ul>
<li>在对象&#x2F;模块中，收集相关共享数据</li>
<li>定义访问共享数据的方法</li>
</ul>
<h4 id="管程的组成"><a href="#管程的组成" class="headerlink" title="管程的组成"></a>管程的组成</h4><p>一个锁</p>
<ul>
<li>控制管程代码的互斥访问</li>
</ul>
<p>0或者多个条件变量</p>
<ul>
<li>管理共享数据的并发访问</li>
</ul>
<img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220908090630331.png" alt="image-20220908090630331" style="zoom:80%;">

<blockquote>
<p>管程临界区每次只能进一个，如果进入到的管程临界区或执行管程代码时，某一条件被占用，不满足条件变量，则会被放入管程内的等待队列，此时管程可由下一个线程接管，当再次满足条件时，唤醒等待队列一个线程抢占执行</p>
</blockquote>
<h4 id="条件变量（Condition-Variable）"><a href="#条件变量（Condition-Variable）" class="headerlink" title="条件变量（Condition Variable）"></a>条件变量（Condition Variable）</h4><p>条件变量是管程内的等待机制</p>
<ul>
<li>进入管程的线程因资源被占用而进入等待状态</li>
<li>每个条件变量表示一种等待原因，对应一个等待队列</li>
</ul>
<p>Wait（）操作</p>
<ul>
<li>将自己阻塞在等待队列中</li>
<li>唤醒一个等待者或释放管程的互后访问</li>
</ul>
<p>Signal（）操作</p>
<ul>
<li>将等待队列中的一个线程唤醒</li>
<li>如果等待队列为空，则等同空操作</li>
</ul>
<img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220829102639849.png" alt="image-20220829102639849">

<h4 id="管程解决生产者-消费者问题"><a href="#管程解决生产者-消费者问题" class="headerlink" title="管程解决生产者-消费者问题"></a>管程解决生产者-消费者问题</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220829103622921.png" alt="image-20220829103622921" style="zoom: 67%;">

<h4 id="管程条件变量的释放处理方式"><a href="#管程条件变量的释放处理方式" class="headerlink" title="管程条件变量的释放处理方式"></a>管程条件变量的释放处理方式</h4><p>Hansen管程：</p>
<ul>
<li>T2唤醒唤醒T1，仍继续执行，直到结束退出管程，T1才开始执行</li>
<li>主要用于真实的OS和Java中</li>
</ul>
<p>Hoare管程：</p>
<ul>
<li>T2唤醒T1后，T1立马恢复管程执行，执行结束后，才到T2执行</li>
<li>主要见于教材中</li>
</ul>
<img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220829110812498.png" alt="image-20220829110812498" style="zoom: 67%;">

<h4 id="Hansen管程与Hoare管程"><a href="#Hansen管程与Hoare管程" class="headerlink" title="Hansen管程与Hoare管程"></a>Hansen管程与Hoare管程</h4><p>Hansen管程</p>
<ul>
<li>条件变量释放仅是一个提示</li>
<li>需要重新检查条件</li>
<li>特点：高效</li>
</ul>
<p>Hoare管程</p>
<ul>
<li>条件变量释放同时表示放弃管程访问</li>
<li>释放后条件变量的状态可用</li>
<li>特点：低效</li>
</ul>
<img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220908091731330.png" alt="image-20220908091731330" style="zoom:80%;">

<h2 id="9、哲学家就餐问题"><a href="#9、哲学家就餐问题" class="headerlink" title="9、哲学家就餐问题"></a>9、哲学家就餐问题</h2><h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><ul>
<li>5个哲学家围绕一张圆桌而坐<ul>
<li>桌子上放着5支叉子</li>
<li>每两个哲学家之间放一支</li>
</ul>
</li>
<li>哲学家的动作包括思考和进餐<ul>
<li>进餐时需同时拿到左右两边的叉子</li>
<li>思考时将两支叉子放回原处</li>
</ul>
</li>
<li>如何保证哲学家们的动作有序进行？<ul>
<li>如：不出现有人永远拿不到叉子</li>
</ul>
</li>
</ul>
<img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220908092455212.png" alt="image-20220908092455212" style="zoom:67%;">

<h4 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220829211820678.png" alt="image-20220829211820678" style="zoom:67%;">

<blockquote>
<p>不正确，可能导致死锁</p>
</blockquote>
<h4 id="方案二-信号量互斥访问"><a href="#方案二-信号量互斥访问" class="headerlink" title="方案二::信号量互斥访问"></a>方案二::信号量互斥访问</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220829211901768.png" alt="image-20220829211901768" style="zoom: 80%;">

<blockquote>
<p>互斥访问正确，但每次只允许一人进餐</p>
</blockquote>
<h4 id="方案三"><a href="#方案三" class="headerlink" title="方案三"></a>方案三</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220829212022640.png" alt="image-20220829212022640" style="zoom:80%;">

<blockquote>
<p>加变量i，2号哲学家来先拿左边筷子，3号哲学家来先拿右边筷子，中间的筷子二者谁抢先算谁的</p>
<p>没有死锁，可以多人同时进餐</p>
</blockquote>
<h2 id="10、读者-写者问题"><a href="#10、读者-写者问题" class="headerlink" title="10、读者-写者问题"></a>10、读者-写者问题</h2><h4 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h4><p>共享数据的两类使用者</p>
<ul>
<li>读者：只读取数据不修改</li>
<li>写者：读取和修改数据</li>
</ul>
<p>读者-写者问题描述：对共享数据的读写</p>
<ul>
<li>“读 - 读”允许<ul>
<li>同一时刻，允许有多个读者同时读</li>
</ul>
</li>
<li>“读－写”互斥<ul>
<li>没有写者时读者才能读</li>
<li>没有读者时写者才能写</li>
</ul>
</li>
<li>“写 - 写”互斥<ul>
<li>没有其他写者时写者才能写</li>
</ul>
</li>
</ul>
<h4 id="信号量解决读者-写者问题"><a href="#信号量解决读者-写者问题" class="headerlink" title="信号量解决读者-写者问题"></a>信号量解决读者-写者问题</h4><p>用信号量描述每个约束</p>
<ul>
<li>信号量WriteMutex<ul>
<li>控制读写操作的互斥</li>
<li>初始化为1</li>
</ul>
</li>
<li>读者计数Rcount<ul>
<li>正在进行读操作的读者数目</li>
<li>初始化为0</li>
</ul>
</li>
<li>信号量CountMutex<ul>
<li>控制对读者计数的互斥修改</li>
<li>初始化为1</li>
</ul>
</li>
</ul>
<img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220829215248958.png" alt="image-20220829215248958" style="zoom: 80%;">

<h4 id="优先策略"><a href="#优先策略" class="headerlink" title="优先策略"></a>优先策略</h4><p>读者优先策略</p>
<ul>
<li>只要有读者正在读状态，后来的读者都能直接进入</li>
<li>如读者持续不断进入，则写者就处于饥饿</li>
</ul>
<p>写者优先策略</p>
<ul>
<li>只要有写者就绪，写者应尽快执行写操作</li>
<li>如写者持续不断就绪，则读者就处于饥饿</li>
</ul>
<h4 id="用管程解决读者-写者问题"><a href="#用管程解决读者-写者问题" class="headerlink" title="用管程解决读者-写者问题"></a>用管程解决读者-写者问题</h4><p><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220829215500272.png" alt="image-20220829215500272"></p>
<h4 id="解决方案详细：读者"><a href="#解决方案详细：读者" class="headerlink" title="解决方案详细：读者"></a>解决方案详细：读者</h4><p><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220829215547076.png" alt="image-20220829215547076"></p>
<h4 id="解决方案详细：写者"><a href="#解决方案详细：写者" class="headerlink" title="解决方案详细：写者"></a>解决方案详细：写者</h4><p><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220829215625842.png" alt="image-20220829215625842"></p>
<blockquote>
<p>管程实现主要以写者优先</p>
</blockquote>
<h1 id="十一、死锁"><a href="#十一、死锁" class="headerlink" title="十一、死锁"></a>十一、死锁</h1><h2 id="1、死锁的概念"><a href="#1、死锁的概念" class="headerlink" title="1、死锁的概念"></a>1、死锁的概念</h2><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>由于竞争资源或通信关系，两个或更多线程在执行中出现，永远相互等待只能由其他进程引发的事件</p>
<h4 id="死锁实例：单向通行桥梁"><a href="#死锁实例：单向通行桥梁" class="headerlink" title="死锁实例：单向通行桥梁"></a>死锁实例：单向通行桥梁</h4><p>桥梁只能单向通行</p>
<p>桥的每个部分可视为一个资源</p>
<p>可能出现死锁</p>
<ul>
<li>对向行驶车辆在桥上相遇</li>
<li>解决方法：一个方向的车辆倒退（资源抢占和回退）</li>
</ul>
<img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220829231026688.png" alt="image-20220829231026688" style="zoom: 67%;">

<p>可能发生饥饿</p>
<ul>
<li>由于一个方向的持续车流，另一个方向的车辆无法通过桥梁</li>
</ul>
<img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220829231316404.png" alt="image-20220829231316404" style="zoom:67%;">



<h4 id="进程访问资源的流程"><a href="#进程访问资源的流程" class="headerlink" title="进程访问资源的流程"></a>进程访问资源的流程</h4><ul>
<li>资源类型R1，R2…..Rm<ul>
<li>CPU执行时间、内存空间、I&#x2F;O设备等</li>
</ul>
</li>
<li>每类资源Ri 有Wi 个实例</li>
<li>进程访问资源的流程<ul>
<li>请求&#x2F;获取<ul>
<li>申请空闲资源</li>
</ul>
</li>
<li>使用&#x2F;占用<ul>
<li>进程占用资源</li>
</ul>
</li>
<li>释放<ul>
<li>资源状态由占用变成空闲</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="资源分类"><a href="#资源分类" class="headerlink" title="资源分类"></a>资源分类</h4><p>可重用资源（Reusable Resource）</p>
<ul>
<li>资源不能被删除且在任何时刻只能有一个进程使用</li>
<li>进程释放资源后，其他进程可重用</li>
<li>可重用资源示例<ul>
<li>硬件：处理器、I &#x2F; O通道、主和副存储器、设备等</li>
<li>软件：文件、数据库和信号量等数据结构</li>
</ul>
</li>
<li>可能出现死锁<ul>
<li>每个进程占用一部分资源并请求其他资源</li>
</ul>
</li>
</ul>
<p>消耗资源（Consumable Resource）</p>
<ul>
<li>资源创建和销毁</li>
<li>消耗资源示例<ul>
<li>在I &#x2F; O 缓冲区的中断、信号、消息等</li>
</ul>
</li>
</ul>
<h4 id="资源分配图"><a href="#资源分配图" class="headerlink" title="资源分配图"></a>资源分配图</h4><p>&#x3D;&#x3D;描述资源和进程间的分配和占用关系的有向图&#x3D;&#x3D;<br>两类顶点</p>
<ul>
<li>系统中的所有进程<br>P&#x3D;(Pi, P2.. Pn）</li>
<li>系统中的所有资源<br>R&#x3D; (Ri, R2..Pm）</li>
</ul>
<p>两类有向边</p>
<ul>
<li>资源请求边<br>进程Pi请求资源Rj：Pi→Rj</li>
<li>资源分配边<br>资源Rj已分配给进程Pi：Rj→Pi</li>
</ul>
<img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220908101632240.png" alt="image-20220908101632240" style="zoom:67%;">

<img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220829232241311.png" alt="image-20220829232241311" style="zoom:67%;">

<h4 id="出现死锁的必要条件"><a href="#出现死锁的必要条件" class="headerlink" title="出现死锁的必要条件"></a>出现死锁的必要条件</h4><p>互斥</p>
<ul>
<li>任何时刻只能由一个进程使用一个资源实例</li>
</ul>
<p>非抢占</p>
<ul>
<li>资源只能在进程使用后资源释放</li>
</ul>
<p>持有并等待</p>
<ul>
<li>进程保持至少一个资源，并正在等待获取其他进程持有的资源</li>
</ul>
<p>循环等待</p>
<ul>
<li><p>存在等待进程集合{ P0，P1，…..，PN }，</p>
<p>P0正在等待P1所占用的资源，</p>
<p>P1正在等待P2所占用的资源，</p>
<p>PN-1正在等待PN所占用的资源，</p>
<p>PN正在等待P0所占用的资源。</p>
</li>
</ul>
<h2 id="2、死锁处理的方法"><a href="#2、死锁处理的方法" class="headerlink" title="2、死锁处理的方法"></a>2、死锁处理的方法</h2><h4 id="死锁处理的方法"><a href="#死锁处理的方法" class="headerlink" title="死锁处理的方法"></a>死锁处理的方法</h4><p>&#x3D;&#x3D;死锁预防（Deadlock Prevention）&#x3D;&#x3D;</p>
<ul>
<li>确保系统永远不会进入死锁状态</li>
</ul>
<p>&#x3D;&#x3D;死锁避免（Deadlock Avoidance）&#x3D;&#x3D;</p>
<ul>
<li>在使用前进行判断，只允许不会出现死锁的进程请求资源</li>
</ul>
<p>&#x3D;&#x3D;死锁检测和恢复（Deadlock Detection &amp; Recovery）&#x3D;&#x3D;</p>
<ul>
<li>在检测到运行系统进入死锁状态后，进行恢复</li>
</ul>
<p>由应用进程处理死锁</p>
<ul>
<li>通常操作系统忽略死锁<ul>
<li>大多数操作系统（包括UNIX）的做法</li>
</ul>
</li>
</ul>
<h4 id="死锁预防：限制申请方式"><a href="#死锁预防：限制申请方式" class="headerlink" title="死锁预防：限制申请方式"></a>死锁预防：限制申请方式</h4><p>预防是采用某种策略，限制并发进程对资源的请求，使系统在任何时刻都不满足死锁的必要要求</p>
<ul>
<li>互斥<ul>
<li>把互斥的共享资源封装成可同时访问的资源，如将其拷贝出来</li>
</ul>
</li>
<li>持有并等待<ul>
<li>进程请求资源时，要求它不持有任何资源</li>
<li>仅允许进程在开始执行时，一次请求所有需要的资源</li>
<li>资源利用率低</li>
</ul>
</li>
<li>非抢占<ul>
<li>如进程请求不能立即分配的资源，则释放已占有资源</li>
<li>只在能够同时获取所有需要资源时，才执行分配操作</li>
</ul>
</li>
<li>循环等待<ul>
<li>对资源排序，要求进程按顺序请求资源</li>
</ul>
</li>
</ul>
<h4 id="死锁避免"><a href="#死锁避免" class="headerlink" title="死锁避免"></a>死锁避免</h4><p>利用额外的先验信息，在分配资源时判断是否会出现死锁，只在不会死锁时分配资源</p>
<ul>
<li>要求进程声明需要资源的&#x3D;&#x3D;最大数目&#x3D;&#x3D;</li>
<li>限定&#x3D;&#x3D;提供&#x3D;&#x3D;与&#x3D;&#x3D;分配&#x3D;&#x3D;的资源数量，确保满足进程的&#x3D;&#x3D;最大&#x3D;&#x3D;需求</li>
<li>&#x3D;&#x3D;动态检查&#x3D;&#x3D;资源分配状态，确保不会出现环形等待</li>
</ul>
<h4 id="资源分配资源的安全状态"><a href="#资源分配资源的安全状态" class="headerlink" title="资源分配资源的安全状态"></a>资源分配资源的安全状态</h4><ul>
<li>当进程请求资源时，系统判断分配后是否处于安全状态</li>
<li>系统处于安全状态<ul>
<li>针对所有已占用进程，存在安全序列</li>
</ul>
</li>
<li>序列&lt;P1，P2….，PN&gt;是安全的<ul>
<li>Pi 要求的资源 ≤ 当前可用资源 + 所有 Pi 持有资源，其中j&lt;i</li>
<li>如Pi 的资源请求不能立即分配，则P等待所有Pj（j&lt;i）完成</li>
<li>Pi 完成后，Pi+1可得到所需资源，执行并释放所分配的资源</li>
<li>最终整个序列的所有Pi 都能获得所需资源</li>
</ul>
</li>
</ul>
<h4 id="安全状态与死锁的关系"><a href="#安全状态与死锁的关系" class="headerlink" title="安全状态与死锁的关系"></a>安全状态与死锁的关系</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220909090613482.png" alt="image-20220909090613482" style="zoom:67%;">

<ul>
<li>系统处于安全状态，一定没有死锁</li>
<li>系统处于不安全状态，可能出现死锁<ul>
<li>避免死锁就是确保系统不会进入不安全状态</li>
</ul>
</li>
</ul>
<h2 id="3、银行家算法（Banker-96-s-Alogrithm）"><a href="#3、银行家算法（Banker-96-s-Alogrithm）" class="headerlink" title="3、银行家算法（Banker&#96;s  Alogrithm）"></a>3、银行家算法（Banker&#96;s  Alogrithm）</h2><h4 id="银行家算法概述"><a href="#银行家算法概述" class="headerlink" title="银行家算法概述"></a>银行家算法概述</h4><p>银行家算法是一个避免死锁产生的算法。以银行借贷分配策略为基础，判断并保证系统处于安全状态</p>
<ul>
<li>客户在第一次申请贷款时，声明所需最大资金量，在满足所有贷款要求并完成项目时，及时归还</li>
<li>在客户贷款数量不超过银行拥有的最大值时，银行家尽量满足客户需要</li>
<li>类比<ul>
<li>银行家 —-&gt; 操作系统</li>
<li>资金 —-&gt; 资源</li>
<li>客户 —-&gt; 申请资源的线程</li>
</ul>
</li>
</ul>
<h4 id="银行家算法：数据结构"><a href="#银行家算法：数据结构" class="headerlink" title="银行家算法：数据结构"></a>银行家算法：数据结构</h4><p>&#x3D;&#x3D;n&#x3D;&#x3D; &#x3D; 线程数量，&#x3D;&#x3D;m&#x3D;&#x3D; &#x3D;资源类型数量</p>
<ul>
<li>&#x3D;&#x3D;Max（总需求量）&#x3D;&#x3D;：n x m 矩阵<br>线程 Ti 最多请求类型 R 的资源Max[ i , j ]个实例</li>
<li>&#x3D;&#x3D;Available（剩余空闲量）&#x3D;&#x3D;：长度为m的向量<br>当前有Available[ i ] 个类型Rj的资源实例可用</li>
<li>&#x3D;&#x3D;Allocation（已分配量）&#x3D;&#x3D;：n x m矩阵<br>线程T当前分配了Allocation[ i , j ]个R的实例</li>
<li>&#x3D;&#x3D;Need（未来需要量）&#x3D;&#x3D;：n x m 矩阵<br>线程 Ti 未来需要Need[ i , j ]个 Rj 资源实例</li>
<li>&#x3D;&#x3D;Need[ i , j ] &#x3D; Max[ i , j ] - Allocation[ i , j ]&#x3D;&#x3D;</li>
</ul>
<h4 id="银行家算法：安全状态判断"><a href="#银行家算法：安全状态判断" class="headerlink" title="银行家算法：安全状态判断"></a>银行家算法：安全状态判断</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220830001152909.png" alt="image-20220830001152909" style="zoom:67%;">

<h4 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h4><p>初始化：</p>
<ul>
<li>Request i 线程 Ti 的资源请求向量</li>
<li>Request i [ j ]线程 Ti 请求资源 Rj 的实例</li>
</ul>
<p>循环：</p>
<ol>
<li>如果 Request i ≤ Need[ i ]，转到步骤2。否则，拒绝资源申请，因为线程已经超过了其最大要求</li>
<li>如果Request i ≤ Available，转到步骤3。否则，Ti 必须等待，因为资源不可用</li>
<li>通过安全状态判断来确定是否分配资源给Ti：<ul>
<li>生成一个需要判断状态是否安全的资源分配环境</li>
</ul>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Available = Available - Request i:</span><br><span class="line">Allocation[i]= Allocationt[i]+Request i</span><br><span class="line">Needt[i]= Needt[i]-Request i</span><br></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;调用安全状态判断&#x3D;&#x3D;<br>如果返回结果是&#x3D;&#x3D;安全&#x3D;&#x3D;，将资源分配给Ti<br>如果返回结果是&#x3D;&#x3D;不安全&#x3D;&#x3D;，系统会拒绝Ti的资源请求</p>
<h4 id="银行家算法安全状态判断示例"><a href="#银行家算法安全状态判断示例" class="headerlink" title="银行家算法安全状态判断示例"></a>银行家算法安全状态判断示例</h4><p>&#x3D;&#x3D;初始状态&#x3D;&#x3D;</p>
<img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220830001345403.png" alt="image-20220830001345403" style="zoom: 80%;">

<p>&#x3D;&#x3D;T2线程完成运行&#x3D;&#x3D;</p>
<img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220830001445186.png" alt="image-20220830001445186" style="zoom: 80%;">

<p>&#x3D;&#x3D;T3线程完成运行&#x3D;&#x3D;</p>
<img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220830001540615.png" alt="image-20220830001540615" style="zoom: 80%;">

<p>&#x3D;&#x3D;这样就都可以完成了&#x3D;&#x3D;</p>
<h4 id="银行家算法安全状态判断示例2"><a href="#银行家算法安全状态判断示例2" class="headerlink" title="银行家算法安全状态判断示例2"></a>银行家算法安全状态判断示例2</h4><p>初始状态</p>
<p><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220830001620746.png" alt="image-20220830001620746"></p>
<p>可用资源不满足任何线程的当前请求资源数量，这是不安全</p>
<h2 id="4、死锁检测"><a href="#4、死锁检测" class="headerlink" title="4、死锁检测"></a>4、死锁检测</h2><h4 id="死锁检测"><a href="#死锁检测" class="headerlink" title="死锁检测"></a>死锁检测</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220909093025399.png" alt="image-20220909093025399" style="zoom: 67%;">

<ul>
<li>允许系统进入死锁状态</li>
<li>维护系统的资源分配图</li>
<li>定期调用死锁检测算法来搜索图中是否存在死锁</li>
<li>出现死锁时，用死锁恢复机制进行恢复</li>
</ul>
<h4 id="死锁检测算法：数据结构"><a href="#死锁检测算法：数据结构" class="headerlink" title="死锁检测算法：数据结构"></a>死锁检测算法：数据结构</h4><p>&#x3D;&#x3D;Available&#x3D;&#x3D;:长度为m的向量</p>
<ul>
<li>每种类型可用资源的数量</li>
</ul>
<p>&#x3D;&#x3D;Allocation&#x3D;&#x3D;:一个n×m矩阵</p>
<ul>
<li>当前分配给各个进程每种类型资源的数量</li>
<li>进程Pi：拥有资源Rj 的Allocation[i，j]个实例</li>
</ul>
<h4 id="死锁检测算法"><a href="#死锁检测算法" class="headerlink" title="死锁检测算法"></a>死锁检测算法</h4><p><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220830141257516.png" alt="image-20220830141257516"></p>
<blockquote>
<p>算法需要O(m x n)^2 操作检测是否系统处于死锁状态</p>
</blockquote>
<h4 id="死锁检测示例1"><a href="#死锁检测示例1" class="headerlink" title="死锁检测示例1"></a>死锁检测示例1</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220830141645737.png" alt="image-20220830141645737" style="zoom:67%;">



<h4 id="死锁检测示例2"><a href="#死锁检测示例2" class="headerlink" title="死锁检测示例2"></a>死锁检测示例2</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220830141711908.png" alt="image-20220830141711908" style="zoom:67%;">



<h4 id="死锁检测算法的使用"><a href="#死锁检测算法的使用" class="headerlink" title="死锁检测算法的使用"></a>死锁检测算法的使用</h4><p>死锁检测的时间和周期选择依据</p>
<ul>
<li>死锁多久可能会发生</li>
<li>多少进程需要被回滚</li>
</ul>
<p>资源图可能有多个循环</p>
<ul>
<li>难于分辨“造成”死锁的关键进程</li>
</ul>
<h4 id="死锁恢复：进程终止"><a href="#死锁恢复：进程终止" class="headerlink" title="死锁恢复：进程终止"></a>死锁恢复：进程终止</h4><ul>
<li>终止所有的死锁进程</li>
<li>一次只终止一个进程直到死锁消除</li>
<li>终止进程的顺序应该是<ul>
<li>进程的优先级</li>
<li>进程已运行时间以及还需运行时间</li>
<li>进程已占用资源</li>
<li>进程完成需要的资源</li>
<li>终止进程数目</li>
<li>进程是交互还是批处理</li>
</ul>
</li>
</ul>
<h4 id="死锁恢复：资源抢占"><a href="#死锁恢复：资源抢占" class="headerlink" title="死锁恢复：资源抢占"></a>死锁恢复：资源抢占</h4><p>选择被抢占进程</p>
<ul>
<li>最小成本目标</li>
</ul>
<p>进程回退</p>
<ul>
<li>返回到一些安全状态，重启进程到安全状态</li>
</ul>
<p>可能出现饥饿</p>
<ul>
<li>同一进程可能一直被选作被抢占者</li>
</ul>
<h2 id="5、进程通信概念"><a href="#5、进程通信概念" class="headerlink" title="5、进程通信概念"></a>5、进程通信概念</h2><h4 id="进程通信（IPC-Inter-Process-Communication）"><a href="#进程通信（IPC-Inter-Process-Communication）" class="headerlink" title="进程通信（IPC,Inter-Process Communication）"></a>进程通信（IPC,Inter-Process Communication）</h4><ul>
<li>进程通信是进程进行通信和同步的机制</li>
<li>IPC提供2个基本操作<ul>
<li>发送操作：send（message）</li>
<li>接收操作：receive(message）</li>
</ul>
</li>
<li>进程通信流程<ul>
<li>在通信进程间建立通信链路</li>
<li>通过send&#x2F;receive交换消息</li>
</ul>
</li>
<li>进程链路特征<ul>
<li>物理（如，共享内存，硬件总线）</li>
<li>逻辑（如，逻辑属性）</li>
</ul>
</li>
</ul>
<h4 id="通信方式"><a href="#通信方式" class="headerlink" title="通信方式"></a>通信方式</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220830143029359.png" alt="image-20220830143029359" style="zoom:67%;">



<h4 id="直接通信"><a href="#直接通信" class="headerlink" title="直接通信"></a>直接通信</h4><p>进程必须正确的命名对方</p>
<ul>
<li>send（P，message）-发送信息到进程P</li>
<li>receive（Q，message）－从进程Q接受消息</li>
</ul>
<p>通信链路的属性</p>
<ul>
<li>自动建立链路</li>
<li>一条链路恰好对应一对通信进程</li>
<li>每对进程之间只有一个链接存在</li>
<li>链接可以是单向的，但通常为双向的</li>
</ul>
<h4 id="间接通信"><a href="#间接通信" class="headerlink" title="间接通信"></a>间接通信</h4><p>通过操作系统维护的消息队列实现进程间的消息接收和发送</p>
<ul>
<li>每个消息队列都有一个唯一的标识</li>
<li>只有共享了相同消息队列的进程，才能够通信</li>
</ul>
<p>通信链路的属性</p>
<ul>
<li>只有共享了相同消息队列的进程，才建立连接</li>
<li>连接可以是单向或双向</li>
<li>消息队列可以与多个进程相关联</li>
<li>每对进程可以共享多个消息队列</li>
</ul>
<p>通信流程</p>
<ul>
<li>创建一个新的消息队列</li>
<li>通过消息队列发送和接收消息</li>
<li>销毁消息队列</li>
</ul>
<p>基本通信操作</p>
<ul>
<li>send（A，message）- 发送消息到队列A</li>
<li>receive（A，message）- 从队列A接受消息</li>
</ul>
<h4 id="阻塞和非阻塞通信"><a href="#阻塞和非阻塞通信" class="headerlink" title="阻塞和非阻塞通信"></a>阻塞和非阻塞通信</h4><ul>
<li>进程通信可划分为阻塞（同步）或非阻塞（异步）</li>
<li>阻塞通信<ul>
<li>阻塞发送</li>
<li>阻塞接收</li>
</ul>
</li>
<li>非阻塞通信<ul>
<li>非阻塞发送</li>
<li>非阻塞接收<br>没有消息发送时，接收者在请求接收消息后，接收不到任何消息</li>
</ul>
</li>
</ul>
<blockquote>
<p>阻塞：同步，一个完成下一个在继续</p>
<ul>
<li>如前面有进程正在通信（发送或接收），则需要此进程需要等待</li>
</ul>
<p>非阻塞：为所欲为，异步，想继续就继续，无需等待</p>
<ul>
<li>如不管有没有进程正在通信（发送或接收），此进程都可以直接通信</li>
</ul>
</blockquote>
<h4 id="通信链路缓冲"><a href="#通信链路缓冲" class="headerlink" title="通信链路缓冲"></a>通信链路缓冲</h4><p>进程发送的消息在链路上可能有3种缓冲方式</p>
<ul>
<li>0容量<br>发送方必须等待接收方</li>
<li>有限容量<br>通信链路缓冲队列满时，发送方必须等待</li>
<li>无限容量<br>发送方不需要等待</li>
</ul>
<h2 id="6、信号和管道"><a href="#6、信号和管道" class="headerlink" title="6、信号和管道"></a>6、信号和管道</h2><h4 id="信号（Signal）"><a href="#信号（Signal）" class="headerlink" title="信号（Signal）"></a>信号（Signal）</h4><p>信号</p>
<ul>
<li>进程间的软件中断通知和处理机制</li>
<li>如：SIGKILL，SIGSTOP，SIGCONT等</li>
</ul>
<p>信号的接收处理</p>
<ul>
<li><p>捕获（catch）：执行进程指定的信号处理函数被调用</p>
</li>
<li><p>忽略（Ignore）：执行操作系统指定的缺省处理</p>
<ul>
<li>例如：进程终止、进程挂起等</li>
</ul>
</li>
<li><p>屏蔽（Mask）：禁止进程接收和处理信号</p>
<ul>
<li>可能是暂时的（当处理同样类型的信号）</li>
</ul>
</li>
</ul>
<p>不足</p>
<ul>
<li>传送的信息量小，只有一个信号类型</li>
</ul>
<h4 id="信号的实现"><a href="#信号的实现" class="headerlink" title="信号的实现"></a>信号的实现</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220830145229429.png" alt="image-20220830145229429" style="zoom: 80%;">

<h4 id="管道（pip）"><a href="#管道（pip）" class="headerlink" title="管道（pip）"></a>管道（pip）</h4><p>进程间基于内存文件的通信机制</p>
<ul>
<li>子进程从父进程继承文件描述符</li>
<li>缺省文件描述符：0stdin，1stdout，2stderr</li>
</ul>
<p>进程不知道（或不关心！）的另一端</p>
<ul>
<li>可能从键盘、文件、程序读取</li>
<li>可能写入到终端、文件、程序</li>
</ul>
<h4 id="与管道相关的系统调用"><a href="#与管道相关的系统调用" class="headerlink" title="与管道相关的系统调用"></a>与管道相关的系统调用</h4><p>读管道：read（fd.buffer，nbytes）</p>
<ul>
<li>scanf（）是基于它实现的</li>
</ul>
<p>写管道：write(fd，buffer，nbytes）</p>
<ul>
<li>printf（）是基于它实现的</li>
</ul>
<p>创建管道：pipe（rgfd）</p>
<ul>
<li>rgfd是2个文件描述符组成的数组</li>
<li>rgfd[0]是读文件描述符</li>
<li>rgfd[1]是写文件描述符</li>
</ul>
<h4 id="管道示例"><a href="#管道示例" class="headerlink" title="管道示例"></a>管道示例</h4><p><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220909095421017.png" alt="image-20220909095421017"></p>
<p>shell</p>
<ul>
<li>创建管道<br>为ls创建一个进程，设置stdout为管道写端<br>为more创建一个进程，设置stdin为管道读端</li>
</ul>
<blockquote>
<p>这是管道在Linux 和Unix系统中常见的用法</p>
</blockquote>
<h2 id="7、消息队列和共享内存"><a href="#7、消息队列和共享内存" class="headerlink" title="7、消息队列和共享内存"></a>7、消息队列和共享内存</h2><h4 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h4><p>消息队列是由操作系统维护的以字节序列为基本单位的间接通信机制</p>
<ul>
<li>每个消息（Message）是一个字节序列</li>
<li>相同标识的消息组成按先进先出顺序组成一个消息队列（Message Queues）</li>
</ul>
<p><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220909095611112.png" alt="image-20220909095611112"></p>
<h4 id="消息队列的系统调用"><a href="#消息队列的系统调用" class="headerlink" title="消息队列的系统调用"></a>消息队列的系统调用</h4><p>msgget(key，flags）</p>
<ul>
<li>获取消息队列标识</li>
</ul>
<p>msgsnd (QID，buf，size，flags）</p>
<ul>
<li>发送消息</li>
</ul>
<p>msgrcv(QID，buf，size，type，flags）</p>
<ul>
<li>接收消息</li>
</ul>
<p>msgctl(…）</p>
<ul>
<li>消息队列控制</li>
</ul>
<h4 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h4><ul>
<li>共享内存是把同&#x3D;&#x3D;一个&#x3D;&#x3D;物理内存区域同时映射到&#x3D;&#x3D;多个&#x3D;&#x3D;进程的内存地址空间的通信机制</li>
<li>进程<ul>
<li>每个进程都有私有内存地址空间</li>
<li>每个进程的内存地址空间需明确设置共享内存段</li>
</ul>
</li>
<li>线程<ul>
<li>同一进程中的线程总是共享相同的内存地址空间</li>
</ul>
</li>
<li>优点<ul>
<li>快速、方便地共享数据</li>
</ul>
</li>
<li>不足<ul>
<li>必须用额外的同步机制来协调数据访问</li>
</ul>
</li>
</ul>
<h4 id="共享内存示例"><a href="#共享内存示例" class="headerlink" title="共享内存示例"></a>共享内存示例</h4><ul>
<li>最快的方法</li>
<li>一个进程写另外一个进程立即可见</li>
<li>没有系统调用干预</li>
<li>没有数据复制</li>
<li>不提供同步<ul>
<li>由程序员提供同步</li>
</ul>
</li>
</ul>
<p><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220909100118135.png" alt="image-20220909100118135"></p>
<h4 id="共享内存系统调用"><a href="#共享内存系统调用" class="headerlink" title="共享内存系统调用"></a>共享内存系统调用</h4><p>shmget( key,size，flags）</p>
<ul>
<li>创建共享段</li>
</ul>
<p>shmat( shmid,* shmaddr flags）</p>
<ul>
<li>把共享段映射到进程地址空间</li>
</ul>
<p>shmdt(* shmaddr）</p>
<ul>
<li>取消共享段到进程地址空间的映射</li>
</ul>
<p>shmctl(…）</p>
<ul>
<li>共享段控制</li>
</ul>
<p>需要信号量等机制协调共享内存的访问冲突</p>
<h2 id="8、消息传递系统（Message-passing-system）（了解）"><a href="#8、消息传递系统（Message-passing-system）（了解）" class="headerlink" title="8、消息传递系统（Message passing system）（了解）"></a>8、消息传递系统（Message passing system）（了解）</h2><ul>
<li>在该机制中，进程不必借助任何共享存储区或数据结构，而是以格式化的消息（message）为单位，将通信的数据封装在消息中，并利用操作系统提供的一组通信命令（原语），在进程间进行消息传递，完成进程间的数据交换。</li>
<li>由于该机制能很好地支持多处理机系统、分布式系统和计算机网络，因此也成为这些领域最主要的通信工具。</li>
<li>基于消息传递系统的通信方式属于高级通信方式，因其实现方式的不同，可进一步分成两类<ul>
<li>直接通信方式，是指发送进程利用OS所提供的发送原语，直接把消息发送给目标进程；</li>
<li>间接通信方式，是指发送和接收进程，都通过共享中间实体（称为邮箱）的方式进行消息的发送和接收，完成进程间的通信。</li>
</ul>
</li>
</ul>
<h1 id="十二、文件系统"><a href="#十二、文件系统" class="headerlink" title="十二、文件系统"></a>十二、文件系统</h1><h2 id="1、文件系统的概念"><a href="#1、文件系统的概念" class="headerlink" title="1、文件系统的概念"></a>1、文件系统的概念</h2><h4 id="文件系统和文件"><a href="#文件系统和文件" class="headerlink" title="文件系统和文件"></a>文件系统和文件</h4><p>文件系统是操作系统中管理持久性数据的子系统，提供数据存储和访问功能</p>
<ul>
<li>组织、检索、读写访问数据</li>
<li>大多数计算机系统都有文件系统</li>
<li>Google也是一个文件系统</li>
</ul>
<p>文件是具有符号名，由字节序列构成的数据项集合</p>
<ul>
<li>文件系统的基本数据单位</li>
<li>文件名是文件的标识符号</li>
</ul>
<h4 id="文件系统的功能"><a href="#文件系统的功能" class="headerlink" title="文件系统的功能"></a>文件系统的功能</h4><p>分配文件磁盘空间</p>
<ul>
<li>管理文件块（位置和顺序）</li>
<li>管理空闲空间（位置）</li>
<li>分配算法（策略）</li>
</ul>
<p>管理文件集合</p>
<ul>
<li>定位：文件及其内容</li>
<li>命名：通过名字找到文件</li>
<li>文件系统结构：文件组织方式</li>
</ul>
<p>数据可靠和安全</p>
<ul>
<li>安全：多层次保护数据安全</li>
<li>可靠<ul>
<li>持久保存文件</li>
<li>避免系统崩溃、媒体错误、攻击等</li>
</ul>
</li>
</ul>
<h4 id="文件属性"><a href="#文件属性" class="headerlink" title="文件属性"></a>文件属性</h4><p>文件属性</p>
<ul>
<li>名称、类型、位置、大小、保护、创建者、创建时间、最近修改时间、…</li>
</ul>
<p>文件头：文件系统元数据中的文件信息</p>
<ul>
<li>文件属性</li>
<li>文件存储位置和顺序</li>
</ul>
<h4 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h4><p>文件访问模式</p>
<ul>
<li>进程访问文件数据前必须先“打开”文件</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">f=open(name，flag）;</span><br><span class="line">....</span><br><span class="line">read(f，...）；</span><br><span class="line">....</span><br><span class="line">close(f);</span><br></pre></td></tr></table></figure>

<p>内核跟踪进程打开的所有文件</p>
<ul>
<li>操作系统为每个进程维护一个打开文件表</li>
<li>文件描述符是打开文件的标识</li>
</ul>
<p><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220912091011406.png" alt="image-20220912091011406"></p>
<h4 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h4><p>操作系统在打开文件表中维护的打开文件状态和信息</p>
<ul>
<li>文件指针<ul>
<li>最近一次读写位置</li>
<li>每个进程分别维护自己的打开文件指针</li>
</ul>
</li>
<li>文件打开计数<ul>
<li>当前打开文件的次数</li>
<li>最后一个进程关闭文件时，将其从打开文件表中移除</li>
</ul>
</li>
<li>文件的磁盘位置<ul>
<li>缓存数据访问信息</li>
</ul>
</li>
<li>访问权限<ul>
<li>每个进程的文件访问模式信息</li>
</ul>
</li>
</ul>
<h4 id="文件的用户视图和系统视图"><a href="#文件的用户视图和系统视图" class="headerlink" title="文件的用户视图和系统视图"></a>文件的用户视图和系统视图</h4><p>文件的用户视图</p>
<ul>
<li>持久的&#x3D;&#x3D;数据结构&#x3D;&#x3D;</li>
</ul>
<p>系统访问接口</p>
<ul>
<li>&#x3D;&#x3D;字节序列&#x3D;&#x3D;的集合（UNIX）</li>
<li>系统不关心存储在磁盘上的数据结构</li>
</ul>
<p>操作系统的文件视图</p>
<ul>
<li>数据块的集合</li>
<li>数据块是逻辑存储单元，而扇区是物理存储单元</li>
<li>块大小&lt;&gt;扇区大小</li>
</ul>
<blockquote>
<p>通常几个扇区构成一个块</p>
</blockquote>
<h4 id="用户视图到系统视图的转换"><a href="#用户视图到系统视图的转换" class="headerlink" title="用户视图到系统视图的转换"></a>用户视图到系统视图的转换</h4><p>进程读文件</p>
<ul>
<li>获取字节所在的数据块</li>
<li>返回数据块内对应部分</li>
</ul>
<p>进程写文件</p>
<ul>
<li>获取数据块</li>
<li>修改数据块中对应部分 </li>
<li>写回数据块</li>
</ul>
<p>&#x3D;&#x3D;文件系统中的基本操作单位是数据块&#x3D;&#x3D;</p>
<ul>
<li>例如，getc（）和putc（）即使每次只访问1字节的数据，也需要缓存目标数据4096字节</li>
</ul>
<h4 id="访问模式"><a href="#访问模式" class="headerlink" title="访问模式"></a>访问模式</h4><ul>
<li>操作系统需要了解进程如何访问文件</li>
<li>&#x3D;&#x3D;顺序访问&#x3D;&#x3D;：按字节依次读取<ul>
<li>大多数的文件访问都是顺序访问</li>
</ul>
</li>
<li>&#x3D;&#x3D;随机访问&#x3D;&#x3D;：从中间读写<ul>
<li>不常用，但仍然重要<br>例如，虚拟内存中把内存页存储在文件</li>
</ul>
</li>
<li>&#x3D;&#x3D;索引访问&#x3D;&#x3D;：依据数据特征索引<ul>
<li>通常操作系统不完整提供索引访问</li>
<li>数据库是建立在索引内容的磁盘访问上</li>
</ul>
</li>
</ul>
<h4 id="索引文件示例"><a href="#索引文件示例" class="headerlink" title="索引文件示例"></a>索引文件示例</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220830161845875.png" alt="image-20220830161845875" style="zoom:67%;">

<h4 id="文件的内部结构"><a href="#文件的内部结构" class="headerlink" title="文件的内部结构"></a>文件的内部结构</h4><p>无结构</p>
<ul>
<li>单词、字节序列</li>
</ul>
<p>简单记录结构</p>
<ul>
<li>分列</li>
<li>固定长度</li>
<li>可变长度</li>
</ul>
<p>复杂结构</p>
<ul>
<li>格式化的文档（如，MS Word，PDF）</li>
<li>可执行文件</li>
<li>……</li>
</ul>
<h4 id="文件共享和访问控制"><a href="#文件共享和访问控制" class="headerlink" title="文件共享和访问控制"></a>文件共享和访问控制</h4><ul>
<li>&#x3D;&#x3D;多用户系统&#x3D;&#x3D;中的文件共享是很必要的</li>
<li>访问控制<ul>
<li>每个用户能够获得哪些文件的哪些访问权限</li>
<li>访问模式：读、写、执行、删除、列表等</li>
</ul>
</li>
<li>文件访问控制列表（ACL）<ul>
<li>&lt;文件实体，权限&gt;</li>
</ul>
</li>
<li>Unix模式<ul>
<li>&lt;用户组|所有人，读写可执行&gt;</li>
<li>&#x3D;&#x3D;用户标识ID&#x3D;&#x3D;<br>识别用户，表明每个用户所允许的权限及保护模式</li>
<li>&#x3D;&#x3D;组标识ID&#x3D;&#x3D;<br>允许用户组成组，并指定了组访问权限</li>
</ul>
</li>
</ul>
<h4 id="语义一致性"><a href="#语义一致性" class="headerlink" title="语义一致性"></a>语义一致性</h4><p>规定多进程如何同时访问共享文件</p>
<ul>
<li>与同步算法相似</li>
<li>因磁盘I&#x2F;O和网络延迟而设计简单</li>
</ul>
<p>Unix文件系统（UFS）语义</p>
<ul>
<li>对打开文件的写入内容立即对其他打开同一文件的其他用户可见</li>
<li>共享文件指针允许多用户同时读取和写入文件</li>
</ul>
<p>会话语义</p>
<ul>
<li>写入内容只有当文件关闭时可见</li>
</ul>
<p>读写锁</p>
<ul>
<li>一些操作系统和文件系统提供该功能</li>
</ul>
<h2 id="2、目录"><a href="#2、目录" class="headerlink" title="2、目录"></a>2、目录</h2><h4 id="分层文件系统"><a href="#分层文件系统" class="headerlink" title="分层文件系统"></a>分层文件系统</h4><ul>
<li>文件以目录的方式组织起来</li>
<li>目录是一类特殊的文件<ul>
<li>目录的内容是文件索引表&lt;文件名，指向文件的指针&gt;</li>
</ul>
</li>
<li>目录和文件的树型结构<ul>
<li>（早期的文件系统是扁平的（只有一层目录）</li>
</ul>
</li>
</ul>
<p><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220912091804249.png" alt="image-20220912091804249"></p>
<h4 id="目录操作"><a href="#目录操作" class="headerlink" title="目录操作"></a>目录操作</h4><p>典型目录操作</p>
<ul>
<li>搜索文件</li>
<li>创建文件</li>
<li>删除文件</li>
<li>列目录</li>
<li>重命名文件</li>
<li>遍历路径</li>
</ul>
<p>操作系统应该只允许内核修改目录</p>
<ul>
<li>确保映射的完整性</li>
<li>应用程序通过系统调用访问目录</li>
</ul>
<h4 id="目录实现"><a href="#目录实现" class="headerlink" title="目录实现"></a>目录实现</h4><p>文件名的线性列表，包涵了指向数据块的指针</p>
<ul>
<li>编程简单</li>
<li>执行耗时</li>
</ul>
<p>&#x3D;&#x3D;哈希表&#x3D;&#x3D;一哈希数据结构的线性表</p>
<ul>
<li>减少目录搜索时间</li>
<li>冲突 – 两个文件名的哈希值相同</li>
<li>固定大小</li>
</ul>
<h2 id="3、文件别名"><a href="#3、文件别名" class="headerlink" title="3、文件别名"></a>3、文件别名</h2><p>两个或多个文件名关联同一个文件</p>
<ul>
<li>&#x3D;&#x3D;硬链接&#x3D;&#x3D;：多个文件项指向一个文件</li>
<li>&#x3D;&#x3D;软链接&#x3D;&#x3D;：以“快捷方式”指向其他文件<ul>
<li>通过存储真实文件的逻辑名称来实现</li>
</ul>
</li>
</ul>
<p><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220912092105833.png" alt="image-20220912092105833"></p>
<h4 id="文件目录中的循环"><a href="#文件目录中的循环" class="headerlink" title="文件目录中的循环"></a>文件目录中的循环</h4><p><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220912092209992.png" alt="image-20220912092209992"></p>
<p>如何保证没有循环？</p>
<ul>
<li>只允许到文件的链接，不允许在子目录的链接</li>
<li>增加链接时，用循环检测算法确定是否合理</li>
</ul>
<p>更多实践</p>
<ul>
<li>限制路径可遍历文件目录的数量</li>
</ul>
<h4 id="名字解析（路径遍历）"><a href="#名字解析（路径遍历）" class="headerlink" title="名字解析（路径遍历）"></a>名字解析（路径遍历）</h4><p>名字解析：把逻辑名字转换成物理资源（如文件）</p>
<ul>
<li>依据路径名，在文件系统中找到实际文件位置</li>
<li>遍历文件目录直到找到目标文件</li>
</ul>
<p>举例：解析“&#x2F;bin&#x2F;ls”</p>
<ul>
<li>读取根目录的文件头（在磁盘固定位置）</li>
<li>读取根目录的数据块，搜索“bin”项</li>
<li>读取bin的文件头</li>
<li>读取bin的数据块；搜索“Is”顶</li>
<li>读取Is的文件头</li>
</ul>
<p>当前工作目录（PWD）</p>
<ul>
<li>每个进程都会指向一个文件目录用于解析文件名</li>
<li>允许用户指定相对路径来代替绝对路径</li>
<li>如，用PWD&#x3D;“&#x2F;bin” 能够解析 “ls“</li>
</ul>
<h4 id="文件系统挂载"><a href="#文件系统挂载" class="headerlink" title="文件系统挂载"></a>文件系统挂载</h4><ul>
<li>文件系统需要先挂载才能被访问</li>
<li>未挂载的文件系统被挂载在挂载点上</li>
</ul>
<p><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220912092424655.png" alt="image-20220912092424655"></p>
<h4 id="文件系统种类"><a href="#文件系统种类" class="headerlink" title="文件系统种类"></a>文件系统种类</h4><p>磁盘文件系统</p>
<ul>
<li>文件存储在数据存储设备上，如磁盘</li>
<li>例如：FAT,NTFS，ext2&#x2F;3，ISO9660，等</li>
</ul>
<p>数据库文件系统</p>
<ul>
<li>文件特征是可被寻址（辨识）的</li>
<li>例如：WinFS</li>
</ul>
<p>日志文件系统</p>
<ul>
<li>记录文件系统的修改&#x2F;事件</li>
</ul>
<p>网络&#x2F;分布式文件系统</p>
<ul>
<li>例如：NFS，SMB，AFS，GFS</li>
</ul>
<p>特殊&#x2F;虚拟文件系统</p>
<h4 id="网络-x2F-分布式文件系统"><a href="#网络-x2F-分布式文件系统" class="headerlink" title="网络 &#x2F; 分布式文件系统"></a>网络 &#x2F; 分布式文件系统</h4><p>文件可以通过网络被共享</p>
<ul>
<li>文件位于远程服务器</li>
<li>客户端远程挂载服务器文件系统</li>
<li>标准系统文件访问被转换成远程访问</li>
<li>标准文件共享协议<br>NFS for Unix，CIFS for Windows</li>
</ul>
<p>分布式文件系统的挑战</p>
<ul>
<li>客户端和客户端上的用户辨别起来很复杂</li>
<li>例如，NFS是不安全的</li>
<li>&#x3D;&#x3D;一致性&#x3D;&#x3D;问题</li>
<li>错误处理模式</li>
</ul>
<h2 id="3、虚拟文件系统"><a href="#3、虚拟文件系统" class="headerlink" title="3、虚拟文件系统"></a>3、虚拟文件系统</h2><h4 id="文件系统的实现"><a href="#文件系统的实现" class="headerlink" title="文件系统的实现"></a>文件系统的实现</h4><p>分层结构</p>
<ul>
<li>虚拟（逻辑）文件系统（VFS，Virtual File System）</li>
<li>特定文件系统模块</li>
</ul>
<p><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220912092650383.png" alt="image-20220912092650383"></p>
<h4 id="虚拟文件系统（VFS）"><a href="#虚拟文件系统（VFS）" class="headerlink" title="虚拟文件系统（VFS）"></a>虚拟文件系统（VFS）</h4><p>目的</p>
<ul>
<li>对所有不同文件系统的抽象</li>
</ul>
<p>功能</p>
<ul>
<li>提供相同的文件和文件系统&#x3D;&#x3D;接口&#x3D;&#x3D;</li>
<li>管理所有文件和文件系统关联的&#x3D;&#x3D;数据结构&#x3D;&#x3D;</li>
<li>高效查询&#x3D;&#x3D;例程&#x3D;&#x3D;，遍历文件系统</li>
</ul>
<h4 id="文件系统的基本数据结构"><a href="#文件系统的基本数据结构" class="headerlink" title="文件系统的基本数据结构"></a>文件系统的基本数据结构</h4><p>文件卷控制块（Unix：“superblock”）</p>
<ul>
<li>每个文件系统都有一个</li>
<li>文件系统详细信息</li>
<li>块、块大小、空余块、计数&#x2F;指针等</li>
</ul>
<p>文件控制块（Unix：“vnode”  or  “inode” )</p>
<ul>
<li>每个文件都有一个</li>
<li>文件详细信息</li>
<li>访问权限、拥有者、大小、数据块位置等</li>
</ul>
<p>目录项（Linux：“dentry”）</p>
<ul>
<li>每个目录项都有一个（目录和文件）</li>
<li>将目录项数据结构及树型布局编码成树型数据结构</li>
<li>指向文件控制块、父目录、子目录等</li>
</ul>
<h4 id="文件系统的组织视图"><a href="#文件系统的组织视图" class="headerlink" title="文件系统的组织视图"></a>文件系统的组织视图</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220830180930676.png" alt="image-20220830180930676" style="zoom:67%;">

<h4 id="文件系统的存储结构"><a href="#文件系统的存储结构" class="headerlink" title="文件系统的存储结构"></a>文件系统的存储结构</h4><p>文件系统数据结构</p>
<ul>
<li>卷控制块（每个文件系统一个）</li>
<li>文件控制块（每个文件一个）</li>
<li>目录节点（每个目录项一个）</li>
</ul>
<p>持久存储在外存中</p>
<ul>
<li>存储设备的数据块中</li>
</ul>
<p>当需要时加载进内存</p>
<ul>
<li>卷控制模块：当文件系统挂载时进入内存</li>
<li>文件控制块：当文件被访问时进入每次</li>
</ul>
<h4 id="文件系统的存储视图"><a href="#文件系统的存储视图" class="headerlink" title="文件系统的存储视图"></a>文件系统的存储视图</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220830181037861.png" alt="image-20220830181037861" style="zoom: 67%;">

<h2 id="4、文件缓存和打开文件"><a href="#4、文件缓存和打开文件" class="headerlink" title="4、文件缓存和打开文件"></a>4、文件缓存和打开文件</h2><h4 id="多种磁盘缓存的位置"><a href="#多种磁盘缓存的位置" class="headerlink" title="多种磁盘缓存的位置"></a>多种磁盘缓存的位置</h4><p><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220830223531993.png" alt="image-20220830223531993"></p>
<h4 id="数据块缓存"><a href="#数据块缓存" class="headerlink" title="数据块缓存"></a>数据块缓存</h4><p>数据块按需读入内存</p>
<ul>
<li>提供read()操作</li>
<li>预读：预先读取后面的数据块</li>
</ul>
<p>数据块使用后被缓存</p>
<ul>
<li>假设数据将会再次用到</li>
<li>写操作可能被缓存和延迟写入</li>
</ul>
<p>两种数据块缓存方式</p>
<ul>
<li>数据块缓存</li>
<li>页缓存：统一缓存数据块和内存页</li>
</ul>
<img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220830223821939.png" alt="image-20220830223821939" style="zoom:50%;">





<h4 id="页缓存"><a href="#页缓存" class="headerlink" title="页缓存"></a>页缓存</h4><p>虚拟页式存储</p>
<ul>
<li>在虚拟地址空间中虚拟页面可映射到本地外存文件中</li>
</ul>
<p>文件数据块的页缓存</p>
<ul>
<li>在虚拟内存中文件数据块被映射成页</li>
<li>文件的读&#x2F;写操作被转换成对内存的访问</li>
<li>可能导致缺页和&#x2F;或设置为脏页</li>
<li>问题：页置换算法需要协调虚拟存储和页缓存间的页面数</li>
</ul>
<p><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220912093337284.png" alt="image-20220912093337284"></p>
<img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220830224053343.png" alt="image-20220830224053343" style="zoom:67%;">

<h4 id="文件系统中打开文件的数据结构"><a href="#文件系统中打开文件的数据结构" class="headerlink" title="文件系统中打开文件的数据结构"></a>文件系统中打开文件的数据结构</h4><p>文件描述符</p>
<ul>
<li>每个被打开的文件都有一个文件描述符</li>
<li>文件状态信息<ul>
<li>目录项、当前文件指针、文件操作设置等</li>
</ul>
</li>
</ul>
<p>打开文件表</p>
<ul>
<li>每个进程一个进程打开文件表</li>
<li>一个系统级的打开文件表</li>
<li>有文件被打开时，文件卷就不能被卸载</li>
</ul>
<h4 id="打开文件表"><a href="#打开文件表" class="headerlink" title="打开文件表"></a>打开文件表</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220830224258512.png" alt="image-20220830224258512" style="zoom:67%;">

<h4 id="打开文件锁"><a href="#打开文件锁" class="headerlink" title="打开文件锁"></a>打开文件锁</h4><p>一些文件系统提供文件锁，用于协调多进程的文件访问</p>
<ul>
<li>&#x3D;&#x3D;强制&#x3D;&#x3D;－根据锁保持情况和访问需求确定是否拒绝访问</li>
<li>&#x3D;&#x3D;劝告&#x3D;&#x3D;－进程可以查找锁的状态来决定怎么做</li>
</ul>
<h2 id="5、文件分配"><a href="#5、文件分配" class="headerlink" title="5、文件分配"></a>5、文件分配</h2><h4 id="文件大小"><a href="#文件大小" class="headerlink" title="文件大小"></a>文件大小</h4><p>大多数文件都很小</p>
<ul>
<li>需要对小文件提供很好的支持</li>
<li>块空间不能太大</li>
</ul>
<p>一些文件非常大</p>
<ul>
<li>必须支持大文件（64位文件偏移）</li>
<li>大文件访问需要高效</li>
</ul>
<h4 id="文件分配"><a href="#文件分配" class="headerlink" title="文件分配"></a>文件分配</h4><ul>
<li><p>如何表示分配给一个文件数据块的位置和顺序</p>
</li>
<li><p>分配方式</p>
<ul>
<li>连续分配</li>
<li>链式分配</li>
<li>索引分配</li>
</ul>
</li>
<li><p>指标</p>
<ul>
<li>存储效率：外部碎片等</li>
<li>读写性能：访问速度</li>
</ul>
</li>
</ul>
<h4 id="连续分配"><a href="#连续分配" class="headerlink" title="连续分配"></a>连续分配</h4><p>文件头指定起始块和长度</p>
<p><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220912101220329.png" alt="image-20220912101220329"></p>
<p>分配策略</p>
<ul>
<li>最先匹配，最佳匹配，….</li>
</ul>
<p>优点</p>
<ul>
<li>文件读取表现好</li>
<li>高效的顺序和随机访问</li>
</ul>
<p>缺点</p>
<ul>
<li>碎片！</li>
<li>文件增长问题<ul>
<li>预分配？</li>
<li>按需分配？</li>
</ul>
</li>
</ul>
<h4 id="链式分配"><a href="#链式分配" class="headerlink" title="链式分配"></a>链式分配</h4><ul>
<li>文件以数据块链表方式存储</li>
<li>文件头包含了到第一块和最后一块的指针</li>
</ul>
<p><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220912101247239.png" alt="image-20220912101247239"></p>
<ul>
<li><p>优点</p>
<ul>
<li>创建、增大、缩小很容易</li>
<li>没有碎片</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>无法实现真正的随机访问</li>
<li>可靠性差<br>破坏一个链，后面的数据块就丢了</li>
</ul>
</li>
</ul>
<h4 id="索引分配"><a href="#索引分配" class="headerlink" title="索引分配"></a>索引分配</h4><ul>
<li>为每个文件创建一个&#x3D;&#x3D;索引数据块&#x3D;&#x3D;<ul>
<li>指向文件数据块的指针列表</li>
</ul>
</li>
<li>文件头包含了索引数据块指针</li>
</ul>
<p><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220912101445737.png" alt="image-20220912101445737"></p>
<ul>
<li><p>优点</p>
<ul>
<li>创建、增大、缩小很容易</li>
<li>没有碎片</li>
<li>支持直接访问</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>当文件很小时，存储索引的&#x3D;&#x3D;开销&#x3D;&#x3D;</li>
<li>如何处理大文件？</li>
</ul>
</li>
</ul>
<h4 id="大文件的索引分配"><a href="#大文件的索引分配" class="headerlink" title="大文件的索引分配"></a>大文件的索引分配</h4><p>链式索引块（IB+IB+…）</p>
<p><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220912101612326.png" alt="image-20220912101612326"></p>
<p>多级索引块（IB * IB *..）</p>
<p><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220912101626681.png" alt="image-20220912101626681"></p>
<h4 id="UFS-Unix-File-System-多级索引分配"><a href="#UFS-Unix-File-System-多级索引分配" class="headerlink" title="UFS(Unix File System)多级索引分配"></a>UFS(Unix File System)多级索引分配</h4><p>文件头包含13个指针</p>
<ul>
<li>10个指针指向数据块</li>
<li>第11个指针指向索引块</li>
<li>第12个指针指向二级索引块</li>
<li>第13个指针指向三级索引块</li>
</ul>
<p>效果</p>
<ul>
<li>提高了文件大小限制阀值</li>
<li>动态分配数据块，文件扩展很容易</li>
<li>小文件开销小</li>
<li>只为大文件分配间接数据块，大文件在访问数据块时需要大量查询</li>
</ul>
<img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220830230543243.png" alt="image-20220830230543243" style="zoom: 80%;">

<h2 id="6、空闲空间管理"><a href="#6、空闲空间管理" class="headerlink" title="6、空闲空间管理"></a>6、空闲空间管理</h2><p>跟踪记录文件卷未分配的数据块</p>
<ul>
<li>采用什么数据结构表示空闲空间列表</li>
</ul>
<h4 id="空闲空间组织：位图"><a href="#空闲空间组织：位图" class="headerlink" title="空闲空间组织：位图"></a>空闲空间组织：位图</h4><p>用位图代表空闲数据块列表</p>
<ul>
<li>111111111111111001110101011101111..</li>
<li>Di&#x3D;0表明数据块i是空闲，否则，表示已分配</li>
</ul>
<p>使用简单但是可能会是一个大的很大向量表</p>
<ul>
<li>160GB磁盘-&gt;40M数据块-&gt;5MB位图</li>
<li>假定空闲空间在磁盘中均匀分布，则找到“0”之前要扫描n&#x2F;r<br>n&#x3D;磁盘上数据块的总数<br>r&#x3D;空闲块的数目</li>
</ul>
<h4 id="其他空闲空间组织方式"><a href="#其他空闲空间组织方式" class="headerlink" title="其他空闲空间组织方式"></a>其他空闲空间组织方式</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220831124735352.png" alt="image-20220831124735352" style="zoom:67%;">



<h2 id="7、冗余磁盘阵列RAID"><a href="#7、冗余磁盘阵列RAID" class="headerlink" title="7、冗余磁盘阵列RAID"></a>7、冗余磁盘阵列RAID</h2><h4 id="磁盘分区"><a href="#磁盘分区" class="headerlink" title="磁盘分区"></a>磁盘分区</h4><p>通常磁盘通过分区来最大限度减小寻道时间</p>
<ul>
<li>分区是一组柱面的集合</li>
<li>每个分区都可视为逻辑上独立的磁盘</li>
</ul>
<img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220912102528428.png" alt="image-20220912102528428" style="zoom:67%;">



<h4 id="典型的磁盘文件系统组织"><a href="#典型的磁盘文件系统组织" class="headerlink" title="典型的磁盘文件系统组织"></a>典型的磁盘文件系统组织</h4><p>文件卷：</p>
<ul>
<li>一个拥有完整文件系统实例的外存空间</li>
<li>通常常驻在磁盘的单个分区上</li>
</ul>
<p><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220912102636179.png" alt="image-20220912102636179"></p>
<blockquote>
<p>windows下的C盘、D盘</p>
</blockquote>
<h4 id="多磁盘管理"><a href="#多磁盘管理" class="headerlink" title="多磁盘管理"></a>多磁盘管理</h4><p>使用多磁盘可改善</p>
<ul>
<li>吞吐量（通过并行）</li>
<li>可靠性和可用性（通过冗余）</li>
</ul>
<p>冗余磁盘阵列（RAID，Redundant Array of Inexpensive Disks）</p>
<ul>
<li>多种磁盘管理技术</li>
<li>RAID分类<br>如，RAID-O，RAID-1，RAID-5</li>
</ul>
<p>冗余磁盘阵列的实现</p>
<ul>
<li>软件：操作系统内核的文件卷管理</li>
<li>硬件：RAID硬件控制器（I&#x2F;O）</li>
</ul>
<h4 id="RAID-0：磁盘条带化"><a href="#RAID-0：磁盘条带化" class="headerlink" title="RAID-0：磁盘条带化"></a>RAID-0：磁盘条带化</h4><p>把数据块分成多个子块，存储在独立的磁盘中</p>
<ul>
<li>通过独立磁盘上并行数据块访问提供更大的磁盘带宽</li>
</ul>
<p><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220912102819051.png" alt="image-20220912102819051"></p>
<h4 id="RAID-1：磁盘镜像"><a href="#RAID-1：磁盘镜像" class="headerlink" title="RAID-1：磁盘镜像"></a>RAID-1：磁盘镜像</h4><p>向两个磁盘写入，从任何一个读取</p>
<ul>
<li>可靠性成倍增长</li>
<li>读取性能线性增加</li>
</ul>
<img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220912102846403.png" alt="image-20220912102846403" style="zoom:67%;">

<h4 id="RAID-4：带校验的磁盘条带化"><a href="#RAID-4：带校验的磁盘条带化" class="headerlink" title="RAID-4：带校验的磁盘条带化"></a>RAID-4：带校验的磁盘条带化</h4><p>数据块级的磁盘条带化加专用奇偶校验磁盘</p>
<ul>
<li>允许从任意一个故障磁盘中恢复</li>
</ul>
<p><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220912102953021.png" alt="image-20220912102953021"></p>
<blockquote>
<p>检验磁盘存储着每个数据块的校验和，会验证磁盘取出的数据的正确性，如果有一个磁盘发生故障，读取数据有误，那么校验磁盘能够使它的数据恢复正确</p>
<p>大大提升了可靠性，和读取效率</p>
</blockquote>
<h3 id="RAID-5：带分布式校验的磁盘条带化"><a href="#RAID-5：带分布式校验的磁盘条带化" class="headerlink" title="RAID-5：带分布式校验的磁盘条带化"></a>RAID-5：带分布式校验的磁盘条带化</h3><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220831130204018.png" alt="image-20220831130204018" style="zoom: 80%;">

<blockquote>
<p>数据块校验和分布在不同的磁盘，减少了校验磁盘的读取压力</p>
</blockquote>
<h4 id="基于位和基于块的磁盘条带化"><a href="#基于位和基于块的磁盘条带化" class="headerlink" title="基于位和基于块的磁盘条带化"></a>基于位和基于块的磁盘条带化</h4><p>条带化和奇偶校验按“&#x3D;&#x3D;字节&#x3D;&#x3D;”或者“&#x3D;&#x3D;位&#x3D;&#x3D;“</p>
<ul>
<li>RAID-0&#x2F;4&#x2F;5:基于数据块</li>
<li>RAID-3:基于位</li>
</ul>
<p><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220912103103137.png" alt="image-20220912103103137"></p>
<blockquote>
<p>基于数据块的常用</p>
</blockquote>
<h4 id="可纠正多个磁盘错误的冗余磁盘阵列"><a href="#可纠正多个磁盘错误的冗余磁盘阵列" class="headerlink" title="可纠正多个磁盘错误的冗余磁盘阵列"></a>可纠正多个磁盘错误的冗余磁盘阵列</h4><p>RAID-5：每组条带块有一个奇偶校验块</p>
<ul>
<li>允许一个磁盘错误</li>
</ul>
<p>RAID-6:每组条带块有两个冗余块</p>
<ul>
<li>允许两个磁盘错误</li>
</ul>
<h4 id="RAID嵌套"><a href="#RAID嵌套" class="headerlink" title="RAID嵌套"></a>RAID嵌套</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220831130849991.png" alt="image-20220831130849991" style="zoom: 67%;">



<h1 id="十三、I-x2F-O系统"><a href="#十三、I-x2F-O系统" class="headerlink" title="十三、I&#x2F;O系统"></a>十三、I&#x2F;O系统</h1><h2 id="1、I-x2F-O特点"><a href="#1、I-x2F-O特点" class="headerlink" title="1、I&#x2F;O特点"></a>1、I&#x2F;O特点</h2><h4 id="三种常见的设备接口类型"><a href="#三种常见的设备接口类型" class="headerlink" title="三种常见的设备接口类型"></a>三种常见的设备接口类型</h4><p>字符设备</p>
<ul>
<li>如：键盘&#x2F;鼠标，串口等</li>
</ul>
<p>块设备</p>
<ul>
<li>如：磁盘驱动器、磁带驱动器、光驱等</li>
</ul>
<p>网络设备</p>
<ul>
<li>如：以太网、无线、蓝牙等</li>
</ul>
<h4 id="设备访问特征"><a href="#设备访问特征" class="headerlink" title="设备访问特征"></a>设备访问特征</h4><p>字符设备</p>
<ul>
<li>访问特征<ul>
<li>以字节为单位顺序访问</li>
</ul>
</li>
<li>I&#x2F;O命令<ul>
<li>get()、put() 等</li>
<li>通常使用文件访问接口和语义</li>
</ul>
</li>
</ul>
<p>块设备</p>
<ul>
<li>访问特征<ul>
<li>均匀的数据块访问</li>
</ul>
</li>
<li>I&#x2F;O命令<ul>
<li>原始I&#x2F;O或文件系统接口</li>
<li>内存映射文件访问</li>
</ul>
</li>
</ul>
<p>网络设备</p>
<ul>
<li>访问特征<ul>
<li>格式化报文交换</li>
</ul>
</li>
<li>I&#x2F;O命令<ul>
<li>send&#x2F;receive网络报文</li>
<li>通过网络接口支持多种网络协议</li>
</ul>
</li>
</ul>
<h4 id="阻塞I-x2F-O：Wait"><a href="#阻塞I-x2F-O：Wait" class="headerlink" title="阻塞I&#x2F;O：Wait"></a>阻塞I&#x2F;O：Wait</h4><ul>
<li>读数据（read）时，进程将进入等待状态，直到完成数据读出</li>
<li>写数据（write）时，进程将进入等待状态，直到设备完成数据写入处理</li>
</ul>
<img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220912103456442.png" alt="image-20220912103456442" style="zoom:67%;">

<blockquote>
<p>用户调用系统调用后，进入内核执行相应设备驱动，控制硬件进行数据传送，完成后发出中断请求，设备驱动处理，返回用户态告诉进程，在这期间进程一直处于等待</p>
</blockquote>
<h4 id="非阻塞I-x2F-O：Dont-Wait"><a href="#非阻塞I-x2F-O：Dont-Wait" class="headerlink" title="非阻塞I&#x2F;O：Dont Wait"></a>非阻塞I&#x2F;O：Dont Wait</h4><ul>
<li>立即从read或write系统调返回，返回值为成功传输字节数</li>
<li>read或write的传输字节数可能为零</li>
</ul>
<img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220912103608697.png" alt="image-20220912103608697" style="zoom: 67%;">

<blockquote>
<p>传输的数据比较小</p>
</blockquote>
<h4 id="异步I-x2F-O-“Tell-Me-Later“"><a href="#异步I-x2F-O-“Tell-Me-Later“" class="headerlink" title="异步I&#x2F;O:“Tell Me Later“"></a>异步I&#x2F;O:“Tell Me Later“</h4><ul>
<li>读数据时，使用指针标记好用户缓冲区，立即返回；稍后内核将填充缓冲区并通知用户</li>
<li>写数据时，使用指针标记好用户缓冲区，立即返回；稍后内核将处理数据并通知用户</li>
</ul>
<img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220912103707801.png" alt="image-20220912103707801" style="zoom: 67%;">

<blockquote>
<p>设备驱动是等待的，而用户态进程是不需要等待的，可以干别的事</p>
</blockquote>
<h2 id="2、I-x2F-O结构"><a href="#2、I-x2F-O结构" class="headerlink" title="2、I&#x2F;O结构"></a>2、I&#x2F;O结构</h2><h4 id="一个实际例子"><a href="#一个实际例子" class="headerlink" title="一个实际例子"></a>一个实际例子</h4><p>北桥</p>
<ul>
<li>内存</li>
<li>AGP&#x2F;PCI-Express</li>
<li>Built-in display</li>
</ul>
<p>南桥</p>
<ul>
<li>ATA&#x2F;IDE</li>
<li>PCI总线</li>
<li>USB&#x2F;Firewire总线</li>
<li>Serial&#x2F;Parallel接口</li>
<li>DMA控制器</li>
<li>Interrupt控制器</li>
<li>RTC，ACPI，BIOS，…</li>
</ul>
<img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220912103844955.png" alt="image-20220912103844955" style="zoom:67%;">

<h4 id="CPU与设备连接"><a href="#CPU与设备连接" class="headerlink" title="CPU与设备连接"></a>CPU与设备连接</h4><p>CPU与设备的通信方式</p>
<ul>
<li>轮询、设备中断和DMA</li>
</ul>
<img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220912104429433.png" alt="image-20220912104429433" style="zoom:67%;">

<p>设备控制器</p>
<ul>
<li>CPU和I&#x2F;O设备间的接口</li>
<li>向CPU提供特殊指令和寄存器</li>
</ul>
<p>I&#x2F;O地址</p>
<ul>
<li>CPU用来控制I&#x2F;O硬件</li>
<li>内存地址或端口号<ul>
<li>I&#x2F;O指令</li>
<li>内存映射I&#x2F;O</li>
</ul>
</li>
</ul>
<h4 id="I-x2F-O指令"><a href="#I-x2F-O指令" class="headerlink" title="I&#x2F;O指令"></a>I&#x2F;O指令</h4><ul>
<li>通过I&#x2F;O端口号访问设备寄存器</li>
<li>特殊的CPU指令<br>out 0x21，AL</li>
</ul>
<h4 id="内存映射I-x2F-O"><a href="#内存映射I-x2F-O" class="headerlink" title="内存映射I&#x2F;O"></a>内存映射I&#x2F;O</h4><ul>
<li>设备的寄存器&#x2F;存储被映射到内存物理地址空间中</li>
<li>通过内存load&#x2F;store指令完成I&#x2F;O操作</li>
<li>MMU设置映射，硬件跳线或程序在启动时设置地址</li>
</ul>
<h4 id="内核I-x2F-O结构"><a href="#内核I-x2F-O结构" class="headerlink" title="内核I&#x2F;O结构"></a>内核I&#x2F;O结构</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220831173014014.png" alt="image-20220831173014014" style="zoom:67%;">

<h4 id="I-x2F-O请求的生存周期"><a href="#I-x2F-O请求的生存周期" class="headerlink" title="I&#x2F;O请求的生存周期"></a>I&#x2F;O请求的生存周期</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220831173052945.png" alt="image-20220831173052945" style="zoom: 80%;">



<h2 id="3、I-x2F-O数据传输"><a href="#3、I-x2F-O数据传输" class="headerlink" title="3、I&#x2F;O数据传输"></a>3、I&#x2F;O数据传输</h2><h4 id="CPU与设备控制器的设备传输"><a href="#CPU与设备控制器的设备传输" class="headerlink" title="CPU与设备控制器的设备传输"></a>CPU与设备控制器的设备传输</h4><p>程序控制I&#x2F;O（PIO，Programmed I&#x2F;O）</p>
<ul>
<li>通过CPU的in&#x2F;out或者load&#x2F;store传输所有数据</li>
<li>特点<ul>
<li>硬件简单，编程容易</li>
<li>消耗的CPU时间和数据量成正比</li>
</ul>
</li>
<li>适用于简单的、小型的设备I&#x2F;O</li>
</ul>
<p>直接内存访问（DMA）</p>
<ul>
<li>设备控制器可直接访问系统总线</li>
<li>控制器直接与内存互相传输数据</li>
<li>特点<ul>
<li>设备传输数据不影响CPU</li>
<li>需要CPU参与设置</li>
</ul>
</li>
<li>适用于高吞吐量I&#x2F;O</li>
</ul>
<h4 id="通过直接I-x2F-O寻址读取磁盘数据的步骤"><a href="#通过直接I-x2F-O寻址读取磁盘数据的步骤" class="headerlink" title="通过直接I&#x2F;O寻址读取磁盘数据的步骤"></a>通过直接I&#x2F;O寻址读取磁盘数据的步骤</h4><p><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220831174236831.png" alt="image-20220831174236831"></p>
<h4 id="I-x2F-O设备通知操作系统的机制"><a href="#I-x2F-O设备通知操作系统的机制" class="headerlink" title="I&#x2F;O设备通知操作系统的机制"></a>I&#x2F;O设备通知操作系统的机制</h4><p>操作系统需要了解设备状态</p>
<ul>
<li>I&#x2F;O操作完成时间</li>
<li>I&#x2F;O操作遇到错误</li>
</ul>
<p>两种方式</p>
<ul>
<li>CPU主动轮询</li>
<li>设备中断</li>
</ul>
<h4 id="轮询"><a href="#轮询" class="headerlink" title="轮询"></a>轮询</h4><ul>
<li>I&#x2F;O设备在特定的&#x3D;&#x3D;状态寄存器&#x3D;&#x3D;中放置状态和错误信息</li>
<li>操作系统&#x3D;&#x3D;定期检测&#x3D;&#x3D;状态寄存器</li>
<li>特点<ul>
<li>简单</li>
<li>I&#x2F;O操作频繁或不可预测时，开销大和延时长</li>
</ul>
</li>
</ul>
<h4 id="设备中断"><a href="#设备中断" class="headerlink" title="设备中断"></a>设备中断</h4><p>设备中断处理流程</p>
<ul>
<li>CPU在I&#x2F;O之前设置任务参数</li>
<li>CPU发出I&#x2F;O请求后，继续执行其他任务</li>
<li>I&#x2F;O设备处理I&#x2F;O请求</li>
<li>I&#x2F;O设备处理完成时，触发CPU中断请求</li>
<li>CPU接收中断，分发到相应中断处理例程</li>
</ul>
<p>特点</p>
<ul>
<li>处理不可预测事件效果好</li>
<li>开销相对较高</li>
</ul>
<p>一些设备可能结合了轮询和设备中断</p>
<ul>
<li>如：高带宽网络设备<ul>
<li>第一个传入数据包到达前采用中断</li>
<li>轮询后面的数据包直到硬件缓存为空</li>
</ul>
</li>
</ul>
<h3 id="设备中断I-x2F-O处理流程"><a href="#设备中断I-x2F-O处理流程" class="headerlink" title="设备中断I&#x2F;O处理流程"></a>设备中断I&#x2F;O处理流程</h3><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220831174740052.png" alt="image-20220831174740052" style="zoom:67%;">



<h2 id="4、磁盘调度"><a href="#4、磁盘调度" class="headerlink" title="4、磁盘调度"></a>4、磁盘调度</h2><h4 id="磁盘工作机制和性能参数"><a href="#磁盘工作机制和性能参数" class="headerlink" title="磁盘工作机制和性能参数"></a>磁盘工作机制和性能参数</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220912105405940.png" alt="image-20220912105405940" style="zoom:67%;">

<ul>
<li>读取或写入时，磁头必须被定位在&#x3D;&#x3D;期望的磁道&#x3D;&#x3D;，并从所&#x3D;&#x3D;期望的柱面和扇区&#x3D;&#x3D;的开始</li>
<li>寻道时间<ul>
<li>定位到期望的磁道所花费的时间</li>
</ul>
</li>
<li>旋转延迟<ul>
<li>从零扇区开始处到达目的地花费的时间</li>
</ul>
</li>
<li>&#x3D;&#x3D;平均旋转延迟时间&#x3D;磁盘旋转一周时间的一半&#x3D;&#x3D;</li>
</ul>
<h4 id="磁盘I-x2F-O传输时间"><a href="#磁盘I-x2F-O传输时间" class="headerlink" title="磁盘I&#x2F;O传输时间"></a>磁盘I&#x2F;O传输时间</h4><p><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220901083451945.png" alt="image-20220901083451945"></p>
<h4 id="磁盘调度算法"><a href="#磁盘调度算法" class="headerlink" title="磁盘调度算法"></a>磁盘调度算法</h4><p>通过优化磁盘访问请求顺序来提高磁盘访问性能</p>
<ul>
<li>寻道时间是磁盘访问最耗时的部分</li>
<li>同时会有多个在同一磁盘上的I&#x2F;O请求</li>
<li>随机处理磁盘访问请求的性能表现很差</li>
</ul>
<h4 id="先进先出（FIFO）算法"><a href="#先进先出（FIFO）算法" class="headerlink" title="先进先出（FIFO）算法"></a>先进先出（FIFO）算法</h4><ul>
<li>按顺序处理请求</li>
<li>公平对待所有进程</li>
<li>在有很多进程的情况下，接近随机调度的性能</li>
</ul>
<h4 id="FIFO算法示例-1"><a href="#FIFO算法示例-1" class="headerlink" title="FIFO算法示例"></a>FIFO算法示例</h4><p><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220901083644552.png" alt="image-20220901083644552"></p>
<h4 id="最短服务时间优先（SSTF）"><a href="#最短服务时间优先（SSTF）" class="headerlink" title="最短服务时间优先（SSTF）"></a>最短服务时间优先（SSTF）</h4><ul>
<li>选择从磁臂当前位置需要移动最少的I&#x2F;O请求</li>
<li>总是选择最短寻道时间</li>
</ul>
<h4 id="SSTF算法示例"><a href="#SSTF算法示例" class="headerlink" title="SSTF算法示例"></a>SSTF算法示例</h4><p><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220901083751024.png" alt="image-20220901083751024"></p>
<h4 id="扫面算法（SCAN）"><a href="#扫面算法（SCAN）" class="headerlink" title="扫面算法（SCAN）"></a>扫面算法（SCAN）</h4><ul>
<li>磁臂在一个方向上移动，访问所有未完成的请求，直到磁臂到达该方向上最后的磁道</li>
<li>调换方向</li>
<li>也称为电梯算法（elevator algorithm）</li>
</ul>
<h4 id="SCAN算法示例"><a href="#SCAN算法示例" class="headerlink" title="SCAN算法示例"></a>SCAN算法示例</h4><p><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220901083857941.png" alt="image-20220901083857941"></p>
<h4 id="循环扫描算法（C-SCAN）"><a href="#循环扫描算法（C-SCAN）" class="headerlink" title="循环扫描算法（C-SCAN）"></a>循环扫描算法（C-SCAN）</h4><ul>
<li>限制了仅在一个方向上扫描</li>
<li>当最后一个磁道也被访问过了后，磁臂返回到磁盘的另外一端再次进行</li>
</ul>
<h4 id="C-LOOK算法"><a href="#C-LOOK算法" class="headerlink" title="C-LOOK算法"></a>C-LOOK算法</h4><ul>
<li>磁臂先到达该方向上最后一个请求处，然后立即反转，而不是先到最后点路径上的所有请求</li>
</ul>
<blockquote>
<p>避免到达该方向上末端点这段路径没有请求的扫描过程</p>
</blockquote>
<h4 id="N步扫描算法（N-Step-SCAN"><a href="#N步扫描算法（N-Step-SCAN" class="headerlink" title="N步扫描算法（N-Step-SCAN)"></a>N步扫描算法（N-Step-SCAN)</h4><p>磁头粘着（Arm Stickiness）现象</p>
<ul>
<li>SSTF、SCAN及CSCAN等算法中，可能出现磁头停留在某处不动的情况</li>
<li>如：进程反复请求对某一磁道的I&#x2F;O操作</li>
</ul>
<p>N步扫描算法</p>
<ul>
<li>将磁盘请求队列分成长度为N的子队列</li>
<li>按FIFO算法依次处理所有子队列</li>
<li>扫描算法处理每个队列</li>
</ul>
<h4 id="双队列扫描算法（FSCAN）"><a href="#双队列扫描算法（FSCAN）" class="headerlink" title="双队列扫描算法（FSCAN）"></a>双队列扫描算法（FSCAN）</h4><p>FSCAN算法是N步扫描算法的简化</p>
<ul>
<li>FSCAN只将磁盘请求队列分成两个子队列</li>
</ul>
<p>FSCAN算法</p>
<ul>
<li>把磁盘I&#x2F;0请求分成两个队列</li>
<li>交替使用扫描算法处理一个队列</li>
<li>新生成的磁盘I&#x2F;0请求放入另一队列中所有的新请求都将被推退到下一次扫描时处理</li>
</ul>
<h4 id="磁盘缓存"><a href="#磁盘缓存" class="headerlink" title="磁盘缓存"></a>磁盘缓存</h4><p>缓存</p>
<ul>
<li>数据传输双方访问速度差异较大时，引入的速度匹配中间层</li>
</ul>
<p>磁盘缓存是磁盘扇区在内存中的缓存区</p>
<ul>
<li>磁盘缓存的调度算法很类似虚拟存储调度算法</li>
<li>磁盘的访问频率远低于虚拟存储中的内存访问频率</li>
<li>通常磁盘缓存调度算法会比虚拟存储复杂</li>
</ul>
<h4 id="单缓存和双缓存"><a href="#单缓存和双缓存" class="headerlink" title="单缓存和双缓存"></a>单缓存和双缓存</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220901091753725.png" alt="image-20220901091753725" style="zoom:67%;">

<h4 id="访问频率置换算法（Frequency-based-Replacement）"><a href="#访问频率置换算法（Frequency-based-Replacement）" class="headerlink" title="访问频率置换算法（Frequency-based-Replacement）"></a>访问频率置换算法（Frequency-based-Replacement）</h4><p>问题</p>
<ul>
<li>在一段密集磁盘访问后，LFU算法的引用计数变化无法反映当前的引用情况</li>
</ul>
<p>算法思路</p>
<ul>
<li>考虑磁盘访问的密集特征，对密集引用不计数</li>
<li>在短周期中使用LRU算法，而在长周期中使用LFU算法</li>
</ul>
<p><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220901091953802.png" alt="image-20220901091953802"></p>
<p>栈中缓存被访问时移到栈顶；如果该块在新区域，引用计数不变；否则，引用计数加1</p>
<ul>
<li>在新区域中引用计数不变的目的是避免密集访问对引用计数不利影响</li>
<li>在中间区域和旧区域中引用计数加1是为了使用LFU算法</li>
</ul>
<p>未缓存数据块读入后放在栈顶，引用计数为1</p>
<p>在旧区域中引用计数最小的缓存块被置换</p>
<ul>
<li>中间区域的定义是为了避免读入的缓存块在第一次出新区域时马上被置换，有一个过渡期</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Qinghai2021</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/">http://example.com/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">Qinghai2021·博客</a>！</span></div></div><div class="tag_share"><div class="post_share"><div class="social-share" data-image="/images/background.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://fastly.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/09/07/Linux%E5%85%8B%E9%9A%86%E5%90%8E%E6%97%A0%E6%B3%95%E9%87%8D%E5%90%AF%E7%BD%91%E7%BB%9C/"><img class="prev-cover" src="/images/background.jpg" onerror="onerror=null;src='https://api.ixiaowai.cn/gqapi/gqapi.php'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Linux克隆后无法重启网络</div></div></a></div><div class="next-post pull-right"><a href="/2022/08/27/%E5%8D%9A%E5%AE%A2%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87/"><img class="next-cover" src="/images/background.jpg" onerror="onerror=null;src='https://api.ixiaowai.cn/gqapi/gqapi.php'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">关于hexo博客插入图片内容解决方法</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">一、操作系统概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E8%AF%BE%E7%A8%8B%E5%AF%BC%E8%AF%BB"><span class="toc-number">1.1.</span> <span class="toc-text">1、课程导读</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BE%E7%A8%8B%E5%9C%B0%E5%9D%80"><span class="toc-number">1.1.0.1.</span> <span class="toc-text">课程地址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86"><span class="toc-number">1.1.0.2.</span> <span class="toc-text">预备知识</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C"><span class="toc-number">1.1.0.3.</span> <span class="toc-text">操作系统实验</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.2.</span> <span class="toc-text">2、什么是操作系统</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9A%E4%B9%89"><span class="toc-number">1.2.0.1.</span> <span class="toc-text">操作系统定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9C%B0%E4%BD%8D"><span class="toc-number">1.2.0.2.</span> <span class="toc-text">操作系统的地位</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">1.2.0.3.</span> <span class="toc-text">操作系统软件的分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6%E7%9A%84%E7%BB%84%E6%88%90"><span class="toc-number">1.2.0.4.</span> <span class="toc-text">操作系统软件的组成</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ucore%E6%95%99%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E6%A0%B8"><span class="toc-number">1.2.0.5.</span> <span class="toc-text">ucore教学操作系统内核</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E6%A0%B8%E7%89%B9%E5%BE%81"><span class="toc-number">1.2.0.6.</span> <span class="toc-text">操作系统内核特征</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E4%BE%8B"><span class="toc-number">1.3.</span> <span class="toc-text">3、操作系统实例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%BC%94%E5%8F%98"><span class="toc-number">1.4.</span> <span class="toc-text">4、操作系统的演变</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E7%94%A8%E6%88%B7%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.4.0.1.</span> <span class="toc-text">单用户系统</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%B9%E5%A4%84%E7%90%86%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.4.0.2.</span> <span class="toc-text">批处理系统</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E9%81%93%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.4.0.3.</span> <span class="toc-text">多道程序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%97%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.4.0.4.</span> <span class="toc-text">分时系统</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AA%E4%BA%BA%E7%94%B5%E8%84%91%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.4.0.5.</span> <span class="toc-text">个人电脑操作系统</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.4.0.6.</span> <span class="toc-text">分布式操作系统</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%BC%94%E5%8F%98%E4%B8%AD%E7%9A%84%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.4.0.7.</span> <span class="toc-text">操作系统演变中的计算机系统</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">1.5.</span> <span class="toc-text">5、操作系统的结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E7%BB%93%E6%9E%84"><span class="toc-number">1.5.0.1.</span> <span class="toc-text">简单结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%B1%82%E7%BB%93%E6%9E%84"><span class="toc-number">1.5.0.2.</span> <span class="toc-text">分层结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BE%AE%E5%86%85%E6%A0%B8%E7%BB%93%E6%9E%84"><span class="toc-number">1.5.0.3.</span> <span class="toc-text">微内核结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%96%E6%A0%B8%E7%BB%93%E6%9E%84"><span class="toc-number">1.5.0.4.</span> <span class="toc-text">外核结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#VMM%EF%BC%88%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AE%A1%E7%90%86%EF%BC%89"><span class="toc-number">1.5.0.5.</span> <span class="toc-text">VMM（虚拟机管理）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81%E5%AE%9E%E9%AA%8C%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.6.</span> <span class="toc-text">6、实验课程设计</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF"><span class="toc-number">1.6.0.1.</span> <span class="toc-text">设计思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E5%86%85%E5%AE%B9%E5%8F%8A%E6%B6%89%E5%8F%8A%E4%BB%A3%E7%A0%81%E9%87%8F"><span class="toc-number">1.6.0.2.</span> <span class="toc-text">实验内容及涉及代码量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%B7%A5%E5%85%B7%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.6.0.3.</span> <span class="toc-text">使用工具简单介绍</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81X86-32%E7%A1%AC%E4%BB%B6%E6%9E%B6%E6%9E%84%E4%BA%86%E8%A7%A3"><span class="toc-number">1.7.</span> <span class="toc-text">7、X86-32硬件架构了解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9B%E7%A7%8D%E8%BF%90%E8%A1%8C%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.7.0.1.</span> <span class="toc-text">四种运行模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%9E%B6%E6%9E%84"><span class="toc-number">1.7.0.2.</span> <span class="toc-text">内存架构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">1.7.0.3.</span> <span class="toc-text">寄存器</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%90%AF%E5%8A%A8-%E4%B8%AD%E6%96%AD-%E5%BC%82%E5%B8%B8%E5%92%8C%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">2.</span> <span class="toc-text">二、启动.中断.异常和系统调用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81BIOS"><span class="toc-number">2.1.</span> <span class="toc-text">1、BIOS</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#RAM%E5%92%8CROM"><span class="toc-number">2.1.0.1.</span> <span class="toc-text">RAM和ROM</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E6%97%B6%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%86%85%E5%AD%98%E5%92%8C%E7%A3%81%E7%9B%98%E5%B8%83%E5%B1%80"><span class="toc-number">2.1.0.2.</span> <span class="toc-text">启动时计算机内存和磁盘布局</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4"><span class="toc-number">2.1.0.3.</span> <span class="toc-text">加载程序的内存地址空间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BIOS%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">2.1.0.4.</span> <span class="toc-text">BIOS系统调用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B"><span class="toc-number">2.2.</span> <span class="toc-text">2、系统启动流程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B"><span class="toc-number">2.2.0.1.</span> <span class="toc-text">系统启动流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CPU%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">2.2.0.2.</span> <span class="toc-text">CPU初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BIOS%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">2.2.0.3.</span> <span class="toc-text">BIOS的初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E5%BC%95%E5%AF%BC%E8%AE%B0%E5%BD%95MBR%E6%A0%BC%E5%BC%8F"><span class="toc-number">2.2.0.4.</span> <span class="toc-text">主引导记录MBR格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%8C%BA%E5%BC%95%E5%AF%BC%E6%89%87%E5%8C%BA%E6%A0%BC%E5%BC%8F"><span class="toc-number">2.2.0.5.</span> <span class="toc-text">分区引导扇区格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD%E7%A8%8B%E5%BA%8F%EF%BC%88bootloader%EF%BC%89"><span class="toc-number">2.2.0.6.</span> <span class="toc-text">加载程序（bootloader）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E8%A7%84%E8%8C%83"><span class="toc-number">2.2.0.7.</span> <span class="toc-text">系统启动规范</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E4%B8%AD%E6%96%AD-%E5%BC%82%E5%B8%B8%E5%92%8C%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">2.3.</span> <span class="toc-text">3、中断.异常和系统调用的比较</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%83%8C%E6%99%AF"><span class="toc-number">2.3.0.1.</span> <span class="toc-text">背景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E7%9A%84%E8%BF%9B%E5%85%A5%E4%B8%8E%E9%80%80%E5%87%BA"><span class="toc-number">2.3.0.2.</span> <span class="toc-text">内核的进入与退出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E3%80%81%E5%BC%82%E5%B8%B8%E5%92%8C%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%AE%9A%E4%B9%89"><span class="toc-number">2.3.0.3.</span> <span class="toc-text">中断、异常和系统调用定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E3%80%81%E5%BC%82%E5%B8%B8%E5%92%8C%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">2.3.0.4.</span> <span class="toc-text">中断、异常和系统调用的比较</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6"><span class="toc-number">2.3.0.5.</span> <span class="toc-text">中断和异常的处理机制</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E5%A4%84%E7%90%86"><span class="toc-number">2.3.0.5.1.</span> <span class="toc-text">硬件处理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%A4%84%E7%90%86"><span class="toc-number">2.3.0.5.2.</span> <span class="toc-text">软件处理</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E5%B5%8C%E5%A5%97"><span class="toc-number">2.3.0.6.</span> <span class="toc-text">中断嵌套</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">2.4.</span> <span class="toc-text">4、系统调用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E5%87%86C%E5%BA%93%E4%BE%8B%E5%AD%90"><span class="toc-number">2.4.0.1.</span> <span class="toc-text">标准C库例子</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">2.4.0.2.</span> <span class="toc-text">系统调用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.4.0.3.</span> <span class="toc-text">系统调用的实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%92%8C%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%9A%84%E4%B8%8D%E5%90%8C%E5%A4%84"><span class="toc-number">2.4.0.4.</span> <span class="toc-text">函数调用和系统调用的不同处</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E3%80%81%E5%BC%82%E5%B8%B8%E5%92%8C%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%9A%84%E5%BC%80%E9%94%80"><span class="toc-number">2.4.0.5.</span> <span class="toc-text">中断、异常和系统调用的开销</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="toc-number">2.5.</span> <span class="toc-text">5、系统调用示例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%A4%8D%E5%88%B6%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%BA%8F%E5%88%97"><span class="toc-number">2.5.0.1.</span> <span class="toc-text">文件复制过程中的系统调用序列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="toc-number">2.5.0.2.</span> <span class="toc-text">系统调用示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%BA%93%E7%9A%84%E6%8E%A5%E5%8F%A3%E7%A4%BA%E4%BE%8B"><span class="toc-number">2.5.0.3.</span> <span class="toc-text">系统调用库的接口示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ucore%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8read-fd-buffer-length-%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.5.0.4.</span> <span class="toc-text">ucore系统调用read(fd , buffer , length)的实现</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E8%BF%9E%E7%BB%AD%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="toc-number">3.</span> <span class="toc-text">三、物理内存管理::连续内存分配</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%92%8C%E5%86%85%E5%AD%98%E5%B1%82%E6%AC%A1"><span class="toc-number">3.1.</span> <span class="toc-text">1、计算机体系结构和内存层次</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-number">3.1.0.1.</span> <span class="toc-text">计算机体系结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%B1%82%E6%AC%A1"><span class="toc-number">3.1.0.2.</span> <span class="toc-text">内存层次</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">3.1.0.3.</span> <span class="toc-text">操作系统的内存管理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-number">3.1.0.4.</span> <span class="toc-text">操作系统的内存管理方式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E5%92%8C%E5%9C%B0%E5%9D%80%E7%94%9F%E6%88%90"><span class="toc-number">3.2.</span> <span class="toc-text">2、地址空间和地址生成</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">3.2.0.1.</span> <span class="toc-text">地址空间的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80%E7%9A%84%E7%94%9F%E6%88%90"><span class="toc-number">3.2.0.2.</span> <span class="toc-text">逻辑地址的生成</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E7%9A%84%E7%94%9F%E6%88%90%E5%92%8C%E9%99%90%E5%88%B6"><span class="toc-number">3.2.0.3.</span> <span class="toc-text">地址的生成和限制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E7%94%9F%E6%88%90%E8%BF%87%E7%A8%8B"><span class="toc-number">3.2.0.4.</span> <span class="toc-text">地址生成过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E6%A3%80%E6%9F%A5"><span class="toc-number">3.2.0.5.</span> <span class="toc-text">地址检查</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E8%BF%9E%E7%BB%AD%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="toc-number">3.3.</span> <span class="toc-text">3、连续内存分配</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9E%E7%BB%AD%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%92%8C%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87"><span class="toc-number">3.3.0.1.</span> <span class="toc-text">连续内存分配和内存碎片</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D"><span class="toc-number">3.3.0.2.</span> <span class="toc-text">动态分区分配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E5%85%88%E5%8C%B9%E9%85%8D%E7%AD%96%E7%95%A5"><span class="toc-number">3.3.0.3.</span> <span class="toc-text">最先匹配策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E4%BD%B3%E5%8C%B9%E9%85%8D%E7%AD%96%E7%95%A5"><span class="toc-number">3.3.0.4.</span> <span class="toc-text">最佳匹配策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E5%B7%AE%E5%8C%B9%E9%85%8D%E7%AD%96%E7%95%A5"><span class="toc-number">3.3.0.5.</span> <span class="toc-text">最差匹配策略</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E7%A2%8E%E7%89%87%E6%95%B4%E7%90%86"><span class="toc-number">3.4.</span> <span class="toc-text">4、碎片整理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A2%8E%E7%89%87%E7%B4%A7%E5%87%91"><span class="toc-number">3.4.0.1.</span> <span class="toc-text">碎片紧凑</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E6%8D%A2%E5%88%86%E5%8C%BA"><span class="toc-number">3.4.0.2.</span> <span class="toc-text">对换分区</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81%E4%BC%99%E4%BC%B4%E7%B3%BB%E7%BB%9F"><span class="toc-number">3.5.</span> <span class="toc-text">5、伙伴系统</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%99%E4%BC%B4%E7%B3%BB%E7%BB%9F"><span class="toc-number">3.5.0.1.</span> <span class="toc-text">伙伴系统</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%99%E4%BC%B4%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.5.0.2.</span> <span class="toc-text">伙伴系统的实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%99%E4%BC%B4%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98"><span class="toc-number">3.5.0.3.</span> <span class="toc-text">伙伴系统中的分配内存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ucore%E4%B8%AD%E7%9A%84%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">3.5.0.4.</span> <span class="toc-text">ucore中的物理内存管理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ucore%E4%B8%AD%E4%BC%99%E4%BC%B4%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.5.0.5.</span> <span class="toc-text">ucore中伙伴系统的实现</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E9%9D%9E%E8%BF%9E%E7%BB%AD%E5%AD%98%E5%82%A8%E5%88%86%E9%85%8D"><span class="toc-number">4.</span> <span class="toc-text">四、物理内存管理::非连续存储分配</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E9%9D%9E%E8%BF%9E%E7%BB%AD%E5%AD%98%E5%82%A8%E5%88%86%E9%85%8D%E7%9A%84%E9%9C%80%E6%B1%82%E8%83%8C%E6%99%AF"><span class="toc-number">4.1.</span> <span class="toc-text">1、非连续存储分配的需求背景</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="toc-number">4.1.0.1.</span> <span class="toc-text">连续分配的缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%9E%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D%E7%9A%84%E8%AE%BE%E8%AE%A1%E7%9B%AE%E6%A0%87"><span class="toc-number">4.1.0.2.</span> <span class="toc-text">非连续分配的设计目标</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%9E%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D%E9%9C%80%E8%A6%81%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">4.1.0.3.</span> <span class="toc-text">非连续分配需要解决的问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%9E%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D%E7%9A%84%E7%A1%AC%E4%BB%B6%E8%BE%85%E5%8A%A9%E6%9C%BA%E5%88%B6"><span class="toc-number">4.1.0.4.</span> <span class="toc-text">非连续分配的硬件辅助机制</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E6%AE%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86"><span class="toc-number">4.2.</span> <span class="toc-text">2、段式存储管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AE%B5%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4"><span class="toc-number">4.2.0.1.</span> <span class="toc-text">段地址空间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AE%B5%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E7%9A%84%E9%80%BB%E8%BE%91%E8%A7%86%E5%9B%BE"><span class="toc-number">4.2.0.2.</span> <span class="toc-text">段地址空间的逻辑视图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AE%B5%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E6%AE%B5%E8%AE%BF%E9%97%AE%E6%9C%BA%E5%88%B6"><span class="toc-number">4.2.0.3.</span> <span class="toc-text">段的概念和段访问机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AE%B5%E8%AE%BF%E9%97%AE%E7%9A%84%E7%A1%AC%E4%BB%B6%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.2.0.4.</span> <span class="toc-text">段访问的硬件实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86"><span class="toc-number">4.3.</span> <span class="toc-text">3、页式存储管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B5%E5%B8%A7%E5%92%8C%E9%A1%B5%E9%9D%A2"><span class="toc-number">4.3.0.1.</span> <span class="toc-text">页帧和页面</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%A7%EF%BC%88frame%EF%BC%89"><span class="toc-number">4.3.0.2.</span> <span class="toc-text">帧（frame）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E9%A1%B5%E5%B8%A7%E7%9A%84%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E8%AE%A1%E7%AE%97%E5%AE%9E%E4%BE%8B"><span class="toc-number">4.3.0.3.</span> <span class="toc-text">基于页帧的物理地址计算实例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B5%EF%BC%88page%EF%BC%89"><span class="toc-number">4.3.0.4.</span> <span class="toc-text">页（page）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B5%E8%A1%A8%EF%BC%9A%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E4%B8%AD%E7%9A%84%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84"><span class="toc-number">4.3.0.5.</span> <span class="toc-text">页表：页式存储中的地址映射</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E9%A1%B5%E8%A1%A8%E6%A6%82%E8%BF%B0"><span class="toc-number">4.4.</span> <span class="toc-text">4、页表概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B5%E8%A1%A8%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">4.4.0.1.</span> <span class="toc-text">页表的结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B5%E8%A1%A8%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E7%A4%BA%E4%BE%8B"><span class="toc-number">4.4.0.2.</span> <span class="toc-text">页表地址转换示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6%E7%9A%84%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98"><span class="toc-number">4.4.0.3.</span> <span class="toc-text">页式存储管理机制的性能问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81%E5%BF%AB%E8%A1%A8%E5%92%8C%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8"><span class="toc-number">4.5.</span> <span class="toc-text">5、快表和多级页表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%AB%E8%A1%A8%EF%BC%88TLB%EF%BC%89"><span class="toc-number">4.5.0.1.</span> <span class="toc-text">快表（TLB）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8"><span class="toc-number">4.5.0.2.</span> <span class="toc-text">多级页表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E7%BA%A7%E9%A1%B5%E8%A1%A8%E5%AE%9E%E4%BE%8B"><span class="toc-number">4.5.0.3.</span> <span class="toc-text">二级页表实例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81%E5%8F%8D%E7%BD%AE%E9%A1%B5%E8%A1%A8"><span class="toc-number">4.6.</span> <span class="toc-text">6、反置页表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%A7%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E9%97%AE%E9%A2%98"><span class="toc-number">4.6.0.1.</span> <span class="toc-text">大地址空间问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B5%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">4.6.0.2.</span> <span class="toc-text">页寄存器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B5%E5%AF%84%E5%AD%98%E5%99%A8%E6%96%B9%E6%A1%88%E7%9A%84%E7%89%B9%E5%BE%81"><span class="toc-number">4.6.0.3.</span> <span class="toc-text">页寄存器方案的特征</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B5%E5%AF%84%E5%AD%98%E5%99%A8%E4%B8%AD%E7%9A%84%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2"><span class="toc-number">4.6.0.4.</span> <span class="toc-text">页寄存器中的地址转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8D%E7%BD%AE%E9%A1%B5%E8%A1%A8"><span class="toc-number">4.6.0.5.</span> <span class="toc-text">反置页表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8D%E7%BD%AE%E9%A1%B5%E8%A1%A8%E7%9A%84hash%E5%86%B2%E7%AA%81"><span class="toc-number">4.6.0.6.</span> <span class="toc-text">反置页表的hash冲突</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81%E6%AE%B5%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86"><span class="toc-number">4.7.</span> <span class="toc-text">7、段页式存储管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AE%B5%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86"><span class="toc-number">4.7.0.1.</span> <span class="toc-text">段页式存储管理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AE%B5%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E4%B8%AD%E5%86%85%E5%AD%98%E5%85%B1%E4%BA%AB"><span class="toc-number">4.7.0.2.</span> <span class="toc-text">段页式存储管理中内存共享</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E6%A6%82%E5%BF%B5"><span class="toc-number">5.</span> <span class="toc-text">五、虚拟存储概念</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E7%9A%84%E9%9C%80%E6%B1%82%E8%83%8C%E6%99%AF"><span class="toc-number">5.1.</span> <span class="toc-text">1、虚拟存储的需求背景</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E7%9A%84%E6%A6%82%E8%BF%B0"><span class="toc-number">5.1.0.1.</span> <span class="toc-text">虚拟存储的概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A2%9E%E9%95%BF%E8%BF%85%E9%80%9F%E7%9A%84%E5%AD%98%E5%82%A8%E9%9C%80%E6%B1%82"><span class="toc-number">5.1.0.2.</span> <span class="toc-text">增长迅速的存储需求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="toc-number">5.1.0.3.</span> <span class="toc-text">存储层次结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AD%98%E5%82%A8%E6%8A%BD%E8%B1%A1"><span class="toc-number">5.1.0.4.</span> <span class="toc-text">操作系统的存储抽象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E7%9A%84%E9%9C%80%E6%B1%82"><span class="toc-number">5.1.0.5.</span> <span class="toc-text">虚拟存储的需求</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E8%A6%86%E7%9B%96%E5%92%8C%E4%BA%A4%E6%8D%A2"><span class="toc-number">5.2.</span> <span class="toc-text">2、覆盖和交换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A6%86%E7%9B%96%E6%8A%80%E6%9C%AF"><span class="toc-number">5.2.0.1.</span> <span class="toc-text">覆盖技术</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A6%86%E7%9B%96%E6%8A%80%E6%9C%AF%E5%AE%9E%E4%BE%8B"><span class="toc-number">5.2.0.2.</span> <span class="toc-text">覆盖技术实例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A6%86%E7%9B%96%E6%8A%80%E6%9C%AF%E7%9A%84%E4%B8%8D%E8%B6%B3"><span class="toc-number">5.2.0.3.</span> <span class="toc-text">覆盖技术的不足</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2%E6%8A%80%E6%9C%AF"><span class="toc-number">5.2.0.4.</span> <span class="toc-text">交换技术</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2%E6%8A%80%E6%9C%AF%E9%9D%A2%E4%B8%B4%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">5.2.0.5.</span> <span class="toc-text">交换技术面临的问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A6%86%E7%9B%96%E5%92%8C%E4%BA%A4%E6%8D%A2%E6%8A%80%E6%9C%AF%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">5.2.1.</span> <span class="toc-text">覆盖和交换技术的比较</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E5%B1%80%E9%83%A8%E6%80%A7%E5%8E%9F%E7%90%86"><span class="toc-number">5.3.</span> <span class="toc-text">3、局部性原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E6%8A%80%E6%9C%AF%E7%9A%84%E7%9B%AE%E6%A0%87"><span class="toc-number">5.3.0.1.</span> <span class="toc-text">虚拟存储技术的目标</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E6%80%A7%E5%8E%9F%E7%90%86"><span class="toc-number">5.3.0.2.</span> <span class="toc-text">局部性原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E6%80%A7%E7%89%B9%E5%BE%81%E4%B8%BE%E4%BE%8B"><span class="toc-number">5.3.0.3.</span> <span class="toc-text">局部性特征举例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E6%A6%82%E5%BF%B5"><span class="toc-number">5.4.</span> <span class="toc-text">4、虚拟存储概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">5.4.0.1.</span> <span class="toc-text">虚拟存储的基本概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81"><span class="toc-number">5.4.0.2.</span> <span class="toc-text">虚拟存储的基本特征</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E7%9A%84%E6%94%AF%E6%8C%81%E6%8A%80%E6%9C%AF"><span class="toc-number">5.4.0.3.</span> <span class="toc-text">虚拟存储的支持技术</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81%E8%99%9A%E6%8B%9F%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8"><span class="toc-number">5.5.</span> <span class="toc-text">5、虚拟页式存储</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86"><span class="toc-number">5.5.0.1.</span> <span class="toc-text">虚拟页式存储管理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E4%B8%AD%E7%9A%84%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2"><span class="toc-number">5.5.0.2.</span> <span class="toc-text">虚拟页式存储中的地址转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E4%B8%AD%E7%9A%84%E9%A1%B5%E8%A1%A8%E9%A1%B9%E7%BB%93%E6%9E%84"><span class="toc-number">5.5.0.3.</span> <span class="toc-text">虚拟页式存储中的页表项结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%A4%BA%E4%BE%8B"><span class="toc-number">5.5.0.4.</span> <span class="toc-text">虚拟页式存储示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#X86%E9%A1%B5%E8%A1%A8%E7%BB%93%E6%9E%84"><span class="toc-number">5.5.0.5.</span> <span class="toc-text">X86页表结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#X86%E9%A1%B5%E8%A1%A8%E9%A1%B9%E7%BB%93%E6%9E%84"><span class="toc-number">5.5.0.6.</span> <span class="toc-text">X86页表项结构</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81%E7%BC%BA%E9%A1%B5%E5%BC%82%E5%B8%B8"><span class="toc-number">5.6.</span> <span class="toc-text">6、缺页异常</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E9%A1%B5%E5%BC%82%E5%B8%B8%EF%BC%88%E7%BC%BA%E9%A1%B5%E4%B8%AD%E6%96%AD%EF%BC%89%E7%9A%84%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B"><span class="toc-number">5.6.0.1.</span> <span class="toc-text">缺页异常（缺页中断）的处理流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E4%B8%AD%E7%9A%84%E5%A4%96%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">5.6.0.2.</span> <span class="toc-text">虚拟页式存储中的外存管理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E7%9A%84%E6%80%A7%E8%83%BD"><span class="toc-number">5.6.0.3.</span> <span class="toc-text">虚拟页式存储管理的性能</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="toc-number">6.</span> <span class="toc-text">六、页面置换算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">6.1.</span> <span class="toc-text">1、页面置换算法的概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%E7%9A%84%E5%8A%9F%E8%83%BD%E3%80%81%E7%9B%AE%E6%A0%87%E5%92%8C%E9%A1%B5%E9%9D%A2%E9%94%81%E5%AE%9A"><span class="toc-number">6.1.0.1.</span> <span class="toc-text">置换算法的功能、目标和页面锁定</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%E7%9A%84%E8%AF%84%E4%BB%B7%E6%96%B9%E6%B3%95"><span class="toc-number">6.1.0.2.</span> <span class="toc-text">置换算法的评价方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%E5%88%86%E7%B1%BB"><span class="toc-number">6.1.0.3.</span> <span class="toc-text">页面置换算法分类</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E6%9C%80%E4%BC%98%E7%AE%97%E6%B3%95%E3%80%81%E5%85%88%E8%BF%9B%E5%85%88%E5%87%BA%E7%AE%97%E6%B3%95%E5%92%8C%E6%9C%80%E8%BF%91%E6%9C%80%E4%B9%85%E6%9C%AA%E4%BD%BF%E7%94%A8%E7%AE%97%E6%B3%95"><span class="toc-number">6.2.</span> <span class="toc-text">2、最优算法、先进先出算法和最近最久未使用算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E4%BC%98%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95OPT"><span class="toc-number">6.2.0.1.</span> <span class="toc-text">最优页面置换算法OPT</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#OPT%E7%AE%97%E6%B3%95%E7%A4%BA%E4%BE%8B"><span class="toc-number">6.2.0.2.</span> <span class="toc-text">OPT算法示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%88%E8%BF%9B%E5%85%88%E5%87%BA%E7%AE%97%E6%B3%95FIFO"><span class="toc-number">6.2.0.3.</span> <span class="toc-text">先进先出算法FIFO</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#FIFO%E7%AE%97%E6%B3%95%E7%A4%BA%E4%BE%8B"><span class="toc-number">6.2.0.4.</span> <span class="toc-text">FIFO算法示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E8%BF%91%E6%9C%80%E6%9C%AA%E8%A2%AB%E4%BD%BF%E7%94%A8%E7%AE%97%E6%B3%95LRU"><span class="toc-number">6.2.0.5.</span> <span class="toc-text">最近最未被使用算法LRU</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LRU%E7%AE%97%E6%B3%95%E7%A4%BA%E4%BE%8B"><span class="toc-number">6.2.0.6.</span> <span class="toc-text">LRU算法示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LRU%E7%AE%97%E6%B3%95%E7%9A%84%E5%8F%AF%E8%83%BD%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95"><span class="toc-number">6.2.0.7.</span> <span class="toc-text">LRU算法的可能实现方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0LRU%E7%AE%97%E6%B3%95"><span class="toc-number">6.2.0.8.</span> <span class="toc-text">用栈实现LRU算法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E6%97%B6%E9%92%9F%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%E5%92%8C%E6%9C%80%E4%B8%8D%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95"><span class="toc-number">6.3.</span> <span class="toc-text">3、时钟置换算法和最不常用算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%B6%E9%92%9F%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95Clock"><span class="toc-number">6.3.0.1.</span> <span class="toc-text">时钟置换算法Clock</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%B6%E9%92%9F%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">6.3.0.2.</span> <span class="toc-text">时钟置换算法的实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%B6%E9%92%9F%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%A4%BA%E4%BE%8B"><span class="toc-number">6.3.0.3.</span> <span class="toc-text">时钟页面置换示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%B9%E8%BF%9B%E7%9A%84%E6%97%B6%E9%92%9F%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="toc-number">6.3.0.4.</span> <span class="toc-text">改进的时钟置换算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%B9%E8%BF%9B%E7%9A%84%E6%97%B6%E9%92%9F%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%E7%A4%BA%E4%BE%8B"><span class="toc-number">6.3.0.5.</span> <span class="toc-text">改进的时钟置换算法示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E4%B8%8D%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95LFU"><span class="toc-number">6.3.0.6.</span> <span class="toc-text">最不常用算法LFU</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LFU%E7%AE%97%E6%B3%95%E7%A4%BA%E4%BE%8B"><span class="toc-number">6.3.0.7.</span> <span class="toc-text">LFU算法示例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81Belady%E7%8E%B0%E8%B1%A1%E5%92%8C%E5%B1%80%E9%83%A8%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%E6%AF%94%E8%BE%83"><span class="toc-number">6.4.</span> <span class="toc-text">4、Belady现象和局部置换算法比较</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Belady%E7%8E%B0%E8%B1%A1"><span class="toc-number">6.4.0.1.</span> <span class="toc-text">Belady现象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#FIFO%E7%AE%97%E6%B3%95%E6%9C%89Belady%E7%8E%B0%E8%B1%A1"><span class="toc-number">6.4.0.2.</span> <span class="toc-text">FIFO算法有Belady现象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LRU%E7%AE%97%E6%B3%95%E6%B2%A1%E6%9C%89Belady%E7%8E%B0%E8%B1%A1"><span class="toc-number">6.4.0.3.</span> <span class="toc-text">LRU算法没有Belady现象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LRU%E3%80%81FIFO%E5%92%8CClock%E7%AE%97%E6%B3%95%E6%AF%94%E8%BE%83"><span class="toc-number">6.4.0.4.</span> <span class="toc-text">LRU、FIFO和Clock算法比较</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81%E5%B7%A5%E4%BD%9C%E9%9B%86%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="toc-number">6.5.</span> <span class="toc-text">5、工作集置换算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#CPU%E5%88%A9%E7%94%A8%E7%8E%87%E5%92%8C%E5%B9%B6%E5%8F%91%E8%BF%9B%E7%A8%8B%E6%95%B0%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">6.5.0.1.</span> <span class="toc-text">CPU利用率和并发进程数的关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="toc-number">6.5.0.2.</span> <span class="toc-text">全局置换算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E9%9B%86"><span class="toc-number">6.5.0.3.</span> <span class="toc-text">工作集</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%B7%A5%E4%BD%9C%E9%9B%86%E7%A4%BA%E4%BE%8B"><span class="toc-number">6.5.0.4.</span> <span class="toc-text">进程的工作集示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E9%9B%86%E5%8F%98%E5%8C%96"><span class="toc-number">6.5.0.5.</span> <span class="toc-text">工作集变化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E9%A9%BB%E9%9B%86"><span class="toc-number">6.5.0.6.</span> <span class="toc-text">常驻集</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E9%9B%86%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="toc-number">6.5.0.7.</span> <span class="toc-text">工作集置换算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E9%9B%86%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%E7%A4%BA%E4%BE%8B"><span class="toc-number">6.5.1.</span> <span class="toc-text">工作集置换算法示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81%E7%BC%BA%E9%A1%B5%E7%8E%87%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="toc-number">6.6.</span> <span class="toc-text">6、缺页率置换算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E9%A1%B5%E7%8E%87"><span class="toc-number">6.6.0.1.</span> <span class="toc-text">缺页率</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E9%A1%B5%E7%8E%87%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="toc-number">6.6.0.2.</span> <span class="toc-text">缺页率置换算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E9%A1%B5%E7%8E%87%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">6.6.0.3.</span> <span class="toc-text">缺页率置换算法的实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E9%A1%B5%E7%8E%87%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%E7%A4%BA%E4%BE%8B"><span class="toc-number">6.6.0.4.</span> <span class="toc-text">缺页率置换算法示例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81%E6%8A%96%E5%8A%A8%E5%92%8C%E8%B4%9F%E8%BD%BD%E6%8E%A7%E5%88%B6"><span class="toc-number">6.7.</span> <span class="toc-text">7、抖动和负载控制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%96%E5%8A%A8%E9%97%AE%E9%A2%98"><span class="toc-number">6.7.0.1.</span> <span class="toc-text">抖动问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B4%9F%E8%BD%BD%E6%8E%A7%E5%88%B6"><span class="toc-number">6.7.0.2.</span> <span class="toc-text">负载控制</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B"><span class="toc-number">7.</span> <span class="toc-text">七、进程和线程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">7.1.</span> <span class="toc-text">1、进程的概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%99%85%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E8%BF%9B%E7%A8%8B"><span class="toc-number">7.1.0.1.</span> <span class="toc-text">实际操作系统中的进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">7.1.0.2.</span> <span class="toc-text">进程的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E8%BF%9B%E7%A8%8B"><span class="toc-number">7.1.0.3.</span> <span class="toc-text">内存中的进程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%BB%84%E6%88%90"><span class="toc-number">7.1.1.</span> <span class="toc-text">进程的组成</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">7.1.1.1.</span> <span class="toc-text">进程的特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%81%94%E7%B3%BB"><span class="toc-number">7.1.1.2.</span> <span class="toc-text">进程与程序的联系</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">7.1.2.</span> <span class="toc-text">进程与程序的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97"><span class="toc-number">7.2.</span> <span class="toc-text">2、进程控制块</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97PCB"><span class="toc-number">7.2.0.1.</span> <span class="toc-text">进程控制块PCB</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">7.2.0.2.</span> <span class="toc-text">进程控制块的使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97"><span class="toc-number">7.2.0.3.</span> <span class="toc-text">进程控制块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E7%9A%84%E4%BF%A1%E6%81%AF"><span class="toc-number">7.2.0.4.</span> <span class="toc-text">进程控制的信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97%E7%9A%84%E7%BB%84%E7%BB%87"><span class="toc-number">7.2.0.5.</span> <span class="toc-text">进程控制块的组织</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81"><span class="toc-number">7.3.</span> <span class="toc-text">3、进程状态</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA"><span class="toc-number">7.3.0.1.</span> <span class="toc-text">进程创建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%89%A7%E8%A1%8C"><span class="toc-number">7.3.0.2.</span> <span class="toc-text">进程的执行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%AD%89%E5%BE%85"><span class="toc-number">7.3.0.3.</span> <span class="toc-text">进程等待</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%8A%A2%E5%8D%A0"><span class="toc-number">7.3.0.4.</span> <span class="toc-text">进程抢占</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%94%A4%E9%86%92"><span class="toc-number">7.3.0.5.</span> <span class="toc-text">进程唤醒</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%BB%93%E6%9D%9F"><span class="toc-number">7.3.0.6.</span> <span class="toc-text">进程结束</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%88%87%E6%8D%A2"><span class="toc-number">7.3.0.7.</span> <span class="toc-text">进程的切换</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E4%B8%89%E7%8A%B6%E6%80%81%E8%BF%9B%E7%A8%8B%E6%A8%A1%E5%9E%8B%E5%8F%8A%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%8F%98%E8%BF%81"><span class="toc-number">7.4.</span> <span class="toc-text">4、三状态进程模型及进程的变迁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81"><span class="toc-number">7.4.0.1.</span> <span class="toc-text">进程状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%8F%98%E8%BF%81"><span class="toc-number">7.4.0.2.</span> <span class="toc-text">一个进程的变迁</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81%E6%8C%82%E8%B5%B7%E8%BF%9B%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-number">7.5.</span> <span class="toc-text">5、挂起进程模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%8C%82%E8%B5%B7"><span class="toc-number">7.5.0.1.</span> <span class="toc-text">进程挂起</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%82%E8%B5%B7%E8%BF%9B%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-number">7.5.0.2.</span> <span class="toc-text">挂起进程模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%82%E8%B5%B7%E7%8A%B6%E6%80%81"><span class="toc-number">7.5.0.3.</span> <span class="toc-text">挂起状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8E%E6%8C%82%E8%B5%B7%E7%9B%B8%E5%85%B3%E7%9A%84%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2"><span class="toc-number">7.5.0.4.</span> <span class="toc-text">与挂起相关的状态转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E9%98%9F%E5%88%97"><span class="toc-number">7.5.0.5.</span> <span class="toc-text">状态队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E7%9A%84%E9%98%9F%E5%88%97%E8%A1%A8%E7%8E%B0"><span class="toc-number">7.5.0.6.</span> <span class="toc-text">进程状态的队列表现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">7.6.</span> <span class="toc-text">6、线程的概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BE%E4%BE%8B%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BC%95%E5%85%A5%E7%BA%BF%E7%A8%8B"><span class="toc-number">7.6.0.1.</span> <span class="toc-text">举例：为什么引入线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95"><span class="toc-number">7.6.0.2.</span> <span class="toc-text">单进程的实现方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95"><span class="toc-number">7.6.0.3.</span> <span class="toc-text">多进程的实现方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E8%A7%A3%E5%86%B3%E6%80%9D%E8%B7%AF"><span class="toc-number">7.6.0.4.</span> <span class="toc-text">多线程的解决思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">7.6.0.5.</span> <span class="toc-text">线程的概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">7.6.0.6.</span> <span class="toc-text">进程和线程的关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B-x3D-%E8%BF%9B%E7%A8%8B-%E5%85%B1%E4%BA%AB%E8%B5%84%E6%BA%90"><span class="toc-number">7.6.0.7.</span> <span class="toc-text">线程 &#x3D; 进程 - 共享资源</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%94%AF%E6%8C%81%E7%9A%84%E7%BA%BF%E7%A8%8B"><span class="toc-number">7.6.0.8.</span> <span class="toc-text">不同操作系统支持的线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">7.6.0.9.</span> <span class="toc-text">线程和进程的比较</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81%E7%94%A8%E6%88%B7%E7%BA%BF%E7%A8%8B"><span class="toc-number">7.7.</span> <span class="toc-text">7、用户线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%89%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">7.7.0.1.</span> <span class="toc-text">线程的三种实现方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E7%BA%BF%E7%A8%8B"><span class="toc-number">7.7.0.2.</span> <span class="toc-text">用户线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%89%B9%E5%BE%81"><span class="toc-number">7.7.0.3.</span> <span class="toc-text">用户线程的特征</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%8D%E8%B6%B3"><span class="toc-number">7.7.0.4.</span> <span class="toc-text">用户线程的不足</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8%E3%80%81%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B"><span class="toc-number">7.8.</span> <span class="toc-text">8、内核线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B"><span class="toc-number">7.8.0.1.</span> <span class="toc-text">内核线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%89%B9%E5%BE%81"><span class="toc-number">7.8.0.2.</span> <span class="toc-text">内核线程的特征</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%BB%E6%9D%83%E8%BF%9B%E7%A8%8B"><span class="toc-number">7.8.0.3.</span> <span class="toc-text">轻权进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB"><span class="toc-number">7.8.0.4.</span> <span class="toc-text">用户线程和内核线程的对应关系</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-number">8.</span> <span class="toc-text">八、进程控制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E8%BF%9B%E7%A8%8B%E5%88%87%E6%8D%A2"><span class="toc-number">8.1.</span> <span class="toc-text">1、进程切换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%88%87%E6%8D%A2"><span class="toc-number">8.1.0.1.</span> <span class="toc-text">进程切换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2%E5%9B%BE%E7%A4%BA"><span class="toc-number">8.1.0.2.</span> <span class="toc-text">上下文切换图示</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97PCB-%E5%86%85%E6%A0%B8%E7%9A%84%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E8%AE%B0%E5%BD%95"><span class="toc-number">8.1.0.3.</span> <span class="toc-text">进程控制块PCB::内核的进程状态记录</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ucore%E7%9A%84%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97%E7%BB%93%E6%9E%84proc-struct"><span class="toc-number">8.1.0.4.</span> <span class="toc-text">ucore的进程控制块结构proc_struct</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ucore%E7%9A%84%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E7%BB%93%E6%9E%84mm-struct"><span class="toc-number">8.1.0.5.</span> <span class="toc-text">ucore的内存地址空间结构mm_struct</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ucore-%E7%9A%84%E8%BF%9B%E7%A8%8B%E9%98%9F%E5%88%97"><span class="toc-number">8.1.0.6.</span> <span class="toc-text">ucore+的进程队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ucore-%E8%BF%9B%E7%A8%8B-x2F-%E7%BA%BF%E7%A8%8B%E5%88%87%E6%8D%A2%E6%B5%81%E7%A8%8B"><span class="toc-number">8.1.0.7.</span> <span class="toc-text">ucore+进程&#x2F;线程切换流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ucore-%E7%9A%84%E8%BF%9B%E7%A8%8B%E5%88%87%E6%8D%A2"><span class="toc-number">8.1.0.8.</span> <span class="toc-text">ucore+的进程切换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#switch-to-%E5%AE%9E%E7%8E%B0"><span class="toc-number">8.1.0.9.</span> <span class="toc-text">switch_to 实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA"><span class="toc-number">8.2.</span> <span class="toc-text">2、进程创建</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%8E%A5%E5%8F%A3"><span class="toc-number">8.2.0.1.</span> <span class="toc-text">创建进程的系统调用接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%96%B0%E8%BF%9B%E7%A8%8B"><span class="toc-number">8.2.0.2.</span> <span class="toc-text">创建新进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#fork-%E7%9A%84%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E5%A4%8D%E5%88%B6"><span class="toc-number">8.2.0.3.</span> <span class="toc-text">fork()的地址空间复制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%92%8C%E6%89%A7%E8%A1%8C"><span class="toc-number">8.2.0.4.</span> <span class="toc-text">程序的加载和执行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8shell%E4%B8%AD%E8%B0%83%E7%94%A8fork-%E5%90%8E%E5%8A%A0%E8%BD%BD%E8%AE%A1%E7%AE%97%E5%99%A8%E7%9A%84%E5%9B%BE%E7%A4%BA"><span class="toc-number">8.2.0.5.</span> <span class="toc-text">在shell中调用fork()后加载计算器的图示</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A9%BA%E9%97%B2%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">8.2.0.6.</span> <span class="toc-text">空闲进程的创建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B"><span class="toc-number">8.2.0.7.</span> <span class="toc-text">创建第一个内核线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#fork-%E7%9A%84%E5%BC%80%E9%94%80"><span class="toc-number">8.2.0.8.</span> <span class="toc-text">fork()的开销</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E8%BF%9B%E7%A8%8B%E5%8A%A0%E8%BD%BD"><span class="toc-number">8.3.</span> <span class="toc-text">3、进程加载</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E5%8A%A0%E8%BD%BD%E5%92%8C%E6%89%A7%E8%A1%8C%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8exec"><span class="toc-number">8.3.0.1.</span> <span class="toc-text">程序加载和执行系统调用exec( )</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E8%BF%9B%E7%A8%8B%E7%AD%89%E5%BE%85%E4%B8%8E%E9%80%80%E5%87%BA"><span class="toc-number">8.4.</span> <span class="toc-text">4、进程等待与退出</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%88%B6%E8%BF%9B%E7%A8%8B%E7%AD%89%E5%BE%85%E5%AD%90%E8%BF%9B%E7%A8%8Bwait"><span class="toc-number">8.4.0.1.</span> <span class="toc-text">父进程等待子进程wait()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%9C%89%E5%BA%8F%E7%BB%88%E6%AD%A2exit"><span class="toc-number">8.4.0.2.</span> <span class="toc-text">进程的有序终止exit()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">8.4.0.3.</span> <span class="toc-text">其他进程控制系统调用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%92%8C%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81"><span class="toc-number">8.4.0.4.</span> <span class="toc-text">进程控制和进程状态</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B9%9D%E3%80%81%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6"><span class="toc-number">9.</span> <span class="toc-text">九、处理机调度</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">9.1.</span> <span class="toc-text">1、处理机调度的概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#CPU%E8%B5%84%E6%BA%90%E7%9A%84%E6%97%B6%E5%88%86%E5%A4%8D%E7%94%A8"><span class="toc-number">9.1.0.1.</span> <span class="toc-text">CPU资源的时分复用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E6%97%B6%E6%9C%BA"><span class="toc-number">9.1.0.2.</span> <span class="toc-text">调度时机</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E8%B0%83%E5%BA%A6%E5%87%86%E5%88%99"><span class="toc-number">9.2.</span> <span class="toc-text">2、调度准则</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E6%9C%BA%E8%B5%84%E6%BA%90%E7%9A%84%E4%BD%BF%E7%94%A8%E6%A8%A1%E5%BC%8F"><span class="toc-number">9.2.0.1.</span> <span class="toc-text">处理机资源的使用模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AF%94%E8%BE%83%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E7%9A%84%E5%87%86%E5%88%99"><span class="toc-number">9.2.0.2.</span> <span class="toc-text">比较调度算法的准则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%9E%E5%90%90%E9%87%8F%E4%B8%8E%E5%93%8D%E5%BA%94%E5%BB%B6%E8%BF%9F"><span class="toc-number">9.2.0.3.</span> <span class="toc-text">吞吐量与响应延迟</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5%E7%9A%84%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4%E7%9B%AE%E6%A0%87"><span class="toc-number">9.2.0.4.</span> <span class="toc-text">处理机调度策略的响应时间目标</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5%E7%9A%84%E5%90%9E%E5%90%90%E9%87%8F%E7%9B%AE%E6%A0%87"><span class="toc-number">9.2.0.5.</span> <span class="toc-text">处理调度策略的吞吐量目标</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%E7%9A%84%E5%85%AC%E5%B9%B3%E6%80%A7%E7%9B%AE%E6%A0%87"><span class="toc-number">9.2.0.6.</span> <span class="toc-text">处理机调度的公平性目标</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E5%85%88%E6%9D%A5%E5%85%88%E6%9C%8D%E5%8A%A1%E3%80%81%E7%9F%AD%E8%BF%9B%E7%A8%8B%E4%BC%98%E5%85%88%E5%92%8C%E6%9C%80%E9%AB%98%E5%93%8D%E5%BA%94%E6%AF%94%E4%BC%98%E5%85%88%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">9.3.</span> <span class="toc-text">3、先来先服务、短进程优先和最高响应比优先调度算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%88%E6%9D%A5%E5%85%88%E6%9C%8D%E5%8A%A1%E7%AE%97%E6%B3%95FCFS"><span class="toc-number">9.3.0.1.</span> <span class="toc-text">先来先服务算法FCFS</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%88%E6%9D%A5%E5%85%88%E6%9C%8D%E5%8A%A1%E7%AE%97%E6%B3%95%E7%89%B9%E5%BE%81"><span class="toc-number">9.3.0.2.</span> <span class="toc-text">先来先服务算法特征</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9F%AD%E8%BF%9B%E7%A8%8B%E4%BC%98%E5%85%88%E7%AE%97%E6%B3%95SPN"><span class="toc-number">9.3.0.3.</span> <span class="toc-text">短进程优先算法SPN</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9F%AD%E8%BF%9B%E7%A8%8B%E4%BC%98%E5%85%88%E7%AE%97%E6%B3%95%E5%85%B7%E6%9C%89%E6%9C%80%E4%BC%98%E5%B9%B3%E5%9D%87%E5%91%A8%E8%BD%AC%E6%97%B6%E9%97%B4"><span class="toc-number">9.3.0.4.</span> <span class="toc-text">短进程优先算法具有最优平均周转时间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9F%AD%E8%BF%9B%E7%A8%8B%E4%BC%98%E5%85%88%E7%AE%97%E6%B3%95%E7%9A%84%E7%89%B9%E5%BE%81%EF%BC%9A%E7%BC%BA%E7%82%B9"><span class="toc-number">9.3.0.5.</span> <span class="toc-text">短进程优先算法的特征：缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9F%AD%E8%BF%9B%E7%A8%8B%E4%BC%98%E5%85%88%E7%AE%97%E6%B3%95%E6%89%A7%E8%A1%8C%E6%97%B6%E9%97%B4%E9%A2%84%E4%BC%B0"><span class="toc-number">9.3.0.6.</span> <span class="toc-text">短进程优先算法执行时间预估</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%84%E4%BC%B0%E6%89%A7%E8%A1%8C%E6%97%B6%E9%97%B4"><span class="toc-number">9.3.0.7.</span> <span class="toc-text">预估执行时间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E9%AB%98%E5%93%8D%E5%BA%94%E6%AF%94%E4%BC%98%E5%85%88%E7%AE%97%E6%B3%95HRRN"><span class="toc-number">9.3.0.8.</span> <span class="toc-text">最高响应比优先算法HRRN</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E6%97%B6%E9%97%B4%E7%89%87%E8%BD%AE%E8%BD%AC%E3%80%81%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E9%98%9F%E5%88%97%E3%80%81%E5%85%AC%E5%B9%B3%E5%85%B1%E4%BA%AB%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E5%92%8Cucore%E8%B0%83%E5%BA%A6%E6%A1%86%E6%9E%B6"><span class="toc-number">9.4.</span> <span class="toc-text">4、时间片轮转、多级反馈队列、公平共享调度算法和ucore调度框架</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E7%89%87%E8%BD%AE%E8%BD%AC%E7%AE%97%E6%B3%95RR"><span class="toc-number">9.4.0.1.</span> <span class="toc-text">时间片轮转算法RR</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E7%89%87%E4%B8%BA20%E7%9A%84RR%E7%AE%97%E6%B3%95%E7%A4%BA%E4%BE%8B"><span class="toc-number">9.4.0.2.</span> <span class="toc-text">时间片为20的RR算法示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E7%89%87%E8%BD%AE%E8%BD%AC%E7%AE%97%E6%B3%95%E4%B8%AD%E7%9A%84%E6%97%B6%E9%97%B4%E7%89%87%E9%95%BF%E5%BA%A6"><span class="toc-number">9.4.0.3.</span> <span class="toc-text">时间片轮转算法中的时间片长度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AF%94%E8%BE%83FCFS%E5%92%8CRR"><span class="toc-number">9.4.0.4.</span> <span class="toc-text">比较FCFS和RR</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E7%BA%A7%E9%98%9F%E5%88%97%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%EF%BC%88MQ%EF%BC%89"><span class="toc-number">9.4.0.5.</span> <span class="toc-text">多级队列调度算法（MQ）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E9%98%9F%E5%88%97%E7%AE%97%E6%B3%95%EF%BC%88MLFQ%EF%BC%89"><span class="toc-number">9.4.0.6.</span> <span class="toc-text">多级反馈队列算法（MLFQ）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%AC%E5%B9%B3%E5%85%B1%E4%BA%AB%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95FSS"><span class="toc-number">9.4.0.7.</span> <span class="toc-text">公平共享调度算法FSS</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%A0%E7%BB%9F%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E7%9A%84%E6%80%BB%E7%BB%93"><span class="toc-number">9.4.0.8.</span> <span class="toc-text">传统调度算法的总结</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ucore%E7%9A%84%E8%B0%83%E5%BA%A6%E6%97%B6%E6%9C%BA%E5%92%8C%E8%BF%9B%E7%A8%8B%E5%88%87%E6%8D%A2"><span class="toc-number">9.4.0.9.</span> <span class="toc-text">ucore的调度时机和进程切换</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81%E5%AE%9E%E6%97%B6%E8%B0%83%E5%BA%A6%E5%92%8C%E5%A4%9A%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6"><span class="toc-number">9.5.</span> <span class="toc-text">5、实时调度和多处理机调度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E6%97%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-number">9.5.0.1.</span> <span class="toc-text">实时操作系统</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E6%97%B6%E4%BB%BB%E5%8A%A1"><span class="toc-number">9.5.0.2.</span> <span class="toc-text">实时任务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%A8%E6%9C%9F%E5%AE%9E%E6%97%B6%E4%BB%BB%E5%8A%A1"><span class="toc-number">9.5.0.3.</span> <span class="toc-text">周期实时任务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A1%AC%E6%97%B6%E9%99%90%E5%92%8C%E8%BD%AF%E6%97%B6%E9%99%90"><span class="toc-number">9.5.0.4.</span> <span class="toc-text">硬时限和软时限</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E8%B0%83%E5%BA%A6%E6%80%A7"><span class="toc-number">9.5.0.5.</span> <span class="toc-text">可调度性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E6%97%B6%E8%B0%83%E5%BA%A6"><span class="toc-number">9.5.0.6.</span> <span class="toc-text">实时调度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6"><span class="toc-number">9.5.0.7.</span> <span class="toc-text">多处理机调度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E7%A7%B0%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E8%BF%9B%E7%A8%8B%E5%88%86%E9%85%8D"><span class="toc-number">9.5.0.8.</span> <span class="toc-text">对称多处理器的进程分配</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81%E4%BC%98%E5%85%88%E7%BA%A7%E5%8F%8D%E7%BD%AE"><span class="toc-number">9.6.</span> <span class="toc-text">6、优先级反置</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7%E5%8F%8D%E7%BD%AE"><span class="toc-number">9.6.0.1.</span> <span class="toc-text">优先级反置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7%E7%BB%A7%E6%89%BF"><span class="toc-number">9.6.0.2.</span> <span class="toc-text">优先级继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7%E5%A4%A9%E8%8A%B1%E6%9D%BF%E5%8D%8F%E8%AE%AE"><span class="toc-number">9.6.0.3.</span> <span class="toc-text">优先级天花板协议</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E3%80%81%E5%90%8C%E6%AD%A5%E4%BA%92%E6%96%A5"><span class="toc-number">10.</span> <span class="toc-text">十、同步互斥</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E8%83%8C%E6%99%AF"><span class="toc-number">10.1.</span> <span class="toc-text">1、背景</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%AD%A3%E7%A1%AE%E6%80%A7"><span class="toc-number">10.1.0.1.</span> <span class="toc-text">并发进程的正确性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%B9%B6%E5%8F%91%E6%89%A7%E8%A1%8C%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-number">10.1.0.2.</span> <span class="toc-text">进程并发执行的好处</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E5%88%9B%E5%BB%BA%E6%96%B0%E8%BF%9B%E7%A8%8B%E6%97%B6%E7%9A%84%E6%A0%87%E8%AF%86%E5%88%86%E9%85%8D"><span class="toc-number">10.1.0.3.</span> <span class="toc-text">并发创建新进程时的标识分配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B0%E8%BF%9B%E7%A8%8B%E5%88%86%E9%85%8D%E6%A0%87%E8%AF%86%E7%9A%84%E5%8F%AF%E8%83%BD%E9%94%99%E8%AF%AF"><span class="toc-number">10.1.0.4.</span> <span class="toc-text">新进程分配标识的可能错误</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C"><span class="toc-number">10.1.0.5.</span> <span class="toc-text">原子操作</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E7%8E%B0%E5%AE%9E%E7%94%9F%E6%B4%BB%E4%B8%AD%E7%9A%84%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98"><span class="toc-number">10.2.</span> <span class="toc-text">2、现实生活中的同步问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8E%B0%E5%AE%9E%E7%94%9F%E6%B4%BB%E4%B8%AD%E7%9A%84%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98"><span class="toc-number">10.2.0.1.</span> <span class="toc-text">现实生活中的同步问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%B6%E5%BA%AD%E9%87%87%E8%B4%AD%E5%8D%8F%E8%B0%83%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90"><span class="toc-number">10.2.0.2.</span> <span class="toc-text">家庭采购协调问题分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%B8%80"><span class="toc-number">10.2.0.3.</span> <span class="toc-text">解决方案一</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%882"><span class="toc-number">10.2.0.4.</span> <span class="toc-text">解决方案2</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%883"><span class="toc-number">10.2.0.5.</span> <span class="toc-text">解决方案3</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%884"><span class="toc-number">10.2.0.6.</span> <span class="toc-text">解决方案4</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%885"><span class="toc-number">10.2.0.7.</span> <span class="toc-text">解决方案5</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%BA%A4%E4%BA%92%E5%85%B3%E7%B3%BB%EF%BC%9A%E7%9B%B8%E4%BA%92%E6%84%9F%E7%9F%A5%E7%A8%8B%E5%BA%A6"><span class="toc-number">10.2.0.8.</span> <span class="toc-text">进程的交互关系：相互感知程度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E4%B8%B4%E7%95%8C%E5%8C%BA"><span class="toc-number">10.3.</span> <span class="toc-text">3、临界区</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%B4%E7%95%8C%E5%8C%BA"><span class="toc-number">10.3.0.1.</span> <span class="toc-text">临界区</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%B4%E7%95%8C%E5%8C%BA%E7%9A%84%E8%AE%BF%E9%97%AE%E8%A7%84%E5%88%99"><span class="toc-number">10.3.0.2.</span> <span class="toc-text">临界区的访问规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%B4%E7%95%8C%E5%8C%BA%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95"><span class="toc-number">10.3.0.3.</span> <span class="toc-text">临界区的实现方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E7%A6%81%E7%94%A8%E7%A1%AC%E4%BB%B6%E4%B8%AD%E6%96%AD%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95"><span class="toc-number">10.4.</span> <span class="toc-text">4、禁用硬件中断同步方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A6%81%E7%94%A8%E7%A1%AC%E4%BB%B6%E4%B8%AD%E6%96%AD"><span class="toc-number">10.4.0.1.</span> <span class="toc-text">禁用硬件中断</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9"><span class="toc-number">10.4.0.2.</span> <span class="toc-text">缺点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81%E5%9F%BA%E4%BA%8E%E8%BD%AF%E4%BB%B6%E7%9A%84%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95"><span class="toc-number">10.5.</span> <span class="toc-text">5、基于软件的同步方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E8%BD%AF%E4%BB%B6%E7%9A%84%E5%90%8C%E6%AD%A5%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95"><span class="toc-number">10.5.0.1.</span> <span class="toc-text">基于软件的同步解决方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%B0%9D%E8%AF%95"><span class="toc-number">10.5.0.2.</span> <span class="toc-text">第一次尝试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%A7%8D%E5%B0%9D%E8%AF%95"><span class="toc-number">10.5.0.3.</span> <span class="toc-text">第二种尝试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%A7%8D%E5%B0%9D%E8%AF%95"><span class="toc-number">10.5.0.4.</span> <span class="toc-text">第三种尝试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Peterson%E7%AE%97%E6%B3%95"><span class="toc-number">10.5.0.5.</span> <span class="toc-text">Peterson算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Peterson%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0"><span class="toc-number">10.5.0.6.</span> <span class="toc-text">Peterson算法实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Dekkers%E7%AE%97%E6%B3%95"><span class="toc-number">10.5.0.7.</span> <span class="toc-text">Dekkers算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#N%E7%BA%BF%E7%A8%8B%E7%9A%84%E8%BD%AF%E4%BB%B6%E6%96%B9%E6%B3%95%EF%BC%88Eisenberg%E5%92%8CMcGuire%EF%BC%89"><span class="toc-number">10.5.0.8.</span> <span class="toc-text">N线程的软件方法（Eisenberg和McGuire）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E8%BD%AF%E4%BB%B6%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%E7%9A%84%E5%88%86%E6%9E%90"><span class="toc-number">10.5.0.9.</span> <span class="toc-text">基于软件的解决方法的分析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81%E9%AB%98%E7%BA%A7%E6%8A%BD%E8%B1%A1%E7%9A%84%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95"><span class="toc-number">10.6.</span> <span class="toc-text">6、高级抽象的同步方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7%E6%8A%BD%E8%B1%A1%E7%9A%84%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95"><span class="toc-number">10.6.0.1.</span> <span class="toc-text">高级抽象的同步方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%81%EF%BC%88Lock%EF%BC%89"><span class="toc-number">10.6.0.2.</span> <span class="toc-text">锁（Lock）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4"><span class="toc-number">10.6.0.3.</span> <span class="toc-text">原子操作指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8TS%E6%8C%87%E4%BB%A4%E5%AE%9E%E7%8E%B0%E8%87%AA%E6%97%8B%E9%94%81%EF%BC%88spinlock%EF%BC%89"><span class="toc-number">10.6.0.4.</span> <span class="toc-text">使用TS指令实现自旋锁（spinlock）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A0%E5%BF%99%E7%AD%89%E5%BE%85%E9%94%81"><span class="toc-number">10.6.0.5.</span> <span class="toc-text">无忙等待锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4%E7%89%B9%E5%BE%81%E9%94%81"><span class="toc-number">10.6.0.6.</span> <span class="toc-text">原子操作指令特征锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93"><span class="toc-number">10.6.0.7.</span> <span class="toc-text">同步方法总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81%E4%BF%A1%E5%8F%B7%E9%87%8F%EF%BC%88semaphore%EF%BC%89"><span class="toc-number">10.7.</span> <span class="toc-text">7、信号量（semaphore）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9E%E9%A1%BE%E5%B9%B6%E5%8F%91%E5%92%8C%E5%90%8C%E6%AD%A5"><span class="toc-number">10.7.0.1.</span> <span class="toc-text">回顾并发和同步</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">10.7.0.2.</span> <span class="toc-text">信号量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E7%B1%BB%E6%AF%94%E7%A4%BA%E4%BE%8B"><span class="toc-number">10.7.0.3.</span> <span class="toc-text">信号量的类比示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E7%89%B9%E6%80%A7"><span class="toc-number">10.7.0.4.</span> <span class="toc-text">信号量的特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E5%8F%91%E5%B1%95"><span class="toc-number">10.7.0.5.</span> <span class="toc-text">信号量的发展</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%B0%E5%BD%95%E5%9E%8B%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">10.7.0.6.</span> <span class="toc-text">记录型信号量的实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E5%88%86%E7%B1%BB%E5%92%8C%E4%BD%BF%E7%94%A8"><span class="toc-number">10.7.0.7.</span> <span class="toc-text">信号量的分类和使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%AE%9E%E7%8E%B0%E4%B8%B4%E7%95%8C%E5%8C%BA%E7%9A%84%E4%BA%92%E6%96%A5%E8%AE%BF%E9%97%AE"><span class="toc-number">10.7.0.8.</span> <span class="toc-text">信号量实现临界区的互斥访问</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%AE%9E%E7%8E%B0%E6%9D%A1%E4%BB%B6%E5%90%8C%E6%AD%A5"><span class="toc-number">10.7.0.9.</span> <span class="toc-text">信号量实现条件同步</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98"><span class="toc-number">10.7.0.10.</span> <span class="toc-text">生产者-消费者问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E8%A7%A3%E5%86%B3%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98"><span class="toc-number">10.7.0.11.</span> <span class="toc-text">信号量解决生产者-消费者问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="toc-number">10.7.0.12.</span> <span class="toc-text">信号量的缺点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8%E3%80%81%E7%AE%A1%E7%A8%8B"><span class="toc-number">10.8.</span> <span class="toc-text">8、管程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95"><span class="toc-number">10.8.0.1.</span> <span class="toc-text">基本同步方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%A1%E7%A8%8B%EF%BC%88Moniter%EF%BC%89"><span class="toc-number">10.8.0.2.</span> <span class="toc-text">管程（Moniter）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%A1%E7%A8%8B%E7%9A%84%E7%BB%84%E6%88%90"><span class="toc-number">10.8.0.3.</span> <span class="toc-text">管程的组成</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%EF%BC%88Condition-Variable%EF%BC%89"><span class="toc-number">10.8.0.4.</span> <span class="toc-text">条件变量（Condition Variable）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%A1%E7%A8%8B%E8%A7%A3%E5%86%B3%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98"><span class="toc-number">10.8.0.5.</span> <span class="toc-text">管程解决生产者-消费者问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%A1%E7%A8%8B%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E7%9A%84%E9%87%8A%E6%94%BE%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-number">10.8.0.6.</span> <span class="toc-text">管程条件变量的释放处理方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Hansen%E7%AE%A1%E7%A8%8B%E4%B8%8EHoare%E7%AE%A1%E7%A8%8B"><span class="toc-number">10.8.0.7.</span> <span class="toc-text">Hansen管程与Hoare管程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9%E3%80%81%E5%93%B2%E5%AD%A6%E5%AE%B6%E5%B0%B1%E9%A4%90%E9%97%AE%E9%A2%98"><span class="toc-number">10.9.</span> <span class="toc-text">9、哲学家就餐问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0"><span class="toc-number">10.9.0.1.</span> <span class="toc-text">问题描述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%A1%88%E4%B8%80"><span class="toc-number">10.9.0.2.</span> <span class="toc-text">方案一</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%A1%88%E4%BA%8C-%E4%BF%A1%E5%8F%B7%E9%87%8F%E4%BA%92%E6%96%A5%E8%AE%BF%E9%97%AE"><span class="toc-number">10.9.0.3.</span> <span class="toc-text">方案二::信号量互斥访问</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%A1%88%E4%B8%89"><span class="toc-number">10.9.0.4.</span> <span class="toc-text">方案三</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10%E3%80%81%E8%AF%BB%E8%80%85-%E5%86%99%E8%80%85%E9%97%AE%E9%A2%98"><span class="toc-number">10.10.</span> <span class="toc-text">10、读者-写者问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0-1"><span class="toc-number">10.10.0.1.</span> <span class="toc-text">问题描述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E8%A7%A3%E5%86%B3%E8%AF%BB%E8%80%85-%E5%86%99%E8%80%85%E9%97%AE%E9%A2%98"><span class="toc-number">10.10.0.2.</span> <span class="toc-text">信号量解决读者-写者问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E7%AD%96%E7%95%A5"><span class="toc-number">10.10.0.3.</span> <span class="toc-text">优先策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E7%AE%A1%E7%A8%8B%E8%A7%A3%E5%86%B3%E8%AF%BB%E8%80%85-%E5%86%99%E8%80%85%E9%97%AE%E9%A2%98"><span class="toc-number">10.10.0.4.</span> <span class="toc-text">用管程解决读者-写者问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E8%AF%A6%E7%BB%86%EF%BC%9A%E8%AF%BB%E8%80%85"><span class="toc-number">10.10.0.5.</span> <span class="toc-text">解决方案详细：读者</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E8%AF%A6%E7%BB%86%EF%BC%9A%E5%86%99%E8%80%85"><span class="toc-number">10.10.0.6.</span> <span class="toc-text">解决方案详细：写者</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E4%B8%80%E3%80%81%E6%AD%BB%E9%94%81"><span class="toc-number">11.</span> <span class="toc-text">十一、死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E6%AD%BB%E9%94%81%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">11.1.</span> <span class="toc-text">1、死锁的概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%BB%E9%94%81"><span class="toc-number">11.1.0.1.</span> <span class="toc-text">死锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E5%AE%9E%E4%BE%8B%EF%BC%9A%E5%8D%95%E5%90%91%E9%80%9A%E8%A1%8C%E6%A1%A5%E6%A2%81"><span class="toc-number">11.1.0.2.</span> <span class="toc-text">死锁实例：单向通行桥梁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E8%AE%BF%E9%97%AE%E8%B5%84%E6%BA%90%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="toc-number">11.1.0.3.</span> <span class="toc-text">进程访问资源的流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B5%84%E6%BA%90%E5%88%86%E7%B1%BB"><span class="toc-number">11.1.0.4.</span> <span class="toc-text">资源分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E5%9B%BE"><span class="toc-number">11.1.0.5.</span> <span class="toc-text">资源分配图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BA%E7%8E%B0%E6%AD%BB%E9%94%81%E7%9A%84%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6"><span class="toc-number">11.1.0.6.</span> <span class="toc-text">出现死锁的必要条件</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E6%AD%BB%E9%94%81%E5%A4%84%E7%90%86%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">11.2.</span> <span class="toc-text">2、死锁处理的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E5%A4%84%E7%90%86%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">11.2.0.1.</span> <span class="toc-text">死锁处理的方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E9%A2%84%E9%98%B2%EF%BC%9A%E9%99%90%E5%88%B6%E7%94%B3%E8%AF%B7%E6%96%B9%E5%BC%8F"><span class="toc-number">11.2.0.2.</span> <span class="toc-text">死锁预防：限制申请方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E9%81%BF%E5%85%8D"><span class="toc-number">11.2.0.3.</span> <span class="toc-text">死锁避免</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E8%B5%84%E6%BA%90%E7%9A%84%E5%AE%89%E5%85%A8%E7%8A%B6%E6%80%81"><span class="toc-number">11.2.0.4.</span> <span class="toc-text">资源分配资源的安全状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E7%8A%B6%E6%80%81%E4%B8%8E%E6%AD%BB%E9%94%81%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">11.2.0.5.</span> <span class="toc-text">安全状态与死锁的关系</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95%EF%BC%88Banker-96-s-Alogrithm%EF%BC%89"><span class="toc-number">11.3.</span> <span class="toc-text">3、银行家算法（Banker&#96;s  Alogrithm）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95%E6%A6%82%E8%BF%B0"><span class="toc-number">11.3.0.1.</span> <span class="toc-text">银行家算法概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">11.3.0.2.</span> <span class="toc-text">银行家算法：数据结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95%EF%BC%9A%E5%AE%89%E5%85%A8%E7%8A%B6%E6%80%81%E5%88%A4%E6%96%AD"><span class="toc-number">11.3.0.3.</span> <span class="toc-text">银行家算法：安全状态判断</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95"><span class="toc-number">11.3.0.4.</span> <span class="toc-text">银行家算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95%E5%AE%89%E5%85%A8%E7%8A%B6%E6%80%81%E5%88%A4%E6%96%AD%E7%A4%BA%E4%BE%8B"><span class="toc-number">11.3.0.5.</span> <span class="toc-text">银行家算法安全状态判断示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95%E5%AE%89%E5%85%A8%E7%8A%B6%E6%80%81%E5%88%A4%E6%96%AD%E7%A4%BA%E4%BE%8B2"><span class="toc-number">11.3.0.6.</span> <span class="toc-text">银行家算法安全状态判断示例2</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B"><span class="toc-number">11.4.</span> <span class="toc-text">4、死锁检测</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B"><span class="toc-number">11.4.0.1.</span> <span class="toc-text">死锁检测</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">11.4.0.2.</span> <span class="toc-text">死锁检测算法：数据结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95"><span class="toc-number">11.4.0.3.</span> <span class="toc-text">死锁检测算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B%E7%A4%BA%E4%BE%8B1"><span class="toc-number">11.4.0.4.</span> <span class="toc-text">死锁检测示例1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B%E7%A4%BA%E4%BE%8B2"><span class="toc-number">11.4.0.5.</span> <span class="toc-text">死锁检测示例2</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">11.4.0.6.</span> <span class="toc-text">死锁检测算法的使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E6%81%A2%E5%A4%8D%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%BB%88%E6%AD%A2"><span class="toc-number">11.4.0.7.</span> <span class="toc-text">死锁恢复：进程终止</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E6%81%A2%E5%A4%8D%EF%BC%9A%E8%B5%84%E6%BA%90%E6%8A%A2%E5%8D%A0"><span class="toc-number">11.4.0.8.</span> <span class="toc-text">死锁恢复：资源抢占</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E6%A6%82%E5%BF%B5"><span class="toc-number">11.5.</span> <span class="toc-text">5、进程通信概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%EF%BC%88IPC-Inter-Process-Communication%EF%BC%89"><span class="toc-number">11.5.0.1.</span> <span class="toc-text">进程通信（IPC,Inter-Process Communication）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F"><span class="toc-number">11.5.0.2.</span> <span class="toc-text">通信方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E9%80%9A%E4%BF%A1"><span class="toc-number">11.5.0.3.</span> <span class="toc-text">直接通信</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%B4%E6%8E%A5%E9%80%9A%E4%BF%A1"><span class="toc-number">11.5.0.4.</span> <span class="toc-text">间接通信</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%BB%E5%A1%9E%E5%92%8C%E9%9D%9E%E9%98%BB%E5%A1%9E%E9%80%9A%E4%BF%A1"><span class="toc-number">11.5.0.5.</span> <span class="toc-text">阻塞和非阻塞通信</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E4%BF%A1%E9%93%BE%E8%B7%AF%E7%BC%93%E5%86%B2"><span class="toc-number">11.5.0.6.</span> <span class="toc-text">通信链路缓冲</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81%E4%BF%A1%E5%8F%B7%E5%92%8C%E7%AE%A1%E9%81%93"><span class="toc-number">11.6.</span> <span class="toc-text">6、信号和管道</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%EF%BC%88Signal%EF%BC%89"><span class="toc-number">11.6.0.1.</span> <span class="toc-text">信号（Signal）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">11.6.0.2.</span> <span class="toc-text">信号的实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%A1%E9%81%93%EF%BC%88pip%EF%BC%89"><span class="toc-number">11.6.0.3.</span> <span class="toc-text">管道（pip）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8E%E7%AE%A1%E9%81%93%E7%9B%B8%E5%85%B3%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">11.6.0.4.</span> <span class="toc-text">与管道相关的系统调用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%A1%E9%81%93%E7%A4%BA%E4%BE%8B"><span class="toc-number">11.6.0.5.</span> <span class="toc-text">管道示例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%92%8C%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98"><span class="toc-number">11.7.</span> <span class="toc-text">7、消息队列和共享内存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-number">11.7.0.1.</span> <span class="toc-text">消息队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">11.7.0.2.</span> <span class="toc-text">消息队列的系统调用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98"><span class="toc-number">11.7.0.3.</span> <span class="toc-text">共享内存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E7%A4%BA%E4%BE%8B"><span class="toc-number">11.7.0.4.</span> <span class="toc-text">共享内存示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">11.7.0.5.</span> <span class="toc-text">共享内存系统调用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8%E3%80%81%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92%E7%B3%BB%E7%BB%9F%EF%BC%88Message-passing-system%EF%BC%89%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="toc-number">11.8.</span> <span class="toc-text">8、消息传递系统（Message passing system）（了解）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E4%BA%8C%E3%80%81%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">12.</span> <span class="toc-text">十二、文件系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">12.1.</span> <span class="toc-text">1、文件系统的概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%92%8C%E6%96%87%E4%BB%B6"><span class="toc-number">12.1.0.1.</span> <span class="toc-text">文件系统和文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="toc-number">12.1.0.2.</span> <span class="toc-text">文件系统的功能</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7"><span class="toc-number">12.1.0.3.</span> <span class="toc-text">文件属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6"><span class="toc-number">12.1.0.4.</span> <span class="toc-text">打开文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-number">12.1.0.5.</span> <span class="toc-text">文件描述符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E7%94%A8%E6%88%B7%E8%A7%86%E5%9B%BE%E5%92%8C%E7%B3%BB%E7%BB%9F%E8%A7%86%E5%9B%BE"><span class="toc-number">12.1.0.6.</span> <span class="toc-text">文件的用户视图和系统视图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E8%A7%86%E5%9B%BE%E5%88%B0%E7%B3%BB%E7%BB%9F%E8%A7%86%E5%9B%BE%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">12.1.0.7.</span> <span class="toc-text">用户视图到系统视图的转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E6%A8%A1%E5%BC%8F"><span class="toc-number">12.1.0.8.</span> <span class="toc-text">访问模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E6%96%87%E4%BB%B6%E7%A4%BA%E4%BE%8B"><span class="toc-number">12.1.0.9.</span> <span class="toc-text">索引文件示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84"><span class="toc-number">12.1.0.10.</span> <span class="toc-text">文件的内部结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB%E5%92%8C%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6"><span class="toc-number">12.1.0.11.</span> <span class="toc-text">文件共享和访问控制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%AD%E4%B9%89%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-number">12.1.0.12.</span> <span class="toc-text">语义一致性</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E7%9B%AE%E5%BD%95"><span class="toc-number">12.2.</span> <span class="toc-text">2、目录</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%B1%82%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">12.2.0.1.</span> <span class="toc-text">分层文件系统</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C"><span class="toc-number">12.2.0.2.</span> <span class="toc-text">目录操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95%E5%AE%9E%E7%8E%B0"><span class="toc-number">12.2.0.3.</span> <span class="toc-text">目录实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E6%96%87%E4%BB%B6%E5%88%AB%E5%90%8D"><span class="toc-number">12.3.</span> <span class="toc-text">3、文件别名</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E4%B8%AD%E7%9A%84%E5%BE%AA%E7%8E%AF"><span class="toc-number">12.3.0.1.</span> <span class="toc-text">文件目录中的循环</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8D%E5%AD%97%E8%A7%A3%E6%9E%90%EF%BC%88%E8%B7%AF%E5%BE%84%E9%81%8D%E5%8E%86%EF%BC%89"><span class="toc-number">12.3.0.2.</span> <span class="toc-text">名字解析（路径遍历）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%8C%82%E8%BD%BD"><span class="toc-number">12.3.0.3.</span> <span class="toc-text">文件系统挂载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%A7%8D%E7%B1%BB"><span class="toc-number">12.3.0.4.</span> <span class="toc-text">文件系统种类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C-x2F-%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">12.3.0.5.</span> <span class="toc-text">网络 &#x2F; 分布式文件系统</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">12.4.</span> <span class="toc-text">3、虚拟文件系统</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">12.4.0.1.</span> <span class="toc-text">文件系统的实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%EF%BC%88VFS%EF%BC%89"><span class="toc-number">12.4.0.2.</span> <span class="toc-text">虚拟文件系统（VFS）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">12.4.0.3.</span> <span class="toc-text">文件系统的基本数据结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BB%84%E7%BB%87%E8%A7%86%E5%9B%BE"><span class="toc-number">12.4.0.4.</span> <span class="toc-text">文件系统的组织视图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">12.4.0.5.</span> <span class="toc-text">文件系统的存储结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AD%98%E5%82%A8%E8%A7%86%E5%9B%BE"><span class="toc-number">12.4.0.6.</span> <span class="toc-text">文件系统的存储视图</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E6%96%87%E4%BB%B6%E7%BC%93%E5%AD%98%E5%92%8C%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6"><span class="toc-number">12.5.</span> <span class="toc-text">4、文件缓存和打开文件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E7%A7%8D%E7%A3%81%E7%9B%98%E7%BC%93%E5%AD%98%E7%9A%84%E4%BD%8D%E7%BD%AE"><span class="toc-number">12.5.0.1.</span> <span class="toc-text">多种磁盘缓存的位置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%9D%97%E7%BC%93%E5%AD%98"><span class="toc-number">12.5.0.2.</span> <span class="toc-text">数据块缓存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B5%E7%BC%93%E5%AD%98"><span class="toc-number">12.5.0.3.</span> <span class="toc-text">页缓存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%B8%AD%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">12.5.0.4.</span> <span class="toc-text">文件系统中打开文件的数据结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6%E8%A1%A8"><span class="toc-number">12.5.0.5.</span> <span class="toc-text">打开文件表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6%E9%94%81"><span class="toc-number">12.5.0.6.</span> <span class="toc-text">打开文件锁</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81%E6%96%87%E4%BB%B6%E5%88%86%E9%85%8D"><span class="toc-number">12.6.</span> <span class="toc-text">5、文件分配</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%A4%A7%E5%B0%8F"><span class="toc-number">12.6.0.1.</span> <span class="toc-text">文件大小</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%88%86%E9%85%8D"><span class="toc-number">12.6.0.2.</span> <span class="toc-text">文件分配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D"><span class="toc-number">12.6.0.3.</span> <span class="toc-text">连续分配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%93%BE%E5%BC%8F%E5%88%86%E9%85%8D"><span class="toc-number">12.6.0.4.</span> <span class="toc-text">链式分配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%88%86%E9%85%8D"><span class="toc-number">12.6.0.5.</span> <span class="toc-text">索引分配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%A7%E6%96%87%E4%BB%B6%E7%9A%84%E7%B4%A2%E5%BC%95%E5%88%86%E9%85%8D"><span class="toc-number">12.6.0.6.</span> <span class="toc-text">大文件的索引分配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#UFS-Unix-File-System-%E5%A4%9A%E7%BA%A7%E7%B4%A2%E5%BC%95%E5%88%86%E9%85%8D"><span class="toc-number">12.6.0.7.</span> <span class="toc-text">UFS(Unix File System)多级索引分配</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81%E7%A9%BA%E9%97%B2%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86"><span class="toc-number">12.7.</span> <span class="toc-text">6、空闲空间管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A9%BA%E9%97%B2%E7%A9%BA%E9%97%B4%E7%BB%84%E7%BB%87%EF%BC%9A%E4%BD%8D%E5%9B%BE"><span class="toc-number">12.7.0.1.</span> <span class="toc-text">空闲空间组织：位图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E7%A9%BA%E9%97%B2%E7%A9%BA%E9%97%B4%E7%BB%84%E7%BB%87%E6%96%B9%E5%BC%8F"><span class="toc-number">12.7.0.2.</span> <span class="toc-text">其他空闲空间组织方式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81%E5%86%97%E4%BD%99%E7%A3%81%E7%9B%98%E9%98%B5%E5%88%97RAID"><span class="toc-number">12.8.</span> <span class="toc-text">7、冗余磁盘阵列RAID</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA"><span class="toc-number">12.8.0.1.</span> <span class="toc-text">磁盘分区</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B8%E5%9E%8B%E7%9A%84%E7%A3%81%E7%9B%98%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%BB%84%E7%BB%87"><span class="toc-number">12.8.0.2.</span> <span class="toc-text">典型的磁盘文件系统组织</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86"><span class="toc-number">12.8.0.3.</span> <span class="toc-text">多磁盘管理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RAID-0%EF%BC%9A%E7%A3%81%E7%9B%98%E6%9D%A1%E5%B8%A6%E5%8C%96"><span class="toc-number">12.8.0.4.</span> <span class="toc-text">RAID-0：磁盘条带化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RAID-1%EF%BC%9A%E7%A3%81%E7%9B%98%E9%95%9C%E5%83%8F"><span class="toc-number">12.8.0.5.</span> <span class="toc-text">RAID-1：磁盘镜像</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RAID-4%EF%BC%9A%E5%B8%A6%E6%A0%A1%E9%AA%8C%E7%9A%84%E7%A3%81%E7%9B%98%E6%9D%A1%E5%B8%A6%E5%8C%96"><span class="toc-number">12.8.0.6.</span> <span class="toc-text">RAID-4：带校验的磁盘条带化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RAID-5%EF%BC%9A%E5%B8%A6%E5%88%86%E5%B8%83%E5%BC%8F%E6%A0%A1%E9%AA%8C%E7%9A%84%E7%A3%81%E7%9B%98%E6%9D%A1%E5%B8%A6%E5%8C%96"><span class="toc-number">12.8.1.</span> <span class="toc-text">RAID-5：带分布式校验的磁盘条带化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E4%BD%8D%E5%92%8C%E5%9F%BA%E4%BA%8E%E5%9D%97%E7%9A%84%E7%A3%81%E7%9B%98%E6%9D%A1%E5%B8%A6%E5%8C%96"><span class="toc-number">12.8.1.1.</span> <span class="toc-text">基于位和基于块的磁盘条带化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E7%BA%A0%E6%AD%A3%E5%A4%9A%E4%B8%AA%E7%A3%81%E7%9B%98%E9%94%99%E8%AF%AF%E7%9A%84%E5%86%97%E4%BD%99%E7%A3%81%E7%9B%98%E9%98%B5%E5%88%97"><span class="toc-number">12.8.1.2.</span> <span class="toc-text">可纠正多个磁盘错误的冗余磁盘阵列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RAID%E5%B5%8C%E5%A5%97"><span class="toc-number">12.8.1.3.</span> <span class="toc-text">RAID嵌套</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E4%B8%89%E3%80%81I-x2F-O%E7%B3%BB%E7%BB%9F"><span class="toc-number">13.</span> <span class="toc-text">十三、I&#x2F;O系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81I-x2F-O%E7%89%B9%E7%82%B9"><span class="toc-number">13.1.</span> <span class="toc-text">1、I&#x2F;O特点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84%E8%AE%BE%E5%A4%87%E6%8E%A5%E5%8F%A3%E7%B1%BB%E5%9E%8B"><span class="toc-number">13.1.0.1.</span> <span class="toc-text">三种常见的设备接口类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E8%AE%BF%E9%97%AE%E7%89%B9%E5%BE%81"><span class="toc-number">13.1.0.2.</span> <span class="toc-text">设备访问特征</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%BB%E5%A1%9EI-x2F-O%EF%BC%9AWait"><span class="toc-number">13.1.0.3.</span> <span class="toc-text">阻塞I&#x2F;O：Wait</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%9E%E9%98%BB%E5%A1%9EI-x2F-O%EF%BC%9ADont-Wait"><span class="toc-number">13.1.0.4.</span> <span class="toc-text">非阻塞I&#x2F;O：Dont Wait</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5I-x2F-O-%E2%80%9CTell-Me-Later%E2%80%9C"><span class="toc-number">13.1.0.5.</span> <span class="toc-text">异步I&#x2F;O:“Tell Me Later“</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81I-x2F-O%E7%BB%93%E6%9E%84"><span class="toc-number">13.2.</span> <span class="toc-text">2、I&#x2F;O结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E5%AE%9E%E9%99%85%E4%BE%8B%E5%AD%90"><span class="toc-number">13.2.0.1.</span> <span class="toc-text">一个实际例子</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CPU%E4%B8%8E%E8%AE%BE%E5%A4%87%E8%BF%9E%E6%8E%A5"><span class="toc-number">13.2.0.2.</span> <span class="toc-text">CPU与设备连接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#I-x2F-O%E6%8C%87%E4%BB%A4"><span class="toc-number">13.2.0.3.</span> <span class="toc-text">I&#x2F;O指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84I-x2F-O"><span class="toc-number">13.2.0.4.</span> <span class="toc-text">内存映射I&#x2F;O</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E6%A0%B8I-x2F-O%E7%BB%93%E6%9E%84"><span class="toc-number">13.2.0.5.</span> <span class="toc-text">内核I&#x2F;O结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#I-x2F-O%E8%AF%B7%E6%B1%82%E7%9A%84%E7%94%9F%E5%AD%98%E5%91%A8%E6%9C%9F"><span class="toc-number">13.2.0.6.</span> <span class="toc-text">I&#x2F;O请求的生存周期</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81I-x2F-O%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93"><span class="toc-number">13.3.</span> <span class="toc-text">3、I&#x2F;O数据传输</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#CPU%E4%B8%8E%E8%AE%BE%E5%A4%87%E6%8E%A7%E5%88%B6%E5%99%A8%E7%9A%84%E8%AE%BE%E5%A4%87%E4%BC%A0%E8%BE%93"><span class="toc-number">13.3.0.1.</span> <span class="toc-text">CPU与设备控制器的设备传输</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E7%9B%B4%E6%8E%A5I-x2F-O%E5%AF%BB%E5%9D%80%E8%AF%BB%E5%8F%96%E7%A3%81%E7%9B%98%E6%95%B0%E6%8D%AE%E7%9A%84%E6%AD%A5%E9%AA%A4"><span class="toc-number">13.3.0.2.</span> <span class="toc-text">通过直接I&#x2F;O寻址读取磁盘数据的步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#I-x2F-O%E8%AE%BE%E5%A4%87%E9%80%9A%E7%9F%A5%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%9C%BA%E5%88%B6"><span class="toc-number">13.3.0.3.</span> <span class="toc-text">I&#x2F;O设备通知操作系统的机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AE%E8%AF%A2"><span class="toc-number">13.3.0.4.</span> <span class="toc-text">轮询</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E4%B8%AD%E6%96%AD"><span class="toc-number">13.3.0.5.</span> <span class="toc-text">设备中断</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E4%B8%AD%E6%96%ADI-x2F-O%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B"><span class="toc-number">13.3.1.</span> <span class="toc-text">设备中断I&#x2F;O处理流程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6"><span class="toc-number">13.4.</span> <span class="toc-text">4、磁盘调度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6%E5%92%8C%E6%80%A7%E8%83%BD%E5%8F%82%E6%95%B0"><span class="toc-number">13.4.0.1.</span> <span class="toc-text">磁盘工作机制和性能参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A3%81%E7%9B%98I-x2F-O%E4%BC%A0%E8%BE%93%E6%97%B6%E9%97%B4"><span class="toc-number">13.4.0.2.</span> <span class="toc-text">磁盘I&#x2F;O传输时间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">13.4.0.3.</span> <span class="toc-text">磁盘调度算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%88%E8%BF%9B%E5%85%88%E5%87%BA%EF%BC%88FIFO%EF%BC%89%E7%AE%97%E6%B3%95"><span class="toc-number">13.4.0.4.</span> <span class="toc-text">先进先出（FIFO）算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#FIFO%E7%AE%97%E6%B3%95%E7%A4%BA%E4%BE%8B-1"><span class="toc-number">13.4.0.5.</span> <span class="toc-text">FIFO算法示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E7%9F%AD%E6%9C%8D%E5%8A%A1%E6%97%B6%E9%97%B4%E4%BC%98%E5%85%88%EF%BC%88SSTF%EF%BC%89"><span class="toc-number">13.4.0.6.</span> <span class="toc-text">最短服务时间优先（SSTF）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SSTF%E7%AE%97%E6%B3%95%E7%A4%BA%E4%BE%8B"><span class="toc-number">13.4.0.7.</span> <span class="toc-text">SSTF算法示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%AB%E9%9D%A2%E7%AE%97%E6%B3%95%EF%BC%88SCAN%EF%BC%89"><span class="toc-number">13.4.0.8.</span> <span class="toc-text">扫面算法（SCAN）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SCAN%E7%AE%97%E6%B3%95%E7%A4%BA%E4%BE%8B"><span class="toc-number">13.4.0.9.</span> <span class="toc-text">SCAN算法示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E6%89%AB%E6%8F%8F%E7%AE%97%E6%B3%95%EF%BC%88C-SCAN%EF%BC%89"><span class="toc-number">13.4.0.10.</span> <span class="toc-text">循环扫描算法（C-SCAN）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-LOOK%E7%AE%97%E6%B3%95"><span class="toc-number">13.4.0.11.</span> <span class="toc-text">C-LOOK算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#N%E6%AD%A5%E6%89%AB%E6%8F%8F%E7%AE%97%E6%B3%95%EF%BC%88N-Step-SCAN"><span class="toc-number">13.4.0.12.</span> <span class="toc-text">N步扫描算法（N-Step-SCAN)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E9%98%9F%E5%88%97%E6%89%AB%E6%8F%8F%E7%AE%97%E6%B3%95%EF%BC%88FSCAN%EF%BC%89"><span class="toc-number">13.4.0.13.</span> <span class="toc-text">双队列扫描算法（FSCAN）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E7%BC%93%E5%AD%98"><span class="toc-number">13.4.0.14.</span> <span class="toc-text">磁盘缓存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E7%BC%93%E5%AD%98%E5%92%8C%E5%8F%8C%E7%BC%93%E5%AD%98"><span class="toc-number">13.4.0.15.</span> <span class="toc-text">单缓存和双缓存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E9%A2%91%E7%8E%87%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%EF%BC%88Frequency-based-Replacement%EF%BC%89"><span class="toc-number">13.4.0.16.</span> <span class="toc-text">访问频率置换算法（Frequency-based-Replacement）</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Qinghai2021</div><div class="author-info__description">阳光宅男💛</div></div><div class="card-info-social-icons is-center"><a class="social-icon" href="//github.com/Qinghai2021?tab=repositories" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:xxxxxx@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">来的都是大哥！</div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/10/05/Java%E9%AB%98%E7%BA%A7-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-%E5%8F%8D%E5%B0%84-8%E6%96%B0%E7%89%B9%E6%80%A7/" title="Java网络编程-反射-8新特性">Java网络编程-反射-8新特性</a><time datetime="2022-10-04T16:00:00.000Z" title="发表于 2022-10-05 00:00:00">2022-10-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/10/04/Java%E9%AB%98%E7%BA%A7-%E9%9B%86%E5%90%88-%E6%B3%9B%E5%9E%8B-IO%E6%B5%81/" title="Java集合-泛型-IO流">Java集合-泛型-IO流</a><time datetime="2022-10-03T16:00:00.000Z" title="发表于 2022-10-04 00:00:00">2022-10-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/10/03/Java%E9%AB%98%E7%BA%A7-%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%B8%B8%E7%94%A8%E7%B1%BB-%E6%9E%9A%E4%B8%BE%E7%B1%BB%E4%B8%8E%E6%B3%A8%E8%A7%A3/" title="Java多线程-常用类-枚举类与注解">Java多线程-常用类-枚举类与注解</a><time datetime="2022-10-02T16:00:00.000Z" title="发表于 2022-10-03 00:00:00">2022-10-03</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/10/02/%E5%B0%9A%E7%A1%85%E8%B0%B7java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/" title="Java编程基础">Java编程基础</a><time datetime="2022-10-01T16:00:00.000Z" title="发表于 2022-10-02 00:00:00">2022-10-02</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/09/30/JavaWeb/" title="JavaWeb笔记">JavaWeb笔记</a><time datetime="2022-09-29T16:00:00.000Z" title="发表于 2022-09-30 00:00:00">2022-09-30</time></div></div></div></div></div></div></main><footer id="footer" style="background: #FFFFFF"><div id="footer-wrap"><div class="copyright">&copy;2022 By Qinghai2021</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/chenxz21/hexo-theme-bcxm">Bcxm</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://fastly.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><div class="js-pjax"></div><script type="text/javascript" src="https://fastly.jsdelivr.net/npm/leancloud-storage@4.10.0/dist/av-min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://fastly.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script id="click-heart" src="https://fastly.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>