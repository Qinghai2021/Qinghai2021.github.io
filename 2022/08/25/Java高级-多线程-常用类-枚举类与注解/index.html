<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>GitHub + Hexo + Node.js + Git搭建个人博客</title><meta name="author" content="Qinghai2021"><meta name="copyright" content="Qinghai2021"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Java 编程高级1.多线程1.基本概念1.程序程序(program)是为完成特定任务、用某种语言编写的一组指令的集合。即指一段静态的代码，静态对象。 2.进程 进程(process)是程序的一次执行过程，或是正在运行的一个程序。是一个动态的过程：有它自身的产生、存在和消亡的过程。——生命周期 如：运行中的QQ，运行中的MP3播放器 程序是静态的，进程是动态的 进程作为资源分配的单位，系统在运行时">
<meta property="og:type" content="article">
<meta property="og:title" content="GitHub + Hexo + Node.js + Git搭建个人博客">
<meta property="og:url" content="http://example.com/2022/08/25/Java%E9%AB%98%E7%BA%A7-%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%B8%B8%E7%94%A8%E7%B1%BB-%E6%9E%9A%E4%B8%BE%E7%B1%BB%E4%B8%8E%E6%B3%A8%E8%A7%A3/index.html">
<meta property="og:site_name" content="Qinghai2021·博客">
<meta property="og:description" content="Java 编程高级1.多线程1.基本概念1.程序程序(program)是为完成特定任务、用某种语言编写的一组指令的集合。即指一段静态的代码，静态对象。 2.进程 进程(process)是程序的一次执行过程，或是正在运行的一个程序。是一个动态的过程：有它自身的产生、存在和消亡的过程。——生命周期 如：运行中的QQ，运行中的MP3播放器 程序是静态的，进程是动态的 进程作为资源分配的单位，系统在运行时">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/images/background.jpg">
<meta property="article:published_time" content="2022-08-25T09:45:41.000Z">
<meta property="article:modified_time" content="2022-09-28T07:02:20.014Z">
<meta property="article:author" content="Qinghai2021">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/images/background.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2022/08/25/Java%E9%AB%98%E7%BA%A7-%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%B8%B8%E7%94%A8%E7%B1%BB-%E6%9E%9A%E4%B8%BE%E7%B1%BB%E4%B8%8E%E6%B3%A8%E8%A7%A3/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":500},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: Qinghai2021","link":"链接: ","source":"来源: Qinghai2021·博客","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://fastly.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://fastly.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'GitHub + Hexo + Node.js + Git搭建个人博客',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-09-28 15:02:20'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.2.0"><link rel="alternate" href="/atom.xml" title="Qinghai2021·博客" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Qinghai2021</div><div class="author-info__description">阳光宅男💛</div></div><div class="card-info-social-icons is-center"><a class="social-icon" href="//github.com/Qinghai2021?tab=repositories" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:xxxxxx@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-clock"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://www.bilibili.com/blackboard/fe/activity-HQjQSdd3L8.html"><i class="fa-fw fas fa-gamepad"></i><span> 游戏</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-tools"></i><span> 工具</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" target="_blank" rel="noopener" href="https://draw.xbyzs.cf"><span> Draw画布</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Qinghai2021·博客</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-clock"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://www.bilibili.com/blackboard/fe/activity-HQjQSdd3L8.html"><i class="fa-fw fas fa-gamepad"></i><span> 游戏</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-tools"></i><span> 工具</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" target="_blank" rel="noopener" href="https://draw.xbyzs.cf"><span> Draw画布</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">GitHub + Hexo + Node.js + Git搭建个人博客</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2022-08-25T09:45:41.000Z" title="发表于 2022-08-25 17:45:41">2022-08-25</time></span></div><div class="meta-secondline"></div></div></div><article class="post-content" id="article-container"><h1 id="Java-编程高级"><a href="#Java-编程高级" class="headerlink" title="Java 编程高级"></a>Java 编程高级</h1><h2 id="1-多线程"><a href="#1-多线程" class="headerlink" title="1.多线程"></a>1.多线程</h2><h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1.基本概念"></a>1.基本概念</h3><h4 id="1-程序"><a href="#1-程序" class="headerlink" title="1.程序"></a>1.程序</h4><p><strong>程序(program)是为完成特定任务、用某种语言编写的一组指令的集合</strong>。即指一段静态的代码，静态对象。</p>
<h4 id="2-进程"><a href="#2-进程" class="headerlink" title="2.进程"></a>2.进程</h4><ol>
<li>进程(process)是程序的一次执行过程，或是正在运行的一个程序。是一个动态的过程：有它自身的产生、存在和消亡的过程。——生命周期</li>
<li>如：运行中的QQ，运行中的MP3播放器</li>
<li>程序是静态的，进程是动态的</li>
<li>进程作为资源分配的单位，系统在运行时会为每个进程分配不同的内存区域</li>
</ol>
<h4 id="3-线程"><a href="#3-线程" class="headerlink" title="3.线程"></a>3.线程</h4><ol>
<li>线程(thread)，进程可进一步细化为线程，是<strong>一个程序内部的一条执行路径</strong>。</li>
<li>若<strong>一个进程同一时间并行执行多个线程</strong>，就是支持多线程的</li>
<li><strong>线程作为调度和执行的单位，每个线程拥有独立的运行栈和程序计数器(pc)，线程切换的开销小</strong> </li>
<li><strong>一个进程中的多个线程共享相同的内存单元&#x2F;内存地址空间它们从同一堆中分配对象，可以访问相同的变量和对象。</strong>这就使得线程间通信更简便、高效。但<strong>多个线程操作共享的系统资源可能就会带来安全的隐患。</strong></li>
</ol>
<p>内存结构：</p>
<p><strong>每个线程，拥有自己独立的：栈、程序计数器</strong></p>
<p><strong>多个线程，共享同一个进程中的结构：方法区、堆</strong></p>
<p><img src="/2022/08/25/Java%E9%AB%98%E7%BA%A7-%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%B8%B8%E7%94%A8%E7%B1%BB-%E6%9E%9A%E4%B8%BE%E7%B1%BB%E4%B8%8E%E6%B3%A8%E8%A7%A3/img%5CSnipaste_2022-01-10_13-24-41.png" alt="Snipaste_2022-01-10_13-24-41"></p>
<h4 id="4-单核和多核CPU理解"><a href="#4-单核和多核CPU理解" class="headerlink" title="4.单核和多核CPU理解"></a>4.单核和多核CPU理解</h4><ol>
<li><strong>单核CPU，其实是一种假的多线程</strong>，因为在一个时间单元内，也只能执行一个线程的任务。例如：一个干多份活，但是由于动作熟练和切换快速，使人感觉有好多人同时在干活</li>
<li>如果是多核的话，才能更好的发挥多线程的效率。（现在的服务器都是多核的）</li>
<li>一<strong>个Java应用程序java.exe，其实至少有三个线程：main()主线程，gc()垃圾回收线程，异常处理线程</strong>。当然如果发生异常，会影响主线程。</li>
</ol>
<h4 id="5-并行与并发"><a href="#5-并行与并发" class="headerlink" title="5.并行与并发"></a>5.并行与并发</h4><ol>
<li>并行：多个CPU同时执行多个任务。比如：多个人同时做不同的事。 </li>
<li>并发：一个CPU(采用时间片)同时执行多个任务。比如：秒杀、多个人做同一件事。</li>
</ol>
<h4 id="6-多线程程序的优点"><a href="#6-多线程程序的优点" class="headerlink" title="6.多线程程序的优点"></a>6.多线程程序的优点</h4><ol>
<li>提高应用程序的响应。对图形化界面更有意义，可增强用户体验。</li>
<li>提高计算机系统CPU的利用率</li>
<li>改善程序结构。将既长又复杂的进程分为多个线程，独立运行，利于理解和修改</li>
</ol>
<h4 id="7-何时需要多线程"><a href="#7-何时需要多线程" class="headerlink" title="7.何时需要多线程"></a>7.何时需要多线程</h4><ol>
<li>程序需要同时执行两个或多个任务。</li>
<li>程序需要实现一些需要等待的任务时，如用户输入、文件读写操作、网络操作、搜索等。</li>
<li>需要一些后台运行的程序时</li>
</ol>
<h3 id="2-多线程的创建和使用"><a href="#2-多线程的创建和使用" class="headerlink" title="2.多线程的创建和使用"></a>2.多线程的创建和使用</h3><h4 id="1-方式一："><a href="#1-方式一：" class="headerlink" title="1.方式一："></a>1.方式一：</h4><h5 id="1-继承于Thread类"><a href="#1-继承于Thread类" class="headerlink" title="1.继承于Thread类"></a>1.继承于Thread类</h5><ol>
<li>创建一个继承于Thread类的子类</li>
<li>重写Thread类的run() —&gt;将此线程执行的操作声明在run() 中</li>
<li>创建Thread类的子类的对象</li>
<li>通过此对象调用 start () 方法</li>
</ol>
<h5 id="2-代码演示"><a href="#2-代码演示" class="headerlink" title="2.代码演示"></a>2.代码演示</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123; <span class="comment">//创建一个继承于Thread类的子类</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;  <span class="comment">//重写Thread类的run() </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span> ; i&lt;<span class="number">100</span> ; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">fristCode</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">mt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(); <span class="comment">//创建Thread类的子类的对象</span></span><br><span class="line">        mt.start();通过此对象调用 start () 方法</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="3-问题"><a href="#3-问题" class="headerlink" title="3.问题"></a>3.问题</h5><ol>
<li><p>我们不能直接调用run() 的方式启动线程</p>
</li>
<li><p>每个线程对象只能调用一次，不可以再让已经start () 的线程去执行。会报错，我们需要重新创建一个线程的对象</p>
</li>
<li><p>&#96;&#96;&#96;java<br>MyThread mt &#x3D; new MyThread();<br>mt.start();<br>MyThread mv &#x3D; new MyThread();<br>mv.start();</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 2.创建Thread类的匿名子类的方式一</span><br><span class="line"></span><br><span class="line">继承于Thread类的方式去创建匿名子类</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">new Thread() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        for (int i = 0; i &lt; 100; i++) &#123;</span><br><span class="line">            if (i % 2 != 0) &#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.start();</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="3-Thread类中的常用方法"><a href="#3-Thread类中的常用方法" class="headerlink" title="3.Thread类中的常用方法"></a>3.Thread类中的常用方法</h4><ol>
<li><p>start ()：启动当前线程，调用当前线程的run()</p>
</li>
<li><p>run ()：通常需要重写Thread类中的此方法，将创建的线程要执行的操作声明在此方法中</p>
</li>
<li><p>currentThread() ：静态方法，返回执行当前代码的线程（在方法中调用）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//public static native Thread currentThread();</span></span><br><span class="line">Thread.currentThread()；</span><br><span class="line"><span class="comment">//在什么方法中调用就返回什么方法的线程</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>getName()：获取当前线程的名字</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span> ; i&lt;<span class="number">100</span> ; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">     <span class="comment">//三者是一样的 ，都是获取当前线程的名字 </span></span><br><span class="line">        <span class="comment">//System.out.println(Thread.currentThread().getName());             			 	          //System.out.println(getName());</span></span><br><span class="line">        System.out.println(<span class="built_in">this</span>.getName());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>setName()：设置当前线程的名字</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">fristCode</span> &#123;</span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">   </span><br><span class="line">           Thread.currentThread().setName(<span class="string">&quot;主线程&quot;</span>);  System.out.println(Thread.currentThread().getName());</span><br><span class="line">   </span><br><span class="line">           <span class="type">MyThread</span> <span class="variable">mt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">           mt.setName(<span class="string">&quot;线程一&quot;</span>);</span><br><span class="line">           System.out.println( mt.getName());</span><br><span class="line"></span><br><span class="line"><span class="number">6.</span> yield()：释放当前CPU的执行权，（释放执行权后cup会重新分配执行任务）</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span> ; i&lt;<span class="number">100</span> ; i++)&#123;</span><br><span class="line">       <span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">           System.out.println(i);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(i==<span class="number">20</span>)&#123;</span><br><span class="line">           yield();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>join()：在线程 a 中调用线程 b . join() ，此时线程a 就进入阻塞状态 ，直到线程b完全执行完以后，线程a才结束阻塞</p>
<p>会报错   ； 有形参 join(1000) 遇到此方法的其他线程要等待该方法的主人1000毫秒</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//在主方法中</span></span><br><span class="line"> <span class="type">MyThread</span> <span class="variable">mt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line"> mt.start(); <span class="comment">//此时有mt线程和main线程同时在跑</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">     System.out.println(<span class="string">&quot;主方法&quot;</span> + i);</span><br><span class="line">     <span class="keyword">if</span> (i == <span class="number">30</span>) &#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             mt.join();  <span class="comment">//mt.join()放在main()相当于main线程会碰到（调用）之后等mt线程结束之后才开启</span></span><br><span class="line">         &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">             e.printStackTrace();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> <span class="comment">//在run中</span></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span> ; i&lt;<span class="number">100</span> ; i++)&#123;</span><br><span class="line">     <span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">         System.out.println(i);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span>(i==<span class="number">20</span>)&#123;<span class="comment">//20处停止，执行别的线程</span></span><br><span class="line">         <span class="keyword">try</span> &#123;<span class="comment">//由于join会报异常，所以解决异常</span></span><br><span class="line">             join();</span><br><span class="line">         &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">             e.printStackTrace();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<ol start="8">
<li><p>stop()：已过时。当执行此方法时，强制结束当前线程</p>
</li>
<li><p>sleep(long  millitime)：让当前线程“睡眠”指定的millitime毫秒。在指定的millitime 的毫秒时间内，当前线程是阻塞状态<br>例如：限流、降低网页加载速度</p>
</li>
<li><p>isAlive()：判断当前线程是否存活–（返回boolean类型）</p>
</li>
</ol>
<h4 id="4-线程的优先级"><a href="#4-线程的优先级" class="headerlink" title="4.线程的优先级"></a>4.线程的优先级</h4><ol>
<li><p>MAX_PRIORITY  :  10</p>
</li>
<li><p>MIN_PRIORITY   :   1</p>
</li>
<li><p>NORM_PRIORITY  :  5—&gt;默认优先级</p>
</li>
<li><p>如何获取和设置当前线程的优先级：</p>
<p>getPriority( ) : 获取线程的优先级</p>
<p>setPriority ( ) : 设置线程的优先级</p>
</li>
<li><p>说明</p>
<p><strong>高优先级的线程只是抢到CPU执行权的概率上高，不意味着低优先级不能执行在高优先级之前</strong></p>
</li>
<li><p>&#96;&#96;&#96;java<br>HelloThread h1 &#x3D; new HelloThread();<br>    h1.setName(“线程一”);<br>    &#x2F;&#x2F;设置分线程的优先级<br>    h1.setPriority(Thread.MAX_PRIORITY);<br>    h1.start();<br><br>    &#x2F;&#x2F;给主线程命名<br>    Thread.currentThread().setName(“主线程”);  Thread.currentThread().setPriority(Thread.MIN_PRIORITY);</p>
</li>
</ol>
<h4 id="5-方式二"><a href="#5-方式二" class="headerlink" title="5.方式二"></a>5.方式二</h4><h5 id="1-实现Runnable-接口"><a href="#1-实现Runnable-接口" class="headerlink" title="1.实现Runnable( ) 接口"></a>1.实现Runnable( ) 接口</h5><ol>
<li><p>创建一个实现类Runnable接口的类</p>
</li>
<li><p>实现类去实现Runnable 中的抽象方法：run（）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建实现类的对象</p>
</li>
<li><p>将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//底层代码</span></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Thread</span><span class="params">(Runnable target)</span> &#123;</span><br><span class="line">       init(<span class="literal">null</span>, target, <span class="string">&quot;Thread-&quot;</span> + nextThreadNum(), <span class="number">0</span>);</span><br><span class="line">&#125;<span class="comment">//将实现类的对象传给Runnable类型的target，因为可以传递实现类的对象--多态性</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>通过Thread类的对象调用start （）</p>
<p>这个在去调用target . run（），此run是实现重写的（private Runnable target;）</p>
</li>
</ol>
<h5 id="2-代码演示-1"><a href="#2-代码演示-1" class="headerlink" title="2.代码演示"></a>2.代码演示</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 创建一个实现了Runnable接口的类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 实现类去实现Runnable中的抽象方法：run()</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//3. 创建实现类的对象</span></span><br><span class="line">        <span class="type">MThread</span> <span class="variable">mThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MThread</span>();</span><br><span class="line">        <span class="comment">//4. 将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(mThread);</span><br><span class="line">        t1.setName(<span class="string">&quot;线程1&quot;</span>);</span><br><span class="line">        <span class="comment">//5. 通过Thread类的对象调用start():① 启动线程 ②调用当前线程的run()--&gt;调用了Runnable类型的target的run()</span></span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//再启动一个线程，遍历100以内的偶数</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(mThread);</span><br><span class="line">        t2.setName(<span class="string">&quot;线程2&quot;</span>);</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-方式二好处"><a href="#3-方式二好处" class="headerlink" title="3.方式二好处"></a>3.方式二好处</h5><p>只需要创建一次实现类的对象，可以创建多个线程的对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Window1</span> <span class="variable">w</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Window1</span>();</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(w);</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(w);</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(w);</span><br><span class="line"></span><br><span class="line">t1.setName(<span class="string">&quot;窗口1&quot;</span>);</span><br><span class="line">t2.setName(<span class="string">&quot;窗口2&quot;</span>);</span><br><span class="line">t3.setName(<span class="string">&quot;窗口3&quot;</span>);</span><br><span class="line"></span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br><span class="line">t3.start();</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="6-创建Thread类的匿名子类的方式二"><a href="#6-创建Thread类的匿名子类的方式二" class="headerlink" title="6.创建Thread类的匿名子类的方式二"></a>6.创建Thread类的匿名子类的方式二</h4><p>实现Runnable接口的方式去创建匿名子类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>()&#123;<span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125; ).start();</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="7-比较两种方式"><a href="#7-比较两种方式" class="headerlink" title="7.比较两种方式"></a>7.比较两种方式</h4><p>比较创建线程的两种方式。</p>
<p><strong>开发中：优先选择：实现Runnable接口的方式</strong></p>
<p><strong>原因：</strong></p>
<ol>
<li><p>实现的方式没有类的单继承性的局限性  （实现方式：可以在去实现别的接口或继承父类。继承方式：只能继承一个，操作局限）</p>
</li>
<li><p>实现的方式更适合来处理多个线程有共享数据的情况。</p>
<p>Window w &#x3D; new Window();&#x2F;&#x2F; 只new一个实现类，下面都共用<br>Thread t1 &#x3D; new Thread(w);<br>Thread t2 &#x3D; new Thread(w);<br>Thread t3 &#x3D; new Thread(w);</p>
</li>
<li><p>卖票问题：继承方式：票得声明成static ，实现方式：票不用声明成static</p>
</li>
</ol>
<p><strong>两种方式的联系：</strong>public class Thread implements Runnable（<strong>都直接或间接的实现了Runnable接口</strong>）</p>
<p><strong>相同点：</strong>两种方式都需要重写run(),将线程要执行的逻辑声明在run()中。</p>
<p>​                  都是调用Thread类中start() 方法启动线程</p>
<h4 id="8-总结"><a href="#8-总结" class="headerlink" title="8.总结"></a>8.总结</h4><p>程序是一段静态的代码，进程是正在运行的程序（相对于程序是动态的），线程是进程中执行的任务（例如：360卫士，同时清理垃圾、扫描病毒、检测电脑）</p>
<p>在java程序中的线程，是通过Thread类去体现的：</p>
<ol>
<li>继承Thread</li>
<li>实现Runnable接口</li>
<li>Thread类也是通过实现了Runnable接口</li>
<li>都要重写Runnable接口中的run方法</li>
<li>都是调用Thread类中start() 方法启动线程</li>
<li>在Java代码运行中相当于只有一个CPU，去给每个线程不断分配执行权，所以可能两个操作无规律的交错进行</li>
</ol>
<h3 id="3-线程的生命周期"><a href="#3-线程的生命周期" class="headerlink" title="3.线程的生命周期"></a>3.线程的生命周期</h3><p><img src="/2022/08/25/Java%E9%AB%98%E7%BA%A7-%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%B8%B8%E7%94%A8%E7%B1%BB-%E6%9E%9A%E4%B8%BE%E7%B1%BB%E4%B8%8E%E6%B3%A8%E8%A7%A3/img%5CSnipaste_2022-01-23_15-11-45.png" alt="Snipaste_2022-01-23_15-11-45"></p>
<h3 id="4-线程的同步"><a href="#4-线程的同步" class="headerlink" title="4.线程的同步"></a>4.线程的同步</h3><h4 id="1-火车卖票问题"><a href="#1-火车卖票问题" class="headerlink" title="1.火车卖票问题"></a>1.火车卖票问题</h4><h5 id="1-引入例子："><a href="#1-引入例子：" class="headerlink" title="1.引入例子："></a>1.引入例子：</h5><p><strong>使用实现Runnable类的方式</strong>，创建三个窗口卖票，总票数为100张</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Windows</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">//Thread.sleep(100); --sleep会抛异常，写时得解决     System.out.println(Thread.currentThread().getName() + &quot;票号：&quot; + ticket);</span></span><br><span class="line">                ticket--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">sellTticket</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">Windows</span> <span class="variable">win</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Windows</span>();</span><br><span class="line"></span><br><span class="line">      <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(win);</span><br><span class="line">      <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(win);</span><br><span class="line">      <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(win);</span><br><span class="line">      t1.setName(<span class="string">&quot;窗口一&quot;</span>);</span><br><span class="line">      t2.setName(<span class="string">&quot;窗口二&quot;</span>);</span><br><span class="line">      t3.setName(<span class="string">&quot;窗口三&quot;</span>);</span><br><span class="line">      t1.start();</span><br><span class="line">      t2.start();</span><br><span class="line">      t3.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>使用继承于Thread类的方式</strong>，创建三个窗口卖票，总票数为100张</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WindowTwo</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">ticket1</span> <span class="operator">=</span> <span class="number">100</span>; <span class="comment">//为了保证多个窗口票数同步，使用static</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ticket1 &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;票号：&quot;</span> + ticket1);</span><br><span class="line">                ticket1--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">sellTticket</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">WindowTwo</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WindowTwo</span>();</span><br><span class="line">        <span class="type">WindowTwo</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WindowTwo</span>();</span><br><span class="line">        <span class="type">WindowTwo</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WindowTwo</span>();</span><br><span class="line"></span><br><span class="line">        t1.setName(<span class="string">&quot;窗口一&quot;</span>);</span><br><span class="line">        t2.setName(<span class="string">&quot;窗口二&quot;</span>);</span><br><span class="line">        t3.setName(<span class="string">&quot;窗口三&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="2-存在问题："><a href="#2-存在问题：" class="headerlink" title="2.存在问题："></a>2.存在问题：</h5><ol>
<li><p>问题：</p>
<ul>
<li><p><strong>卖票过程中，都出现重票、错票–&gt;出现了线程的安全问题</strong></p>
</li>
<li><p><strong>可以在卖票过程中加个阻塞，问题更加明显</strong></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">       <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">       Thread.sleep(<span class="number">100</span>); <span class="comment">//sleep会抛异常，写时得解决    System.out.println(Thread.currentThread().getName() + &quot;票号：&quot; + ticket);</span></span><br><span class="line">            ticket--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>出现问题的原因：当某个线程操作车票的过程中，尚未操作完成，其他线程参与进来，操作车票</p>
</li>
<li><p>如何解决：；当一个线程a在操作ticket的时候，其他线程不能参与进来。直到线程a操作完成ticket时，其他线程才可以开始操作，这种情况即使线程a出现了阻塞，也不能改变。（相当于给厕所装个锁）</p>
</li>
</ol>
<h4 id="2-解决问题方式一"><a href="#2-解决问题方式一" class="headerlink" title="2.解决问题方式一"></a>2.解决问题方式一</h4><h5 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h5><p>在Java中，我们通过同步机制，来解决线程的安全问题</p>
<p><strong>《方式一：同步代码块》</strong></p>
<p>synchronized (同步监视器){</p>
<p>&#x2F;&#x2F;需要被同步的代码—-<strong>不能多也不能少</strong></p>
<p><strong>包少：一些共享数据还是会出现线程安全问题</strong></p>
<p><strong>包多：首先单线程效率会变低，其次，例如：卖票问题，如果包了while(true),就会一个窗口把票都卖了，不满足题意</strong></p>
<p>}</p>
<p>说明：</p>
<ol>
<li><p>操作<strong>共享数据</strong>的代码，即为需要被同步的代码</p>
</li>
<li><p>共享数据：多个线程共同操作的变量。比如：ticket就是共享数据</p>
</li>
<li><p>同步监视器，俗称：锁。<strong>任何一个类的对象</strong>，都可以充当锁</p>
<p>要求：<strong>多个线程必须要共用同一把锁</strong>（不能声明在run方法）</p>
</li>
</ol>
<h5 id="2-解决实现类的卖票"><a href="#2-解决实现类的卖票" class="headerlink" title="2.解决实现类的卖票"></a>2.解决实现类的卖票</h5><p>该方式的问题通常在处理同步监视器，以及括号包含的需要被同步的代码上，不能多也不能少。</p>
<p>同步监视器：实现类可以直接使用this关键字充当当前对象，因为在main方法中只创建了一个该类的对象，所以多个线程使用的是同一个this。当然，也可以通过造一个对象在该类中</p>
<p>代码演示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span>  <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span> ( ) ;<span class="comment">//不能声明在方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;    </span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"><span class="comment">//    synchronized( obj )&#123;   //方式一 使用万能的obj</span></span><br><span class="line">    <span class="keyword">synchronized</span>( <span class="built_in">this</span> )&#123;   <span class="comment">//方式二  直接使用当前对象 this （不用在去new对象）</span></span><br><span class="line">        <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="comment">//Thread.sleep(100); --sleep会抛异常，写时得解决     System.out.println(Thread.currentThread().getName() + &quot;票号：&quot; + ticket);</span></span><br><span class="line">            ticket--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="3-解决继承Thread卖票"><a href="#3-解决继承Thread卖票" class="headerlink" title="3.解决继承Thread卖票"></a>3.解决继承Thread卖票</h5><p>因为其一个窗口造一个对象，使用造新对象的方式充当当前对象去作为同步监视器，该对象得声明成static类型的，这样多个窗口才能使用同一个对象</p>
<p>当然，<strong>也有不用造新对象的方法，直接用 “ 类名 . class ” 充当当前对象作为同步监视器 ，因为类只加载一次，也可以充当对象使用–即所有都是面向对象</strong></p>
<p>代码演示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Object <span class="type">static</span>  <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span> ( ) ;<span class="comment">//不能声明在方法，static的</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"><span class="comment">//    synchronized( obj )&#123;   //方式一  造object对象</span></span><br><span class="line"><span class="keyword">synchronized</span>( WindowTwo.class )&#123;   <span class="comment">//方式二  使用此类对象充当当前对象</span></span><br><span class="line"> <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="comment">//Thread.sleep(100); --sleep会抛异常，写时得解决     System.out.println(Thread.currentThread().getName() + &quot;票号：&quot; + ticket);</span></span><br><span class="line">  ticket--;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="3-解决问题方式二"><a href="#3-解决问题方式二" class="headerlink" title="3.解决问题方式二"></a>3.解决问题方式二</h4><h5 id="1-介绍-1"><a href="#1-介绍-1" class="headerlink" title="1.介绍"></a>1.介绍</h5><p>此方式为《同步方法》同样说明与《同步代码块》一样，也是使用的synchronized，也是得有共享数据。也是要求synchronized覆盖的括号内不能有代码不能多也不能少。</p>
<p>关于同步方法的总结：</p>
<ol>
<li><p><strong>同步方法仍然涉及到同步监视器</strong>，只是<strong>不需要我们显式的声明</strong></p>
</li>
<li><p><strong>非静态的同步方法，同步监视器是：this</strong></p>
<p><strong>静态的同步方法，同步监视器是：当前类本身</strong></p>
</li>
</ol>
<h5 id="2-解决实现类的卖票-1"><a href="#2-解决实现类的卖票-1" class="headerlink" title="2.解决实现类的卖票"></a>2.解决实现类的卖票</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//run中无多余代码-------使用非静态的同步方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">run</span> <span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//共享数据被操作的代码</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//如果run又包含了多余的代码，则需要将共享数据被操作的代码封装到另外的方法中，且在该方法声明使用时synchronized。然后在run中调用此方法。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">void</span>  <span class="title function_">run</span> <span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            show();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;<span class="comment">//同步监视器：this</span></span><br><span class="line"><span class="comment">//共享数据被操作的代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="2-解决继承Thread卖票"><a href="#2-解决继承Thread卖票" class="headerlink" title="2.解决继承Thread卖票"></a>2.解决继承Thread卖票</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//run中无多余代码-------使用静态的同步方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">run</span> <span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//共享数据被操作的代码</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果run又包含了多余的代码，则需要将共享数据被操作的代码封装到另外的方法中，且在该方法声明使用时synchronized。然后在run中调用此方法。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">void</span>  <span class="title function_">run</span> <span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            show();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;<span class="comment">//同步监视器：当前类本身</span></span><br><span class="line"><span class="comment">//共享数据被操作的代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="4-解决问题的利弊"><a href="#4-解决问题的利弊" class="headerlink" title="4.解决问题的利弊"></a>4.解决问题的利弊</h4><p>同步的方式，解决了线程的安全问题。—-好处</p>
<p>操作同步代码时，只能有一个线程参与，其他线程等待。相当于是一个单线程的过程，效率低——坏处</p>
<h4 id="5-在谈单例模式懒汉式"><a href="#5-在谈单例模式懒汉式" class="headerlink" title="5.在谈单例模式懒汉式"></a>5.在谈单例模式懒汉式</h4><p>由于面向对象（下）讲过单例模式的懒汉式，其中<strong>存在线程不安全问题，现在利用线程同步的解决不安全问题</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bank</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Bank</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Bank</span>  <span class="variable">instance</span>  <span class="operator">=</span> <span class="literal">null</span> ;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Bank <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Bank</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">//多个线程可能同时进入，造了多个对象</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>方式一同步代码块改进：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bank</span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Bank</span>  <span class="variable">instance</span>  <span class="operator">=</span> <span class="literal">null</span> ;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Bank</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">//第一种：效率稍低</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Bank <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">    	<span class="keyword">synchronized</span>(Bank.class)&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123; </span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Bank</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">//因为一个线程拿到锁后造了对象走了，其他线程还在等待，后再拿锁</span></span><br><span class="line">    </span><br><span class="line">     <span class="comment">//第二种：效率稍高</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> Bank <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">     	<span class="keyword">if</span>(instance == <span class="literal">null</span>)</span><br><span class="line">    	<span class="keyword">synchronized</span>(Bank.class)&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Bank</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;<span class="comment">//因为一个线程拿锁造对象走了，别的线程判断一下就走了，不用在等待拿锁</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方式二同步方法改进：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bank</span> &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Bank</span>  <span class="variable">instance</span>  <span class="operator">=</span> <span class="literal">null</span> ;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Bank</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Bank <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Bank</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h4 id="6-死锁问题"><a href="#6-死锁问题" class="headerlink" title="6.死锁问题"></a>6.死锁问题</h4><h5 id="1-介绍-2"><a href="#1-介绍-2" class="headerlink" title="1.介绍"></a>1.介绍</h5><p><strong>不同线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁</strong></p>
<h5 id="2-说明"><a href="#2-说明" class="headerlink" title="2.说明"></a>2.说明</h5><ol>
<li>出现死锁后，不会出现异常，不会出现提示，知识所有的线程都处于阻塞状态，无法继续</li>
<li>我们使用同步时，要避免出现死锁</li>
</ol>
<p>解决方法：</p>
<ol>
<li>专门的算法、原则</li>
<li><strong>尽量减少同步资源</strong>的定义</li>
<li><strong>尽量避免嵌套同步</strong></li>
</ol>
<p>代码演示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="type">Object</span> <span class="variable">obj2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(obj1)&#123;</span><br><span class="line">     <span class="comment">// 执行一些代码</span></span><br><span class="line">      <span class="keyword">synchronized</span>(obj2)&#123;  <span class="comment">//拿了1等2</span></span><br><span class="line">    <span class="comment">//    在执行一些代码</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.start();</span><br><span class="line"><span class="comment">//上面拿了obj1下面拿了obj2，接下来又嵌套了一层，且他们需要的锁相反，都在等待对方先给锁----这演示的是最简单的死锁--可以将一个锁封装为方法，调用</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>()&#123;<span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(obj2)&#123;</span><br><span class="line">      <span class="comment">//执行一些代码</span></span><br><span class="line">      <span class="keyword">synchronized</span>(obj1)&#123;  <span class="comment">//拿了2等1</span></span><br><span class="line">       <span class="comment">// 在执行一些代码</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; ).start();</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="7-解决问题方式三"><a href="#7-解决问题方式三" class="headerlink" title="7.解决问题方式三"></a>7.解决问题方式三</h4><p>解决线程安全问题的方式三：Lock锁—-JDK 5.0新增</p>
<ol>
<li><strong>实例化ReentrantLock(若是继承的方式，则实例化对象得是static的)</strong></li>
<li>调用锁定方法Lock( ) </li>
<li>调用解锁方法unlock</li>
</ol>
<p>代码演示：</p>
<p>下面实现类方式演示，(若是继承的方式，则实例化对象得是static的，为了使每个线程的Lock一样）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Window</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="comment">//实例化ReentrantLock</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>( );</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;    </span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"><span class="keyword">try</span>&#123;  <span class="comment">//用try包裹共享数据被操作的代码，最后用finally调用方法解锁</span></span><br><span class="line">	lock.lock();<span class="comment">//调用锁定方法Lock( ) </span></span><br><span class="line">    <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">//Thread.sleep(100); --sleep会抛异常，写时得解决     System.out.println(Thread.currentThread().getName() + &quot;票号：&quot; + ticket);</span></span><br><span class="line">              ticket--;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">     lock.unlock();<span class="comment">//调用解锁方法unlock</span></span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>面试题：</p>
<ol>
<li><p>synchronized 与Lock 的异同？</p>
<p>相同：二者都可以解决线程安全问题</p>
<p>不同：synchronized机制在执行完相应的同步代码以后，自动的释放同步锁</p>
<p>​            Lock 需要手动的启动同步（Lock( ) ），同时结束同步也需要手动释放</p>
</li>
<li><p>如何解决线程安全问题？有几种方式</p>
</li>
</ol>
<p><strong>优先使用顺序：</strong></p>
<p><strong>Lock —&gt; 同步代码块（已经进入了方法体，分配了相应资源）—&gt;同步方法</strong>                                                                                                                                                                                                                                                                                                                                        </p>
<h3 id="5-线程的通信"><a href="#5-线程的通信" class="headerlink" title="5.线程的通信"></a>5.线程的通信</h3><h4 id="1-介绍-3"><a href="#1-介绍-3" class="headerlink" title="1.介绍"></a>1.介绍</h4><ol>
<li>线程之间通信的两个基本问题是互斥和同步。</li>
<li>线程同步是指线程之间所具有的一种制约关系，<strong>一个线程的执行依赖另一个线程的消息</strong>，当它没有得到另一个线程的消息时应等待，直到消息到达时才被唤醒。</li>
<li>线程互斥是指对于共享的操作系统资源，在各线程访问时的排它性。当有若干个线程都要使用某一共享资源时，任何时刻最多只允许一个线程去使用，其它要使用该资源的线程必须等待，直到占用资源者释放该资源。</li>
</ol>
<h4 id="2-涉及三个方法"><a href="#2-涉及三个方法" class="headerlink" title="2.涉及三个方法"></a>2.涉及三个方法</h4><p>1.wati() :一旦执行此方法，当前<strong>线程就进入阻塞状态，并释放同步监视器</strong></p>
<p>2.notify() ：一旦执行此方法，就会<strong>唤醒被wait 的一个</strong>线程，如有多个线程被wait ，就唤醒优先级高的线程</p>
<p>3.notifyAll()：一旦执行此方法，就会<strong>唤醒所有</strong>被wait 的线程</p>
<p>说明：</p>
<ol>
<li><p>wait() 、notify()、notifyAll(<strong>) 三个方法必须使用在同步代码块中或同步方法中</strong></p>
</li>
<li><p>wait() 、notify()、notifyAll() 三个方法的<strong>调用者必须是同步代码块或同步方法中的同步监视器</strong>，否则，会出现IllegalMonitorStateExcption异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (<span class="built_in">this</span>)&#123;</span><br><span class="line"><span class="comment">//或synchronized (obj)</span></span><br><span class="line">    <span class="built_in">this</span>.notify();。</span><br><span class="line">  <span class="comment">//或  obj.wait();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>wait() 、notify()、notifyAll() 三个方法是定义在java.lang.Object类中</strong>（因为这三个方法只能在同步代码块或同步方法中使用，又同步监视器可以是任何的一个类，所以就将这三方法定义在Object类中）</p>
</li>
</ol>
<h4 id="3-sleep-和wait-的区别"><a href="#3-sleep-和wait-的区别" class="headerlink" title="3.sleep()和wait()的区别"></a>3.sleep()和wait()的区别</h4><ol>
<li>相同点：一旦执行方法，都可以使得当前的<strong>线程进入阻塞状态</strong></li>
<li>不同点：<ol>
<li><strong>两个方法声明的位置不同</strong>：sleep() 声明在Thread类中，wait() 声明在Object类中</li>
<li><strong>调用的要求不同</strong>：sleep() 可以在任何需要的场景下调用。wait() 必须在同步代码块或同步方法中</li>
<li><strong>关于是否释放同步监视器</strong>：如果两个方法都使用在同步代码块或同步方法中，sleep()不会释放锁，wait()会释放锁（同步监视器）。</li>
</ol>
</li>
</ol>
<h4 id="4-生产者和消费者例题"><a href="#4-生产者和消费者例题" class="headerlink" title="4.生产者和消费者例题"></a>4.生产者和消费者例题</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">线程通信的应用：经典例题：生产者/消费者问题</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 生产者(Productor)将产品交给店员(Clerk)，而消费者(Customer)从店员处取走产品，</span></span><br><span class="line"><span class="comment">* 店员一次只能持有固定数量的产品(比如:20），如果生产者试图生产更多的产品，店员</span></span><br><span class="line"><span class="comment">* 会叫生产者停一下，如果店中有空位放产品了再通知生产者继续生产；如果店中没有产品</span></span><br><span class="line"><span class="comment">* 了，店员会告诉消费者等一下，如果店中有产品了再通知消费者来取走产品。</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 分析：</span></span><br><span class="line"><span class="comment">* 1. 是否是多线程问题？是，生产者线程，消费者线程</span></span><br><span class="line"><span class="comment">* 2. 是否有共享数据？是，店员（或产品）</span></span><br><span class="line"><span class="comment">* 3. 如何解决线程的安全问题？同步机制,有三种方法</span></span><br><span class="line"><span class="comment">* 4. 是否涉及线程的通信？是</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>代码演示：</p>
<p>讲解：细节在于两者class Clerk中的两个方法。生产者消费者Clerk是同一个对象，使用同步方法解决线程安全问题，生产者消费者用的也是同一个同步监视器this，因此生产消费不会同时进行。</p>
<p>根据题目供给关系，产多不产，没了不卖。即当产品大于20，生产者被wait，释放锁。这时消费者拿锁，生产完后notify解锁一个生产者去生产，若生产速度等于消费速度，则会保持平衡</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Clerk</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">productCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//生产产品</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">produceProduct</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(productCount &lt; <span class="number">20</span>)&#123;</span><br><span class="line">            productCount++;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:开始生产第&quot;</span> + productCount + <span class="string">&quot;个产品&quot;</span>);</span><br><span class="line"></span><br><span class="line">            notify();</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//等待</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//消费产品</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">consumeProduct</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(productCount &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:开始消费第&quot;</span> + productCount + <span class="string">&quot;个产品&quot;</span>);</span><br><span class="line">            productCount--;</span><br><span class="line"></span><br><span class="line">            notify();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//等待</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Producer</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;<span class="comment">//生产者</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Clerk clerk;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Producer</span><span class="params">(Clerk clerk)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.clerk = clerk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(getName() + <span class="string">&quot;:开始生产产品.....&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            clerk.produceProduct();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Consumer</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;<span class="comment">//消费者</span></span><br><span class="line">    <span class="keyword">private</span> Clerk clerk;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Consumer</span><span class="params">(Clerk clerk)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.clerk = clerk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(getName() + <span class="string">&quot;:开始消费产品.....&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">20</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            clerk.consumeProduct();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Clerk</span> <span class="variable">clerk</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Clerk</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Producer</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Producer</span>(clerk);</span><br><span class="line">        p1.setName(<span class="string">&quot;生产者1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Consumer</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Consumer</span>(clerk);</span><br><span class="line">        c1.setName(<span class="string">&quot;消费者1&quot;</span>);</span><br><span class="line">        <span class="type">Consumer</span> <span class="variable">c2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Consumer</span>(clerk);</span><br><span class="line">        c2.setName(<span class="string">&quot;消费者2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        p1.start();</span><br><span class="line">        c1.start();</span><br><span class="line">        c2.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h4 id="5-会释放锁的操作"><a href="#5-会释放锁的操作" class="headerlink" title="5.会释放锁的操作"></a>5.会释放锁的操作</h4><p><img src="/2022/08/25/Java%E9%AB%98%E7%BA%A7-%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%B8%B8%E7%94%A8%E7%B1%BB-%E6%9E%9A%E4%B8%BE%E7%B1%BB%E4%B8%8E%E6%B3%A8%E8%A7%A3/img%5CSnipaste_2022-01-25_22-00-13.png" alt="Snipaste_2022-01-25_22-00-13"></p>
<h4 id="6-不会释放锁的操作"><a href="#6-不会释放锁的操作" class="headerlink" title="6.不会释放锁的操作"></a>6.不会释放锁的操作</h4><p><img src="/2022/08/25/Java%E9%AB%98%E7%BA%A7-%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%B8%B8%E7%94%A8%E7%B1%BB-%E6%9E%9A%E4%B8%BE%E7%B1%BB%E4%B8%8E%E6%B3%A8%E8%A7%A3/img%5CSnipaste_2022-01-25_22-00-23.png" alt="Snipaste_2022-01-25_22-00-23"></p>
<h3 id="6-创建线程的方式三"><a href="#6-创建线程的方式三" class="headerlink" title="6.创建线程的方式三"></a>6.创建线程的方式三</h3><h4 id="1-实现Callable接口"><a href="#1-实现Callable接口" class="headerlink" title="1.实现Callable接口"></a>1.实现Callable接口</h4><p>实现Callable接口。 — JDK 5.0新增</p>
<p>说明：</p>
<ol>
<li><p><strong>创建实现类实现Callable接口，并重写call方法</strong>（该方法返回值类型是Object，所以是可以返回任何类型，且是可以抛出异常的。）</p>
</li>
<li><p>new一个实现类对象，将实现类对象作为实参new一个FutureTask对象。</p>
</li>
<li><p>将FutureTask对象作为实参，new一个Thread来调用start()方法。（Thread构造器也是用Runnable类型接受的，实际上FutureTask也实现了Runnable接口）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">NumThread</span> <span class="variable">numThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NumThread</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">FutureTask</span> <span class="variable">futureTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FutureTask</span>(numThread);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask).start();</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="2-代码演示-2"><a href="#2-代码演示-2" class="headerlink" title="2.代码演示"></a>2.代码演示</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建一个实现Callable的实现类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NumThread</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&#123;</span><br><span class="line">    <span class="comment">//2.实现call方法，将此线程需要执行的操作声明在call()中</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadNew</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//3.创建Callable接口实现类的对象</span></span><br><span class="line">        <span class="type">NumThread</span> <span class="variable">numThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NumThread</span>();</span><br><span class="line">        <span class="comment">//4.将此Callable接口实现类的对象作为传递到FutureTask构造器中，创建FutureTask的对象</span></span><br><span class="line">        <span class="type">FutureTask</span> <span class="variable">futureTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FutureTask</span>(numThread);</span><br><span class="line">        <span class="comment">//5.将FutureTask的对象作为参数传递到Thread类的构造器中，创建Thread对象，并调用start()</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//6.获取Callable中call方法的返回值，如不想有返回值，可以在重写call方法时返回null。</span></span><br><span class="line">            <span class="comment">//get()返回值即为FutureTask构造器参数Callable实现类重写的call()的返回值。</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">sum</span> <span class="operator">=</span> futureTask.get();</span><br><span class="line">            System.out.println(<span class="string">&quot;总和为：&quot;</span> + sum);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="7-创建线程的方式四"><a href="#7-创建线程的方式四" class="headerlink" title="7.创建线程的方式四"></a>7.创建线程的方式四</h3><h4 id="1-线程池"><a href="#1-线程池" class="headerlink" title="1.线程池"></a>1.线程池</h4><p><strong>背景</strong>：经常创建和销毁、使用量特别大的资源，比如并发情况下的线程，</p>
<p>对性能影响很大。 </p>
<p><strong>思路</strong>：提前创建好多个线程，放入线程池中，使用时直接获取，使用完</p>
<p>放回池中。可以避免频繁创建销毁、实现重复利用。类似生活中的公共交</p>
<p>通工具。</p>
<p><strong>好处</strong>：</p>
<ol>
<li>提高响应速度（减少了创建新线程的时间）</li>
<li>降低资源消耗（重复利用线程池中线程，不需要每次都创建）</li>
<li>便于线程管理<ol>
<li>corePoolSize：核心池的大小</li>
<li>maximumPoolSize：最大线程数 </li>
<li>keepAliveTime：线程没有任务时最多保持多长时间后会终止</li>
</ol>
</li>
</ol>
<h4 id="2-说明："><a href="#2-说明：" class="headerlink" title="2.说明："></a>2.说明：</h4><p>1.创建线程池：提供指定线程数量的线程池</p>
<p>方式一：</p>
<ul>
<li>ThreadPoolExecutor service &#x3D; new ThreadPoolExecutor(CORE_POOL_SIZE)</li>
</ul>
<p>方式二：</p>
<ul>
<li><p>Executors 工具类，可以直接调用里面的静态方法（newFixedThreadPool）。返回值是ThreadPoolExecutor，它继承了AbstractExecutorService，这个类实现了ExecutorService接口</p>
</li>
<li><p>ExecutorService接口（execute()、submit()、shutdown()、shutdownNow()都是这个接口中的方法）</p>
</li>
</ul>
<ol start="2">
<li>向线程池提交任务（实现Runnable接口的run方法的类）–可提交多次</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">service.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;适合使用于Runnable</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    ... <span class="comment">// 线程执行的任务</span></span><br><span class="line">&#125;&#125;);</span><br><span class="line"> <span class="comment">//service.submit(Callable callable);//适合使用于Callable</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>3.关闭线程池</p>
<p>service.shutdown(); </p>
<ul>
<li><strong>设置线程池的状态为SHUTDOWN，然后中断所有没有正在执行任务的线程</strong></li>
</ul>
<p>service.shutdownNow(); </p>
<ul>
<li><strong>设置线程池的状态为 STOP，然后尝试停止所有的正在执行或暂停任务的线程，并返回等待执行任务的列表</strong></li>
</ul>
<h4 id="3-代码演示"><a href="#3-代码演示" class="headerlink" title="3.代码演示"></a>3.代码演示</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumberThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt;= <span class="number">100</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: &quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NumberThread1</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt;= <span class="number">100</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> != <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: &quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPool</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//1. 提供指定线程数量的线程池</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">service1</span> <span class="operator">=</span> (ThreadPoolExecutor) service;</span><br><span class="line">        <span class="comment">//设置线程池的属性</span></span><br><span class="line"><span class="comment">//        System.out.println(service.getClass());</span></span><br><span class="line"><span class="comment">//        service1.setCorePoolSize(15);</span></span><br><span class="line"><span class="comment">//        service1.setKeepAliveTime();</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.执行指定的线程的操作。需要提供实现Runnable接口或Callable接口实现类的对象</span></span><br><span class="line">        service.execute(<span class="keyword">new</span> <span class="title class_">NumberThread</span>());<span class="comment">//适合适用于Runnable</span></span><br><span class="line">        service.execute(<span class="keyword">new</span> <span class="title class_">NumberThread1</span>());<span class="comment">//适合适用于Runnable</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        service.submit(Callable callable);//适合使用于Callable</span></span><br><span class="line">        <span class="comment">//3.关闭连接池</span></span><br><span class="line">        service.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="2-常用类"><a href="#2-常用类" class="headerlink" title="2.常用类"></a>2.常用类</h2><h3 id="1-String"><a href="#1-String" class="headerlink" title="1.String"></a>1.String</h3><h4 id="1-String详细介绍"><a href="#1-String详细介绍" class="headerlink" title="1.String详细介绍"></a>1.String详细介绍</h4><ol>
<li><p>String:字符串，使用一对””引起来表示。</p>
</li>
<li><p>String声明为final的，不可被继承</p>
</li>
<li><p>String实现了Serializable接口：表示字符串是支持序列化的。</p>
<p>​          实现了Comparable接口：表示String可以比较大小</p>
</li>
<li><p>String内部定义了final char[] value用于存储字符串数据</p>
</li>
<li><p>String:代表不可变的字符序列。简称：不可变性。</p>
<p><strong>体现：</strong> </p>
<ol>
<li><p>当对字符串<strong>重新赋值</strong>时，<strong>需要重写指定内存区域赋值</strong>，不能使用原有的value进行赋值。</p>
<p>String s1 &#x3D; “abc”;   s1 &#x3D; “hello”;</p>
</li>
<li><p>当对现有的字符串进行<strong>连接操作</strong>时，也<strong>需要重新指定内存区域赋值</strong>，不能使用原有的value进行赋值。</p>
<p>String s3 &#x3D; “ wwe;   s3 +&#x3D;s1;</p>
</li>
<li><p>当调用String的replace()方法<strong>修改指定字符或字符串</strong>时，<strong>也需要重新指定内存区域赋值</strong>，不能使用原有的value进行赋值。  String s4 &#x3D; “abc”;  String s5 &#x3D; s4.replace(‘a’, ‘m’);&#x2F;&#x2F;左老右新</p>
</li>
</ol>
</li>
<li><p>通过<strong>字面量的方式（区别于new）</strong>给一个字符串赋值，此时的字符串值声明在字符串常量池中。（下结详细讲解）</p>
</li>
<li><p><strong>字符串常量池中是不会存储相同内容的字符串的（有复用性）</strong>。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;<span class="comment">//字面量的定义方式</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">System.out.println(s1 == s2); <span class="literal">true</span><span class="comment">//比较s1和s2的地址值</span></span><br><span class="line">s1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">System.out.println(s1 == s2); <span class="literal">false</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="2-String两种实例化区别"><a href="#2-String两种实例化区别" class="headerlink" title="2.String两种实例化区别"></a>2.String两种实例化区别</h4><p>String的实例化方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式一：通过字面量定义的方式</span></span><br><span class="line"><span class="type">String</span>  <span class="variable">s1</span>  <span class="operator">=</span>  <span class="string">&quot;javaEE &quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式二：通过new + 构造器的方式</span></span><br><span class="line"><span class="type">String</span>  <span class="variable">s3</span>  <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">String</span> ( <span class="string">&quot;javaEE &quot;</span> );</span><br></pre></td></tr></table></figure>

<p> 不同点：</p>
<ol>
<li>字面量定义的方式是在方法区常量池中开辟空间存放字符，<strong>栈空间中声明的对象直接指向常量池的字符串</strong></li>
<li>构造器方式是在方法区常量池中查找有无一样的字符串，没有则开辟新空间存放字符，栈空间指向堆中新造的对象实例，堆空间String类对象实例指向常量池中声明char数组存储的字符串</li>
</ol>
<p>相同点：<strong>字符都是存放在常量池中，只不过一个直接获取，一个是间接获取</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;java&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">System.out.print(str1==str2); <span class="comment">//false str1是常量池中字符串地址，str2是堆空间中对象实例的地址</span></span><br></pre></td></tr></table></figure>

<p><img src="/2022/08/25/Java%E9%AB%98%E7%BA%A7-%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%B8%B8%E7%94%A8%E7%B1%BB-%E6%9E%9A%E4%B8%BE%E7%B1%BB%E4%B8%8E%E6%B3%A8%E8%A7%A3/img%5CSnipaste_2022-01-26_10-21-28.png" alt="Snipaste_2022-01-26_10-21-28">面试题：</p>
<ol>
<li><p>面试题：String s &#x3D; new String(“abc”);方式创建对象，在内存中创建了几个对象？两个。一个是堆空间中new结构，另一个是char[]对应的常量池中的数据：”abc”</p>
</li>
<li><p><strong>引用数据类型通过值传递来改变本身数据，值传递传的是地址。但是对于String类型有不可变性，传递地址到形参，修改数据也只是在常量池新造的，原本的数据没有被修改</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">面试题：</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;good&quot;</span>);</span><br><span class="line">    <span class="type">char</span>[] ch = &#123; <span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;s&#x27;</span>, <span class="string">&#x27;t&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">(String str, <span class="type">char</span> ch[])</span> &#123;</span><br><span class="line">        str = <span class="string">&quot;test ok&quot;</span>;</span><br><span class="line">        ch[<span class="number">0</span>] = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">StringTest</span> <span class="variable">ex</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringTest</span>();</span><br><span class="line">        ex.change(ex.str, ex.ch);</span><br><span class="line">        System.out.println(ex.str);<span class="comment">//good</span></span><br><span class="line">        System.out.println(ex.ch);<span class="comment">//best</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="3-String不同连接操作"><a href="#3-String不同连接操作" class="headerlink" title="3.String不同连接操作"></a>3.String不同连接操作</h4><p>结论：</p>
<ol>
<li><p><strong>常量与常量的拼接结果在常量池</strong>。且常量池中不会存在相同内容的常量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;javaEEhadoop&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;javaEE&quot;</span> + <span class="string">&quot;hadoop&quot;</span>;</span><br><span class="line">System.out.println(s3 == s4);<span class="comment">//true 地址一样</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>只要其中有一个是变量，结果就在堆中</strong>。（相当于new的方式）</p>
<p>内存解析：在方法区常量池中查找有无一样的字符串，没有则开辟新空间存放字符，栈空间指向堆中新造的对象实例，堆空间String类对象实例指向常量池中声明char数组存储的字符串</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;javaEE&quot;</span>;</span><br><span class="line">   <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;hadoop&quot;</span>;</span><br><span class="line">   <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;javaEEhadoop&quot;</span>;</span><br><span class="line">   <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> s1 + <span class="string">&quot;hadoop&quot;</span>;</span><br><span class="line">   <span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> <span class="string">&quot;javaEE&quot;</span> + s2;</span><br><span class="line">   <span class="type">String</span> <span class="variable">s6</span> <span class="operator">=</span> s1 + s2;</span><br><span class="line">   <span class="comment">//3、4、5、6、地址值各不相同。带变量的相当于new了空间在堆中</span></span><br><span class="line">   </span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>拼接问题调用intern()方法（String中的方法），字符返回值就在常量池中</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">   <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;javaEE&quot;</span>;</span><br><span class="line">   <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;javaEEhadoop&quot;</span>;</span><br><span class="line">   <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> s1 + <span class="string">&quot;hadoop&quot;</span>;</span><br><span class="line">   <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> s3.intern();<span class="comment">//返回值得到的s4使用的常量池中已经存在的“javaEEhadoop”</span></span><br><span class="line">   System.out.println(s4 == s2);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">####  面试题：</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line"><span class="type">String</span>  <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;javaEEhadoop&quot;</span> ;</span><br><span class="line"><span class="keyword">final</span>  <span class="type">String</span>  <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;javaEE&quot;</span> ;  <span class="comment">//加上final 就成常量了</span></span><br><span class="line"><span class="type">String</span>  <span class="variable">s3</span>  <span class="operator">=</span>  s2  +  <span class="string">&quot;hadoop&quot;</span> ; <span class="comment">//这里相加就是在常量池中的，地址值一样</span></span><br><span class="line"></span><br><span class="line">System.out.println(s1 == s3);  <span class="comment">//true</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="4-JVM字符串常量池存放位置说明"><a href="#4-JVM字符串常量池存放位置说明" class="headerlink" title="4.JVM字符串常量池存放位置说明"></a>4.JVM字符串常量池存放位置说明</h4><p>JDK 1.6(JDK 6.0 ,java 6.0)：字符串常量池存储在方法区（具体体现是：永久区）</p>
<p>JDK 1.7 ：字符串常量池存储在堆空间</p>
<p>JDK 1.8 ：字符串常量池存储在方法区（改名为元空间）</p>
<h4 id="5-String常用方法"><a href="#5-String常用方法" class="headerlink" title="5.String常用方法"></a>5.String常用方法</h4><h5 id="1-一档"><a href="#1-一档" class="headerlink" title="1.一档"></a>1.一档</h5><ol>
<li><p>int length()：</p>
<p>返回字符串的<strong>长度</strong>： return value.length</p>
<p>String s1 &#x3D; “aBc” ;  int len &#x3D; s1.length();</p>
</li>
<li><p>char charAt(int index)：</p>
<p>返回某<strong>索引处的字符</strong>return value[index]</p>
<p>String s1 &#x3D; “aBc” ;  char ch &#x3D; charAt(0) ; &#x2F;&#x2F;a</p>
</li>
<li><p>boolean isEmpty()：</p>
<p>判断<strong>是否是空</strong>字符串：return value.length &#x3D;&#x3D; 0</p>
<p>String s1 &#x3D; “aBc” ;  boolean bo &#x3D; s1.isEmpty(); &#x2F;&#x2F; fasle</p>
</li>
<li><p>String toLowerCase()：</p>
<p>使用默认语言环境，将 String 中的所有字符转换为<strong>小写</strong>   String   s2 &#x3D; s1.toLowerCase();</p>
</li>
<li><p>String toUpperCase()：</p>
<p>使用默认语言环境，将 String 中的所有字符转换为<strong>大写</strong>String   s2 &#x3D; s1.toUpperCase();</p>
</li>
<li><p>String trim()：</p>
<p>返回字符串的副本，忽略前导空白和尾部空白</p>
<p><strong>去掉字符串头尾的空格</strong></p>
</li>
<li><p>boolean equals(Object obj)：</p>
<p>比较字符串的<strong>内容是否相同</strong></p>
</li>
<li><p>boolean equalsIgnoreCase(String anotherString)：</p>
<p>与equals方法类似，<strong>忽略大小写</strong></p>
</li>
<li><p>String concat(String str):</p>
<p>将指定<strong>字符串连接到此字符串的结尾</strong>。 等价于用“+”</p>
</li>
<li><p>int compareTo(String anotherString)：</p>
<p>比较两个<strong>字符串的大小</strong></p>
<p>s1.compareTo(s2);</p>
<p>比较Ascll值，用调用者减实参，返回正数，调用者大，否则实参大</p>
</li>
<li><p>String substring(int beginIndex)：</p>
<p><strong>返回一个新的字符串，它是此字符串的从beginIndex开始截取到最后的一个子字符串。</strong></p>
</li>
<li><p>String substring(int beginIndex, int endIndex) ：</p>
<p>返回一个新字符串，它是此<strong>字符串从beginIndex开始截取到endIndex(不包含)的一个子字符串。[ a ,  b)</strong></p>
</li>
</ol>
<h5 id="2-二档"><a href="#2-二档" class="headerlink" title="2.二档"></a>2.二档</h5><ol>
<li><p>boolean endsWith(String suffix)：</p>
<p>测试此字符串是否以指定的后缀结束<br>String str1 &#x3D; “hellowworld”;<br>boolean b1 &#x3D; str1.endsWith(“rld”);&#x2F;&#x2F;可是多个字符</p>
</li>
<li><p>boolean startsWith(String prefix)：</p>
<p>测试此字符串是否以指定的前缀开始</p>
</li>
<li><p>boolean startsWith(String prefix, int toffset)：</p>
<p>测试此字符串从指定索引 ( 包含 ) 开始的子字符串是否以指定前缀开始</p>
</li>
<li><p>boolean contains(CharSequence s)：</p>
<p>当且仅当此字符串包含指定的 char 值序列时（字符匹配），返回 true<br>String str1 &#x3D; “hellowworld”;<br>String str2 &#x3D; “wor”;<br>System.out.println(str1.contains(str2));&#x2F;&#x2F;ture</p>
</li>
<li><p>int indexOf(String str)：</p>
<p>返回指定子字符串在此字符串中第一次出现处的索引（从左往右）</p>
</li>
<li><p>int indexOf(String str, int fromIndex)：</p>
<p>返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始</p>
</li>
<li><p>int lastIndexOf(String str)：</p>
<p>返回指定子字符串在此字符串中最右边出现处的索引</p>
</li>
<li><p>int lastIndexOf(String str, int fromIndex)：</p>
<p>返回指定子字符串在此字符串中最后一次出现处的索引，从指定的索引开始反向搜索</p>
</li>
<li><p>注：indexOf和lastIndexOf方法如果未找到都是返回-1</p>
</li>
<li><p>什么情况下，indexOf(str)和lastIndexOf(str)返回值相同？<br>情况一：存在唯一的一个str。情况二：不存在str</p>
</li>
</ol>
<h5 id="3-三档"><a href="#3-三档" class="headerlink" title="3.三档"></a>3.三档</h5><p><strong>替换：</strong></p>
<ol>
<li><p>String replace(char oldChar, char newChar)：</p>
<p>返回一个新的字符串，它是通过用 newChar <strong>替换此字符串中出现的所有 oldChar 得到的。</strong><br>String str1 &#x3D; “北京尚硅谷教育北京”;<br>String str2 &#x3D; str1.replace(‘北’, ‘东’);</p>
</li>
<li><p>String replace(CharSequence target, CharSequence replacement)：</p>
<p>使用指定的字面值替换序列替换此字符串所有匹配字面值目标序列的子字符串。<br>String str3 &#x3D; str1.replace(“北京”, “上海”);</p>
</li>
<li><p>String replaceAll(String regex, String replacement)：</p>
<p>使用给定的 replacement 替换此字符串所有匹配给定的<strong>正则表达式</strong>的子字符串。<br>&#x2F;&#x2F;把字符串中的数字替换成,，如果结果中开头和结尾有，的话去掉<br>String str &#x3D; “12hello34world5java7891mysql456”;<br>String string &#x3D; str.replaceAll(“\d+”, “,”).replaceAll(“^,|,$”, “”);<br>System.out.println(string);</p>
</li>
<li><p>String replaceFirst(String regex, String replacement)：</p>
<p>使用给定的 replacement 替换此字符串匹配给定的<strong>正则表达式</strong>的第一个子字符串。</p>
</li>
</ol>
<p><strong>匹配:</strong></p>
<p>​      boolean matches(String regex)： 告知此字符串是否匹配给定的正则表达式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str = <span class="string">&quot;12345&quot;</span>;</span><br><span class="line"><span class="comment">//判断str字符串中是否全部有数字组成，即有1-n个数字组成</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">matches</span> <span class="operator">=</span> str.matches(<span class="string">&quot;\\d+&quot;</span>);</span><br><span class="line">System.out.println(matches);</span><br></pre></td></tr></table></figure>

<p><strong>切片：</strong></p>
<ol>
<li><p>String[] split(String regex)：</p>
<p>根据给定正则表达式的匹配拆分此字符串。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str = <span class="string">&quot;hello|world|java&quot;</span>;</span><br><span class="line">String[] strs = str.split(<span class="string">&quot;\\|&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; strs.length; i++) &#123;</span><br><span class="line">    System.out.println(strs[i])</span><br></pre></td></tr></table></figure>

</li>
<li><p>String[] split(String regex, int limit)：</p>
<p>根据匹配给定的正则表达式来拆分此字符串，最多不超过limit个，如果超过了，剩下的全部都放到最后一个元素中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">str2 = <span class="string">&quot;hello.world.java&quot;</span>;</span><br><span class="line">String[] strs2 = str2.split(<span class="string">&quot;\\.&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; strs2.length; i++) &#123;</span><br><span class="line">    System.out.println(strs2[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="6-String-与其他类型的转换"><a href="#6-String-与其他类型的转换" class="headerlink" title="6.String 与其他类型的转换"></a>6.String 与其他类型的转换</h4><h5 id="1-复习与包装类的转换"><a href="#1-复习与包装类的转换" class="headerlink" title="1.复习与包装类的转换"></a>1.复习与包装类的转换</h5><p>复习：String 与基本数据类型、包装类之间的转换。</p>
<ol>
<li><p>String –&gt; 基本数据类型、包装类：调用包装类的静态方法：parseXxx(str)</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;123&quot;</span>;</span><br><span class="line"><span class="comment">//      int num = (int)str1;//错误的</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> Integer.parseInt(str1);</span><br></pre></td></tr></table></figure>

</li>
<li><p>基本数据类型、包装类 –&gt; String:调用String重载的valueOf(xxx)</p>
</li>
</ol>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> String.valueOf(num);<span class="comment">//&quot;123&quot; 方式一</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> num + <span class="string">&quot;&quot;</span>; <span class="comment">//方式二</span></span><br></pre></td></tr></table></figure>

<h5 id="2-与char"><a href="#2-与char" class="headerlink" title="2.与char[ ]"></a>2.与char[ ]</h5><p>String 与 char[]之间的转换</p>
<ol>
<li><p>String –&gt; char[]:调用String的toCharArray()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;abc123&quot;</span>;  <span class="comment">//题目： a21cb3</span></span><br><span class="line"><span class="type">char</span>[] charArray = str1.toCharArray();</span><br></pre></td></tr></table></figure>
</li>
<li><p>char[] –&gt; String:调用String的构造器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>[] arr = <span class="keyword">new</span> <span class="title class_">char</span>[]&#123;<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;o&#x27;</span>&#125;;</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(arr);</span><br></pre></td></tr></table></figure></li>
</ol>
<h5 id="3-与byte"><a href="#3-与byte" class="headerlink" title="3.与byte [ ]"></a>3.与byte [ ]</h5><p>String 与 byte[]之间的转换</p>
<ol>
<li><p>编码：String –&gt; byte[]</p>
<p>调用String的getBytes()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;abc123中国&quot;</span>;</span><br><span class="line"><span class="type">byte</span>[] bytes = str1.getBytes();<span class="comment">//使用默认的字符集，进行编码。</span></span><br><span class="line">System.out.println(Arrays.toString(bytes));</span><br><span class="line"><span class="type">byte</span>[] gbks = str1.getBytes(<span class="string">&quot;gbk&quot;</span>);<span class="comment">//使用gbk字符集进行编码。由于会写错编码集，所以会有异常。</span></span><br><span class="line">System.out.println(Arrays.toString(gbks));</span><br></pre></td></tr></table></figure>

</li>
<li><p>解码：byte[] –&gt; String</p>
<p>调用String的构造器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bytes);<span class="comment">//使用默认的字符集，进行解码。</span></span><br><span class="line">System.out.println(str2);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(gbks);</span><br><span class="line">System.out.println(str3);<span class="comment">//出现乱码。原因：编码集和解码集不一致！</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(gbks, <span class="string">&quot;gbk&quot;</span>);</span><br><span class="line">System.out.println(str4);<span class="comment">//没有出现乱码。原因：编码集和解码集一致！</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>编码与解码：</p>
<ol>
<li>编码：字符串 –&gt;字节  (看得懂 —&gt;看不懂的二进制数据)</li>
<li>解码：编码的逆过程，字节 –&gt; 字符串 （看不懂的二进制数据 —&gt; 看得懂）</li>
<li>说明：解码时，要求解码使用的字符集必须与编码时使用的字符集一致，否则会出现乱码。</li>
</ol>
<h3 id="2-StringBuffer及Builder"><a href="#2-StringBuffer及Builder" class="headerlink" title="2.StringBuffer及Builder"></a>2.StringBuffer及Builder</h3><h4 id="1-面试题-三者String异同"><a href="#1-面试题-三者String异同" class="headerlink" title="1.面试题: 三者String异同"></a>1.面试题: 三者String异同</h4><p>面试题：String、StringBuffer、StringBuilder三者的异同？</p>
<ol>
<li>String:<strong>不可变的字符序列</strong>；底层使用<strong>char[]存储</strong></li>
<li>StringBuffer:<strong>可变</strong>的字符序列；<strong>线程安全</strong>的（使用synchronized同步方法），效率低；底层使用<strong>char[]存储</strong></li>
<li>StringBuilder:<strong>可变</strong>的字符序列；jdk5.0新增的，<strong>线程不安全</strong>的，效率高；底层使用<strong>char[]存储</strong></li>
<li><strong>StringBuffer、StringBuilder只区别在线程是否安全</strong></li>
</ol>
<p><strong>可变性理解：声明一个确定的字符串，可修改原有的字符串</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuffer</span> <span class="variable">sb1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;abc&quot;</span>); <span class="comment">//声明方式</span></span><br><span class="line">sb1.setCharAt(<span class="number">0</span>,<span class="string">&#x27;m&#x27;</span>); <span class="comment">//此方法无返回值</span></span><br><span class="line">System.out.println(sb1); <span class="comment">//mbc </span></span><br></pre></td></tr></table></figure>



<p><strong>源码分析：底层的具体区别</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>();<span class="comment">//char[] value = new char[0];</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);<span class="comment">//char[] value =  new char[]&#123;&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">sb1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line"><span class="comment">//char[] value = new char[16];底层创建了一个长度是16的数组。</span></span><br><span class="line">System.out.println(sb1.length());<span class="comment">//0</span></span><br><span class="line">sb1.append(<span class="string">&#x27;a&#x27;</span>);   <span class="comment">//value[0] = &#x27;a&#x27;;</span></span><br><span class="line">sb1.append(<span class="string">&#x27;b&#x27;</span>);   <span class="comment">//value[1] = &#x27;b&#x27;;</span></span><br><span class="line"></span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">sb2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line"><span class="comment">//char[] value = new char[&quot;abc&quot;.length() + 16];底层结构</span></span><br><span class="line">System.out.println(sb2.length());<span class="comment">//输出具体存在的字符个数：3</span></span><br></pre></td></tr></table></figure>

<p><strong>扩容问题:</strong>    sb1.append(‘a’); </p>
<ol>
<li><p>如果要添加的数据底层数组盛不下了，那就需要扩容底层的数组。</p>
</li>
<li><p>默认情况下，扩容为原来容量的2倍 + 2，同时将<strong>原有数组中的元素复制到新的数组中。</strong></p>
</li>
<li><p>指导意义：</p>
<p>由于在超出容量，添加新容量复制数组会降低效率，开发中建议大家使用：StringBuffer(int capacity) 或 StringBuilder(int capacity)</p>
<p><strong>提前指定好所需的容量</strong></p>
</li>
</ol>
<h4 id="2-StringBuffer常用方法"><a href="#2-StringBuffer常用方法" class="headerlink" title="2.StringBuffer常用方法"></a>2.StringBuffer常用方法</h4><p>由于StringBuffer、StringBuilder在方法上差别不大，只区别在线程安全与否，这里只举StringBuffer的方法</p>
<p>StringBuffer的常用方法：</p>
<ol>
<li><p>StringBuffer  append(xxx)</p>
<p>提供了很多的append()方法，用于进行字符串拼接</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuffer</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">s1.append(<span class="number">1</span>);</span><br><span class="line">s1.append(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">System.out.println(s1); <span class="comment">//abc11</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>StringBuffer delete(int start,int end)</p>
<p>删除指定位置的内容 [ a  ,   b ) 左闭右开的</p>
<p>s1.delete(2,4);</p>
</li>
<li><p>StringBuffer replace(int start, int end, String str)</p>
<p>把 [ start , end ) 位置替换为str</p>
<p> s1.replace(2,4,”hello”);</p>
</li>
<li><p>StringBuffer insert(int offset, xxx)</p>
<p>在指定位置插入xxx</p>
<p>s1.insert(2,”wwe”);</p>
</li>
<li><p>StringBuffer reverse() </p>
<p>把当前字符序列逆转</p>
<p>s1.reverse();</p>
</li>
<li><p>public int indexOf(String str) </p>
<p>返回指定字符串位置索引，没有返回 -1。</p>
<p>System.out.println(s1.indexOf(“b”));</p>
</li>
<li><p>public String substring(int start,int end)</p>
<p>返回一个从start开始到end索引结束的左闭右开区间的子字符串</p>
<p>String s2 &#x3D; s1.substring(1, 3);</p>
</li>
<li><p>public int length()  </p>
<p>长度  s1.length();</p>
</li>
<li><p>public char charAt(int n )</p>
<p>返回指定索引字符：从 0 开始</p>
</li>
<li><p>public void setCharAt(int n ,char ch)</p>
<p>无返回值，添加指定在指定索引处</p>
</li>
</ol>
<p>总结：重点注意一下方法</p>
<p>增：append(xxx)<br>删：delete(int start,int end)<br>改：setCharAt(int n ,char ch) &#x2F; replace(int start, int end, String str)</p>
<p>查：charAt(int n )</p>
<p>插：insert(int offset, xxx)<br>长度：length();<br>*遍历：for() + charAt() &#x2F; toString()</p>
<h4 id="3-三者效率对比"><a href="#3-三者效率对比" class="headerlink" title="3.三者效率对比"></a>3.三者效率对比</h4><p>对比String、StringBuffer、StringBuilder三者的效率：</p>
<p>从高到低排列：StringBuilder &gt; StringBuffer &gt; String</p>
<p>测试代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//初始设置</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">    <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="comment">//开始对比</span></span><br><span class="line">    startTime = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20000</span>; i++) &#123;</span><br><span class="line">        buffer.append(String.valueOf(i));</span><br><span class="line">    &#125;</span><br><span class="line">    endTime = System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;StringBuffer的执行时间：&quot;</span> + (endTime - startTime));</span><br><span class="line"></span><br><span class="line">startTime = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20000</span>; i++) &#123;</span><br><span class="line">    builder.append(String.valueOf(i));</span><br><span class="line">&#125;</span><br><span class="line">endTime = System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">&quot;StringBuilder的执行时间：&quot;</span> + (endTime - startTime));</span><br><span class="line"></span><br><span class="line">startTime = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20000</span>; i++) &#123;</span><br><span class="line">    text = text + i;</span><br><span class="line">&#125;</span><br><span class="line">endTime = System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">&quot;String的执行时间：&quot;</span> + (endTime - startTime));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h4 id="4-String与两者的之间转换"><a href="#4-String与两者的之间转换" class="headerlink" title="4.String与两者的之间转换"></a>4.String与两者的之间转换</h4><ol>
<li><p>String —&gt; StringBuffer、StringBuilder </p>
<p>调用StringBuffer、StringBuilder 构造器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span>  <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="type">StringBuffer</span>  <span class="variable">sb1</span>  <span class="operator">=</span>  <span class="keyword">new</span>   <span class="title class_">StringBuffer</span>(s1);</span><br></pre></td></tr></table></figure>
</li>
<li><p>StringBuffer、StringBuilder —&gt;String </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式一：调用String构造器</span></span><br><span class="line"><span class="type">StringBuffer</span>  <span class="variable">sb1</span>  <span class="operator">=</span>  <span class="keyword">new</span>   <span class="title class_">StringBuffer</span>(<span class="string">&quot;abcc&quot;</span>);</span><br><span class="line"><span class="type">String</span>  <span class="variable">s1</span> <span class="operator">=</span>  <span class="keyword">new</span>  <span class="title class_">String</span>(sb1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式二：StringBuffer、StringBuilder的toString( ) </span></span><br><span class="line"><span class="type">StringBuffer</span>  <span class="variable">sb1</span>  <span class="operator">=</span>  <span class="keyword">new</span>   <span class="title class_">StringBuffer</span>(<span class="string">&quot;abcc&quot;</span>);</span><br><span class="line"><span class="type">String</span>  <span class="variable">s1</span> <span class="operator">=</span> sb1.toString() ;  </span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="3-关于String常见算法题"><a href="#3-关于String常见算法题" class="headerlink" title="3.关于String常见算法题"></a>3.关于String常见算法题</h3><h4 id="1-指定字符反转"><a href="#1-指定字符反转" class="headerlink" title="1.指定字符反转"></a>1.指定字符反转</h4><p>将一个字符串进行反转。将字符串中指定部分进行反转。比如“abcdefg”反转为“abcfedcg”</p>
<p>具体代码演示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式一：转换为char数组，在转回</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">reverse1</span><span class="params">(String str, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (str != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">char</span>[] c1 = str.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start, j = end; i &lt; j; j--, i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">temp</span> <span class="operator">=</span> c1[i];</span><br><span class="line">            c1[i] = c1[j];</span><br><span class="line">            c1[j] = temp;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(c1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式二:利用String连接</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">reverse2</span><span class="params">(String str, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (str != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> str.substring(<span class="number">0</span>, start);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> end; i &gt;= start; i--) &#123;</span><br><span class="line">            s1 += str.charAt(i);</span><br><span class="line">        &#125;</span><br><span class="line">        s1 += str.substring(end + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> s1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式三：效率更高，利用StringBuilder可变性直接连接</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">reverse3</span><span class="params">(String str, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(str!=<span class="literal">null</span>)&#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">stringBuffer</span> <span class="operator">=</span> newStringBuilder(str.length());</span><br><span class="line">        stringBuffer.append(str.substring(<span class="number">0</span>,start));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=end ;i&gt;=start ; i--)&#123;</span><br><span class="line">            stringBuffer.append(str.charAt(i));</span><br><span class="line">        &#125;</span><br><span class="line">        stringBuffer.append(str.substring(end+<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">return</span> stringBuffer.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h4 id="2-字符串中出现的次数"><a href="#2-字符串中出现的次数" class="headerlink" title="2.字符串中出现的次数"></a>2.字符串中出现的次数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">获取一个字符串在另一个字符串中出现的次数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">number</span><span class="params">(String str,String str1)</span>&#123;</span><br><span class="line">   <span class="type">int</span> <span class="variable">mainStr</span> <span class="operator">=</span> str.length();</span><br><span class="line">   <span class="type">int</span> <span class="variable">subStr</span> <span class="operator">=</span>  str1.length();</span><br><span class="line">   <span class="type">int</span> index=<span class="number">0</span>,count=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">if</span>(mainStr&gt;=subStr)&#123;</span><br><span class="line">       <span class="keyword">while</span>((index=str.indexOf(str1,index))!=-<span class="number">1</span>)&#123;</span><br><span class="line">           count++;</span><br><span class="line">           index+=subStr;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> count;</span><br><span class="line">   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h4 id="3-获取两个字符串中最大相同子串"><a href="#3-获取两个字符串中最大相同子串" class="headerlink" title="3.获取两个字符串中最大相同子串"></a>3.获取两个字符串中最大相同子串</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment"> 情况一：只有一个最大字符子串</span></span><br><span class="line"><span class="comment">    获取两个字符串中最大相同子串</span></span><br><span class="line"><span class="comment">    str1=&quot;abcwerthelloyuiodef&quot; str2 = &quot;cvhellobnm&quot;</span></span><br><span class="line"><span class="comment">    提示：将短的那个串进行长度依次递减的子串与较长的串比较</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getMaxSameString</span><span class="params">(String str1,String str2)</span>&#123;</span><br><span class="line"> <span class="keyword">if</span>(str1!=<span class="literal">null</span> &amp;&amp; str2!=<span class="literal">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">   <span class="type">String</span> <span class="variable">maxStr</span> <span class="operator">=</span> (str1.length()&gt;=str2.length())?str1:str2;</span><br><span class="line">    <span class="type">String</span> <span class="variable">minStr</span> <span class="operator">=</span> (str1.length()&lt;str2.length())?str1:str2;</span><br><span class="line">         <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> minStr.length();</span><br><span class="line">          <span class="comment">//每一轮都少一个，在第二层循环从左往右移动对比。</span></span><br><span class="line">         <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span> ; i&lt;minStr.length() ; i++) &#123; </span><br><span class="line">          <span class="comment">//因subString是左闭右开，所以包括length</span></span><br><span class="line">             <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>, y = length - i; y &lt;= length; x++, y++) &#123;</span><br><span class="line">             <span class="type">String</span> <span class="variable">subStr</span> <span class="operator">=</span> minStr.substring(x,y);</span><br><span class="line">             <span class="keyword">if</span>(maxStr.contains(subStr))&#123;</span><br><span class="line">                 <span class="keyword">return</span> subStr;</span><br><span class="line">             &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">// 情况二：如果存在多个长度相同的最大相同子串</span></span><br><span class="line">    <span class="comment">// 此时先返回String[]，后面可以用集合中的ArrayList替换，较方便</span></span><br><span class="line">    <span class="keyword">public</span> String[] getMaxSameString1(String str1, String str2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (str1 != <span class="literal">null</span> &amp;&amp; str2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">StringBuffer</span> <span class="variable">sBuffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">            <span class="type">String</span> <span class="variable">maxString</span> <span class="operator">=</span> (str1.length() &gt; str2.length()) ? str1 : str2;</span><br><span class="line">            <span class="type">String</span> <span class="variable">minString</span> <span class="operator">=</span> (str1.length() &gt; str2.length()) ? str2 : str1;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> minString.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>, y = len - i; y &lt;= len; x++, y++) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">subString</span> <span class="operator">=</span> minString.substring(x, y);</span><br><span class="line">                <span class="keyword">if</span> (maxString.contains(subString)) &#123;</span><br><span class="line">                    sBuffer.append(subString + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//                System.out.println(sBuffer);</span></span><br><span class="line">                <span class="keyword">if</span> (sBuffer.length() != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            String[] split = sBuffer.toString().replaceAll(<span class="string">&quot;,$&quot;</span>, <span class="string">&quot;&quot;</span>).split(<span class="string">&quot;\\,&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> split;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>






<h3 id="4-JDK-8之前日期和时间"><a href="#4-JDK-8之前日期和时间" class="headerlink" title="4.JDK 8之前日期和时间"></a>4.JDK 8之前日期和时间</h3><p>JDK 8之前日期和时间的API测试</p>
<h4 id="1-System类"><a href="#1-System类" class="headerlink" title="1.System类"></a>1.System类</h4><p>System类中的currentTimeMillis()</p>
<p>返回当前时间与1970年1月1日0时0分0秒之间以毫秒为单位的时间差。</p>
<p>称为时间戳</p>
<p>long time &#x3D; System.currentTimeMillis();<br>System.out.println(time);</p>
<h4 id="2-date类"><a href="#2-date类" class="headerlink" title="2.date类"></a>2.date类</h4><p>java.util.Date类 是 java.sql.Date类 的 父类（前者是java程序中常用的，后者是数据库中常用的时间）</p>
<p>1.两个构造器的使用</p>
<ol>
<li><p>构造器一：Date()：创建一个对应当前时间的Date对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Date</span> <span class="variable">date1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">System.out.println(date1.toString());</span><br><span class="line"><span class="comment">//Sat Feb 16 16:35:31 GMT+08:00 2019</span></span><br><span class="line">System.out.println(date1.getTime());</span><br><span class="line"><span class="comment">//1550306204104 从1970年1月1日0时0分0秒</span></span><br></pre></td></tr></table></figure>



</li>
<li><p>构造器二：创建指定毫秒数的Date对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Date</span> <span class="variable">date2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">155030620410L</span>);</span><br><span class="line"><span class="comment">//也是从1970年1月1日0时0分0秒计算</span></span><br><span class="line">System.out.println(date2.toString());</span><br></pre></td></tr></table></figure></li>
</ol>
<p>2.两个方法的使用</p>
<ol>
<li><p>toString():显示当前的年、月、日、时、分、秒</p>
<p>System.out.println(date1.toString());<br>输出格式：Sat Feb 16 16:35:31 GMT+08:00 2019</p>
</li>
<li><p>getTime():获取当前Date对象对应的毫秒数。（时间戳）</p>
<p>System.out.println(date1.getTime());<br>输出格式：1550306204104</p>
</li>
</ol>
<p>3.java.sql.Date对应着数据库中的日期类型的变量</p>
<ol>
<li><p>如何实例化？  </p>
<p>只能用指定毫秒数的构造器了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java.sql.<span class="type">Date</span> <span class="variable">date3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">java</span>.sql.Date(<span class="number">355325345L</span>);</span><br><span class="line">System.out.println(date3);</span><br><span class="line"><span class="comment">//其toString输出格式1971-02-13  区别于util包下的</span></span><br></pre></td></tr></table></figure>

</li>
<li><p>如何将java.util.Date对象转换为java.sql.Date对象</p>
<p>情况一：声明父类，new子类—（强转）多态性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Date</span> <span class="variable">date4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">java</span>.sql.Date(<span class="number">2343243242323L</span>);</span><br><span class="line">java.sql.<span class="type">Date</span> <span class="variable">date5</span> <span class="operator">=</span> (java.sql.Date)date4;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>​     情况二：声明父类，new父类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Date</span> <span class="variable">date6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">  java.sql.<span class="type">Date</span> <span class="variable">date7</span> <span class="operator">=</span>  <span class="keyword">new</span>  <span class="title class_">java</span>.sql.Date(date6.getTime());</span><br></pre></td></tr></table></figure>

<p>   ​</p>
<h4 id="3-SimpleDateFormat类"><a href="#3-SimpleDateFormat类" class="headerlink" title="3.SimpleDateFormat类"></a>3.SimpleDateFormat类</h4><p>SimpleDateFormat的使用：<strong>SimpleDateFormat对日期Date类的格式化和解析</strong></p>
<p>1.两个操作：</p>
<ol>
<li><p>格式化：日期 —&gt;字符串 </p>
<p>String  format(Date date )</p>
</li>
<li><p>解析：格式化的逆过程，字符串 —&gt; 日期</p>
<p>Date  parse(String  string )  该字符串日期格式是与构造器对应格式</p>
</li>
</ol>
<p>2.类型一：默认构造器，格式化日期单一</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实例化SimpleDateFormat :  使用默认的构造器</span></span><br><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">sdf</span>  <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>();</span><br><span class="line"><span class="comment">//格式化：日期 ---&gt;字符串</span></span><br><span class="line"><span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">System.out.println(date);<span class="comment">//Thu Jan 27 20:03:38 CST 2022</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">format</span> <span class="operator">=</span> sdf.format(date);</span><br><span class="line">System.out.println(format);<span class="comment">//22-1-27 下午8:03</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//解析：格式化的逆过程，字符串 ---&gt; 日期</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;19-12-18 上午11:43&quot;</span>; <span class="comment">//只能是这种格式</span></span><br><span class="line"><span class="type">Date</span> <span class="variable">date1</span> <span class="operator">=</span> sdf.parse(str);</span><br><span class="line">System.out.println(date1);<span class="comment">//Wed Dec 18 11:43:00 CST 2019</span></span><br></pre></td></tr></table></figure>

<p>3.类型二：调用带参构造器，可选择合适的日期格式的构造器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">sdf1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>);<span class="comment">//y年，M月，d天，h小时，m分钟，s秒</span></span><br><span class="line">    <span class="comment">//格式化</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">format1</span> <span class="operator">=</span> sdf1.format(date);</span><br><span class="line">    System.out.println(format1);<span class="comment">//2019-02-18 11:48:27</span></span><br><span class="line">    <span class="comment">//解析:要求字符串必须是符合SimpleDateFormat识别的格式(通过构造器参数体现),否则，抛异常</span></span><br><span class="line">    <span class="type">Date</span> <span class="variable">date2</span> <span class="operator">=</span> sdf1.parse(<span class="string">&quot;2020-02-18 11:48:27&quot;</span>);</span><br><span class="line">    System.out.println(date2);<span class="comment">//Tue Feb 18 11:48:27 CST 2020</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h4 id="4-Calendar日历类"><a href="#4-Calendar日历类" class="headerlink" title="4.Calendar日历类"></a>4.Calendar日历类</h4><p>Calendar日历类(抽象类：不能new对象）的使用：</p>
<h5 id="1-实例化"><a href="#1-实例化" class="headerlink" title="1.实例化"></a>1.实例化</h5><ol>
<li><p>方式一：创建其子类（GregorianCalendar）的对象</p>
</li>
<li><p>方式二：调用其静态方法getInstance()</p>
<p>其实第二种方式也是new的GregorianCalendar对象，方式二容易记住</p>
<p><strong>Calendar  calendar  &#x3D;  Calendar.getInstance();</strong></p>
</li>
</ol>
<h5 id="2-常用方法"><a href="#2-常用方法" class="headerlink" title="2.常用方法"></a>2.常用方法</h5><p>注意：</p>
<p>获取月份时：一月是0，二月是1….12月是11</p>
<p>获取星期时：周日是1，周一是2…周六是7</p>
<ol>
<li><p>int  get()</p>
<p>获取指定信息：YEAR、MONTH、DAY_OF_YEAR等等</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Calendar</span>  <span class="variable">calendar</span>  <span class="operator">=</span>  Calendar.getInstance();</span><br><span class="line"><span class="type">int</span> <span class="variable">days</span> <span class="operator">=</span> calendar.get(Calendar.DAY_OF_MONTH); <span class="comment">//这月的第几天</span></span><br><span class="line">System.out.println(days);</span><br><span class="line"><span class="comment">//这年的第几天：DAY_OF_YEAR</span></span><br></pre></td></tr></table></figure>

</li>
<li><p>void  set()</p>
<p>修改指定信息     ，calendar可变性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Calendar</span>  <span class="variable">calendar</span>  <span class="operator">=</span>  Calendar.getInstance();</span><br><span class="line">calendar.set(Calendar.DAY_OF_MONTH,<span class="number">22</span>);</span><br><span class="line">days = calendar.get(Calendar.DAY_OF_MONTH);</span><br><span class="line">System.out.println(days);<span class="comment">//22</span></span><br></pre></td></tr></table></figure>

</li>
<li><p>void  add()</p>
<p>增加指定信息个数，负数为减少个数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> calendar.add(Calendar.DAY_OF_MONTH,-<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">Calendar</span>  <span class="variable">calendar</span>  <span class="operator">=</span>  Calendar.getInstance();</span><br><span class="line">calendar.add(Calendar.DAY_OF_MONTH,-<span class="number">3</span>);</span><br><span class="line">days = calendar.get(Calendar.DAY_OF_MONTH);</span><br><span class="line">System.out.println(days);</span><br></pre></td></tr></table></figure>

</li>
<li><p>Date  getTime()</p>
<p><strong>获取Date类型的日期：日历类—&gt; Date</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Calendar</span>  <span class="variable">calendar</span>  <span class="operator">=</span>  Calendar.getInstance();</span><br><span class="line"><span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> calendar.getTime();</span><br><span class="line">System.out.println(date);</span><br></pre></td></tr></table></figure>

</li>
<li><p>void  setTime()</p>
<p><strong>Date类 —&gt; 日历类</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Calendar</span>  <span class="variable">calendar</span>  <span class="operator">=</span>  Calendar.getInstance();</span><br><span class="line"><span class="type">Date</span> <span class="variable">date1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">calendar.setTime(date1); <span class="comment">//不用返回值，对象可变</span></span><br><span class="line"> days = calendar.get(Calendar.DAY_OF_MONTH);</span><br><span class="line">    System.out.println(days);</span><br></pre></td></tr></table></figure></li>
</ol>
<h5 id="3-练习"><a href="#3-练习" class="headerlink" title="3.练习"></a>3.练习</h5><p>练习一：字符串”2020-09-08”转换为java.sql.Date</p>
<p>字符串–&gt;SimpleDateFormat类–&gt;util.Date类—&gt;sql.Date类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">birth</span> <span class="operator">=</span> <span class="string">&quot;2020-09-08&quot;</span>;</span><br><span class="line"> <span class="type">SimpleDateFormat</span> <span class="variable">sdf1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line"> <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> sdf1.parse(birth);</span><br><span class="line">java.sql.<span class="type">Date</span> <span class="variable">birthDate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">java</span>.sql.Date(date.getTime());</span><br><span class="line">System.out.println(birthDate);</span><br></pre></td></tr></table></figure>



<p>练习二：”三天打渔两天晒网”   1990-01-01  xxxx-xx-xx 打渔？晒网？</p>
<p>举例：2020-09-08 ？ 总天数</p>
<p>总天数 % 5 &#x3D;&#x3D; 1,2,3 : 打渔<br>总天数 % 5 &#x3D;&#x3D; 4,0 : 晒网</p>
<p>总天数的计算？<br>方式一：( date2.getTime() - date1.getTime()) &#x2F; (1000 * 60 * 60 * 24) + 1<br>方式二：1990-01-01  –&gt; 2019-12-31  +  2020-01-01 –&gt;2020-09-08</p>
<h3 id="5-JDK8中日期和时间"><a href="#5-JDK8中日期和时间" class="headerlink" title="5.JDK8中日期和时间"></a>5.JDK8中日期和时间</h3><h4 id="1-总体介绍"><a href="#1-总体介绍" class="headerlink" title="1.总体介绍"></a>1.总体介绍</h4><ol>
<li>java.time  包含值对象的基础包</li>
<li>java.time.chrono  提供对不同日历系统的访问</li>
<li>java.time.format   格式化和解析时间和日期</li>
<li>java.time.temporal    包括底层框架和扩展特性</li>
<li>java.time.zone    包含时区支持的类</li>
</ol>
<p>说明：</p>
<p>大多数开发者只会用到基础包和format包，也可能会用到temporal包。因此，尽管有68个新的公开类型，大多数开发者，大概只会用到其中的三分之一</p>
<h4 id="1-LocalDate-x2F-Time-x2F-DateTime"><a href="#1-LocalDate-x2F-Time-x2F-DateTime" class="headerlink" title="1.LocalDate&#x2F;Time&#x2F;DateTime"></a>1.LocalDate&#x2F;Time&#x2F;DateTime</h4><h5 id="1-出现背景"><a href="#1-出现背景" class="headerlink" title="1.出现背景"></a>1.出现背景</h5><p>JDK 1.0中包含了一个java.util.Date类，但是它的大多数方法已经在JDK 1.1引入Calendar类之后被弃用了。而Calendar并不比Date好多少。<strong>它们面临的问题是</strong>：</p>
<ol>
<li><p>可变性：像日期和时间这样的类应该是<strong>不可变</strong>的。</p>
</li>
<li><p>偏移性：<strong>Date中的年份是从1900开始</strong>的，而<strong>月份都从0开始</strong>。</p>
<p>Date date1 &#x3D; new Date(2020 - 1900,9 - 1,8);<br>System.out.println(date1);&#x2F;&#x2F;Tue Sep 08 00:00:00 GMT+08:00 2020</p>
</li>
<li><p>格式化：格式化只对Date有用，Calendar则不行。</p>
</li>
<li><p>此外，它们也不是线程安全的；不能处理闰秒等</p>
</li>
</ol>
<h5 id="2-主要介绍及方法"><a href="#2-主要介绍及方法" class="headerlink" title="2.主要介绍及方法"></a>2.主要介绍及方法</h5><p>LocalDate（只有日期）、LocalTime（只有时间）、LocalDateTime （日期加时间）的使用</p>
<p>说明：</p>
<ol>
<li><p><strong>LocalDateTime</strong>相较于LocalDate、LocalTime，使用频率要高</p>
</li>
<li><p>类似于Calendar</p>
</li>
</ol>
<p><strong>主要方法使用</strong>：主要以LocalDateTime举例</p>
<ol>
<li><p><strong>now()  —–静态方法（实例化方式一）</strong></p>
<p><strong>获取当前的日期、时间、日期+时间</strong></p>
<p>LocalDate localDate &#x3D; LocalDate.now();<br>LocalTime localTime &#x3D; LocalTime.now();<br>LocalDateTime localDateTime &#x3D; LocalDateTime.now();</p>
</li>
<li><p><strong>of()   —–静态方法（实例化方式二）</strong></p>
<p><strong>设置指定的年、月、日、时、分、秒。没有偏移量</strong></p>
<p>LocalDateTime localDateTime1 &#x3D; LocalDateTime.of(2020, 10, 6, 13, 23, 43);</p>
</li>
<li><p><strong>getXxx()：获取相关的属性</strong></p>
<p> System.out.println(localDateTime.getDayOfMonth());<br> System.out.println(localDateTime.getDayOfWeek());<br> System.out.println(localDateTime.getMonth());<br> System.out.println(localDateTime.getMonthValue());<br> System.out.println(localDateTime.getMinute());</p>
</li>
<li><p>withXxx()：设置相关的属性—有返回值，体现不可变性</p>
<p> LocalDate localDate1 &#x3D; localDate.withDayOfMonth(22);<br> System.out.println(localDate);18–原来的不变<br> System.out.println(localDate1);20 </p>
</li>
<li><p>plusMonths(3)：加个数—-有返回值，体现不可变性</p>
<p> LocalDateTime localDateTime3 &#x3D; localDateTime.plusMonths(3);<br>System.out.println(localDateTime);<br>System.out.println(localDateTime3);</p>
</li>
<li><p>minusDays(6)：减个数—–有返回值，体现不可变性</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LocalDateTime</span> <span class="variable">localDateTime4</span> <span class="operator">=</span> localDateTime.minusDays(<span class="number">6</span>);</span><br><span class="line">System.out.println(localDateTime);</span><br><span class="line">System.out.println(localDateTime4);</span><br></pre></td></tr></table></figure>



<h4 id="2-Instan类瞬时"><a href="#2-Instan类瞬时" class="headerlink" title="2.Instan类瞬时"></a>2.Instan类瞬时</h4><p><strong>说明：</strong></p>
<ol>
<li><p><strong>时间线上的一个瞬时点。 这可能被用来记录应用程序中的事件时间戳。</strong></p>
</li>
<li><p>类似于 java.util.Date类</p>
</li>
</ol>
<p><strong>主要方法使用：</strong></p>
<ol>
<li><p><strong>now()  —–静态方法（实例化方式）</strong></p>
<p>获取本初子午线对应的标准时间(0时线，和北京时间差8小时)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Instant</span> <span class="variable">instant</span> <span class="operator">=</span> Instant.now();</span><br><span class="line">System.out.println(instant);<span class="comment">//2019-02-18T07:29:41.719Z</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>atOffset(ZoneOffset.ofHours(8))</p>
<p>添加时间的偏移量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">OffsetDateTime</span> <span class="variable">offsetDateTime</span>   <span class="operator">=</span>  instant.atOffset(ZoneOffset.ofHours(<span class="number">8</span>));</span><br><span class="line">System.out.println(offsetDateTime);<span class="comment">//2019-02-18T15:32:50.611+08:00</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>toEpochMilli(long  Milli)</p>
<p>获取自1970年1月1日0时0分0秒（UTC）开始的毫秒数  —&gt; Date类的getTime()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">milli</span> <span class="operator">=</span> instant.toEpochMilli();</span><br><span class="line">System.out.println(milli);</span><br></pre></td></tr></table></figure>
</li>
<li><p>ofEpochMilli()</p>
<p>通过给定的毫秒数，获取Instant实例  –&gt;Date(long millis)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Instant</span> <span class="variable">instant1</span> <span class="operator">=</span> Instant.ofEpochMilli(<span class="number">1550475314878L</span>);</span><br><span class="line">System.out.println(instant1);</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="3-DateTimeFormatter-类"><a href="#3-DateTimeFormatter-类" class="headerlink" title="3.DateTimeFormatter 类"></a>3.DateTimeFormatter 类</h4><p>java.time.format.DateTimeFormatter 类</p>
<p><strong>该类提供了三种格式化方法：</strong></p>
<ol>
<li><p>预定义的标准格式ISO_LOCAL_DATE_TIME;ISO_LOCAL_DATE;ISO_LOCAL_TIME</p>
</li>
<li><p>本地化相关的格式</p>
<p>ofLocalizedDateTime(FormatStyle.LONG)</p>
</li>
<li><p>自定义的格式</p>
<p><strong>ofPattern(“yyyy-MM-dd hh:mm:ss”)</strong></p>
</li>
</ol>
<p><strong>使用说明：</strong></p>
<ol>
<li><p><strong>预定义的标准格式</strong></p>
<p>ISO_LOCAL_DATE_TIME    日期+时间</p>
<p>ISO_LOCAL_DATE               日期</p>
<p>ISO_LOCAL_TIME               时间</p>
<p><strong>实例化：</strong></p>
<p>DateTimeFormatter  formatter  &#x3D;  DateTimeFormatter.ISO_LOCAL_DATE_TIME;</p>
<p><strong>format( ) 格式化:日期–&gt;字符串</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="type">LocalDateTime</span> <span class="variable">localDateTime</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> formatter.format(localDateTime);</span><br><span class="line">System.out.println(localDateTime);<span class="comment">// 2019-02-18T15:42:18.797</span></span><br><span class="line">System.out.println(str1); <span class="comment">// 2019-02-18T15:42:18.797</span></span><br></pre></td></tr></table></figure>

<p><strong>parse() 解析：字符串 –&gt;日期 返回值类型为TemporalAccessor</strong> </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">TemporalAccessor</span> <span class="variable">parse</span> <span class="operator">=</span> formatter.parse(<span class="string">&quot;2019-02-18T15:42:18.797&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(parse);<span class="comment">//2019-02-18T15:42:18.797</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>本地化相关的格式  –解析方式一样，不列举</strong></p>
<p><strong>适用于LocalDateTime（日期+时间形式）：</strong></p>
<p>ofLocalizedDateTime(FormatStyle.SHORT);</p>
<ol>
<li>FormatStyle.LONG   2022年1月28日 上午11时56分26秒</li>
<li>FormatStyle.MEDIUM   2022-1-28 11:57:15</li>
<li>FormatStyle.SHORT      22-1-28 上午11:57</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DateTimeFormatter</span> <span class="variable">formatter1</span> <span class="operator">=</span> DateTimeFormatter.ofLocalizedDateTime(FormatStyle.SHORT);</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> formatter1.format(localDateTime);</span><br><span class="line">System.out.println(str2);<span class="comment">//2019年2月18日 下午03时47分16秒</span></span><br></pre></td></tr></table></figure>



<p><strong>适用于LocalizedDate()（日期）：</strong></p>
<p>ofLocalizedDate(FormatStyle.FULL);</p>
<ol>
<li><p>FormatStyle.LONG       2022年1月28日</p>
</li>
<li><p>FormatStyle.MEDIUM    2022-1-28</p>
</li>
<li><p>FormatStyle.SHORT       22-1-28</p>
</li>
<li><p>FormatStyle.FULL    2022年1月28日 星期五</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DateTimeFormatter</span> <span class="variable">formatter2</span> <span class="operator">=</span> DateTimeFormatter.ofLocalizedDate(FormatStyle.FULL);</span><br><span class="line"><span class="comment">//格式化</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span>formatter2.format(LocalDate.now());</span><br><span class="line">System.out.println(str3);<span class="comment">//2019-2-18  </span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p><strong>自定义的格式</strong></p>
<p><strong>ofPattern(“yyyy-MM-dd hh:mm:ss”)</strong></p>
<p>yyyy-MM-dd hh:mm:ss   2019-02-18 03:52:09</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DateTimeFormatter</span> <span class="variable">formatter3</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>);</span><br><span class="line"><span class="comment">//格式化</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> formatter3.format(LocalDateTime.now());</span><br><span class="line">System.out.println(str4);<span class="comment">//2019-02-18 03:52:09</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//解析</span></span><br><span class="line"><span class="type">TemporalAccessor</span> <span class="variable">accessor</span> <span class="operator">=</span> formatter3.parse(<span class="string">&quot;2019-02-18 03:52:09&quot;</span>);</span><br><span class="line">System.out.println(accessor);</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="6-Java比较器"><a href="#6-Java比较器" class="headerlink" title="6.Java比较器"></a>6.Java比较器</h3><h4 id="1-介绍-4"><a href="#1-介绍-4" class="headerlink" title="1.介绍"></a>1.介绍</h4><p>在Java中经常会涉及到对象数组的排序问题，那么就涉及到对象之间的比较问题。 </p>
<p>Java实现对象排序的方式有两种：</p>
<ol>
<li>自然排序：java.lang.Comparable</li>
<li>定制排序：java.util.Comparator</li>
</ol>
<p><strong>一、说明：</strong></p>
<p>Java中的对象，正常情况下，只能进行比较：&#x3D;&#x3D;  或  !&#x3D; 。不能使用 &gt; 或 &lt; 的但是在开发场景中，我们需要对多个对象进行排序，言外之意，就需要比较对象的大小。</p>
<p><strong>如何实现？</strong></p>
<p>使用两个接口中的任何一个：Comparable 或 Comparator</p>
<p><strong>二、Comparable接口与Comparator的使用的对比：</strong></p>
<p>Comparable<strong>接口的方式一旦一定，保证Comparable接口实现类的对象在任何位置都可以比较大小。</strong></p>
<p>Comparator接口属于<strong>临时性的比较</strong>。</p>
<h4 id="2-Comparable自然排序"><a href="#2-Comparable自然排序" class="headerlink" title="2.Comparable自然排序"></a>2.Comparable自然排序</h4><p>Comparable接口的使用举例：  自然排序</p>
<p> <strong>通过Collections.sort 或Arrays.sort内部调用此重写的compareTo进行排序</strong></p>
<ol>
<li><p>像String、包装类等实现了Comparable接口，重写了compareTo(obj)方法，给出了比较两个对象大小的方式。</p>
</li>
<li><p>像String、包装类重写compareTo()方法以后，默认进行了从小到大的排列</p>
</li>
<li><p><strong>重写compareTo(obj)的规则  (默认由小到大) ：</strong></p>
<ol>
<li>如果当前对象this大于形参对象obj，则返回正整数，</li>
<li>如果当前对象this小于形参对象obj，则返回负整数，</li>
<li>如果当前对象this等于形参对象obj，则返回零。</li>
</ol>
</li>
<li><p>对于<strong>自定义类</strong>来说，如果需要排序，我们可以让<strong>自定义类实现Comparable接口，重写compareTo(obj)方法。</strong>在compareTo(obj)方法中指明如何排序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//指明商品比较大小的方式:按照价格从低到高排序,再按照产品名称从高到低排序</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Object o)</span> &#123;</span><br><span class="line"><span class="comment">//        System.out.println(&quot;**************&quot;);</span></span><br><span class="line">        <span class="keyword">if</span>(o <span class="keyword">instanceof</span> Goods)&#123;</span><br><span class="line">            <span class="type">Goods</span> <span class="variable">goods</span> <span class="operator">=</span> (Goods)o;</span><br><span class="line">            <span class="comment">//方式一：</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">this</span>.price &gt; goods.price)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">this</span>.price &lt; goods.price)&#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//            return 0;</span></span><br><span class="line"><span class="comment">//          价格相同的按照名称字符大小排序</span></span><br><span class="line">          <span class="keyword">return</span> -<span class="built_in">this</span>.name.compareTo(goods.name);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//方式二：调用包装类已有的compare</span></span><br><span class="line"><span class="comment">//           return Double.compare(this.price,goods.price);</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        return 0;</span></span><br><span class="line"><span class="comment">//如果传入的不是本类型的数据，抛出个提示异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;传入的数据类型不一致！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> */</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">    String[] arr = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;AA&quot;</span>,<span class="string">&quot;CC&quot;</span>,<span class="string">&quot;KK&quot;</span>,<span class="string">&quot;MM&quot;</span>,<span class="string">&quot;GG&quot;</span>,<span class="string">&quot;JJ&quot;</span>,<span class="string">&quot;DD&quot;</span>&#125;;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    Arrays.sort(arr);</span><br><span class="line"></span><br><span class="line">    System.out.println(Arrays.toString(arr)); <span class="comment">//[AA, CC, DD, GG, JJ, KK, MM]</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">    Goods[] arr = <span class="keyword">new</span> <span class="title class_">Goods</span>[<span class="number">5</span>];</span><br><span class="line">    arr[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">Goods</span>(<span class="string">&quot;lenovoMouse&quot;</span>,<span class="number">34</span>);</span><br><span class="line">    arr[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">Goods</span>(<span class="string">&quot;dellMouse&quot;</span>,<span class="number">43</span>);</span><br><span class="line">    arr[<span class="number">2</span>] = <span class="keyword">new</span> <span class="title class_">Goods</span>(<span class="string">&quot;xiaomiMouse&quot;</span>,<span class="number">12</span>);</span><br><span class="line">    arr[<span class="number">3</span>] = <span class="keyword">new</span> <span class="title class_">Goods</span>(<span class="string">&quot;huaweiMouse&quot;</span>,<span class="number">65</span>);</span><br><span class="line">    arr[<span class="number">4</span>] = <span class="keyword">new</span> <span class="title class_">Goods</span>(<span class="string">&quot;microsoftMouse&quot;</span>,<span class="number">43</span>);</span><br><span class="line"></span><br><span class="line">    Arrays.sort(arr);<span class="comment">//内部调用Goods重写CompareTo方法</span></span><br><span class="line"></span><br><span class="line">    System.out.println(Arrays.toString(arr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="3-Comparator定制排序"><a href="#3-Comparator定制排序" class="headerlink" title="3.Comparator定制排序"></a>3.Comparator定制排序</h4><p><strong>1.背景：</strong></p>
<p>当元素的类型<strong>没有实现java.lang.Comparable接口</strong>而又不方便修改代码（String类内重写的方法不能修改），或者实现了java.lang.Comparable接口的排序规则不适合当前的操作，那么可以考虑使用 Comparator 的对象<strong>临时创建一个排序规则来排序</strong></p>
<p>**2.重写compare(Object o1,Object o2)规则  ( 默认由小到大 )  ： **</p>
<p>比较o1和o2的大小：</p>
<ol>
<li>如果方法返回正整数，则表示o1大于o2；</li>
<li>如果返回0，表示相等；</li>
<li>返回负整数，表示o1小于o2。</li>
</ol>
<h4 id="3-自定义Comparator类"><a href="#3-自定义Comparator类" class="headerlink" title="3.自定义Comparator类"></a>3.自定义Comparator类</h4><p> <strong>通过Collections.sort 或Arrays.sort内部调用此重写的compare进行排序</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">String[] arr = <span class="keyword">new</span> <span class="title class_">String</span>[ ] &#123; <span class="string">&quot;AA&quot;</span>,<span class="string">&quot;CC&quot;</span>,<span class="string">&quot;KK&quot;</span>,<span class="string">&quot;MM&quot;</span>,<span class="string">&quot;GG&quot;</span>,<span class="string">&quot;JJ&quot;</span>,<span class="string">&quot;DD&quot;</span> &#125; ;</span><br><span class="line">   Arrays.sort(arr, <span class="keyword">new</span> <span class="title class_">Comparator</span>()&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>  <span class="type">int</span>  <span class="title function_">compare</span><span class="params">(Object o1, Object o2)</span> &#123;</span><br><span class="line">		<span class="comment">//1. 如果方法返回正整数，则表示o1大于o2；</span></span><br><span class="line">		<span class="comment">//2. 如果返回0，表示相等；</span></span><br><span class="line">		<span class="comment">//3. 返回负整数，表示o1小于o2。</span></span><br><span class="line">	 &#125; </span><br><span class="line"></span><br><span class="line">&#125; ) ;</span><br></pre></td></tr></table></figure>

<p><strong>具体代码演示：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line"> String[] arr = <span class="keyword">new</span> <span class="title class_">String</span>[]      &#123;<span class="string">&quot;AA&quot;</span>,<span class="string">&quot;CC&quot;</span>,<span class="string">&quot;KK&quot;</span>,<span class="string">&quot;MM&quot;</span>,<span class="string">&quot;GG&quot;</span>,<span class="string">&quot;JJ&quot;</span>,<span class="string">&quot;DD&quot;</span>&#125;;</span><br><span class="line">   Arrays.sort(arr,<span class="keyword">new</span> <span class="title class_">Comparator</span>()&#123;</span><br><span class="line">            <span class="comment">//按照字符串从大到小的顺序排列</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object o1, Object o2)</span> &#123;</span><br><span class="line">     <span class="keyword">if</span>(o1 <span class="keyword">instanceof</span> String &amp;&amp; o2 <span class="keyword">instanceof</span>  String)&#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> (String) o1;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> (String) o2;</span><br><span class="line">                    <span class="keyword">return</span> -s1.compareTo(s2);</span><br><span class="line">                &#125;</span><br><span class="line"><span class="comment">//                return 0;</span></span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;输入的数据类型不一致&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h3 id="7-System类"><a href="#7-System类" class="headerlink" title="7.System类"></a>7.System类</h3><h4 id="1-介绍-5"><a href="#1-介绍-5" class="headerlink" title="1.介绍"></a>1.介绍</h4><ol>
<li>System类代表系统，系统级的很多属性和控制方法都放置在该类的内部。</li>
<li>该类位于java.lang包。 </li>
<li><strong>由于该类的构造器是private的，所以无法创建该类的对象，也就是无法实例化该类。其内部的成员变量和成员方法都是static的，所以也可以很方便的进行调用。</strong></li>
</ol>
<h4 id="2-成员方法"><a href="#2-成员方法" class="headerlink" title="2.成员方法"></a>2.成员方法</h4><ol>
<li><p>native long currentTimeMillis()</p>
<p>该方法的作用是返回当前的计算机时间，时间的表达格式为当前计算机时</p>
<p>间和GMT时间(格林威治时间)1970年1月1号0时0分0秒所差的毫秒数</p>
</li>
<li><p>void exit(int status)</p>
<p>该方法的作用是退出程序。其中status的值为0代表正常退出，非零代表</p>
<p>异常退出。使用该方法可以在图形界面编程中实现程序的退出功能等</p>
</li>
<li><p>void gc()</p>
<p>该方法的作用是请求系统进行垃圾回收。至于系统是否立刻回收，则</p>
<p>取决于系统中垃圾回收算法的实现以及系统执行时的情况</p>
</li>
<li><p>String getProperty(String key)</p>
<p>方法的作用是获得系统中属性名为key的属性对应的值。系统中常见</p>
<p>的属性名以及属性的作用</p>
<p>java . version  java 运行环境版本</p>
<p>java.home    java安装目录</p>
<p>os . version      操作系统的版本</p>
<p>os . name     操作系统的名称</p>
<p>user . name    用户的账户名称</p>
<p>user . home   用户的主目录</p>
<p>user.dir        用户的当前工作目录</p>
</li>
</ol>
<h3 id="8-Math类"><a href="#8-Math类" class="headerlink" title="8.Math类"></a>8.Math类</h3><h4 id="1-介绍-6"><a href="#1-介绍-6" class="headerlink" title="1.介绍"></a>1.介绍</h4><p>java.lang.Math提供了一系列静态方法用于科学计算。其方法的参数和返回值类型一般为double型。</p>
<h4 id="2-常用方法-1"><a href="#2-常用方法-1" class="headerlink" title="2.常用方法"></a>2.常用方法</h4><ol>
<li>abs（） 绝对值</li>
<li>acos,asin,atan,cos,sin,tan 三角函数</li>
<li>sqrt（） 平方根</li>
<li>pow(double a,doble b) a的b次幂</li>
<li>log（） 自然对数</li>
<li>exp（） e为底指数</li>
<li>max(double a,double b)</li>
<li>min(double a,double b)</li>
<li>random() 返回0.0到1.0的随机数</li>
<li>long round(double a) double型数据a转换为long型（四舍五入）</li>
<li>toDegrees(double angrad) 弧度—&gt;角度</li>
<li>toRadians(double angdeg) 角度—&gt;弧度</li>
</ol>
<h3 id="9-BigInteger类"><a href="#9-BigInteger类" class="headerlink" title="9.BigInteger类"></a>9.BigInteger类</h3><h4 id="1-介绍-7"><a href="#1-介绍-7" class="headerlink" title="1.介绍"></a>1.介绍</h4><ol>
<li>Integer类作为int的包装类，能存储的最大整型值为231-1，Long类也是有限的，最大为263-1。如果要表示再大的整数，不管是基本数据类型还是他们的包装类都无能为力，更不用说进行运算了。</li>
<li>java.math包的BigInteger可以表示不可变的任意精度的整数。BigInteger 提供所有 Java 的基本整数操作符的对应物，并提供 java.lang.Math 的所有相关方法。另外，BigInteger 还提供以下运算：模算术、GCD 计算、质数测试、素数生成、位操作以及一些其他操作。</li>
</ol>
<p>构造器 ：BigInteger(String val)：根据字符串构建BigInteger对象</p>
<p>BigInteger bi &#x3D; new BigInteger(“1243323434343434241123”);</p>
<h4 id="2-常用方法-2"><a href="#2-常用方法-2" class="headerlink" title="2.常用方法"></a>2.常用方法</h4><ol>
<li><p><strong>public BigInteger abs()</strong></p>
<p>返回此 BigInteger 的绝对值的 BigInteger。 </p>
</li>
<li><p><strong>BigInteger add(BigInteger val)</strong> </p>
<p>返回其值为 (this + val) 的 BigInteger</p>
</li>
<li><p><strong>BigInteger subtract(BigInteger val)</strong> </p>
<p>返回其值为 (this - val) 的 BigInteger</p>
</li>
<li><p><strong>BigInteger multiply(BigInteger val)</strong> </p>
<p>返回其值为 (this * val) 的 BigInteger</p>
</li>
<li><p><strong>BigInteger divide(BigInteger val)</strong> </p>
<p>返回其值为 (this &#x2F; val) 的 BigInteger。整数相除只保留整数部分。 </p>
</li>
<li><p><strong>BigInteger remainder(BigInteger val)</strong> </p>
<p>返回其值为 (this % val) 的 BigInteger。 </p>
</li>
<li><p><strong>BigInteger[] divideAndRemainder(BigInteger val)</strong></p>
<p>返回包含 (this &#x2F; val) 后跟(this % val) 的两个 BigInteger 的数组。 </p>
</li>
<li><p><strong>BigInteger pow(int exponent)</strong> </p>
<p>返回其值为 (thisexponent) 的 BigInteger。</p>
</li>
</ol>
<h3 id="10-BigDecimal类"><a href="#10-BigDecimal类" class="headerlink" title="10.BigDecimal类"></a>10.BigDecimal类</h3><h4 id="1-介绍-8"><a href="#1-介绍-8" class="headerlink" title="1.介绍"></a>1.介绍</h4><ol>
<li>一般的Float类和Double类可以用来做科学计算或工程计算，但在商业计算中，要求数字精度比较高，故用到java.math.BigDecimal类。 </li>
<li>BigDecimal类支持不可变的、任意精度的有符号十进制定点数。</li>
</ol>
<p>构造器 :   </p>
<ol>
<li>public BigDecimal(double val) </li>
<li>public BigDecimal(String val)</li>
</ol>
<h4 id="2-常用方法-3"><a href="#2-常用方法-3" class="headerlink" title="2.常用方法"></a>2.常用方法</h4><ol>
<li><p>public BigDecimal add(BigDecimal augend)</p>
<p>加法</p>
</li>
<li><p>public BigDecimal subtract(BigDecimal subtrahend)</p>
<p>减法</p>
</li>
<li><p>public BigDecimal multiply(BigDecimal multiplicand)</p>
<p>乘法</p>
</li>
<li><p>public BigDecimal divide(BigDecimal divisor, int scale, int roundingMode)</p>
<p>除法 （BigDecimal对象 ， 保留几位小数  ， 是否四舍五入）</p>
<p>BigDecimal.ROUND_HALF_UP   要四舍五入BigDecimal.ROUND_HALF_DOWN  不四舍五入</p>
<p>代码演示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">   <span class="type">BigDecimal</span> <span class="variable">bd1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;12435.351&quot;</span>);</span><br><span class="line">   <span class="type">BigDecimal</span> <span class="variable">bd2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;11&quot;</span>);</span><br><span class="line">   </span><br><span class="line">   System.out.println(bi);   <span class="comment">//12435.351</span></span><br><span class="line">   <span class="comment">// System.out.println(bd1.divide(bd2));</span></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">System.out.println(bd1.divide(bd2, BigDecimal.ROUND_HALF_UP));</span><br><span class="line">   System.out.println(bd1.divide(bd2, <span class="number">15</span>, BigDecimal.ROUND_HALF_UP));</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="3-枚举类与注解"><a href="#3-枚举类与注解" class="headerlink" title="3.枚举类与注解"></a>3.枚举类与注解</h2><h3 id="1-枚举类的使用"><a href="#1-枚举类的使用" class="headerlink" title="1.枚举类的使用"></a>1.枚举类的使用</h3><h4 id="1-介绍-9"><a href="#1-介绍-9" class="headerlink" title="1.介绍"></a>1.介绍</h4><ol>
<li>枚举类的理解：<strong>类的对象只有有限个，确定的</strong>。我们称此类为枚举类</li>
<li><strong>当需要定义一组常量时，强烈建议使用枚举类</strong></li>
<li>如果枚举类中只有一个对象，则可以作为单例模式的实现方式。</li>
<li>如一下的用处：<ol>
<li>星期：Monday(星期一)、……、Sunday(星期天) </li>
<li>性别：Man(男)、Woman(女) </li>
<li>季节：Spring(春节)……Winter(冬天) </li>
<li>支付方式：Cash（现金）、WeChatPay（微信）、Alipay(支付宝)、BankCard(银行卡)、CreditCard(信用卡) </li>
<li>就职状态：Busy、Free、Vocation、Dimission</li>
<li>订单状态：Nonpayment（未付款）、Paid（已付款）、Delivered（已发货）、</li>
<li>Return（退货）、Checked（已确认）Fulfilled（已配货）、</li>
<li>线程状态：创建、就绪、运行、阻塞、死亡</li>
</ol>
</li>
</ol>
<h4 id="2-自定义枚举类"><a href="#2-自定义枚举类" class="headerlink" title="2.自定义枚举类"></a>2.自定义枚举类</h4><h5 id="1-如何自定义枚举类"><a href="#1-如何自定义枚举类" class="headerlink" title="1.如何自定义枚举类"></a>1.如何自定义枚举类</h5><p>方式一：jdk5.0之前，自定义枚举类</p>
<ol>
<li><p>声明当前枚举类对象中的属性: private final修饰</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String seasonName;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String seasonDesc;</span><br></pre></td></tr></table></figure>
</li>
<li><p>私有化类的构造器,并给对象属性赋值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="title function_">Season</span><span class="params">(String seasonName,String seasonDesc)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.seasonName = seasonName;</span><br><span class="line"><span class="built_in">this</span>.seasonDesc = seasonDesc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>提供当前枚举类的多个对象：public static final的（<strong>在枚举类内部new全局常量的对象</strong>）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">SPRING</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;春天&quot;</span>,<span class="string">&quot;春暖花开&quot;</span>);</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">SUMMER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;夏天&quot;</span>,<span class="string">&quot;夏日炎炎&quot;</span>);</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">AUTUMN</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;秋天&quot;</span>,<span class="string">&quot;秋高气爽&quot;</span>);</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">WINTER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;冬天&quot;</span>,<span class="string">&quot;冰天雪地&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>其他诉求：获取枚举类对象的属性  或  提供toString()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">getSeasonName</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> seasonName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getSeasonDesc</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> seasonDesc;</span><br><span class="line">&#125; <span class="comment">//或重写toString方法去提供用户所需的常量</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<p>全部代码演示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义枚举类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Season</span>&#123;</span><br><span class="line">    <span class="comment">//1.声明Season对象的属性:private final修饰</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonDesc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.私有化类的构造器,并给对象属性赋值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Season</span><span class="params">(String seasonName,String seasonDesc)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.seasonName = seasonName;</span><br><span class="line">        <span class="built_in">this</span>.seasonDesc = seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.提供当前枚举类的多个对象：public static final的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">SPRING</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;春天&quot;</span>,<span class="string">&quot;春暖花开&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">SUMMER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;夏天&quot;</span>,<span class="string">&quot;夏日炎炎&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">AUTUMN</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;秋天&quot;</span>,<span class="string">&quot;秋高气爽&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">WINTER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;冬天&quot;</span>,<span class="string">&quot;冰天雪地&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.其他诉求1：获取枚举类对象的属性</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSeasonName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> seasonName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSeasonDesc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4.其他诉求1：提供toString()</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Season&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;seasonName=&#x27;&quot;</span> + seasonName + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, seasonDesc=&#x27;&quot;</span> + seasonDesc + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="2-声明调用自定义枚举类"><a href="#2-声明调用自定义枚举类" class="headerlink" title="2.声明调用自定义枚举类"></a>2.声明调用自定义枚举类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Season</span> <span class="variable">spring</span> <span class="operator">=</span> Season.SPRING;   <span class="comment">//“  类名 . 内部new的全局常量  ”</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span>  <span class="variable">s1</span>  <span class="operator">=</span>   spring . getSeasonDesc( ) ;</span><br></pre></td></tr></table></figure>

<h4 id="3-enum关键字定义枚举类"><a href="#3-enum关键字定义枚举类" class="headerlink" title="3.enum关键字定义枚举类"></a>3.enum关键字定义枚举类</h4><h5 id="1-如何定义enum类"><a href="#1-如何定义enum类" class="headerlink" title="1.如何定义enum类"></a>1.如何定义enum类</h5><p>方式二：jdk5.0，可以使用enum关键字定义枚举类</p>
<p>说明：定义的枚举类默认继承于java.lang.Enum类</p>
<ol>
<li><p>enum定义的枚举类区别于自定义枚举类在于，这里首先的得提供当前枚举类的多个或单个对象，<strong>由于这些对象在枚举类中都是全局常量，所以省略了多余的代码，只需写对象名后加“（属性赋值）”，如有多个则用逗号隔开，最后一个用分号</strong></p>
<p>代码演示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">enum</span> <span class="title class_">Season</span>&#123;  <span class="comment">//--   enum + 类名  来定义类</span></span><br><span class="line">       SPRING(<span class="string">&quot;春天&quot;</span>,<span class="string">&quot;春暖花开&quot;</span>),</span><br><span class="line">       SUMMER(<span class="string">&quot;夏天&quot;</span>,<span class="string">&quot;夏日炎炎&quot;</span>),</span><br><span class="line">       AUTUMN(<span class="string">&quot;秋天&quot;</span>,<span class="string">&quot;秋高气爽&quot;</span>),</span><br><span class="line">       WINTER(<span class="string">&quot;冬天&quot;</span>,<span class="string">&quot;冰天雪地&quot;</span>);</span><br><span class="line">       <span class="comment">//如果没有属性：</span></span><br><span class="line">       SPRING,</span><br><span class="line">       SUMMER,</span><br><span class="line">       AUTUMN,</span><br><span class="line">       WINTER;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>声明当前枚举类对象中的属性: private final修饰</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String seasonName;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String seasonDesc;</span><br></pre></td></tr></table></figure>


</li>
<li><p>私有化类的构造器,并给对象属性赋值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="title function_">Season</span><span class="params">(String seasonName,String seasonDesc)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.seasonName = seasonName;</span><br><span class="line"></span><br><span class="line"><span class="built_in">this</span>.seasonDesc = seasonDesc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h5 id="2-enum类中常用方法"><a href="#2-enum类中常用方法" class="headerlink" title="2.enum类中常用方法"></a>2.enum类中常用方法</h5><ol>
<li><p>values()</p>
<p><strong>返回枚举类型的对象数组</strong>。该方法可以很方便地遍历所有的枚举值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Season1[] values = Season1.values();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; values.length;i++)&#123;</span><br><span class="line">    System.out.println(values[i]);</span><br><span class="line">    <span class="comment">//输出：SPRIN GSUMMER AUTUMN WINTER</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>valueOf(String str)   —<strong>声明一个枚举类对象方式</strong></p>
<p>可以把一个字符串转为对应的枚举类对象。要求字符串必须是枚举类对象 的“名字”。如不是，会有运行时异常：IllegalArgumentException。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//valueOf(String objName):返回枚举类中对象名是objName的对象。</span></span><br><span class="line">        <span class="type">Season1</span> <span class="variable">winter</span> <span class="operator">=</span> Season1.valueOf(<span class="string">&quot;WINTER&quot;</span>); <span class="comment">//传入的参数必须存在于枚举类中</span></span><br><span class="line"><span class="comment">//如果没有objName的枚举类对象，则抛异常：     IllegalArgumentException</span></span><br><span class="line"><span class="comment">//   Season1 winter = Season1.valueOf(&quot;WINTER1&quot;);</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>toString()    — 也可考虑重写</p>
<p>返回当前枚举类对象常量的名称</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(winter.toString()); <span class="comment">//WINTER</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h5 id="3-enum枚举类实现接口"><a href="#3-enum枚举类实现接口" class="headerlink" title="3.enum枚举类实现接口"></a>3.enum枚举类实现接口</h5><p>情况一：<strong>实现接口，在enum类中实现抽象方法</strong></p>
<ol>
<li>&#96;&#96;&#96;java<br>enum Season1 implements Info{<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">2. 重写接口中抽象方法</span><br><span class="line"></span><br><span class="line">3. **这里多个对象都共用一个重写的方法 （这不是重点讲的）**</span><br><span class="line"></span><br><span class="line">情况二：**让枚举类的对象分别实现接口中的抽象方法**</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">enum Season1 implements Info&#123;</span><br><span class="line">SPRING(&quot;春天&quot;,&quot;春暖花开&quot;)&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void show() &#123;</span><br><span class="line">        System.out.println(&quot;春天在哪里？&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">SUMMER(&quot;夏天&quot;,&quot;夏日炎炎&quot;)&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void show() &#123;</span><br><span class="line">        System.out.println(&quot;宁夏&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">AUTUMN(&quot;秋天&quot;,&quot;秋高气爽&quot;)&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void show() &#123;</span><br><span class="line">        System.out.println(&quot;秋天不回来&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">WINTER(&quot;冬天&quot;,&quot;冰天雪地&quot;)&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void show() &#123;</span><br><span class="line">        System.out.println(&quot;大约在冬季&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="2-注解Annotation"><a href="#2-注解Annotation" class="headerlink" title="2.注解Annotation"></a>2.注解Annotation</h3><h4 id="1-注解的概述"><a href="#1-注解的概述" class="headerlink" title="1.注解的概述"></a>1.注解的概述</h4><p>① jdk 5.0 新增的功能</p>
<p>② Annotation 其实就是代码里的特殊标记, <strong>这些标记可以在编译, 类加载, 运行时被读取, 并执行相应的处理</strong>。通过使用 Annotation,程序员可以在不改变原有逻辑的情况下, 在源文件中嵌入一些补充信息。</p>
<p>③在JavaSE中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等。在JavaEE&#x2F;Android中注解占据了更重要的角色，例如用来配置应用程序的任何切面，代替JavaEE旧版中所遗留的繁冗代码和XML配置等。</p>
<p>.框架  &#x3D;  注解  +  反射机制  +  设计模式</p>
<h4 id="2-Annocation使用示例"><a href="#2-Annocation使用示例" class="headerlink" title="2.Annocation使用示例"></a>2.Annocation使用示例</h4><p>示例一：生成文档相关的注解</p>
<ol>
<li>@author <strong>标明开发该类模块的作者</strong>，多个作者之间使用,分割</li>
<li>@version 标明该类模块的版本</li>
<li>@see 参考转向，也就是相关主题</li>
<li>@since 从哪个版本开始增加的</li>
<li>@param 对方法中某参数的说明，如果没有参数就不能写</li>
<li>@return 对方法返回值的说明，如果方法的返回值类型是void就不能写</li>
<li>@exception 对方法可能抛出的异常进行说明 ，如果方法没有用throws显式抛出的异常就不能写</li>
</ol>
<p>示例二：在编译时进行格式检查(JDK内置的三个基本注解)</p>
<ol>
<li><p>@Override: 限定<strong>重写父类方法</strong>, 该注解只能用于方法</p>
</li>
<li><p>@Deprecated: 用于表示所修饰的元素(类, 方法等)已过时。通常是因为所修饰<strong>的结构危险</strong>或<strong>存在更好的选择</strong></p>
</li>
<li><p>@SuppressWarnings: <strong>抑制编译器警告</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;unused&quot;)</span> <span class="comment">//提示声明还未使用</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="meta">@SuppressWarnings(&#123; &quot;unused&quot;, &quot;rawtypes&quot; &#125;)</span></span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br></pre></td></tr></table></figure></li>
</ol>
<p>示例三：跟踪代码依赖性，实现替代配置文件功能</p>
<h4 id="3-如何自定义注解"><a href="#3-如何自定义注解" class="headerlink" title="3.如何自定义注解"></a>3.如何自定义注解</h4><p>参照@SuppressWarnings定义</p>
<ol>
<li><p><strong>注解声明为：@interface</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>内部定义成员，通常使用value表示</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>可以指定成员的默认值，使用default定义  ，有单个成员时可在声明时指定值</p>
<p><strong>使用default在内部初始值</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>有单个成员时可在声明时指定值</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MyAnnotation(value=&quot;abc&quot;)</span> <span class="comment">//value可加可不加</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">	.....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>如果<strong>自定义注解没有成员，表明是一个标识作用</strong>。</p>
</li>
</ol>
<p><strong>注意：</strong></p>
<ol>
<li>如果注解有成员，在使用注解时，需要指明成员的值。</li>
<li>自定义注解必须配上注解的信息处理流程(使用反射)才有意义。</li>
<li>自定义注解通过都会指明两个元注解：Retention、Target</li>
</ol>
<h4 id="4-jdk-提供的4种元注解"><a href="#4-jdk-提供的4种元注解" class="headerlink" title="4.jdk 提供的4种元注解"></a>4.jdk 提供的4种元注解</h4><p><strong>元注解：对现有的注解进行解释说明的注解</strong></p>
<ol>
<li><p>Retention：指定所修饰的 Annotation 的生命周期：SOURCE（没编译时就不在了）\CLASS（默认行为–编译时还在）\RUNTIME （运行时还在）</p>
<p><strong>只有声明为RUNTIME生命周期的注解，才能通过反射获取</strong>。</p>
</li>
<li><p>Target  :  用于指定被修饰的 Annotation 能用于修饰哪些程序元素</p>
<p>以下的出现的频率较低</p>
</li>
<li><p>Documented  :  表示所修饰的注解在被javadoc解析时，保留下来。</p>
<p>一般情况以下被javadoc解析为.class文件中没有注解，但是加上这个注解可将注解保留下来</p>
</li>
<li><p>Inherited  :  被它修饰的 Annotation 将具有继承性。</p>
<p>用它注解时，该类的子类也拥有同父类一样的注解</p>
</li>
<li><p>代码演示：</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">   <span class="meta">@Inherited</span></span><br><span class="line">   <span class="meta">@Repeatable(MyAnnotations.class)</span></span><br><span class="line">   <span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line">   <span class="meta">@Target(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE,TYPE_PARAMETER,TYPE_USE&#125;)</span></span><br><span class="line">   <span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line"></span><br><span class="line">String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>




<h4 id="5-通过反射获取注解信息"><a href="#5-通过反射获取注解信息" class="headerlink" title="5.通过反射获取注解信息"></a>5.通过反射获取注解信息</h4><p>—到反射内容时系统讲解</p>
<p>6.jdk 8 中注解的新特性：</p>
<h5 id="1-可重复注解"><a href="#1-可重复注解" class="headerlink" title="1.可重复注解"></a>1.可重复注解</h5><p>需求：使用两个同名的注解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MyAnnotation(value=&quot;hi&quot;)</span></span><br><span class="line"><span class="meta">@MyAnnotation(value=&quot;abc&quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>① 在MyAnnotation上声明@Repeatable，成员值为MyAnnotations.class</p>
<p>② MyAnnotation的Target和Retention<strong>等元注解</strong>与MyAnnotations<strong>相同</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Inherited</span>  <span class="comment">//---原来的注解</span></span><br><span class="line"><span class="meta">@Repeatable(MyAnnotations.class)</span><span class="comment">//---操作一</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE,TYPE_PARAMETER,TYPE_USE&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line"></span><br><span class="line">String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Inherited</span>   <span class="comment">//-----重复的注解 </span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotations &#123;</span><br><span class="line"></span><br><span class="line">MyAnnotation[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="2-类型注解"><a href="#2-类型注解" class="headerlink" title="2.类型注解"></a>2.类型注解</h5><p>类型注解：能在多个类型中注解</p>
<p>ElementType.TYPE_PARAMETER 表示该注解能写在类型变量的声明语句中（如：泛型声明。)<br>ElementType.TYPE_USE 表示该注解能写在使用类型的任何语句中。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Qinghai2021</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2022/08/25/Java%E9%AB%98%E7%BA%A7-%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%B8%B8%E7%94%A8%E7%B1%BB-%E6%9E%9A%E4%B8%BE%E7%B1%BB%E4%B8%8E%E6%B3%A8%E8%A7%A3/">http://example.com/2022/08/25/Java%E9%AB%98%E7%BA%A7-%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%B8%B8%E7%94%A8%E7%B1%BB-%E6%9E%9A%E4%B8%BE%E7%B1%BB%E4%B8%8E%E6%B3%A8%E8%A7%A3/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">Qinghai2021·博客</a>！</span></div></div><div class="tag_share"><div class="post_share"><div class="social-share" data-image="/images/background.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://fastly.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/08/27/%E5%8D%9A%E5%AE%A2%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87/"><img class="prev-cover" src="/images/background.jpg" onerror="onerror=null;src='https://api.ixiaowai.cn/gqapi/gqapi.php'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">关于hexo博客插入图片内容解决方法</div></div></a></div><div class="next-post pull-right"><a href="/2022/08/25/Java%E9%AB%98%E7%BA%A7-%E9%9B%86%E5%90%88-%E6%B3%9B%E5%9E%8B-IO%E6%B5%81/"><img class="next-cover" src="/images/background.jpg" onerror="onerror=null;src='https://api.ixiaowai.cn/gqapi/gqapi.php'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">GitHub + Hexo + Node.js + Git搭建个人博客</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Java-%E7%BC%96%E7%A8%8B%E9%AB%98%E7%BA%A7"><span class="toc-number">1.</span> <span class="toc-text">Java 编程高级</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.1.</span> <span class="toc-text">1.多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">1.程序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">2.进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.1.1.3.</span> <span class="toc-text">3.线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%8D%95%E6%A0%B8%E5%92%8C%E5%A4%9A%E6%A0%B8CPU%E7%90%86%E8%A7%A3"><span class="toc-number">1.1.1.4.</span> <span class="toc-text">4.单核和多核CPU理解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E5%B9%B6%E8%A1%8C%E4%B8%8E%E5%B9%B6%E5%8F%91"><span class="toc-number">1.1.1.5.</span> <span class="toc-text">5.并行与并发</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%A8%8B%E5%BA%8F%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-number">1.1.1.6.</span> <span class="toc-text">6.多线程程序的优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E4%BD%95%E6%97%B6%E9%9C%80%E8%A6%81%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.1.1.7.</span> <span class="toc-text">7.何时需要多线程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E4%BD%BF%E7%94%A8"><span class="toc-number">1.1.2.</span> <span class="toc-text">2.多线程的创建和使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%96%B9%E5%BC%8F%E4%B8%80%EF%BC%9A"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">1.方式一：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E7%BB%A7%E6%89%BF%E4%BA%8EThread%E7%B1%BB"><span class="toc-number">1.1.2.1.1.</span> <span class="toc-text">1.继承于Thread类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA"><span class="toc-number">1.1.2.1.2.</span> <span class="toc-text">2.代码演示</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E9%97%AE%E9%A2%98"><span class="toc-number">1.1.2.1.3.</span> <span class="toc-text">3.问题</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-Thread%E7%B1%BB%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">3.Thread类中的常用方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">1.1.2.3.</span> <span class="toc-text">4.线程的优先级</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E6%96%B9%E5%BC%8F%E4%BA%8C"><span class="toc-number">1.1.2.4.</span> <span class="toc-text">5.方式二</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%AE%9E%E7%8E%B0Runnable-%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.1.2.4.1.</span> <span class="toc-text">1.实现Runnable( ) 接口</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA-1"><span class="toc-number">1.1.2.4.2.</span> <span class="toc-text">2.代码演示</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E6%96%B9%E5%BC%8F%E4%BA%8C%E5%A5%BD%E5%A4%84"><span class="toc-number">1.1.2.4.3.</span> <span class="toc-text">3.方式二好处</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E5%88%9B%E5%BB%BAThread%E7%B1%BB%E7%9A%84%E5%8C%BF%E5%90%8D%E5%AD%90%E7%B1%BB%E7%9A%84%E6%96%B9%E5%BC%8F%E4%BA%8C"><span class="toc-number">1.1.2.5.</span> <span class="toc-text">6.创建Thread类的匿名子类的方式二</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E6%AF%94%E8%BE%83%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">1.1.2.6.</span> <span class="toc-text">7.比较两种方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-%E6%80%BB%E7%BB%93"><span class="toc-number">1.1.2.7.</span> <span class="toc-text">8.总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">1.1.3.</span> <span class="toc-text">3.线程的生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5"><span class="toc-number">1.1.4.</span> <span class="toc-text">4.线程的同步</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%81%AB%E8%BD%A6%E5%8D%96%E7%A5%A8%E9%97%AE%E9%A2%98"><span class="toc-number">1.1.4.1.</span> <span class="toc-text">1.火车卖票问题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%BC%95%E5%85%A5%E4%BE%8B%E5%AD%90%EF%BC%9A"><span class="toc-number">1.1.4.1.1.</span> <span class="toc-text">1.引入例子：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%AD%98%E5%9C%A8%E9%97%AE%E9%A2%98%EF%BC%9A"><span class="toc-number">1.1.4.1.2.</span> <span class="toc-text">2.存在问题：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98%E6%96%B9%E5%BC%8F%E4%B8%80"><span class="toc-number">1.1.4.2.</span> <span class="toc-text">2.解决问题方式一</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.1.4.2.1.</span> <span class="toc-text">1.介绍</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E8%A7%A3%E5%86%B3%E5%AE%9E%E7%8E%B0%E7%B1%BB%E7%9A%84%E5%8D%96%E7%A5%A8"><span class="toc-number">1.1.4.2.2.</span> <span class="toc-text">2.解决实现类的卖票</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E8%A7%A3%E5%86%B3%E7%BB%A7%E6%89%BFThread%E5%8D%96%E7%A5%A8"><span class="toc-number">1.1.4.2.3.</span> <span class="toc-text">3.解决继承Thread卖票</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98%E6%96%B9%E5%BC%8F%E4%BA%8C"><span class="toc-number">1.1.4.3.</span> <span class="toc-text">3.解决问题方式二</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E4%BB%8B%E7%BB%8D-1"><span class="toc-number">1.1.4.3.1.</span> <span class="toc-text">1.介绍</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E8%A7%A3%E5%86%B3%E5%AE%9E%E7%8E%B0%E7%B1%BB%E7%9A%84%E5%8D%96%E7%A5%A8-1"><span class="toc-number">1.1.4.3.2.</span> <span class="toc-text">2.解决实现类的卖票</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E8%A7%A3%E5%86%B3%E7%BB%A7%E6%89%BFThread%E5%8D%96%E7%A5%A8"><span class="toc-number">1.1.4.3.3.</span> <span class="toc-text">2.解决继承Thread卖票</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98%E7%9A%84%E5%88%A9%E5%BC%8A"><span class="toc-number">1.1.4.4.</span> <span class="toc-text">4.解决问题的利弊</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E5%9C%A8%E8%B0%88%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E6%87%92%E6%B1%89%E5%BC%8F"><span class="toc-number">1.1.4.5.</span> <span class="toc-text">5.在谈单例模式懒汉式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98"><span class="toc-number">1.1.4.6.</span> <span class="toc-text">6.死锁问题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E4%BB%8B%E7%BB%8D-2"><span class="toc-number">1.1.4.6.1.</span> <span class="toc-text">1.介绍</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E8%AF%B4%E6%98%8E"><span class="toc-number">1.1.4.6.2.</span> <span class="toc-text">2.说明</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98%E6%96%B9%E5%BC%8F%E4%B8%89"><span class="toc-number">1.1.4.7.</span> <span class="toc-text">7.解决问题方式三</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E7%BA%BF%E7%A8%8B%E7%9A%84%E9%80%9A%E4%BF%A1"><span class="toc-number">1.1.5.</span> <span class="toc-text">5.线程的通信</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BB%8B%E7%BB%8D-3"><span class="toc-number">1.1.5.1.</span> <span class="toc-text">1.介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%B6%89%E5%8F%8A%E4%B8%89%E4%B8%AA%E6%96%B9%E6%B3%95"><span class="toc-number">1.1.5.2.</span> <span class="toc-text">2.涉及三个方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-sleep-%E5%92%8Cwait-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.1.5.3.</span> <span class="toc-text">3.sleep()和wait()的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E7%94%9F%E4%BA%A7%E8%80%85%E5%92%8C%E6%B6%88%E8%B4%B9%E8%80%85%E4%BE%8B%E9%A2%98"><span class="toc-number">1.1.5.4.</span> <span class="toc-text">4.生产者和消费者例题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E4%BC%9A%E9%87%8A%E6%94%BE%E9%94%81%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">1.1.5.5.</span> <span class="toc-text">5.会释放锁的操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E4%B8%8D%E4%BC%9A%E9%87%8A%E6%94%BE%E9%94%81%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">1.1.5.6.</span> <span class="toc-text">6.不会释放锁的操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E5%BC%8F%E4%B8%89"><span class="toc-number">1.1.6.</span> <span class="toc-text">6.创建线程的方式三</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%AE%9E%E7%8E%B0Callable%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.1.6.1.</span> <span class="toc-text">1.实现Callable接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA-2"><span class="toc-number">1.1.6.2.</span> <span class="toc-text">2.代码演示</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E5%BC%8F%E5%9B%9B"><span class="toc-number">1.1.7.</span> <span class="toc-text">7.创建线程的方式四</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">1.1.7.1.</span> <span class="toc-text">1.线程池</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%AF%B4%E6%98%8E%EF%BC%9A"><span class="toc-number">1.1.7.2.</span> <span class="toc-text">2.说明：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA"><span class="toc-number">1.1.7.3.</span> <span class="toc-text">3.代码演示</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%B8%B8%E7%94%A8%E7%B1%BB"><span class="toc-number">1.2.</span> <span class="toc-text">2.常用类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-String"><span class="toc-number">1.2.1.</span> <span class="toc-text">1.String</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-String%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">1.String详细介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-String%E4%B8%A4%E7%A7%8D%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%8C%BA%E5%88%AB"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">2.String两种实例化区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-String%E4%B8%8D%E5%90%8C%E8%BF%9E%E6%8E%A5%E6%93%8D%E4%BD%9C"><span class="toc-number">1.2.1.3.</span> <span class="toc-text">3.String不同连接操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-JVM%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0%E5%AD%98%E6%94%BE%E4%BD%8D%E7%BD%AE%E8%AF%B4%E6%98%8E"><span class="toc-number">1.2.1.4.</span> <span class="toc-text">4.JVM字符串常量池存放位置说明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-String%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.1.5.</span> <span class="toc-text">5.String常用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E4%B8%80%E6%A1%A3"><span class="toc-number">1.2.1.5.1.</span> <span class="toc-text">1.一档</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E4%BA%8C%E6%A1%A3"><span class="toc-number">1.2.1.5.2.</span> <span class="toc-text">2.二档</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E4%B8%89%E6%A1%A3"><span class="toc-number">1.2.1.5.3.</span> <span class="toc-text">3.三档</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-String-%E4%B8%8E%E5%85%B6%E4%BB%96%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.2.1.6.</span> <span class="toc-text">6.String 与其他类型的转换</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%A4%8D%E4%B9%A0%E4%B8%8E%E5%8C%85%E8%A3%85%E7%B1%BB%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.2.1.6.1.</span> <span class="toc-text">1.复习与包装类的转换</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E4%B8%8Echar"><span class="toc-number">1.2.1.6.2.</span> <span class="toc-text">2.与char[ ]</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E4%B8%8Ebyte"><span class="toc-number">1.2.1.6.3.</span> <span class="toc-text">3.与byte [ ]</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-StringBuffer%E5%8F%8ABuilder"><span class="toc-number">1.2.2.</span> <span class="toc-text">2.StringBuffer及Builder</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%9D%A2%E8%AF%95%E9%A2%98-%E4%B8%89%E8%80%85String%E5%BC%82%E5%90%8C"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">1.面试题: 三者String异同</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-StringBuffer%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">2.StringBuffer常用方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%B8%89%E8%80%85%E6%95%88%E7%8E%87%E5%AF%B9%E6%AF%94"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">3.三者效率对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-String%E4%B8%8E%E4%B8%A4%E8%80%85%E7%9A%84%E4%B9%8B%E9%97%B4%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.2.2.4.</span> <span class="toc-text">4.String与两者的之间转换</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%85%B3%E4%BA%8EString%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E9%A2%98"><span class="toc-number">1.2.3.</span> <span class="toc-text">3.关于String常见算法题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%8C%87%E5%AE%9A%E5%AD%97%E7%AC%A6%E5%8F%8D%E8%BD%AC"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">1.指定字符反转</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">2.字符串中出现的次数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E8%8E%B7%E5%8F%96%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9B%B8%E5%90%8C%E5%AD%90%E4%B8%B2"><span class="toc-number">1.2.3.3.</span> <span class="toc-text">3.获取两个字符串中最大相同子串</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-JDK-8%E4%B9%8B%E5%89%8D%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4"><span class="toc-number">1.2.4.</span> <span class="toc-text">4.JDK 8之前日期和时间</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-System%E7%B1%BB"><span class="toc-number">1.2.4.1.</span> <span class="toc-text">1.System类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-date%E7%B1%BB"><span class="toc-number">1.2.4.2.</span> <span class="toc-text">2.date类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-SimpleDateFormat%E7%B1%BB"><span class="toc-number">1.2.4.3.</span> <span class="toc-text">3.SimpleDateFormat类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-Calendar%E6%97%A5%E5%8E%86%E7%B1%BB"><span class="toc-number">1.2.4.4.</span> <span class="toc-text">4.Calendar日历类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="toc-number">1.2.4.4.1.</span> <span class="toc-text">1.实例化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.4.4.2.</span> <span class="toc-text">2.常用方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E7%BB%83%E4%B9%A0"><span class="toc-number">1.2.4.4.3.</span> <span class="toc-text">3.练习</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-JDK8%E4%B8%AD%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4"><span class="toc-number">1.2.5.</span> <span class="toc-text">5.JDK8中日期和时间</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%80%BB%E4%BD%93%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.2.5.1.</span> <span class="toc-text">1.总体介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-LocalDate-x2F-Time-x2F-DateTime"><span class="toc-number">1.2.5.2.</span> <span class="toc-text">1.LocalDate&#x2F;Time&#x2F;DateTime</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%87%BA%E7%8E%B0%E8%83%8C%E6%99%AF"><span class="toc-number">1.2.5.2.1.</span> <span class="toc-text">1.出现背景</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E4%B8%BB%E8%A6%81%E4%BB%8B%E7%BB%8D%E5%8F%8A%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.5.2.2.</span> <span class="toc-text">2.主要介绍及方法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Instan%E7%B1%BB%E7%9E%AC%E6%97%B6"><span class="toc-number">1.2.5.3.</span> <span class="toc-text">2.Instan类瞬时</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-DateTimeFormatter-%E7%B1%BB"><span class="toc-number">1.2.5.4.</span> <span class="toc-text">3.DateTimeFormatter 类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-Java%E6%AF%94%E8%BE%83%E5%99%A8"><span class="toc-number">1.2.6.</span> <span class="toc-text">6.Java比较器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BB%8B%E7%BB%8D-4"><span class="toc-number">1.2.6.1.</span> <span class="toc-text">1.介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Comparable%E8%87%AA%E7%84%B6%E6%8E%92%E5%BA%8F"><span class="toc-number">1.2.6.2.</span> <span class="toc-text">2.Comparable自然排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-Comparator%E5%AE%9A%E5%88%B6%E6%8E%92%E5%BA%8F"><span class="toc-number">1.2.6.3.</span> <span class="toc-text">3.Comparator定制排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E8%87%AA%E5%AE%9A%E4%B9%89Comparator%E7%B1%BB"><span class="toc-number">1.2.6.4.</span> <span class="toc-text">3.自定义Comparator类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-System%E7%B1%BB"><span class="toc-number">1.2.7.</span> <span class="toc-text">7.System类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BB%8B%E7%BB%8D-5"><span class="toc-number">1.2.7.1.</span> <span class="toc-text">1.介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.7.2.</span> <span class="toc-text">2.成员方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-Math%E7%B1%BB"><span class="toc-number">1.2.8.</span> <span class="toc-text">8.Math类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BB%8B%E7%BB%8D-6"><span class="toc-number">1.2.8.1.</span> <span class="toc-text">1.介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-1"><span class="toc-number">1.2.8.2.</span> <span class="toc-text">2.常用方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-BigInteger%E7%B1%BB"><span class="toc-number">1.2.9.</span> <span class="toc-text">9.BigInteger类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BB%8B%E7%BB%8D-7"><span class="toc-number">1.2.9.1.</span> <span class="toc-text">1.介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-2"><span class="toc-number">1.2.9.2.</span> <span class="toc-text">2.常用方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-BigDecimal%E7%B1%BB"><span class="toc-number">1.2.10.</span> <span class="toc-text">10.BigDecimal类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BB%8B%E7%BB%8D-8"><span class="toc-number">1.2.10.1.</span> <span class="toc-text">1.介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-3"><span class="toc-number">1.2.10.2.</span> <span class="toc-text">2.常用方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%9E%9A%E4%B8%BE%E7%B1%BB%E4%B8%8E%E6%B3%A8%E8%A7%A3"><span class="toc-number">1.3.</span> <span class="toc-text">3.枚举类与注解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%9E%9A%E4%B8%BE%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">1.3.1.</span> <span class="toc-text">1.枚举类的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BB%8B%E7%BB%8D-9"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">1.介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%9E%9A%E4%B8%BE%E7%B1%BB"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">2.自定义枚举类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%A6%82%E4%BD%95%E8%87%AA%E5%AE%9A%E4%B9%89%E6%9E%9A%E4%B8%BE%E7%B1%BB"><span class="toc-number">1.3.1.2.1.</span> <span class="toc-text">1.如何自定义枚举类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%A3%B0%E6%98%8E%E8%B0%83%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E6%9E%9A%E4%B8%BE%E7%B1%BB"><span class="toc-number">1.3.1.2.2.</span> <span class="toc-text">2.声明调用自定义枚举类</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-enum%E5%85%B3%E9%94%AE%E5%AD%97%E5%AE%9A%E4%B9%89%E6%9E%9A%E4%B8%BE%E7%B1%BB"><span class="toc-number">1.3.1.3.</span> <span class="toc-text">3.enum关键字定义枚举类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%A6%82%E4%BD%95%E5%AE%9A%E4%B9%89enum%E7%B1%BB"><span class="toc-number">1.3.1.3.1.</span> <span class="toc-text">1.如何定义enum类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-enum%E7%B1%BB%E4%B8%AD%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.1.3.2.</span> <span class="toc-text">2.enum类中常用方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-enum%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.3.1.3.3.</span> <span class="toc-text">3.enum枚举类实现接口</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%B3%A8%E8%A7%A3Annotation"><span class="toc-number">1.3.2.</span> <span class="toc-text">2.注解Annotation</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%B3%A8%E8%A7%A3%E7%9A%84%E6%A6%82%E8%BF%B0"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">1.注解的概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Annocation%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">2.Annocation使用示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%A6%82%E4%BD%95%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3"><span class="toc-number">1.3.2.3.</span> <span class="toc-text">3.如何自定义注解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-jdk-%E6%8F%90%E4%BE%9B%E7%9A%844%E7%A7%8D%E5%85%83%E6%B3%A8%E8%A7%A3"><span class="toc-number">1.3.2.4.</span> <span class="toc-text">4.jdk 提供的4种元注解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E9%80%9A%E8%BF%87%E5%8F%8D%E5%B0%84%E8%8E%B7%E5%8F%96%E6%B3%A8%E8%A7%A3%E4%BF%A1%E6%81%AF"><span class="toc-number">1.3.2.5.</span> <span class="toc-text">5.通过反射获取注解信息</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%8F%AF%E9%87%8D%E5%A4%8D%E6%B3%A8%E8%A7%A3"><span class="toc-number">1.3.2.5.1.</span> <span class="toc-text">1.可重复注解</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E7%B1%BB%E5%9E%8B%E6%B3%A8%E8%A7%A3"><span class="toc-number">1.3.2.5.2.</span> <span class="toc-text">2.类型注解</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Qinghai2021</div><div class="author-info__description">阳光宅男💛</div></div><div class="card-info-social-icons is-center"><a class="social-icon" href="//github.com/Qinghai2021?tab=repositories" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:xxxxxx@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">来的都是大哥！</div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/09/07/Linux%E9%9D%99%E6%80%81%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/" title="Linux静态网络配置">Linux静态网络配置</a><time datetime="2022-09-07T13:22:52.000Z" title="发表于 2022-09-07 21:22:52">2022-09-07</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/09/07/Linux%E5%85%8B%E9%9A%86%E5%90%8E%E6%97%A0%E6%B3%95%E9%87%8D%E5%90%AF%E7%BD%91%E7%BB%9C/" title="Linux克隆后无法重启网络">Linux克隆后无法重启网络</a><time datetime="2022-09-07T13:04:31.000Z" title="发表于 2022-09-07 21:04:31">2022-09-07</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/08/27/%E5%8D%9A%E5%AE%A2%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87/" title="关于hexo博客插入图片内容解决方法">关于hexo博客插入图片内容解决方法</a><time datetime="2022-08-26T16:00:00.000Z" title="发表于 2022-08-27 00:00:00">2022-08-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/08/25/Java%E9%AB%98%E7%BA%A7-%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%B8%B8%E7%94%A8%E7%B1%BB-%E6%9E%9A%E4%B8%BE%E7%B1%BB%E4%B8%8E%E6%B3%A8%E8%A7%A3/" title="GitHub + Hexo + Node.js + Git搭建个人博客">GitHub + Hexo + Node.js + Git搭建个人博客</a><time datetime="2022-08-25T09:45:41.000Z" title="发表于 2022-08-25 17:45:41">2022-08-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/08/25/Java%E9%AB%98%E7%BA%A7-%E9%9B%86%E5%90%88-%E6%B3%9B%E5%9E%8B-IO%E6%B5%81/" title="GitHub + Hexo + Node.js + Git搭建个人博客">GitHub + Hexo + Node.js + Git搭建个人博客</a><time datetime="2022-08-25T09:45:41.000Z" title="发表于 2022-08-25 17:45:41">2022-08-25</time></div></div></div></div></div></div></main><footer id="footer" style="background: #FFFFFF"><div id="footer-wrap"><div class="copyright">&copy;2022 By Qinghai2021</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/chenxz21/hexo-theme-bcxm">Bcxm</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://fastly.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><div class="js-pjax"></div><script type="text/javascript" src="https://fastly.jsdelivr.net/npm/leancloud-storage@4.10.0/dist/av-min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://fastly.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script id="click-heart" src="https://fastly.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>