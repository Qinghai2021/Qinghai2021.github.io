<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-06-15T05:14:35.138Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://example.com/2022/08/25/Java%20%E4%B9%A0%E9%A2%98/"/>
    <id>http://example.com/2022/08/25/Java%20%E4%B9%A0%E9%A2%98/</id>
    <published>2022-08-25T05:11:00.425Z</published>
    <updated>2022-06-15T05:14:35.138Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-数据结构"><a href="#Java-数据结构" class="headerlink" title="Java 数据结构"></a>Java 数据结构</h1><h2 id="入门篇"><a href="#入门篇" class="headerlink" title="入门篇"></a>入门篇</h2><h3 id="1-matches-方法"><a href="#1-matches-方法" class="headerlink" title="1. matches() 方法"></a>1. matches() 方法</h3><p>说明：matches() 方法用于检测字符串是否匹配给定的正则表达式。</p><p>将正则表达式内置其中</p><p>例题：</p><p><img src="/Java%E7%BB%83%E4%B9%A0_img%5CSnipaste_2022-03-15_20-40-21.png" alt="Snipaste_2022-03-15_20-40-21"></p><h3 id="2-String-与基本数据类型的转换"><a href="#2-String-与基本数据类型的转换" class="headerlink" title="2. String 与基本数据类型的转换"></a>2. String 与基本数据类型的转换</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">基本数据类型、包装类--&gt;String类型.</span><br><span class="line">调用String重载的valueOf(Xxx  xxx)</span><br><span class="line"><span class="type">int</span> <span class="variable">num1</span>  <span class="operator">=</span> <span class="number">10</span> ;</span><br><span class="line"><span class="type">Integer</span>  <span class="variable">num2</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">方式一：</span><br><span class="line"><span class="type">String</span>  <span class="variable">str1</span> <span class="operator">=</span> num1 +<span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="type">String</span>  <span class="variable">str2</span>  <span class="operator">=</span> num2 +<span class="string">&quot;&quot;</span>;</span><br><span class="line">方式二：</span><br><span class="line"><span class="type">String</span>  <span class="variable">str1</span> <span class="operator">=</span> String . valueOf(num1)；</span><br><span class="line"><span class="type">String</span>  <span class="variable">str2</span> <span class="operator">=</span> String . valueOf(num2)；</span><br><span class="line">String类型---&gt;基本数据类型、包装类.</span><br><span class="line">调用包装类的parseXxx(String   s  )</span><br><span class="line"><span class="type">String</span>  <span class="variable">str1</span>  <span class="operator">=</span>  <span class="string">&quot;123&quot;</span>;</span><br><span class="line"><span class="type">int</span>  <span class="variable">num1</span> <span class="operator">=</span> Integer . parseInt(str1)  ;</span><br><span class="line"><span class="type">Integer</span>  <span class="variable">num2</span> <span class="operator">=</span> Integer . parseInt(str1)  ;</span><br></pre></td></tr></table></figure><p><img src="/Java%E7%BB%83%E4%B9%A0_img%5CSnipaste_2022-03-15_20-58-27.png" alt="Snipaste_2022-03-15_20-58-27"></p><h3 id="3-Scanner-输入"><a href="#3-Scanner-输入" class="headerlink" title="3.Scanner 输入"></a>3.Scanner 输入</h3><ol><li>Scanner的实例化：Scanner scan &#x3D; new Scanner(System.in);</li><li>调用Scanner类的相关方法（next（）这是输入String类型特殊&#x2F;nextXxx（）这是输入其他类型的)</li></ol><p>hasNextInt() : 判断从控制台输入的数据是否是该类型，返回一个boolean类型 ，是否是Int 类型</p><p><img src="/Java%E7%BB%83%E4%B9%A0_img%5Cimage-20220315212214358.png" alt="image-20220315212214358"></p><h3 id="4-求二维数组的长度"><a href="#4-求二维数组的长度" class="headerlink" title="4.求二维数组的长度"></a>4.求二维数组的长度</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[][] arr = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;&#125;;</span><br><span class="line">System.out.println(arr.length); <span class="comment">//求行数</span></span><br><span class="line">System.out.println(arr[<span class="number">1</span>].length); <span class="comment">//求每行列数</span></span><br></pre></td></tr></table></figure><p>5.Class类newInstance</p><p><strong>Class.forName：</strong>静态方法，返回与给定的字符串名称相关联<strong>类</strong>或<strong>接口</strong>的Class对象</p><p><strong>newInstance()：</strong>可以为类创建一个实例 x.getClass.newInstance()，创建了一个同x一样类型的新实例。newInstance()方法调用默认构造器（无参数构造器）初始化新建对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String className = scanner.next();</span><br><span class="line">Class.forName(className).newInstance();</span><br></pre></td></tr></table></figure><h3 id="5-Random类"><a href="#5-Random类" class="headerlink" title="5.Random类"></a>5.Random类</h3><h4 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h4><p>来自  java.util.Random 的类 ； </p><p>其作用是 生成一个随机数；</p><p>seed ： 种子 ； 改变生成的随机数  ；如果确定种子 ，则每次生成的随机数都相同 </p><p>构造器：</p><p>public Random(){  }   空参构造器   seed 是现在时间的毫秒数计算的</p><p>public  Random( long  seed ) { }  带参构造器  </p><p>通过调用 setSeed(  ) 设置种子</p><p>使用：</p><p>通过 nextXxx() 可进行调用  </p><p>例如 nextInt( )  生成一个 int 范围内的随机数</p><p>通过nextXxx( int  bounds )  可修改范围</p><p>例如 nextInt( 10)  [  0 ,  10 ) 之间的一个数</p><pre><code>    Random r = new Random(2);    System.out.println(r.nextInt());//-1154715079        System.out.println(r.nextInt());//1260042744</code></pre><h3 id="6-输出年份各月天数"><a href="#6-输出年份各月天数" class="headerlink" title="6.输出年份各月天数"></a>6.输出年份各月天数</h3><p>输入任意年份，输出该年份各月天数（请使用 Calendar 类中的方法）</p><p>输入描述：</p><p>任意年份（int类型整数）</p><p>输出描述：</p><p>x年1月:yy天</p><p>x年2月:yy天</p><p>x年3月:yy天</p><p>x年4月:yy天<br>x年5月:yy天<br>x年6月:yy天<br>x年7月:yy天<br>x年8月:yy天<br>x年9月:yy天<br>x年10月:yy天<br>x年11月:yy天<br>x年12月:yy天（x为输入的任意年份，yy为当月天数）</p><p>输入任意年份，输出该年份各月天数（请使用 Calendar 类中的方法）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Calendar ints = Calendar.getInstance(); //获取默认时区时间的日历</span><br><span class="line">        for( int month=1 ; month &lt;=12 ; month ++ )&#123;</span><br><span class="line">            ints.set(year,month,0);  //设置指定日期</span><br><span class="line">        System.out.println(year + &quot;年&quot; + month + &quot;月:&quot; + ints.get(Calendar.DAY_OF_MONTH) + &quot;天&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">//get(int filed) 执行字段返回该字段想要信息</span><br><span class="line">//DAY_OF_MONTH  月的天数</span><br></pre></td></tr></table></figure><h3 id="7-split-分割的字符串数组"><a href="#7-split-分割的字符串数组" class="headerlink" title="7.split() 分割的字符串数组"></a>7.split() 分割的字符串数组</h3><p>String str1[]&#x3D;str.split(“ -” );<br>意思为：以 - 为分隔符将str字符串分割成一个字符串数组。</p><h3 id="8-Deque接口"><a href="#8-Deque接口" class="headerlink" title="8.Deque接口"></a>8.Deque接口</h3><p>参考文章：<a href="https://blog.csdn.net/devnn/article/details/82716447">(64条消息) 【Java】Java双端队列Deque使用详解_devnn的博客-CSDN博客_deque java</a></p><p><strong>Deque是一个双端队列接口，继承自Queue接口</strong>，Deque的实现类是LinkedList、ArrayDeque、LinkedBlockingDeque，其中LinkedList是最常用的。</p><p>关于Queue的介绍可以看上一篇文章：Java队列Queue使用详解</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Deque有三种用途：</span><br><span class="line">普通队列(一端进另一端出):</span><br><span class="line">Queue queue = new LinkedList()或Deque deque = new LinkedList()</span><br><span class="line">双端队列(两端都可进出)</span><br><span class="line">Deque deque = new LinkedList()</span><br><span class="line">堆栈</span><br><span class="line">Deque deque = new LinkedList()</span><br></pre></td></tr></table></figure><p>注意：Java堆栈Stack类已经过时，Java官方推荐使用Deque替代Stack使用。Deque堆栈操作方法：push()、pop()、peek()。</p><p>Deque是一个线性collection，支持在两端插入和移除元素。名称 deque 是“double ended queue（双端队列）”的缩写，通常读为“deck”。大多数 Deque 实现对于它们能够包含的元素数没有固定限制，但此接口既支持有容量限制的双端队列，也支持没有固定大小限制的双端队列。</p><p>此接口定义在双端队列两端访问元素的方法。提供插入、移除和检查元素的方法。每种方法都存在两种形式：一种形式在操作失败时抛出异常，另一种形式返回一个特殊值（null 或 false，具体取决于操作）。插入操作的后一种形式是专为使用有容量限制的 Deque 实现设计的；在大多数实现中，插入操作不能失败。</p><p>使用方法：</p><p>add()  默认从末尾开始加入元素 </p><p>addLast()  addFirst()  指定加入方向</p><p>同样的有删除remove()  removeLast()  removeFirst()</p><p>检查 ：get()  getLast()  getFirst()</p><p>isEmpty( )  检查是否空</p><h3 id="9-统计一句话中重复单词的个数"><a href="#9-统计一句话中重复单词的个数" class="headerlink" title="9.统计一句话中重复单词的个数"></a>9.统计一句话中重复单词的个数</h3><p>涉及Map基本使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">        Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;Character, Integer&gt;();</span><br><span class="line">   <span class="comment">//write your code here......</span></span><br><span class="line">    line = line.replaceAll(<span class="string">&quot;[^a-zA-Z]&quot;</span>,<span class="string">&quot;&quot;</span>); <span class="comment">//替换多有非字母的字符为无</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> line.length();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>( <span class="type">int</span> i=<span class="number">0</span> ; i&lt;t ; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(map.get(line.charAt(i)) == <span class="literal">null</span>)&#123;</span><br><span class="line">            map.put(line.charAt(i),<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            map.put(line.charAt(i),map.get(line.charAt(i))+<span class="number">1</span>);  <span class="comment">//更新数据</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Set&lt;Map.Entry&lt;Character, Integer&gt;&gt; entrys = map.entrySet();  <span class="comment">//获取entry键值对集合</span></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Character, Integer&gt; entry : entrys) &#123;     </span><br><span class="line">        System.out.println(entry.getKey() + <span class="string">&quot;:&quot;</span> + entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-map简单应用"><a href="#10-map简单应用" class="headerlink" title="10.map简单应用"></a>10.map简单应用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">        Map&lt;Integer, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, String&gt;();</span><br><span class="line">        map.put(<span class="number">1</span>, <span class="string">&quot;Amy&quot;</span>);</span><br><span class="line">        map.put(<span class="number">2</span>, <span class="string">&quot;Joe&quot;</span>);</span><br><span class="line">        map.put(<span class="number">3</span>, <span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">        map.put(<span class="number">4</span>, <span class="string">&quot;Susan&quot;</span>);</span><br><span class="line">    <span class="comment">//write your code here......</span></span><br><span class="line">    Set&lt;Map.Entry&lt;Integer,String&gt;&gt; entrys = map.entrySet();</span><br><span class="line">    <span class="keyword">for</span>(Map.Entry&lt;Integer,String&gt; entry : entrys)&#123;</span><br><span class="line">        System.out.println(entry.getKey() + <span class="string">&quot;:&quot;</span> + entry.getValue()); <span class="comment">//是输出修改前的</span></span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    map.put(<span class="number">5</span>,name); <span class="comment">//加元素</span></span><br><span class="line">    map.remove(<span class="number">4</span>);    <span class="comment">//移除</span></span><br><span class="line">    map.put(<span class="number">3</span>,<span class="string">&quot;Tommy&quot;</span>);  <span class="comment">//修改</span></span><br><span class="line">    </span><br><span class="line">    System.out.println();   </span><br><span class="line">        <span class="comment">//获取过的entry集合不用再次获取，内容是动态变化的</span></span><br><span class="line">    <span class="keyword">for</span>(Map.Entry&lt;Integer,String&gt; entry : entrys)&#123;</span><br><span class="line">        System.out.println(entry.getKey() + <span class="string">&quot;:&quot;</span> + entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​<br>​      &#x2F;&#x2F;统计字符串中空格、字母、数字、的个数<br>​      char[] c1 &#x3D; str.toCharArray();<br>​       for(int i&#x3D;0 ; i&lt; c1.length ; i++){  &#x2F;&#x2F;char数组的长度表达 c1.length<br>​            if(c1[i]&#x3D;&#x3D;’ ‘){   &#x2F;&#x2F;可用’’ +字符表达 ， 也可用ASCII码表达进行比较<br>​                space++;<br>​            }else if(c1[i]&gt;&#x3D;’0’ &amp;&amp; c1[i]&lt;&#x3D;’9’){<br>​                numbers++;<br>​            }else if(c1[i]&gt;&#x3D;’a’ &amp;&amp; c1[i]&lt;&#x3D;’z’ || c1[i]&gt;&#x3D;’A’ &amp;&amp; c1[i]&lt;&#x3D;’Z’){<br>​                words++;<br>​            }else{<br>​                other++;<br>​            }<br>​        }</p><h3 id="11-将HashSet中元素变成数组"><a href="#11-将HashSet中元素变成数组" class="headerlink" title="11.将HashSet中元素变成数组"></a>11.将HashSet中元素变成数组</h3><p><strong>JAVA47</strong> <strong>记录点赞用户</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//方式一</span></span><br><span class="line"> <span class="keyword">public</span> String[] getLikeUsers()&#123;</span><br><span class="line">        String[] arr = <span class="keyword">new</span> <span class="title class_">String</span>[set.size()];</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">ite</span> <span class="operator">=</span> set.iterator();</span><br><span class="line">        <span class="keyword">while</span>(ite.hasNext())&#123;</span><br><span class="line">            arr[i] = (String)ite.next();</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;    </span><br><span class="line"> <span class="comment">//方式二题解</span></span><br><span class="line">    <span class="comment">//return  names.toArray(new String[0]); String[0] 大小随意，只要写就行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="1-替换空格"><a href="#1-替换空格" class="headerlink" title="1.替换空格"></a>1.替换空格</h3><h4 id="关于数据结构的第一题"><a href="#关于数据结构的第一题" class="headerlink" title="关于数据结构的第一题"></a>关于数据结构的第一题</h4><p> 替换String中的空格为%20 ，此方法使用String中的replace(“ “ , “%20”) , 通过了，但是看了题解用的方法却稍微麻烦<br> 原因是：直接使用replace（）效率会慢，而是采用效率更高的方法</p><h4 id="关于replace-底层源码"><a href="#关于replace-底层源码" class="headerlink" title="关于replace 底层源码"></a>关于replace 底层源码</h4><p> 使用多种方法，效率不如遍历+连接的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">replace</span><span class="params">(CharSequence target, CharSequence replacement)</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> Pattern.compile(target.toString(), Pattern.LITERAL).matcher(                <span class="built_in">this</span>).replaceAll(Matcher.quoteReplacement(replacement.toString()));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p> StringBuffer + append()<br> 具体代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">replaceSpace</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span>(Character c : s.toCharArray())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">&#x27; &#x27;</span>) res.append(<span class="string">&quot;%20&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> res.append(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="关于StringBuffer和StringBuilder"><a href="#关于StringBuffer和StringBuilder" class="headerlink" title="关于StringBuffer和StringBuilder"></a>关于StringBuffer和StringBuilder</h4><p>在java中频繁使用字符串拼接，会在方法区中占用大量内存，因为java中字符串是不可变的，每一次拼接都会产生新字符串，即<strong>要在字符串常量池中开辟新的空间存储它（产生新的对象）。所以就有了StringBuffer这个类，用来解决字符串拼接造成方法区内存浪费的问题</strong>（StringBuffer 和 StringBuilder 类的对象能够被多次的修改，并且不产生新的未使用对象）。那么下面我们来看一下它的具体实现：</p><p>1.首先创建StringBuffer对象，它的默认初始化容量（字符串缓冲区）是16（无参构造情况下），这个我们通过看JDK中的源代码可以知道。</p><p>2.<strong>StringBuffe底层实际上是一个byte数组（jdk版本不同可能为char数组），用来存放修改后的字符串</strong>，即不用在字符串常量池中创建新的对象。</p><p>3.<strong>你可以调用append方法，往里面添加字符串，底层数组满了，会自动进行扩容</strong>（底层调用了System.arraycopy()方法，对数组进行扩容，实质就是指向一个更大的数组，原来那个小的由垃圾回收器回收）。</p><p>4.为了提高StringBuffer的性能，应根据实际情况确定初始化容量，减少底层数组扩容次数。</p><p>5.<strong>StringBuffer和StringBuilder的区别：前者的方法都有synchronized修饰，表示在多线程环境下运行时是安全的，后者没有，在多线程环境下运行是不安全的。</strong>但<strong>StringBuilder 相较于 StringBuffer 有速度优势，所以多数情况下建议使用 StringBuilder 类。</strong></p><h3 id="2-从尾到头打印链表"><a href="#2-从尾到头打印链表" class="headerlink" title="2.从尾到头打印链表"></a>2.从尾到头打印链表</h3><h4 id="方法一：递归法"><a href="#方法一：递归法" class="headerlink" title="方法一：递归法"></a>方法一：递归法</h4><p>利用递归，先递推至链表末端；回溯时，依次将节点值加入列表，即可实现链表值的倒序输出。</p><ul><li><strong>时间复杂度 O(N)：</strong> 遍历链表，递归 <em>N</em> 次。</li><li><strong>空间复杂度 O(N)：</strong> 系统递归需要使用 O(N)的栈空间</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void recur(ListNode head) &#123;</span><br><span class="line">        if(head == null) return;</span><br><span class="line">        recur(head.next);</span><br><span class="line">        tmp.add(head.val);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="方法二：辅助栈法"><a href="#方法二：辅助栈法" class="headerlink" title="方法二：辅助栈法"></a>方法二：辅助栈法</h4><p>链表只能 <strong>从前至后</strong> 访问每个节点，而题目要求 <strong>倒序输出</strong> 各节点值，这种 <strong>先入后出</strong> 的需求可以借助 <strong>栈</strong> 来实现。</p><ul><li><strong>时间复杂度 O(N)O(N)：</strong> 入栈和出栈共使用 O(N)O(N) 时间。</li><li><strong>空间复杂度 O(N)O(N)：</strong> 辅助栈 stack 和数组 res 共使用 O(N)O(N) 的额外空间。</li></ul><p><strong>Java 数组长度不可变，因此使用 List 先存储，再转为数组并返回。</strong></p><p><strong>使用方法说明LinkedList：</strong></p><p><strong>void addLast(Object o)</strong>  传递一个对象作为参数，并且该对象将添加到链接列表的末尾</p><p><strong>public E removeLast()</strong>    方法移除并返回此列表的最后一个元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] reversePrint(ListNode head) &#123;</span><br><span class="line">        LinkedList&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="literal">null</span>) &#123;</span><br><span class="line">            stack.addLast(head.val);</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[stack.size()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; res.length; i++)</span><br><span class="line">            res[i] = stack.removeLast();</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-用两个栈实现队列"><a href="#3-用两个栈实现队列" class="headerlink" title="3.用两个栈实现队列"></a>3.用两个栈实现队列</h3><p><strong>解题思路：</strong></p><p>在Java中没有给出队列，但能用LinkedList双向链表来实现，由于题目要求使用双栈实现队列，因为栈底元素无法直接删除，需要将上方所有元素出栈。列表倒序操作可使用双栈实现：栈A元素出栈过滤到栈B，倒序后，B 执行出栈则相当于删除了 A 的栈底元素，即对应队首元素。</p><p>注：使用一个LinkedList对象也能实现队列，速度快于双栈</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public void appendTail(int value) &#123;</span><br><span class="line">   A.addLast(value);</span><br><span class="line"> &#125;</span><br><span class="line"> public int deleteHead() &#123;</span><br><span class="line">   if(A.isEmpty())&#123;</span><br><span class="line">     return -1;</span><br><span class="line">   &#125;</span><br><span class="line">   return A.removeFirst();</span><br></pre></td></tr></table></figure><p><strong>时间复杂度：</strong> appendTail()函数为 O(1) ；deleteHead() 函数在 N次队首元素删除操作中总共需完成 N个元素的倒序。<br><strong>空间复杂度 O(N)</strong> ： 最差情况下，栈 A 和 B 共保存 N个元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CQueue</span> &#123;</span><br><span class="line">    LinkedList&lt;Integer&gt; A, B;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        A = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line">        B = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">appendTail</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        A.addLast(value);  <span class="comment">//添加元素到后尾</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">deleteHead</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(!B.isEmpty()) <span class="keyword">return</span> B.removeLast();  <span class="comment">//删除后尾元素</span></span><br><span class="line">        <span class="keyword">if</span>(A.isEmpty()) <span class="keyword">return</span> -<span class="number">1</span>;   <span class="comment">//如上B为空，A也为空则返回-1</span></span><br><span class="line">        <span class="keyword">while</span>(!A.isEmpty())</span><br><span class="line">            B.addLast(A.removeLast());  <span class="comment">//将A中元素从后尾依次从B的后尾加入，则就可实现A的头可以在出栈时先出</span></span><br><span class="line">        <span class="keyword">return</span> B.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="关于LinkedList"><a href="#关于LinkedList" class="headerlink" title="关于LinkedList"></a>关于LinkedList</h4><p>对于频繁的插入、删除操作，使用此类效率比ArrayList高；底层使用双向链表存储</p><p>常用方法的介绍：</p><ul><li><ul><li><table><thead><tr><th><code>boolean</code></th><th><code>add(E e)</code>  将指定的元素追加到此列表的末尾。</th></tr></thead><tbody><tr><td><code>void</code></td><td><code>add(int index, E element)</code>  在此列表中的指定位置插入指定的元素。</td></tr><tr><td><code>boolean</code></td><td><code>addAll(Collection&lt;? extends E&gt; c)</code>  按照指定集合的迭代器返回的顺序将指定集合中的所有元素追加到此列表的末尾。</td></tr><tr><td><code>boolean</code></td><td><code>addAll(int index,  Collection&lt;? extends E&gt; c)</code>  将指定集合中的所有元素插入到此列表中，从指定的位置开始。</td></tr><tr><td><code>void</code></td><td><code>addFirst(E e)</code>  在该列表开头插入指定的元素。</td></tr><tr><td><code>void</code></td><td><code>addLast(E e)</code>  将指定的元素追加到此列表的末尾。</td></tr></tbody></table></li></ul></li></ul><p>addLast()方法和不带索引的add()方法实现的效果一样.</p><ul><li><ul><li><table><thead><tr><th><code>E</code></th><th><code>remove()</code>  检索并删除此列表的头（第一个元素）。</th></tr></thead><tbody><tr><td><code>E</code></td><td><code>remove(int index)</code>  删除该列表中指定位置的元素。</td></tr><tr><td><code>boolean</code></td><td><code>remove(Object o)</code>  从列表中删除指定元素的第一个出现（如果存在）。</td></tr><tr><td><code>E</code></td><td><code>removeFirst()</code>  从此列表中删除并返回第一个元素。</td></tr><tr><td><code>boolean</code></td><td><code>removeFirstOccurrence(Object o)</code>  删除此列表中指定元素的第一个出现（从头到尾遍历列表时）。</td></tr><tr><td><code>E</code></td><td><code>removeLast()</code>  从此列表中删除并返回最后一个元素。</td></tr></tbody></table></li></ul></li></ul><p>还有一些其他集合类常用的方法，这里就不过多介绍了</p><h4 id="关于Stack"><a href="#关于Stack" class="headerlink" title="关于Stack"></a>关于Stack</h4><p><code>Stack</code>类代表最先进先出（LIFO）堆栈的对象。  它扩展了类别<code>Vector</code>与五个操作，允许一个向量被视为堆栈。</p><p> 设置在通常的<code>push</code>和<code>pop</code>操作，以及作为一种方法来<code>peek</code>在堆栈，以测试堆栈是否为<code>empty</code>的方法，以及向<code>search</code>在栈中的项目的方法在顶部项目和发现多远它是从顶部</p><ul><li><ul><li><table><thead><tr><th><code>boolean</code></th><th><code>empty()</code>  测试此堆栈是否为空。</th></tr></thead><tbody><tr><td><code>E</code></td><td><code>peek()</code>  查看此堆栈顶部的对象，而不从堆栈中删除它。</td></tr><tr><td><code>E</code></td><td><code>pop()</code>  删除此堆栈顶部的对象，并将该对象作为此函数的值返回。</td></tr><tr><td><code>E</code></td><td><code>push(E item)</code>  将项目推送到此堆栈的顶部。</td></tr><tr><td><code>int</code></td><td><code>search(Object o)</code>  返回一个对象在此堆栈上的基于1的位置。</td></tr></tbody></table></li></ul></li></ul><h3 id="4-剑指-Offer-30-包含min函数的栈"><a href="#4-剑指-Offer-30-包含min函数的栈" class="headerlink" title="4.剑指 Offer 30. 包含min函数的栈"></a>4.剑指 Offer 30. 包含min函数的栈</h3><p>解题思路：<br>普通栈的 push() 和 pop() 函数的复杂度为 O(1)O(1) ；而获取栈最小值 min() 函数需要遍历整个栈，复杂度为 O(N)O(N) 。</p><p><strong>本题难点： 将 min() 函数复杂度降为 O(1)O(1)</strong> ，可通过建立辅助栈实现；<br>数据栈 AA ： 栈 AA 用于存储所有元素，保证入栈 push() 函数、出栈 pop() 函数、获取栈顶 top() 函数的正常逻辑。<br>辅助栈 BB ： <strong>栈 BB 中存储栈 AA 中所有 非严格降序 的元素，则栈 AA 中的最小元素始终对应栈 BB 的栈顶元素</strong>，即 min() 函数只需返回栈 BB 的栈顶元素即可。<br>因此，只需设法维护好 栈 BB 的元素，使其保持<strong>非严格降序</strong>，即可实现 min() 函数的 O(1)O(1) 复杂度。</p><p>链接：<a href="https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/solution/mian-shi-ti-30-bao-han-minhan-shu-de-zhan-fu-zhu-z/">https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/solution/mian-shi-ti-30-bao-han-minhan-shu-de-zhan-fu-zhu-z/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">  </span><br><span class="line">  Stack&lt;Integer&gt; stackA,stackB;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">MinStack</span><span class="params">()</span> &#123;</span><br><span class="line">   stackA = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;Integer&gt;();</span><br><span class="line">  stackB = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;Integer&gt;();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(stackB.isEmpty() || stackB.peek()&gt;= x)(</span><br><span class="line">      stackB.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    stackA.push(x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(stackA.peek().equals(stackB.peek()))&#123;  <span class="comment">//此题如果用==将会无法通过 Integer的equals重写过，比较的                       是内部value的值， ==如果在[-128,127]会被cache缓存,超过这个范围则比较的是对象是否相同</span></span><br><span class="line">      stackB.pop();</span><br><span class="line">    &#125;</span><br><span class="line">   stackA.pop();</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> stackA.peek();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">min</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> stackB.peek();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-剑指-Offer-24-反转链表"><a href="#5-剑指-Offer-24-反转链表" class="headerlink" title="5.剑指 Offer 24. 反转链表"></a>5.剑指 Offer 24. 反转链表</h3><p>假设链表为1→2→3→∅，我们想要把它改成∅←1←2←3。</p><p><strong>在遍历链表时，将当前节点的next 指针改为指向前一个节点</strong>。由于节点没有引用其前一个节点，因此必须事先存储其前一个节点。在更改引用之前，还需要存储后一个节点。最后返回新的头引用。</p><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：O(n)，其中 n 是链表的长度。需要遍历链表一次。</li><li>空间复杂度：O(1)。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">curr</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (curr != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> curr.next;  <span class="comment">//保存下一位节点</span></span><br><span class="line">            curr.next = prev;    <span class="comment">//反转了指向，将下一位节点指向 prev(假定的前节点)</span></span><br><span class="line">            prev = curr;     <span class="comment">//假定前节点指向当前节点，准备下一次反转指向操作</span></span><br><span class="line">            curr = next;    <span class="comment">// 当前节点也指向下一位节点，准备下一次反转指向操作</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="6-复杂链表的复制"><a href="#6-复杂链表的复制" class="headerlink" title="6.复杂链表的复制"></a>6.复杂链表的复制</h3><p><a href="https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/solution/fu-za-lian-biao-de-fu-zhi-by-leetcode-so-9ik5/">复杂链表的复制 - 复杂链表的复制 - 力扣（LeetCode） (leetcode-cn.com)</a></p><h4 id="方法一：回溯-哈希表"><a href="#方法一：回溯-哈希表" class="headerlink" title="方法一：回溯 + 哈希表"></a>方法一：回溯 + 哈希表</h4><p>复杂度分析</p><p>时间复杂度：O(n)，其中 nn 是链表的长度。对于每个节点，我们至多访问其「后继节点」和「随机指针指向的节点」各一次，均摊每个点至多被访问两次。</p><p>空间复杂度：O(n)，其中 n 是链表的长度。为哈希表的空间开销。</p><p>思路：回溯，拷贝当前节点，分别向下和向随机指针递归，返回值是是当前节点，那么递归回溯时就可以将向下指针和向随机指针赋值</p><p>哈希表，防止二次创建，且能便于查找建立过的节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    Map&lt;Node, Node&gt; cachedNode = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Node, Node&gt;(); <span class="comment">//利用Map存储创建过节点，便于查找</span></span><br><span class="line"><span class="keyword">public</span> Node <span class="title function_">copyRandomList</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!cachedNode.containsKey(head)) &#123;  <span class="comment">//由于每个节点要遍历两次，所以会有重复创建</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">headNew</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(head.val);   </span><br><span class="line">        cachedNode.put(head, headNew);   </span><br><span class="line">        headNew.next = copyRandomList(head.next);<span class="comment">//新节点的下一个节点，利用递归的从后向前依次创建节点返回</span></span><br><span class="line">        headNew.random = copyRandomList(head.random); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cachedNode.get(head);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法二：迭代-节点拆分"><a href="#方法二：迭代-节点拆分" class="headerlink" title="方法二：迭代 + 节点拆分"></a>方法二：迭代 + 节点拆分</h4><p>时间复杂度：O(n)，其中 n是链表的长度。我们只需要遍历该链表三次。</p><p>读者们也可以自行尝试在计算拷贝节点的随机指针的同时计算其后继指针，这样只需要遍历两次。<br>空间复杂度：O(1)。<strong>注意返回值不计入空间复杂度。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">copyRandomList</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//给每个节点前面添加一个副本</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> head; node != <span class="literal">null</span>; node = node.next.next) &#123; <span class="comment">//两次next，每次都遍历原节点</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">nodeNew</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(node.val);</span><br><span class="line">            nodeNew.next = node.next;</span><br><span class="line">            node.next = nodeNew;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将副本之间的随机指针连接</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> head; node != <span class="literal">null</span>; node = node.next.next) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">nodeNew</span> <span class="operator">=</span> node.next;</span><br><span class="line">            nodeNew.random = (node.random != <span class="literal">null</span>) ? node.random.next : <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">Node</span> <span class="variable">headNew</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="comment">//将副本之间的普通指针连接并断开与原链表的连接</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> head; node != <span class="literal">null</span>; node = node.next) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">nodeNew</span> <span class="operator">=</span> node.next;  <span class="comment">//nodeNew 指向它的副本</span></span><br><span class="line">            node.next = node.next.next;  <span class="comment">//它的next 指向它原来指向的节点，断开指向副本</span></span><br><span class="line">            nodeNew.next = (nodeNew.next != <span class="literal">null</span>) ? nodeNew.next.next : <span class="literal">null</span>; <span class="comment">//副本指向对应的副本</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> headNew;  <span class="comment">//返回副本的头节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后一步图</p><p><img src="/Java%E7%BB%83%E4%B9%A0_img%5Cimage-20220328173325475.png" alt="image-20220328173325475"></p><h3 id="数组中重复的数字"><a href="#数组中重复的数字" class="headerlink" title="数组中重复的数字"></a>数组中重复的数字</h3><p>自己写的3ms  实际运行比官方的稍微快一些</p><p>时间复杂度O(nlongn)   复杂度大概是这</p><p>空间复杂度O(1);</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(nums);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span> ; i&lt;nums.length ; i++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(nums[i-<span class="number">1</span>]==nums[i])&#123;</span><br><span class="line">        <span class="keyword">return</span> nums[i];</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>官方写的  4ms</p><p>时间复杂度：O(n)。<br>遍历数组一遍。使用哈希集合（HashSet），添加元素的时间复杂度为 O(1)，故总的时间复杂度是 O(n)<br>空间复杂度：O(n)。不重复的每个元素都可能存入集合，因此占用 O(n) 额外空间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findRepeatNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">repeat</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!set.add(num)) &#123;</span><br><span class="line">                repeat = num;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> repeat;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大佬写的 看不懂  1ms</p><p>时间复杂度O(n)</p><p>空间复杂度为O(1)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> nums[i];</span><br><span class="line">     <span class="keyword">if</span>(k &lt; <span class="number">0</span>) k += n;</span><br><span class="line">    <span class="keyword">if</span>(nums[k] &lt; <span class="number">0</span>) <span class="keyword">return</span> k;</span><br><span class="line">     nums[k] -= n;</span><br><span class="line"></span><br><span class="line">   &#125;  </span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br></pre></td></tr></table></figure><h3 id="在排序数组中查找数字-I"><a href="#在排序数组中查找数字-I" class="headerlink" title="在排序数组中查找数字 I"></a>在排序数组中查找数字 I</h3><p>统计一个数字在已排序数组中出现的次数。</p><p>自己写的鸡肋算法，无语</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> low=<span class="number">0</span>,high=nums.length-<span class="number">1</span>,tar=-<span class="number">1</span>,num=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(low&lt;=high)&#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span>(low+high)/<span class="number">2</span>;</span><br><span class="line">     <span class="keyword">if</span>(nums[mid]==target)&#123;</span><br><span class="line">        tar=mid;</span><br><span class="line">        num++;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&gt;target)&#123;</span><br><span class="line">        high = mid-<span class="number">1</span>;</span><br><span class="line">     &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        low = mid+<span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span>(tar!=-<span class="number">1</span>)&#123;</span><br><span class="line">     <span class="type">int</span> i=tar-<span class="number">1</span>,j=tar+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(;i&gt;=<span class="number">0</span>||j&lt;=nums.length-<span class="number">1</span>;i--,j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=<span class="number">0</span>&amp;&amp;nums[i]==target)&#123;</span><br><span class="line">         num++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j&lt;=nums.length-<span class="number">1</span>&amp;&amp;nums[j]==target)&#123;</span><br><span class="line">          num++;</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>官方的，真的麻了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftIdx</span> <span class="operator">=</span> binarySearch(nums, target, <span class="literal">true</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightIdx</span> <span class="operator">=</span> binarySearch(nums, target, <span class="literal">false</span>) - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (leftIdx &lt;= rightIdx &amp;&amp; rightIdx &lt; nums.length &amp;&amp; nums[leftIdx] == target &amp;&amp; nums[rightIdx] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> rightIdx - leftIdx + <span class="number">1</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target, <span class="type">boolean</span> lower)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>, ans = nums.length;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &gt; target || (lower &amp;&amp; nums[mid] &gt;= target)) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">            ans = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="青蛙跳台阶问题"><a href="#青蛙跳台阶问题" class="headerlink" title="青蛙跳台阶问题"></a>青蛙跳台阶问题</h3><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。</p><p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p><p>这是一种斐波那契数列的应用，如图：</p><p>![image-20220501211932098](F:\Learn_data\Java\Java练习\Java 习题\image-20220501211932098.png)</p><p>时间复杂度为O(n)，空间复杂度为O(1)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numWays</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> fibOne=<span class="number">1</span>,fibTow=<span class="number">1</span>,fibNu=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">      fibNu = (fibOne+fibTow)%(<span class="number">1000000007</span>);</span><br><span class="line">      fibOne = fibTow;</span><br><span class="line">      fibTow = fibNu;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fibNu;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="旋转数组的最小数字"><a href="#旋转数组的最小数字" class="headerlink" title="旋转数组的最小数字"></a>旋转数组的最小数字</h3><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。</p><p>给你一个可能存在 <strong>重复</strong> 元素值的数组 <code>numbers</code> ，它原来是一个升序排列的数组，并按上述情形进行了一次旋转。请返回旋转数组的<strong>最小元素</strong>。例如，数组 <code>[3,4,5,1,2]</code> 为 <code>[1,2,3,4,5]</code> 的一次旋转，该数组的最小值为 1。 </p><p>注意，数组 <code>[a[0], a[1], a[2], ..., a[n-1]]</code> 旋转一次 的结果为数组 <code>[a[n-1], a[0], a[1], a[2], ..., a[n-2]]</code> 。</p><p>涉及内容为查找与排序</p><p>思路：一个数组可分为两个有序的子数组，题目的意思是查找最小元素，该最小元素是在第二个子数组中，可用<strong>二分查找</strong></p><p>每一次mid都和high进行比较，如果mid&gt;high，则该mid在第一个子数组，将low&#x3D;mid+1；mid&lt;high，则在第二个子数组，将high&#x3D;mid；总之，每次都能减少一半</p><p>提示：high&#x3D;mid，而不是high&#x3D;mid-1，因为mid&lt;high时，mid可能就是最小值，不能将其省略</p><p>如果mid等于high，则分不出在哪一个子数组中，进行high-1，相当于做一次顺序查找</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minArray</span><span class="params">(<span class="type">int</span>[] numbers)</span> &#123;</span><br><span class="line">    <span class="type">int</span> low=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> high=numbers.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(low&lt;=high)&#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (low+high)/<span class="number">2</span>;</span><br><span class="line">     <span class="keyword">if</span>(numbers[mid]&gt;numbers[high])&#123;</span><br><span class="line">      low = mid + <span class="number">1</span>;</span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span>(numbers[mid]&lt;numbers[high])&#123;</span><br><span class="line">        high = mid;</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">       high-=<span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> numbers[low];</span><br><span class="line">  </span><br></pre></td></tr></table></figure><h3 id="二进制中1的个数"><a href="#二进制中1的个数" class="headerlink" title="二进制中1的个数"></a>二进制中1的个数</h3><p>编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为 <a href="http://en.wikipedia.org/wiki/Hamming_weight">汉明重量</a>).）。</p><p><strong>方法一</strong>：循环检查二进制位</p><p>控制台输入n，二进制串位数为32位，所以我们可以逐个比较</p><p>利用1左移i位和n进行与运算，这时n会转成二进制，二者补零对齐进行比较，如果结果不为0，则该位置的1匹配成功</p><p>时间复杂度：O(k) k&#x3D;32，共比较32次</p><p>空间复杂度：O(1)，只需要常数个空间来保存变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hammingWeight</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> ret=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span> ; i&lt;<span class="number">32</span> ; i++)&#123;</span><br><span class="line">      <span class="keyword">if</span>((n &amp; (<span class="number">1</span>&lt;&lt;i))!=<span class="number">0</span>)&#123;</span><br><span class="line">        ret++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><strong>方法二</strong>：位运算优化<br>思路及解法</p><p>观察这个运算：n&amp;(n - 1), 其预算结果恰为把 n 的二进制位中的最低位的 1 变为 0 之后的结果。</p><p>每一次n 都和 n 减一相与，得到的数在赋值给n，n不等于0时，个数加1 ，直到相与的结果n等于0时结束</p><p>因此运算次数就等于 n<em>n</em> 的二进制位中 11 的个数。</p><p>时间复杂度：O(logn)。循环次数等于 n 的二进制位中 1 的个数，最坏情况下 n 的二进制位全部为 1。我们需要循环 logn 次。</p><p>空间复杂度：O(1)，我们只需要常数的空间保存若干变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hammingWeight</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">            n &amp;= n - <span class="number">1</span>;</span><br><span class="line">            ret++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="调整数组顺序使奇数位于偶数前面"><a href="#调整数组顺序使奇数位于偶数前面" class="headerlink" title="调整数组顺序使奇数位于偶数前面"></a>调整数组顺序使奇数位于偶数前面</h3><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数在数组的前半部分，所有偶数在数组的后半部分</p><p>使用双指针找出前半部分的偶数和后半部分的奇数，即可交换，有点类似与快速排序的思想</p><p>时间复杂度：O(n) ，一共遍历n次，因为要判断每一个数的奇偶性</p><p>空间复杂度：O(1)，使用常数个空间的变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] exchange(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">    <span class="type">int</span> low=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> high=nums.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(low&lt;high)&#123;</span><br><span class="line">      <span class="keyword">while</span>(low&lt;high&amp;&amp;nums[low]%<span class="number">2</span>!=<span class="number">0</span>)&#123; <span class="comment">//nums[i] &amp; 1) == 1 取模的另一种方式，因为对于二进制，第一位为1就是奇数，为0就是偶数</span></span><br><span class="line">        low++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span>(low&lt;high&amp;&amp;nums[high]%<span class="number">2</span>==<span class="number">0</span>)&#123; <span class="comment">//nums[j] &amp; 1) == 0</span></span><br><span class="line">        high--;  </span><br><span class="line">      &#125;</span><br><span class="line">       <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[high];</span><br><span class="line">        nums[high] = nums[low];</span><br><span class="line">        nums[low] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="矩阵中的路径"><a href="#矩阵中的路径" class="headerlink" title="矩阵中的路径"></a>矩阵中的路径</h3><p>中等难度—–回溯法</p><p>给定一个 <code>m x n</code> 二维字符网格 <code>board</code> 和一个字符串单词 <code>word</code> 。如果 <code>word</code> 存在于网格中，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p><p>思路：回溯法非常适合多个步骤组成 的问题，并且每个步骤都有多个选项 ，当我们在某步选择了其中一个选项时，就进入下一步，然后又面临新的选项 我们就这样重复选择，直到达最终的状态</p><p>第一个匹配是字符遍历所有的矩阵，循环选择上下左右的字符，递归调用，如果不是下一个匹配的字符，则回溯</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">exist</span><span class="params">(<span class="type">char</span>[][] board, String word)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> board.length, w = board[<span class="number">0</span>].length;</span><br><span class="line">    <span class="type">boolean</span>[][] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[h][w];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; h; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; w; j++) &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> check(board, visited, i, j, word, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(<span class="type">char</span>[][] board, <span class="type">boolean</span>[][] visited, <span class="type">int</span> i, <span class="type">int</span> j, String s, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (board[i][j] != s.charAt(k)) &#123; <span class="comment">//判断节点等于不等于对于字符</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (k == s.length() - <span class="number">1</span>) &#123; <span class="comment">//k是从0开始的</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    visited[i][j] = <span class="literal">true</span>; <span class="comment">//程序到这说明是匹配的对应字符，将其置为true，表已经过</span></span><br><span class="line">    <span class="type">int</span>[][] directions = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;&#125;; <span class="comment">//找上下左右的字符</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>[] dir : directions) &#123;  <span class="comment">//循环，将i和j与dir相加得到上下左右的字符</span></span><br><span class="line"></span><br><span class="line">      <span class="type">int</span> <span class="variable">newi</span> <span class="operator">=</span> i + dir[<span class="number">0</span>], newj = j + dir[<span class="number">1</span>]; </span><br><span class="line">      <span class="keyword">if</span> (newi &gt;= <span class="number">0</span> &amp;&amp; newi &lt; board.length &amp;&amp; newj &gt;= <span class="number">0</span> &amp;&amp; newj &lt; board[<span class="number">0</span>].length) &#123;<span class="comment">//不能是矩阵以外</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!visited[newi][newj]) &#123; <span class="comment">//如果每有经过此点</span></span><br><span class="line">          <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> check(board, visited, newi, newj, s, k + <span class="number">1</span>);<span class="comment">//将新节点递归，k+1</span></span><br><span class="line">          </span><br><span class="line">          <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            result = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    visited[i][j] = <span class="literal">false</span>;<span class="comment">//假设前面没路了，总条线匹配不成功，递归返回时，将之前匹配成功的字符改为false，便于后面的再次使用</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="机器人的运动范围"><a href="#机器人的运动范围" class="headerlink" title="机器人的运动范围"></a>机器人的运动范围</h3><p>难度中等</p><p>地上有一个m行n列的方格，从坐标 <code>[0,0]</code> 到坐标 <code>[m-1,n-1]</code> 。一个机器人从坐标 <code>[0, 0] </code>的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7&#x3D;18。但它不能进入方格 [35, 38]，因为3+5+3+8&#x3D;19。请问该机器人能够到达多少个格子？</p><p> 与上一题类似，这里还是利用DFS深度优先遍历，回溯法+剪枝</p><p>时间复杂度：O(nm) 递归遍历nm次</p><p>空间复杂度：O(nm)  使用visit了nm数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">movingCount</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">  <span class="type">boolean</span>[][] visit = <span class="keyword">new</span> <span class="title class_">boolean</span>[m][n];</span><br><span class="line">  <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> p(visit,<span class="number">0</span>,<span class="number">0</span>,k);</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">p</span><span class="params">(<span class="type">boolean</span>[][] visit,<span class="type">int</span> i,<span class="type">int</span> j,<span class="type">int</span> k)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(((i%<span class="number">10</span>)+(i/<span class="number">10</span>)+(j%<span class="number">10</span>)+(j/<span class="number">10</span>))&gt;k)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;   </span><br><span class="line">    visit[i][j]=<span class="literal">true</span>;</span><br><span class="line">    <span class="type">int</span> sum=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span>[][] dire = &#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> d[] : dire)&#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">newi</span> <span class="operator">=</span> i+d[<span class="number">0</span>] , newj = j + d[<span class="number">1</span>];      <span class="keyword">if</span>(i&gt;=<span class="number">0</span>&amp;&amp;newi&gt;=<span class="number">0</span>&amp;&amp;i&lt;visit.length&amp;&amp;newi&lt;visit.length&amp;&amp;j&gt;=<span class="number">0</span>&amp;&amp;newj&gt;=<span class="number">0</span>&amp;&amp;j&lt;visit[<span class="number">0</span>].length&amp;&amp;newj&lt;visit[<span class="number">0</span>].length)&#123;</span><br><span class="line">        <span class="keyword">if</span>(visit[newi][newj]!=<span class="literal">true</span>)</span><br><span class="line">        sum = sum + p(visit,newi,newj,k);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="14-I-剪绳子"><a href="#14-I-剪绳子" class="headerlink" title="14- I. 剪绳子"></a>14- I. 剪绳子</h3><p>难度中等427</p><p>给你一根长度为 <code>n</code> 的绳子，请把绳子剪成整数长度的 <code>m</code> 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 <code>k[0],k[1]...k[m-1]</code> 。请问 <code>k[0]*k[1]*...*k[m-1]</code> 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p><p>公式推导题解：<a href="https://leetcode-cn.com/problems/jian-sheng-zi-lcof/solution/mian-shi-ti-14-i-jian-sheng-zi-tan-xin-si-xiang-by/">https://leetcode-cn.com/problems/jian-sheng-zi-lcof/solution/mian-shi-ti-14-i-jian-sheng-zi-tan-xin-si-xiang-by/</a></p><p>结论：分段长度为e的即2.7，乘积最大，本题取整数3来进行分段</p><p>简要思路概述：该题涉及动态规划的思想和贪心的思想。</p><p>动态规划：</p><ul><li>第一个特点：这个问题的目标是求剪出的各段绳子长度的乘 积最大值，也就是求 个间题的最优解</li><li>第二个特点：整体问题的最优解是依赖各各子问题的最优解</li><li>第三个特点：我们把问题分解成若干个小问题，这些小问题之间还有相互重叠的更小的问题</li><li>第四个特点：由于子问题在分解大问题的过程中重复出现 ，为 了避免重复求解子问 题，我们可以用从下往上的顺序先计算小问题的最优解并存储下来，再以此为基础求取大 问题的 优解 从上往下分析 ，从下 往上求解问题。</li></ul><p>贪婪算法：</p><p>尽可能多地剪长度为3的绳子，当剩下的绳子长度为4时，剪为两段为2的，因为接近e的乘积最大，也可不用剪，因为4&#x3D;2*2</p><p>由于题目m&gt;1,即至少分两段，所以n&lt;&#x3D;3时，分段为1和2或1和1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">cuttingRope</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">3</span>) <span class="keyword">return</span> n-<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> n/<span class="number">3</span>,b = n%<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> (<span class="type">int</span>)Math.pow(<span class="number">3</span>,a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">1</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> (<span class="type">int</span>)Math.pow(<span class="number">3</span>,a-<span class="number">1</span>)*<span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">int</span>)Math.pow(<span class="number">3</span>,a)*<span class="number">2</span>;    </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="字符串中最大的-3-位相同数字"><a href="#字符串中最大的-3-位相同数字" class="headerlink" title="字符串中最大的 3 位相同数字"></a><a href="https://leetcode-cn.com/problems/largest-3-same-digit-number-in-string/">字符串中最大的 3 位相同数字</a></h3><p>难度简单2</p><p>给你一个字符串 <code>num</code> ，表示一个大整数。如果一个整数满足下述所有条件，则认为该整数是一个 <strong>优质整数</strong> ：</p><ul><li>该整数是 <code>num</code> 的一个长度为 <code>3</code> 的 <strong>子字符串</strong> 。</li><li>该整数由唯一一个数字重复 <code>3</code> 次组成。</li></ul><p>以字符串形式返回 <strong>最大的优质整数</strong> 。如果不存在满足要求的整数，则返回一个空字符串 <code>&quot;&quot;</code> 。</p><p>思路：模拟窗口大小为3的窗口，满足则进入，取出相同的三个字符与上一位进入的进行比较，大则替换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">largestGoodInteger</span><span class="params">(String num)</span> &#123;</span><br><span class="line">   <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">   <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> num.length();</span><br><span class="line">   <span class="type">char</span>[] cs = num.toCharArray();</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i + <span class="number">2</span> &lt; n; i++) &#123;</span><br><span class="line">     <span class="keyword">if</span> (cs[i] == cs[i + <span class="number">1</span>] &amp;&amp; cs[i + <span class="number">1</span>] == cs[i + <span class="number">2</span>]) &#123;</span><br><span class="line">       <span class="keyword">if</span> (num.substring(i, i + <span class="number">3</span>).compareTo(res) &gt; <span class="number">0</span>) res = num.substring(i, i + <span class="number">3</span>);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> res;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="II-剪绳子-II"><a href="#II-剪绳子-II" class="headerlink" title="II. 剪绳子 II"></a><a href="https://leetcode-cn.com/problems/jian-sheng-zi-ii-lcof/">II. 剪绳子 II</a></h3><p>难度中等189</p><p>给你一根长度为 <code>n</code> 的绳子，请把绳子剪成整数长度的 <code>m</code> 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 <code>k[0],k[1]...k[m - 1]</code> 。请问 <code>k[0]*k[1]*...*k[m - 1]</code> 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p><p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p><p>此题与 <a href="https://leetcode-cn.com/problems/jian-sheng-zi-lcof/">面试题14- I. 剪绳子</a> 主体等价，唯一不同在于本题目涉及 <strong>“大数越界情况下的求余问题”</strong> 。</p><p>有两种求余方法：</p><ul><li>循环取余 ，时间复杂度为O(n)</li><li>快速幂取余，时间复杂度O(log2n)</li></ul><p>首先来看循环取余，即每一次运算都进行一次取余</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">cuttingRope</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">3</span>) </span><br><span class="line">            <span class="keyword">return</span> n - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> n % <span class="number">3</span>, p = <span class="number">1000000007</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> lineNums=n/<span class="number">3</span>;           <span class="comment">//线段被我们分成以3为大小的小线段个数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;lineNums;i++) <span class="comment">//从第一段线段开始验算，3的ret次方是否越界。注意是验算lineNums-1次。</span></span><br><span class="line">            ret = <span class="number">3</span>*ret % p;</span><br><span class="line">        <span class="keyword">if</span>(b == <span class="number">0</span>) </span><br><span class="line">            <span class="keyword">return</span> (<span class="type">int</span>)(ret * <span class="number">3</span> % p);   <span class="comment">//刚好被3整数的，要算上前一段</span></span><br><span class="line">        <span class="keyword">if</span>(b == <span class="number">1</span>) </span><br><span class="line">            <span class="keyword">return</span> (<span class="type">int</span>)(ret * <span class="number">4</span> % p);   <span class="comment">//被3整数余1的，要算上前一段</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>)(ret * <span class="number">6</span> % p);       <span class="comment">//被3整数余2的，要算上前一段</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="数值的整数次方"><a href="#数值的整数次方" class="headerlink" title="数值的整数次方"></a><a href="https://leetcode.cn/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/">数值的整数次方</a></h3><p>难度中等</p><p>实现 <a href="https://www.cplusplus.com/reference/valarray/pow/">pow(<em>x</em>, <em>n</em>)</a> ，即计算 x 的 n 次幂函数（即，xn）。不得使用库函数，同时不需要考虑大数问题。</p><p><strong>方法一</strong>：快速幂 + 递归</p><p>思路：快速幂有点二分思想，二分在于每次的幂都是前一个的两倍，由于幂有奇数的情况，如果从小到大乘的话，你将不知道前面是否是奇数还是偶数，如果是奇数你得加一个x，所以我们采取先从大到小递归x^n，递归条件是n次方除2，向下取整，即n是奇数时，n-1除2，返回时就可判断每一步得到的n是奇数还是偶数进行合适的返回</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">myPow</span><span class="params">(<span class="type">double</span> x, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">N</span> <span class="operator">=</span> n;</span><br><span class="line">        <span class="keyword">return</span> N &gt;= <span class="number">0</span> ? quickMul(x, N) : <span class="number">1.0</span> / quickMul(x, -N);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">quickMul</span><span class="params">(<span class="type">double</span> x, <span class="type">long</span> N)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (N == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">double</span> <span class="variable">y</span> <span class="operator">=</span> quickMul(x, N / <span class="number">2</span>); <span class="comment">//除2递归到n=0</span></span><br><span class="line">        <span class="keyword">return</span> N % <span class="number">2</span> == <span class="number">0</span> ? y * y : y * y * x;  <span class="comment">//判断当前n奇偶性，是否添加额外的x</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方法二</strong>：快速幂 + 迭代</p><p>由于递归需要使用额外的栈空间，我们试着将递归转写为迭代。在方法一中，我们也提到过，从左到右进行推导是不容易的，因为我们不知道是否需要额外乘 x。但我们不妨找一找规律，看看哪些地方额外乘了 x，并且它们对答案产生了什么影响。<br>链接：<a href="https://leetcode.cn/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/solution/shu-zhi-de-zheng-shu-ci-fang-by-leetcode-yoqr/">https://leetcode.cn/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/solution/shu-zhi-de-zheng-shu-ci-fang-by-leetcode-yoqr/</a><br>思路：具体思路看官网的解答，就是将奇数多余出来的一个x，当做贡献，而这个x会被一次次平方，记录x^n中，我们从大往小推导，x每一次循环都会平方，如果遇到幂是奇数时，将x加到总数上，即此时该奇数贡献的x被平方后的大小，将所有贡献的x多次平方过后的x幂加起来。就是x^n;</p><p>无风不起浪，先是有x^1贡献的一个x，之后这个x被平方k次，k即循环的次数，当然中间为m的位置还有奇数也贡献了自己的x，之后也被平方了k-m次，这就是次算法的思想；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">myPow</span><span class="params">(<span class="type">double</span> x, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(x == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">b</span> <span class="operator">=</span> n;</span><br><span class="line">        <span class="type">double</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">if</span>(b &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            x = <span class="number">1</span> / x;</span><br><span class="line">            b = -b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>((b &amp; <span class="number">1</span>) == <span class="number">1</span>) res *= x; <span class="comment">//n%2==1</span></span><br><span class="line">            x *= x;</span><br><span class="line">            b &gt;&gt;= <span class="number">1</span>; <span class="comment">//n除2</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="表达式匹配"><a href="#表达式匹配" class="headerlink" title="表达式匹配"></a><a href="https://leetcode.cn/problems/zheng-ze-biao-da-shi-pi-pei-lcof/">表达式匹配</a></h3><p>难度困难</p><p>请实现一个函数用来匹配包含<code>&#39;. &#39;</code>和<code>&#39;*&#39;</code>的正则表达式。模式中的字符<code>&#39;.&#39;</code>表示任意一个字符，而<code>&#39;*&#39;</code>表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串<code>&quot;aaa&quot;</code>与模式<code>&quot;a.a&quot;</code>和<code>&quot;ab*ac*a&quot;</code>匹配，但与<code>&quot;aa.a&quot;</code>和<code>&quot;ab*a&quot;</code>均不匹配。</p><p>结合下面这个视频及此段代码，差不多理解此思想</p><p><a href="https://www.bilibili.com/video/BV1rf4y1i7GQ?spm_id_from=333.1007.top_right_bar_window_history.content.click">LeetCode力扣刷题 | 剑指Offer 19. 正则表达式匹配_哔哩哔哩_bilibili</a></p><p><a href="https://leetcode.cn/problems/zheng-ze-biao-da-shi-pi-pei-lcof/solution/zhu-xing-xiang-xi-jiang-jie-you-qian-ru-shen-by-je/">逐行详细讲解，由浅入深，dp和递归两种思路 - 正则表达式匹配 - 力扣（LeetCode）</a></p><p>思路：创建一个布尔类型的二维数组，行代表匹配串，列代表模式串，逐行匹配，即每添加一个字符，都用全部模式串与新串匹配。匹配不成功则是false，成功则为true。</p><p>将模式串分为空和非空两类：</p><p>当模式串为空时，匹配串也为空，则为true，匹配串不为空，则为false</p><p>当模式串不为空时，无论匹配串空或不空都得计算，因为模式串也有可能匹配到空的匹配串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isMatch</span><span class="params">(String A, String B)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> A.length();</span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> B.length();</span><br><span class="line">    <span class="type">boolean</span>[][] f = <span class="keyword">new</span> <span class="title class_">boolean</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= m; j++) &#123;</span><br><span class="line">        <span class="comment">//分成空正则和非空正则两种</span></span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">0</span>) &#123; <span class="comment">//正则为空时</span></span><br><span class="line">          f[i][j] = i == <span class="number">0</span>; </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">//非空正则分为两种情况 * 和 非*</span></span><br><span class="line">          <span class="keyword">if</span> (B.charAt(j - <span class="number">1</span>) != <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; (A.charAt(i - <span class="number">1</span>) == B.charAt(j - <span class="number">1</span>) || B.charAt(j - <span class="number">1</span>) == <span class="string">&#x27;.&#x27;</span>)) &#123;</span><br><span class="line">              f[i][j] = f[i - <span class="number">1</span>][j - <span class="number">1</span>];  <span class="comment">//等于上一位字符匹配的结果，即true</span></span><br><span class="line">           &#125;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//碰到 * 了，分为看和不看两种情况</span></span><br><span class="line">            <span class="comment">//不看</span></span><br><span class="line">            <span class="keyword">if</span> (j &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">              f[i][j] |= f[i][j - <span class="number">2</span>];  <span class="comment">//用或，不确定看不看，忽略后面两位，即*和*前面的一位，因为*是匹配0或多个</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//看</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt;= <span class="number">1</span> &amp;&amp; j &gt;= <span class="number">2</span> &amp;&amp; (A.charAt(i - <span class="number">1</span>) == B.charAt(j - <span class="number">2</span>) || B.charAt(j - <span class="number">2</span>) == <span class="string">&#x27;.&#x27;</span>)) &#123;</span><br><span class="line">              f[i][j] |= f[i - <span class="number">1</span>][j];  <span class="comment">//匹配串上一位匹配结果</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[n][m];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="树的子结构"><a href="#树的子结构" class="headerlink" title="树的子结构"></a><a href="https://leetcode.cn/problems/shu-de-zi-jie-gou-lcof/">树的子结构</a></h3><p>K神题解：<a href="https://leetcode.cn/problems/shu-de-zi-jie-gou-lcof/solution/mian-shi-ti-26-shu-de-zi-jie-gou-xian-xu-bian-li-p/">https://leetcode.cn/problems/shu-de-zi-jie-gou-lcof/solution/mian-shi-ti-26-shu-de-zi-jie-gou-xian-xu-bian-li-p/</a></p><p>难度中等</p><p>输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)</p><p>B是A的子结构， 即 A中有出现和B相同的结构和节点值。</p><p>思路：递归寻找A中各个节点，充当根节点作为子树A，与子树B比较，即recur方法功能，匹配成功返回true</p><p>isSubStructure：||有阻断功能，即前面为true，则返回true，不执行后面的操作</p><p>recur方法：比较两个子树是否相等</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSubStructure</span><span class="params">(TreeNode A, TreeNode B)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (A != <span class="literal">null</span> &amp;&amp; B != <span class="literal">null</span>) &amp;&amp; (recur(A, B) || isSubStructure(A.left, B) || isSubStructure(A.right, B));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断以A为根节点的A树是否存在以B为根节点的子树B</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">recur</span><span class="params">(TreeNode A, TreeNode B)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(B == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//递归的终止条件，B为空</span></span><br><span class="line">        <span class="keyword">if</span>(A == <span class="literal">null</span> || A.val != B.val) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//如果B不为空，而A为空，则说明不匹配，或者值不同也说明不匹配</span></span><br><span class="line">        <span class="keyword">return</span> recur(A.left, B.left) &amp;&amp; recur(A.right, B.right); <span class="comment">//继续递归左右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度 O(MN) ： 其中 M,N分别为树 A 和 树 B 的节点数量；先序遍历树 A 占用 O(M) ，每次调用 recur(A, B) 判断占用 O(N) 。<br>空间复杂度 O(M)： 当树 A 和树 B 都退化为链表时，递归调用深度最大。当  NM≤N 时，遍历树 A 与递归判断的总递归深度为 M ；当 M&gt;N 时，最差情况为遍历至树 A 叶子节点，此时总递归深度为 M</p><h3 id="对称的二叉树"><a href="#对称的二叉树" class="headerlink" title="对称的二叉树"></a><a href="https://leetcode.cn/problems/dui-cheng-de-er-cha-shu-lcof/">对称的二叉树</a></h3><p>难度简单</p><p>请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</p><p>例如，二叉树 [1,2,2,3,4,4,3] 是对称的。</p><p>思路：将树以根为中心，分为两半看，递归左边的左和右边的右，后面在递归左边的右和右边的左</p><p>&amp;&amp;：有连接作用</p><p>终止条件：</p><ul><li>如果两边都为空，返回true</li><li>如果其中一边为空，一边不为空，或者两边值不等，返回false</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> root==<span class="literal">null</span>?<span class="literal">true</span>:recur(root.left,root.right);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">recur</span><span class="params">(TreeNode L,TreeNode R)</span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(L==<span class="literal">null</span>&amp;&amp;R==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">     <span class="keyword">if</span>(L==<span class="literal">null</span>||R==<span class="literal">null</span>||L.val!=R.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">     <span class="keyword">return</span> recur(L.left,R.right)&amp;&amp;recur(L.right,R.left);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="顺时针打印矩阵"><a href="#顺时针打印矩阵" class="headerlink" title="顺时针打印矩阵"></a><a href="https://leetcode.cn/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/">顺时针打印矩阵</a></h3><p>难度简单</p><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字</p><p>思路：模拟</p><ul><li><p>根据顺时针可知，可有大循环中四个循环，分别是右、下、左和上</p></li><li><p>每一次循环过后就要将边对于边界减1，表示已经遍历过了</p></li><li><p>分别有上下左右四个边界，代码中即 t&#x3D;0、b&#x3D;高、l&#x3D;0、r&#x3D;宽</p></li></ul><blockquote><ul><li><code>res[x++]</code> 等价于先给 <code>res[x]</code> 赋值，再给 <code>x</code> 自增 11 ；</li><li><code>++t &gt; b</code> 等价于先给 <code>t</code> 自增 11 ，再判断 <code>t &gt; b</code> 逻辑表达式。</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] spiralOrder(<span class="type">int</span>[][] matrix) &#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = matrix[<span class="number">0</span>].length - <span class="number">1</span>, t = <span class="number">0</span>, b = matrix.length - <span class="number">1</span>, x = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[(r + <span class="number">1</span>) * (b + <span class="number">1</span>)];</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l; i &lt;= r; i++) res[x++] = matrix[t][i]; <span class="comment">// left to right.</span></span><br><span class="line">            <span class="keyword">if</span>(++t &gt; b) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> t; i &lt;= b; i++) res[x++] = matrix[i][r]; <span class="comment">// top to bottom.</span></span><br><span class="line">            <span class="keyword">if</span>(l &gt; --r) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> r; i &gt;= l; i--) res[x++] = matrix[b][i]; <span class="comment">// right to left.</span></span><br><span class="line">            <span class="keyword">if</span>(t &gt; --b) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> b; i &gt;= t; i--) res[x++] = matrix[i][l]; <span class="comment">// bottom to top.</span></span><br><span class="line">            <span class="keyword">if</span>(++l &gt; r) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="31-栈的压入、弹出序列"><a href="#31-栈的压入、弹出序列" class="headerlink" title="31. 栈的压入、弹出序列"></a><a href="https://leetcode.cn/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/">31. 栈的压入、弹出序列</a></h3><p>难度中等</p><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。</p><p>思路：辅助栈模拟</p><p>循环入栈，每次入栈一个元素，while循环看看栈顶是否与出栈元素相同，同则出栈</p><p>最后元素全部入栈以后，看看栈是否为空来判断正确性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">validateStackSequences</span><span class="params">(<span class="type">int</span>[] pushed, <span class="type">int</span>[] popped)</span> &#123;</span><br><span class="line">  Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">  <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> num : pushed)&#123;</span><br><span class="line">    stack.push(num);</span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty()&amp;&amp;stack.peek()==popped[i])&#123;</span><br><span class="line">      i++;</span><br><span class="line">      stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="32-I-从上到下打印二叉树"><a href="#32-I-从上到下打印二叉树" class="headerlink" title="32 - I. 从上到下打印二叉树"></a><a href="https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/">32 - I. 从上到下打印二叉树</a></h3><p>难度中等</p><p>从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。</p><p>思路：广度优先遍历，需要用一个队列来存放当前节点的子节点</p><p>将当前节点打印，当子节点不为空时入队，循环出队下一个节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] levelOrder(TreeNode root) &#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">    LinkedList&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    queue.add(root);</span><br><span class="line">    ArrayList&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    TreeNode node;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">      node = queue.remove();</span><br><span class="line">      ans.add(node.val);</span><br><span class="line">      <span class="keyword">if</span>(node.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">        queue.add(node.left);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(node.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">        queue.add(node.right);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[ans.size()];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span> ; i&lt;ans.size() ; i++)&#123;</span><br><span class="line">      res[i] = ans.get(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="33-二叉搜索树的后序遍历序列"><a href="#33-二叉搜索树的后序遍历序列" class="headerlink" title="33. 二叉搜索树的后序遍历序列"></a><a href="https://leetcode.cn/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/">33. 二叉搜索树的后序遍历序列</a></h3><p>难度中等</p><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 <code>true</code>，否则返回 <code>false</code>。假设输入的数组的任意两个数字都互不相同。</p><p>题意：给出一个数组，将其按后续遍历看成一棵二叉树，在判断这棵二叉树是不是搜索二叉树，即根节点大于左子树，小于右子树</p><p>作者：jyd<br>链接：<a href="https://leetcode.cn/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/solution/mian-shi-ti-33-er-cha-sou-suo-shu-de-hou-xu-bian-6/">https://leetcode.cn/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/solution/mian-shi-ti-33-er-cha-sou-suo-shu-de-hou-xu-bian-6/</a></p><h4 id="方法一：递归分治"><a href="#方法一：递归分治" class="headerlink" title="方法一：递归分治"></a>方法一：递归分治</h4><p>思路：</p><p>可以通过递归，判断所有子树的 <strong>正确性</strong> （即其后序遍历是否满足二叉搜索树的定义） ，若所有子树都正确，则此序列为二叉搜索树的后序遍历。</p><p><strong>递归解析：</strong></p><ul><li><p>终止条件： i&gt;&#x3D;j ，说明这节点无左右子树，直接返回true</p></li><li><p>递推工作：<br><strong>划分左右子树</strong>： 遍历后序遍历的 [i, j] 区间元素，<strong>寻找第一个大于根节点 的节点</strong>，索引记为 m 。此时，可划分出左子树区间 [i,m-1] 、右子树区间 [m, j - 1]、根节点索引 j 。</p></li><li><p>判断是否为二叉搜索树：<br><strong>左子树区间</strong> [i, m - 1]内的<strong>所有节点</strong>都应 &lt;postorder[j] （<strong>小于根节点</strong>）。</p><p>而第 <strong>1.划分左右子树 步骤已经保证左子树区间的正确性，因此只需要判断右子树区间即可</strong>。</p></li><li><p><strong>右子树区间</strong> [m, j-1]内的<strong>所有节点</strong>都应 &gt; postorder[j]（<strong>大于根节点</strong>）。</p><p>实现方式为遍历，当遇到 ≤postorder[j] 的节点则跳出；则可通过 p &#x3D; j判断是否为二叉搜索树。<strong>即如果右子树全部大于根节点时，p&#x3D;j</strong></p></li><li><p><strong>返回值</strong>： 所有子树都需正确才可判定正确，因此使用 <strong>与逻辑符 &amp;&amp; 连接</strong>。<br>p &#x3D; j ： 判断此树 是否正确。<br>recur(i, m - 1)recur(i,m−1) ： 判断 此树的左子树 是否正确。<br>recur(m, j - 1)recur(m,j−1) ： 判断 此树的右子树 是否正确。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">verifyPostorder</span><span class="params">(<span class="type">int</span>[] postorder)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> recur(postorder, <span class="number">0</span>, postorder.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">recur</span><span class="params">(<span class="type">int</span>[] postorder, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= j) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//此节点为叶子节点，直接返回true</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> i;</span><br><span class="line">        <span class="keyword">while</span>(postorder[p] &lt; postorder[j]) p++; <span class="comment">//找比根节点第一个大的节点，划分左右子树区间</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> p; <span class="comment">//记住区间值，待会返回</span></span><br><span class="line">        <span class="keyword">while</span>(postorder[p] &gt; postorder[j]) p++; <span class="comment">//判断所有右子树是否大于根节点，由p==j可知</span></span><br><span class="line">        <span class="keyword">return</span> p == j &amp;&amp; recur(postorder, i, m - <span class="number">1</span>) &amp;&amp; recur(postorder, m, j - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//判断是否是二叉搜索，递归左右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="34-二叉树中和为某一值的路径"><a href="#34-二叉树中和为某一值的路径" class="headerlink" title="34. 二叉树中和为某一值的路径"></a><a href="https://leetcode.cn/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/">34. 二叉树中和为某一值的路径</a></h3><p>难度中等</p><p>给你二叉树的根节点 <code>root</code> 和一个整数目标和 <code>targetSum</code> ，找出所有 <strong>从根节点到叶子节点</strong> 路径总和等于给定目标和的路径。</p><p><strong>叶子节点</strong> 是指没有子节点的节点。</p><p>思路：先序遍历，回溯法</p><ul><li><p>递归先序遍历每个节点，终止条件是节点为空，</p></li><li><p>创建一个链表记录路径，将每个遍历的节点加到路径中，并减去该路径的权，</p></li><li><p>判断该节点是否是叶子节点且路径和等于目标值，如果等于则将该路径加到返回结果中，否则将该节点移除路径，</p></li><li><p>之后在遍历左子树和右子树</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    LinkedList&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(); </span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">pathSum</span><span class="params">(TreeNode root, <span class="type">int</span> sum)</span> &#123;</span><br><span class="line">        recur(root, sum);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">recur</span><span class="params">(TreeNode root, <span class="type">int</span> tar)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        path.add(root.val);</span><br><span class="line">        tar -= root.val;</span><br><span class="line">        <span class="keyword">if</span>(tar == <span class="number">0</span> &amp;&amp; root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>)</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>(path));</span><br><span class="line">        recur(root.left, tar);</span><br><span class="line">        recur(root.right, tar);</span><br><span class="line">        path.removeLast(); <span class="comment">//移除节点是在最后执行，当遍历完左子树和右子树，就移除当前节点，用于清空遍历过的子树，且之前也将有合适的路径加入到返回结果中l</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="36-二叉搜索树与双向链表"><a href="#36-二叉搜索树与双向链表" class="headerlink" title="36. 二叉搜索树与双向链表"></a><a href="https://leetcode.cn/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/">36. 二叉搜索树与双向链表</a></h3><p>难度中等</p><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。</p><p>思路：</p><ul><li>将二叉搜索树按从小到大遍历用中序遍历</li><li>用pre前节点和cur当前节点完成指针遍历链接</li><li>head保存第一个遍历到的叶子节点，即最小的节点</li><li>当遍历结束时，pre节点的记录了最后的节点</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    Node pre, head;</span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">treeToDoublyList</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        dfs(root);</span><br><span class="line">        head.left = pre;</span><br><span class="line">        pre.right = head;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(Node cur)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        dfs(cur.left);</span><br><span class="line">        <span class="keyword">if</span>(pre != <span class="literal">null</span>) pre.right = cur;</span><br><span class="line">        <span class="keyword">else</span> head = cur;</span><br><span class="line">        cur.left = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        dfs(cur.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="剑指-Offer-37-序列化二叉树"><a href="#剑指-Offer-37-序列化二叉树" class="headerlink" title="剑指 Offer 37. 序列化二叉树"></a><a href="https://leetcode.cn/problems/xu-lie-hua-er-cha-shu-lcof/">剑指 Offer 37. 序列化二叉树</a></h3><p>难度困难</p><p>请实现两个函数，分别用来序列化和反序列化二叉树。</p><p>你需要设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 &#x2F; 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。</p><p>思路：</p><p>序列化：借用队列辅助，按层遍历树，加入StringBulider，节点为空时加入字符串null，每个字符串用逗号隔开</p><p>反序列化：将序列化字符串按逗号隔开转为字符串数组，借用辅助队列及while循环，每次循环 i 都会加二，即遍历当前出队列节点的左右节点，即从左往右的按层遍历。当出队列的节点不为空时new对象，并赋值给当前节点左节点或右节点，然后加入队列中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Codec</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">serialize</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="string">&quot;[]&quot;</span>;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;[&quot;</span>);</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;() &#123;&#123; add(root); &#125;&#125;;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="keyword">if</span>(node != <span class="literal">null</span>) &#123;</span><br><span class="line">                res.append(node.val + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">                queue.add(node.left);</span><br><span class="line">                queue.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> res.append(<span class="string">&quot;null,&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        res.deleteCharAt(res.length() - <span class="number">1</span>);</span><br><span class="line">        res.append(<span class="string">&quot;]&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">deserialize</span><span class="params">(String data)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(data.equals(<span class="string">&quot;[]&quot;</span>)) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    String[] vals = data.substring(<span class="number">1</span>, data.length() - <span class="number">1</span>).split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(Integer.parseInt(vals[<span class="number">0</span>]));</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;() &#123;&#123; add(root); &#125;&#125;;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">        <span class="keyword">if</span>(!vals[i].equals(<span class="string">&quot;null&quot;</span>)) &#123;</span><br><span class="line">            node.left = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(Integer.parseInt(vals[i]));</span><br><span class="line">            queue.add(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">if</span>(!vals[i].equals(<span class="string">&quot;null&quot;</span>)) &#123;</span><br><span class="line">            node.right = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(Integer.parseInt(vals[i]));</span><br><span class="line">            queue.add(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="剑指-Offer-38-字符串的排列"><a href="#剑指-Offer-38-字符串的排列" class="headerlink" title="剑指 Offer 38. 字符串的排列"></a><a href="https://leetcode.cn/problems/zi-fu-chuan-de-pai-lie-lcof/">剑指 Offer 38. 字符串的排列</a></h3><p>难度中等</p><p>输入一个字符串，打印出该字符串中字符的所有排列。</p><p>你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。</p><p>思路：深度优先遍历或回溯法，和剪枝</p><p>算法模型，逐一固定元素，每固定一位，将后其余元素交换位置，这里利用递归加循环，达到回溯重定向效果。之后将交换元素复原以便下一次交换时错乱导致重复</p><p>递归终止条件：当前位置到达最后一位时，即 x &#x3D; c . length - 1，终止条件发生时将当前数组写入结果</p><p>一个固定位置上的元素不能重复，因此这里需要HashSet来将进行判断，如有重复则不执行这次循环，即剪枝</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">char</span>[] c;</span><br><span class="line">    <span class="keyword">public</span> String[] permutation(String s) &#123;</span><br><span class="line">        c = s.toCharArray();</span><br><span class="line">        dfs(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res.toArray(<span class="keyword">new</span> <span class="title class_">String</span>[res.size()]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(x == c.length - <span class="number">1</span>) &#123;</span><br><span class="line">            res.add(String.valueOf(c));      <span class="comment">// 添加排列方案</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        HashSet&lt;Character&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> x; i &lt; c.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(set.contains(c[i])) <span class="keyword">continue</span>; <span class="comment">// 重复，因此剪枝</span></span><br><span class="line">            set.add(c[i]);</span><br><span class="line">            swap(i, x);                      <span class="comment">// 交换，将 c[i] 固定在第 x 位</span></span><br><span class="line">            dfs(x + <span class="number">1</span>);                      <span class="comment">// 开启固定第 x + 1 位字符</span></span><br><span class="line">            swap(i, x);                      <span class="comment">// 恢复交换</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">tmp</span> <span class="operator">=</span> c[a];</span><br><span class="line">        c[a] = c[b];</span><br><span class="line">        c[b] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="剑指-Offer-39-数组中出现次数超过一半的数字"><a href="#剑指-Offer-39-数组中出现次数超过一半的数字" class="headerlink" title="剑指 Offer 39. 数组中出现次数超过一半的数字"></a><a href="https://leetcode.cn/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/">剑指 Offer 39. 数组中出现次数超过一半的数字</a></h3><p>难度简单</p><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。</p><p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p><p>方法一：哈希表</p><p>思路：用hashMap记录元素出现的个数，之后找出个数最多的元素返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, Integer&gt; <span class="title function_">countNums</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; counts = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!counts.containsKey(num)) &#123;</span><br><span class="line">                counts.put(num, <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                counts.put(num, counts.get(num) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> counts;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">majorityElement</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; counts = countNums(nums);</span><br><span class="line"></span><br><span class="line">    Map.Entry&lt;Integer, Integer&gt; majorityEntry = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : counts.entrySet()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (majorityEntry == <span class="literal">null</span> || entry.getValue() &gt; majorityEntry.getValue()) &#123;</span><br><span class="line">            majorityEntry = entry;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> majorityEntry.getKey();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二：摩尔投票法</p><p>摩尔投票法：<br>设输入数组 nums 的众数为 xx ，数组长度为 nn 。</p><p>推论一： 若记 众数 的票数为 +1 ，非众数 的票数为 -1 ，则一定有所有数字的 票数和 &gt; 0。</p><p>推论二： 若数组的前 a 个数字的 票数和 &#x3D; 0 ，则数组剩余 (n−a) 个数字的 票数和一定仍 &gt;0 ，即后 (n−a) 个数字的 众数仍为 x</p><p>思路：当票数为0时，将当前元素作为候选者，把将票数置为1，与下一位比较是否等于候选者，等于则票数加1，否则票数减1。由于众数个数多，因此循环结束的候选者一定是众数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">majorityElement</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>, votes = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(votes == <span class="number">0</span>) x = num;</span><br><span class="line">            votes += num == x ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="剑指-Offer-40-最小的k个数"><a href="#剑指-Offer-40-最小的k个数" class="headerlink" title="剑指 Offer 40. 最小的k个数"></a><a href="https://leetcode.cn/problems/zui-xiao-de-kge-shu-lcof/">剑指 Offer 40. 最小的k个数</a></h3><p>难度简单</p><p>输入整数数组 <code>arr</code> ，找出其中最小的 <code>k</code> 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。</p><p>方法一 快速排序</p><p>这里没有设置变量来存放哨兵，所以哨兵的位置不会被替换，直到找到位置才被替换</p><p>快排，循环每次都能找到一个元素的准确位置，即将数组分为了两份，之后进行递归左右数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] getLeastNumbers(<span class="type">int</span>[] arr, <span class="type">int</span> k) &#123;</span><br><span class="line">        quickSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOf(arr, k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">        <span class="comment">// 子数组长度为 1 时终止递归</span></span><br><span class="line">        <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 哨兵划分操作（以 arr[l] 作为基准数）</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l, j = r;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[j] &gt;= arr[l]) j--;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[i] &lt;= arr[l]) i++;</span><br><span class="line">            swap(arr, i, j);</span><br><span class="line">        &#125;</span><br><span class="line">        swap(arr, i, l);</span><br><span class="line">        <span class="comment">// 递归左（右）子数组执行哨兵划分</span></span><br><span class="line">        quickSort(arr, l, i - <span class="number">1</span>);</span><br><span class="line">        quickSort(arr, i + <span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二： 基于快速排序的数组划分</p><p>由于只需要前k个最小的数，我们只需排序到下标为k的元素时停止，返回前k个元素数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] getLeastNumbers(<span class="type">int</span>[] arr, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k &gt;= arr.length) <span class="keyword">return</span> arr;</span><br><span class="line">        <span class="keyword">return</span> quickSort(arr, k, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] quickSort(<span class="type">int</span>[] arr, <span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l, j = r;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[j] &gt;= arr[l]) j--;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[i] &lt;= arr[l]) i++;</span><br><span class="line">            swap(arr, i, j);</span><br><span class="line">        &#125;</span><br><span class="line">        swap(arr, i, l);</span><br><span class="line">        <span class="keyword">if</span> (i &gt; k) <span class="keyword">return</span> quickSort(arr, k, l, i - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; k) <span class="keyword">return</span> quickSort(arr, k, i + <span class="number">1</span>, r); <span class="comment">//不满足时继续递归排序</span></span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOf(arr, k);  <span class="comment">//直到找到i=k时终止</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="剑指-Offer-41-数据流中的中位数"><a href="#剑指-Offer-41-数据流中的中位数" class="headerlink" title="剑指 Offer 41. 数据流中的中位数"></a><a href="https://leetcode.cn/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/">剑指 Offer 41. 数据流中的中位数</a></h3><p>难度困难328</p><p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。</p><p>例如</p><p>[2,3,4] 的中位数是 3</p><p>[2,3] 的中位数是 (2 + 3) &#x2F; 2 &#x3D; 2.5</p><p>设计一个支持以下两种操作的数据结构：</p><ul><li>void addNum(int num) - 从数据流中添加一个整数到数据结构中。</li><li>double findMedian() - 返回目前所有元素的中位数。</li></ul><p>优先队列PriorityQueue是Queue接口的实现，可以对其中元素进行排序，</p><p>可以放基本数据类型的包装类（如：Integer，Long等）或自定义的类</p><p>对于基本数据类型的包装器类，优先队列中元素<strong>默认排列顺序是升序排列</strong></p><p>但对于自己定义的类来说，需要自己定义比较器</p><p>二、常用方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">peek()<span class="comment">//返回队首元素</span></span><br><span class="line">poll()<span class="comment">//返回队首元素，队首元素出队列</span></span><br><span class="line">add()<span class="comment">//添加元素</span></span><br><span class="line">size()<span class="comment">//返回队列元素个数</span></span><br><span class="line">isEmpty()<span class="comment">//判断队列是否为空，为空返回true,不空返回false</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MedianFinder</span> &#123;</span><br><span class="line">    Queue&lt;Integer&gt; A, B;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MedianFinder</span><span class="params">()</span> &#123;</span><br><span class="line">        A = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(); <span class="comment">// 小顶堆，保存较大的一半</span></span><br><span class="line">        B = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((x, y) -&gt; (y - x)); <span class="comment">// 大顶堆，保存较小的一半</span></span><br><span class="line">    &#125; <span class="comment">// (x, y) -&gt; (y - x) Lambda表达式，PriorityQueue类中有构造器参数为比较器，所以此表达式看成比较器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addNum</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(A.size() != B.size()) &#123;</span><br><span class="line">            A.add(num);  <span class="comment">//A元素个数大于等于B的元素个数，因此他们不等于时A多了，先加入A排序后出队最小的给B</span></span><br><span class="line">            B.add(A.poll());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            B.add(num);  <span class="comment">//因为A的元素需要多于B，所以先将该元素加入B排序后出队最大的给A</span></span><br><span class="line">            A.add(B.poll());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">findMedian</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> A.size() != B.size() ? A.peek() : (A.peek() + B.peek()) / <span class="number">2.0</span>;</span><br><span class="line">    &#125;<span class="comment">//个数为奇数时，中位数为A的栈顶，为偶数时，中位数为A和B的栈顶的一半，注意除2时用2.0，结果就为double类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：<br>查找中位数 O(1)： 获取堆顶元素使用 O(1) 时间；<br>添加数字 O(log N) ： 堆的插入和弹出操作使用 O(logN) 时间。<br>空间复杂度 O(N) ： 其中 N 为数据流中的元素数量，小顶堆 A 和大顶堆 B 最多同时保存 NN个元素</p><p>作者：jyd<br>链接：<a href="https://leetcode.cn/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/solution/mian-shi-ti-41-shu-ju-liu-zhong-de-zhong-wei-shu-y/">https://leetcode.cn/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/solution/mian-shi-ti-41-shu-ju-liu-zhong-de-zhong-wei-shu-y/</a></p><h3 id="剑指-Offer-42-连续子数组的最大和"><a href="#剑指-Offer-42-连续子数组的最大和" class="headerlink" title="剑指 Offer 42. 连续子数组的最大和"></a><a href="https://leetcode.cn/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/">剑指 Offer 42. 连续子数组的最大和</a></h3><p>难度简单</p><p>输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。</p><p>要求时间复杂度为O(n)。</p><p>思路：动态规划</p><p>设置一个动态规划列表dp，每次进入列表的数值都是此前数值和的最大值</p><p>转移方程：</p><p>​列表dp的前一个数值大于0，则将下一个值与此相加并加入动态规划列表</p><p>​列表dp的前一个数值小于0，则将下一个值不变的并加入动态规划列表</p><p>设置一个MAX来存放数值和的最大值</p><img src="https://pic.leetcode-cn.com/8fec91e89a69d8695be2974de14b74905fcd60393921492bbe0338b0a628fd9a-Picture1.png" alt="Picture1.png" style="zoom: 67%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            nums[i] += Math.max(nums[i - <span class="number">1</span>], <span class="number">0</span>); <span class="comment">//上一个数和是否大于0，大于则与本数相加放入替换位置，否则本数加0替换当前位置</span></span><br><span class="line">            res = Math.max(res, nums[i]); <span class="comment">//保存数和最大值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>空间复杂度降低：<br>由于 dp[i] 只与 dp[i-1] 和 nums[i]有关系，因此可以将原数组 nums 用作 dp列表，即直接在 nums 上修改即可。<br>由于省去 dp 列表使用的额外空间，因此空间复杂度从 O(N) 降至 O(1) 。<br>复杂度分析：</p><p>时间复杂度 O(N) ： 线性遍历数组 nums 即可获得结果，使用 O(N) 时间。<br>空间复杂度 O(1) ： 使用常数大小的额外空间</p><h3 id="剑指-Offer-43-1～n-整数中-1-出现的次数"><a href="#剑指-Offer-43-1～n-整数中-1-出现的次数" class="headerlink" title="剑指 Offer 43. 1～n 整数中 1 出现的次数"></a><a href="https://leetcode.cn/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/">剑指 Offer 43. 1～n 整数中 1 出现的次数</a></h3><p>难度困难</p><p>输入一个整数 <code>n</code> ，求1～n这n个整数的十进制表示中1出现的次数。</p><p>例如，输入12，1～12这些整数中包含1 的数字有1、10、11和12，1一共出现了5次。</p><p>思路：<a href="https://www.bilibili.com/video/BV1v5411J77K?spm_id_from=333.337.search-card.all.click&vd_source=a5ed31dd56b3cc5bac118687c71bf851">LeetCode刷题力扣题解 | 剑指Offer 43. 1～n 整数中 1 出现的次数 | 思路讲解及Python3代码实现_哔哩哔哩_bilibili</a></p><p>计算个十百千万，每个位数上1出现的次数之和</p><p>其中位数上计算方式有三种情况：</p><ul><li>当前位cur&gt;1时，当前位出现1的个数为高位+1（因为是从0开始的），乘以当前位数</li><li>当前位cur&#x3D;&#x3D;1时，分为两种</li><li>当前位cur&#x3D;&#x3D;0时，当前位出现1的个数为高位（不用加1，因为要减1抵消了），乘以当前位数，（为什么减1？因为当前位是0，没有出现1，所以要向上减1，当前位出现1）</li></ul><img src="F:\Learn_data\Java\Java练习\Java 习题\image-20220615131404484.png" alt="image-20220615131404484" style="zoom: 33%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countDigitOne</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> cur=<span class="number">0</span>,high=<span class="number">0</span>,low=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">long</span> i=<span class="number">1</span>;i&lt;=n;i*=<span class="number">10</span>)&#123;</span><br><span class="line">      high=(<span class="type">int</span>)(n/i);</span><br><span class="line">      cur=high%<span class="number">10</span>;</span><br><span class="line">      high=high/<span class="number">10</span>;</span><br><span class="line">      <span class="keyword">if</span>(cur&gt;<span class="number">1</span>)&#123;</span><br><span class="line">        sum+=((high+<span class="number">1</span>)*i);</span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cur&lt;<span class="number">1</span>)&#123;</span><br><span class="line">        sum+=(high*i);</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        low=(<span class="type">int</span>)(n%i);</span><br><span class="line">        sum+=((high*i)+low+<span class="number">1</span>); </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java-数据结构&quot;&gt;&lt;a href=&quot;#Java-数据结构&quot; class=&quot;headerlink&quot; title=&quot;Java 数据结构&quot;&gt;&lt;/a&gt;Java 数据结构&lt;/h1&gt;&lt;h2 id=&quot;入门篇&quot;&gt;&lt;a href=&quot;#入门篇&quot; class=&quot;headerlink</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/2022/08/25/hello-world/"/>
    <id>http://example.com/2022/08/25/hello-world/</id>
    <published>2022-08-25T04:52:23.186Z</published>
    <updated>2022-08-25T04:52:23.186Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
