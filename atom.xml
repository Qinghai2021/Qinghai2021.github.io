<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Qinghai2021·博客</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-10-05T08:44:59.553Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Qinghai2021</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java网络编程-反射-8新特性</title>
    <link href="http://example.com/2022/10/05/Java%E9%AB%98%E7%BA%A7-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-%E5%8F%8D%E5%B0%84-8%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>http://example.com/2022/10/05/Java%E9%AB%98%E7%BA%A7-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-%E5%8F%8D%E5%B0%84-8%E6%96%B0%E7%89%B9%E6%80%A7/</id>
    <published>2022-10-04T16:00:00.000Z</published>
    <updated>2022-10-05T08:44:59.553Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、网络编程"><a href="#一、网络编程" class="headerlink" title="一、网络编程"></a>一、网络编程</h1><h3 id="1-1网络编程概述"><a href="#1-1网络编程概述" class="headerlink" title="1.1网络编程概述"></a>1.1网络编程概述</h3><p>Java层面的网络编程：</p><ul><li>Java是 Internet 上的语言，它从语言级上提供了对网络应用程序的支持，程序员能够很容易开发常见的网络应用程序。</li><li><strong>Java提供的网络类库，可以实现无痛的网络连接</strong>，联网的底层细节被隐藏在 Java 的本机安装系统里，由 JVM 进行控制。并且 <strong>Java 实现了一个跨平台的网络库，程序员面对的是一个统一的网络编程环境</strong></li></ul><p>网络基础：</p><ul><li>计算机网络：把分布在不同地理区域的计算机与专门的外部设备用通信线路互连成一个规模大、功能强的网络系统，从而使<strong>众多的计算机可以方便地互相传递信息、共享硬件、软件、数据信息等资源</strong>。</li></ul><p>网络编程的目的：</p><ul><li><strong>直接或间接地通过网络协议与其它计算机实现数据交换，进行通讯</strong>。</li></ul><p>网络编程中有<strong>两个主要的问题</strong>：</p><ol><li>如何准确地定位网络上一台或多台主机；定位主机上的特定的应用</li><li>找到主机后如何可靠高效地进行数据传输</li></ol><h3 id="1-2网络通信要素概述"><a href="#1-2网络通信要素概述" class="headerlink" title="1.2网络通信要素概述"></a>1.2网络通信要素概述</h3><p>如何实现网络中的主机互相通信</p><ul><li><p>通信双方地址</p><p>1.IP</p><p>2.端口号</p></li><li><p>一定的规则（即：网络通信协议。有两套参考模型）</p></li></ul><ol><li>OSI参考模型：模型过于理想化，未能在因特网上进行广泛推广</li><li>TCP&#x2F;IP参考模型(或TCP&#x2F;IP协议)：事实上的国际标准。</li><li>二者划分参考图：<img src="/2022/10/05/Java%E9%AB%98%E7%BA%A7-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-%E5%8F%8D%E5%B0%84-8%E6%96%B0%E7%89%B9%E6%80%A7/Snipaste_2022-02-08_18-59-33.png" alt="Snipaste_2022-02-08_18-59-33"></li></ol><p>实现过程：数据封装—–&gt;数据拆封</p><p><img src="/2022/10/05/Java%E9%AB%98%E7%BA%A7-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-%E5%8F%8D%E5%B0%84-8%E6%96%B0%E7%89%B9%E6%80%A7/Snipaste_2022-02-08_18-59-55.png" alt="Snipaste_2022-02-08_18-59-55"></p><h3 id="1-3通信要素一：IP和端口号"><a href="#1-3通信要素一：IP和端口号" class="headerlink" title="1.3通信要素一：IP和端口号"></a>1.3通信要素一：IP和端口号</h3><h4 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h4><p><strong>1.IP 地址:InetAddress</strong></p><ol><li><p>唯一的标识 Internet 上的计算机（通信实体）</p></li><li><p>本地回环地址(hostAddress)：127.0.0.1 主机名(hostName)：localhost</p><p>IP地址分类方式1：IPV4 和 IPV6</p><ol><li>IPV4：4个字节组成，4个0-255。大概42亿，30亿都在北美，亚洲4亿。2011年初已经用尽。以点分十进制表示，如192.168.0.1</li><li>IPV6：128位（16个字节），写成8个无符号整数，每个整数用四个十六进制位表示，数之间用冒号（：）分开，如：3ffe:3201:1401:1280:c8ff:fe4d:db39:1984</li></ol><p>IP地址分类方式2：公网地址(万维网使用)和私有地址(局域网使用)。</p><ul><li>192.168.开头的就是私有址址，范围即为192.168.0.0–192.168.255.255，专门为组织机构内部使用</li></ul></li><li><p>特点：不易记忆—之后使用域名(<a href="http://www.baidu.com)-&gt;后台在去识别其ip地址/">www.baidu.com)-&gt;后台在去识别其IP地址</a></p></li></ol><p><strong>2.端口号</strong></p><ol><li>端口号标识正在计算机上运行的进程（程序）</li><li>不同的进程有不同的端口号</li><li>被规定为一个 16 位的整数 0~65535。</li></ol><p>端口分类：</p><ol><li>公认端口：0~1023。被预先定义的服务通信占用（如：HTTP占用端口80，FTP占用端口21，Telnet占用端口23） </li><li>注册端口：1024~49151。分配给用户进程或应用程序。（如：Tomcat占用端口8080，MySQL占用端口3306，Oracle占用端口1521等）。 </li><li>动态&#x2F;私有端口：49152~65535。</li></ol><p>端口号与IP地址的组合得出一个网络套接字：Socket</p><h4 id="2-使用情景"><a href="#2-使用情景" class="headerlink" title="2.使用情景"></a>2.使用情景</h4><p>一、网络编程中有两个主要的问题</p><ul><li><p>1.如何准确地定位网络上一台或多台主机；定位主机上的特定的应用</p></li><li><p>2.找到主机后如何可靠高效地进行数据传输</p></li></ul><p>二、网络编程中的两个要素解决对应问题：</p><ul><li>1.对应问题一：IP和端口号—双方通信地址</li><li>2.对应问题二：提供网络通信协议：TCP&#x2F;IP参考模型（应用层、传输层、网络层、物理+数据链路层）</li></ul><h4 id="3-IP说明"><a href="#3-IP说明" class="headerlink" title="3.IP说明"></a>3.IP说明</h4><ol><li><p>IP:唯一的标识 Internet 上的计算机（通信实体）</p></li><li><p><strong>在Java中使用InetAddress类代表IP</strong></p></li><li><p>IP分类：</p><p>IPv4 和 IPv6 –&gt;万维网（共有地址） 和 局域网（私有地址）</p></li><li><p>域名:   <a href="http://www.baidu.com/">www.baidu.com</a>   <a href="http://www.mi.com/">www.mi.com</a>  <a href="http://www.sina.com/">www.sina.com</a>  <a href="http://www.jd.com/">www.jd.com</a>  <a href="http://www.vip.com/">www.vip.com</a></p><p>域名解析：域名容易记忆，当在连接网络时输入一个主机的域名后，域名服务器(DNS)负责将域名转化成IP地址，这样才能和主机建立连接</p></li><li><p>本地回路地址：127.0.0.1  对应着：localhost</p></li></ol><p><strong>如何实例化InetAddress:两个方法：</strong></p><ol><li><p>getByName(String host)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">使用域名,后台会去识别其IP地址</span><br><span class="line"><span class="type">InetAddress</span> <span class="variable">inet1</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;192.168.10.14&quot;</span>);</span><br><span class="line"><span class="type">InetAddress</span> <span class="variable">inet2</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;www.atguigu.com&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>getLocalHost()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取本地ip</span></span><br><span class="line"><span class="type">InetAddress</span> <span class="variable">inet4</span> <span class="operator">=</span> InetAddress.getLocalHost();</span><br></pre></td></tr></table></figure></li></ol><p>两个常用方法：</p><ol><li><p>getHostName() </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//getHostName()</span></span><br><span class="line">System.out.println(inet2.getHostName());</span><br><span class="line"><span class="comment">//www.atguigu.com</span></span><br></pre></td></tr></table></figure></li><li><p>getHostAddress()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//getHostAddress()</span></span><br><span class="line">System.out.println(inet2.getHostAddress());</span><br><span class="line"><span class="comment">//111.12.25.212</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="4-端口号说明"><a href="#4-端口号说明" class="headerlink" title="4.端口号说明"></a>4.端口号说明</h4><ol><li>正在计算机上运行的进程。</li><li>要求：不同的进程有不同的端口号</li><li>范围：被规定为一个 16 位的整数 0~65535。</li></ol><p>端口号与IP地址的组合得出一个网络套接字：Socket</p><p>客户端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>创建Socket对象，指明服务器端的ip和端口号</span><br><span class="line"><span class="type">InetAddress</span> <span class="variable">inet</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;192.168.14.100&quot;</span>);</span><br><span class="line">socket = <span class="keyword">new</span> <span class="title class_">Socket</span>(inet,<span class="number">8899</span>);</span><br></pre></td></tr></table></figure><p>服务器端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>创建服务器端的ServerSocket，指明自己的端口号</span><br><span class="line"><span class="type">ServerSocket</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8899</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="1-4通信要素二：网络协议"><a href="#1-4通信要素二：网络协议" class="headerlink" title="1.4通信要素二：网络协议"></a>1.4通信要素二：网络协议</h3><h4 id="1-TCP和UDP协议"><a href="#1-TCP和UDP协议" class="headerlink" title="1.TCP和UDP协议"></a>1.TCP和UDP协议</h4><p>TCP协议：</p><ol><li>使用TCP协议前，<strong>须先建立TCP连接</strong>，<strong>形成传输数据通道</strong></li><li>传输前，采用<strong>“三次握手”</strong>方式，点对点通信，<strong>是可靠的</strong></li><li>TCP协议进行通信的两个应用进程：客户端、服务端。</li><li>在连接中<strong>可进行大数据量的传输</strong></li><li>传输完毕，需<strong>释放已建立的连接，效率低</strong></li></ol><p>三次握手：在传输前，甲通知已，已回复收到，甲在回复收到给已</p><p>四次挥手：在传输结束后，甲通知已结束，已回复收到，已在回复我结束了，甲在回复已，没有回应则结束</p><p>UDP协议： </p><ol><li>将数据、源、目的封装成数据包，<strong>不需要建立连接</strong></li><li>每个数据报的大小限制在64K内 </li><li><strong>发送不管对方是否准备好，接收方收到也不确认，只管发送不管是否收到，故是不可靠的</strong> </li><li>可以广播发送</li><li>发送数据结束时<strong>无需释放资源，开销小，速度快</strong></li></ol><h4 id="2-Socket"><a href="#2-Socket" class="headerlink" title="2.Socket"></a>2.Socket</h4><p><strong>1.介绍</strong></p><ol><li><strong>网络上具有唯一标识的IP地址和端口号组合在一起才能构成唯一能识别的标识符套接字。</strong> </li><li><strong>通信的两端都要有Socket，是两台机器间通信的端点。</strong> </li><li>网络通信其实就是Socket间的通信。</li><li>Socket允许程序把网络连接当成一个流，数据在两个Socket间通过IO传输。</li><li>一般主动发起通信的应用程序属客户端，等待通信请求的为服务端。</li></ol><p>Socket分类：</p><ol><li>流套接字（stream socket）：使用<strong>TCP提供可依赖的字节流</strong>服务</li><li>数据报套接字（datagram socket）：使用<strong>UDP提供“尽力而为”的数据报</strong>服务</li></ol><p> Socket类的常用构造器： </p><ol><li>public Socket(InetAddress address,int port)创建一个<strong>流套接字</strong>并将其连接到指定 IP 地址的指定端口号。 </li><li>public Socket(String host,int port)创建一个<strong>流套接字</strong>并将其连接到指定主机上的指定端口号。</li></ol><p><strong>2.Socket类的常用方法</strong></p><ol><li><p><strong>public InputStream getInputStream()</strong></p><p>返回此套接字的输入流。可以用于接收网络消息</p></li><li><p><strong>public OutputStream getOutputStream()</strong></p><p>返回此套接字的输出流。可以用于发送网络消息</p></li><li><p>public InetAddress getInetAddress()</p><p>此套接字连接到的远程 IP 地址；如果套接字是未连接的，则返回 null。 </p></li><li><p>public InetAddress getLocalAddress()</p><p>获取套接字绑定的本地地址。 即本端的IP地址</p></li><li><p>public int getPort()</p><p>此套接字连接到的远程端口号；如果尚未连接套接字，则返回 0。 </p></li><li><p>public int getLocalPort()</p><p>返回此套接字绑定到的本地端口。 如果尚未绑定套接字，则返回 -1。即本端的端口号。 </p></li><li><p><strong>public void close()</strong></p><p>关闭此套接字。套接字被关闭后，便不可在以后的网络连接中使用（即无法重新连接或重新绑定）。需要创建新的套接字对象。 关闭此套接字也将会关闭该套接字的 InputStream 和OutputStream。 </p></li><li><p><strong>public void shutdownInput()</strong></p><p>如果在套接字上调用 shutdownInput() 后从套接字输入流读取内容，则流将返回 EOF（文件结束符）。 即不能在从此套接字的输入流中接收任何数据。 </p></li><li><p><strong>public void shutdownOutput()</strong></p><p>禁用此套接字的输出流。对于 TCP 套接字，任何以前写入的数据都将被发送，并且后跟 TCP 的正常连接终止序列。 如果在套接字上调用 shutdownOutput() 后写入套接字输出流，则该流将抛出 IOException。 即不能通过此套接字的输出流发送任何数据。</p></li></ol><h3 id="1-5实现TCP的网络编程"><a href="#1-5实现TCP的网络编程" class="headerlink" title="1.5实现TCP的网络编程"></a>1.5实现TCP的网络编程</h3><h5 id="例子1"><a href="#例子1" class="headerlink" title="例子1"></a>例子1</h5><p>客户端发送信息给服务端，服务端将数据显示在控制台上</p><p>抽象举例：客户岛和服务岛，某人开船从客户岛要去服务岛，这人有服务岛的地址（IP地址），且声明了自己船停靠在服务岛的港口号（端口号），服务岛这边则准备好端口号并且接收到这人要来的消息</p><p>注意：先运行服务端等候，在运行客户端去发消息进行交互</p><p>Socket和ServerSocket涉及方法：</p><ol><li><p>getOutputStream() 获取输出流</p></li><li><p>ServerSocket中accept()  表示接收来自于客户端的socket</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ServerSocket</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">9090</span>);</span><br><span class="line"><span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> ss.accept();</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>getInputStream()  获取输入流</p></li></ol><p>代码演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TCPTest1</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//客户端</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">client</span><span class="params">()</span>  &#123;</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.创建Socket对象，指明服务器端的ip和端口号</span></span><br><span class="line">            <span class="type">InetAddress</span> <span class="variable">inet</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;192.168.14.100&quot;</span>);</span><br><span class="line">            socket = <span class="keyword">new</span> <span class="title class_">Socket</span>(inet,<span class="number">8899</span>);</span><br><span class="line">            <span class="comment">//2.获取一个输出流，用于输出数据</span></span><br><span class="line">            os = socket.getOutputStream();</span><br><span class="line">            <span class="comment">//3.写出数据的操作</span></span><br><span class="line">            os.write(<span class="string">&quot;你好，我是客户端mm&quot;</span>.getBytes());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//4.资源的关闭</span></span><br><span class="line">            <span class="keyword">if</span>(os != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    os.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(socket != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    socket.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//服务端</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">server</span><span class="params">()</span>  &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.创建服务器端的ServerSocket，指明自己的端口号</span></span><br><span class="line">            ss = <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8899</span>);</span><br><span class="line">            <span class="comment">//2.调用accept()表示接收来自于客户端的socket</span></span><br><span class="line">            socket = ss.accept();</span><br><span class="line">            <span class="comment">//3.获取输入流</span></span><br><span class="line">            is = socket.getInputStream();</span><br><span class="line"></span><br><span class="line"><span class="comment">//不建议这样写，因为中文是三个字节存储的，可能会拆开转换字符可能会有乱码</span></span><br><span class="line"><span class="comment">//        byte[] buffer = new byte[1024];</span></span><br><span class="line"><span class="comment">//        int len;</span></span><br><span class="line"><span class="comment">//        while((len = is.read(buffer)) != -1)&#123;</span></span><br><span class="line"><span class="comment">//            String str = new String(buffer,0,len);</span></span><br><span class="line"><span class="comment">//            System.out.print(str);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">            <span class="comment">//4.读取输入流中的数据--先存入所有字节，统一转换</span></span><br><span class="line">            baos = <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">5</span>];</span><br><span class="line">            <span class="type">int</span> len;</span><br><span class="line">            <span class="keyword">while</span>((len = is.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">                baos.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(baos.toString());</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;收到了来自于：&quot;</span> + socket.getInetAddress().getHostAddress() + <span class="string">&quot;的数据&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(baos != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="comment">//5.关闭资源</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    baos.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(is != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    is.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(socket != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    socket.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(ss != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    ss.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="例题2"><a href="#例题2" class="headerlink" title="例题2"></a>例题2</h5><p>客户端发送文件给服务端，服务端将文件保存在本地。</p><p>代码演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TCPTest2</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    这里涉及到的异常，应该使用try-catch-finally处理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">client</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//1.</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(InetAddress.getByName(<span class="string">&quot;127.0.0.1&quot;</span>),<span class="number">9090</span>);</span><br><span class="line">        <span class="comment">//2.用socket造一个输出流</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">        <span class="comment">//3.造一个输入流读入文件</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;beauty.jpg&quot;</span>));</span><br><span class="line">        <span class="comment">//4.</span></span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span>((len = fis.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            os.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//5.</span></span><br><span class="line">        fis.close();</span><br><span class="line">        os.close();</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    这里涉及到的异常，应该使用try-catch-finally处理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">server</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//1.</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">9090</span>);</span><br><span class="line">        <span class="comment">//2.</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> ss.accept();</span><br><span class="line">        <span class="comment">//3.用socket造一个输入流</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">        <span class="comment">//4.在造一个输出流将文件保存服务端本地</span></span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;beauty1.jpg&quot;</span>));</span><br><span class="line">        <span class="comment">//5.</span></span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span>((len = is.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            fos.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//6.</span></span><br><span class="line">        fos.close();</span><br><span class="line">        is.close();</span><br><span class="line">        socket.close();</span><br><span class="line">        ss.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="例题3"><a href="#例题3" class="headerlink" title="例题3"></a>例题3</h5><p>从客户端发送文件给服务端，服务端保存到本地。并返回“发送成功”给客户端。并关闭相应的连接。</p><p>涉及方法：</p><ul><li><p>关闭数据的输出 ： socket.shutdownOutput();</p><p>由于服务端是接收方，在还没关闭流前，它不知道你还有没有数据要传输，不能对你进行反馈，所以在客户端传完数据后，调用关闭数据输出</p></li></ul><p>代码演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TCPTest3</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        这里涉及到的异常，应该使用try-catch-finally处理</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">client</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//1.</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(InetAddress.getByName(<span class="string">&quot;127.0.0.1&quot;</span>),<span class="number">9090</span>);</span><br><span class="line">        <span class="comment">//2.</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">        <span class="comment">//3.</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;beauty.jpg&quot;</span>));</span><br><span class="line">        <span class="comment">//4.</span></span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span>((len = fis.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            os.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//关闭数据的输出</span></span><br><span class="line">        socket.shutdownOutput();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.接收来自于服务器端的数据，并显示到控制台上</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">byte</span>[] bufferr = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">20</span>];</span><br><span class="line">        <span class="type">int</span> len1;</span><br><span class="line">        <span class="keyword">while</span>((len1 = is.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            baos.write(buffer,<span class="number">0</span>,len1);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(baos.toString());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6.</span></span><br><span class="line">        fis.close();</span><br><span class="line">        os.close();</span><br><span class="line">        socket.close();</span><br><span class="line">        baos.close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    这里涉及到的异常，应该使用try-catch-finally处理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">server</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//1.</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">9090</span>);</span><br><span class="line">        <span class="comment">//2.</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> ss.accept();</span><br><span class="line">        <span class="comment">//3.</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">        <span class="comment">//4.</span></span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;beauty2.jpg&quot;</span>));</span><br><span class="line">        <span class="comment">//5.</span></span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span>((len = is.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            fos.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;图片传输完成&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6.服务器端给予客户端反馈</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">        os.write(<span class="string">&quot;你好，美女，照片我已收到，非常漂亮！&quot;</span>.getBytes());</span><br><span class="line">        <span class="comment">//7.</span></span><br><span class="line">        fos.close();</span><br><span class="line">        is.close();</span><br><span class="line">        socket.close();</span><br><span class="line">        ss.close();</span><br><span class="line">        os.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="1-6实现UDP的网络编程"><a href="#1-6实现UDP的网络编程" class="headerlink" title="1.6实现UDP的网络编程"></a>1.6实现UDP的网络编程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UDPTest</span> &#123;</span><br><span class="line">    <span class="comment">//发送端</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sender</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"><span class="comment">//1.创建DatagramSocket获取socket</span></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;我是UDP方式发送的导弹&quot;</span>;</span><br><span class="line">        <span class="type">byte</span>[] data = str.getBytes();</span><br><span class="line">        <span class="comment">//2.创建一个包，打包传输的数据、IP、端口号</span></span><br><span class="line">        <span class="type">InetAddress</span> <span class="variable">inet</span> <span class="operator">=</span> InetAddress.getLocalHost();</span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(data,<span class="number">0</span>,data.length,inet,<span class="number">9090</span>);</span><br><span class="line"><span class="comment">//3.发送包</span></span><br><span class="line">        socket.send(packet);</span><br><span class="line"></span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//接收端</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiver</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"><span class="comment">//1.创建DatagramSocket指明端口号获取socket</span></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(<span class="number">9090</span>);</span><br><span class="line"><span class="comment">//2.将创建一个包用于接收数据</span></span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">100</span>];</span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(buffer,<span class="number">0</span>,buffer.length);</span><br><span class="line"><span class="comment">//3.接收--无返回值packet已接收数据</span></span><br><span class="line">        socket.receive(packet);</span><br><span class="line">    <span class="comment">//若要输出时调用getData()返回byte数组，用String构造器转换成字符</span></span><br><span class="line">       System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(packet.getData(),<span class="number">0</span>,packet.getLength()));</span><br><span class="line"><span class="comment">//4.关闭流</span></span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="1-7URL编程"><a href="#1-7URL编程" class="headerlink" title="1.7URL编程"></a>1.7URL编程</h3><h4 id="1-介绍-1"><a href="#1-介绍-1" class="headerlink" title="1.介绍"></a>1.介绍</h4><p>说明：</p><ol><li><p>URL:统一资源定位符，对应着互联网的某一资源地址（如：种子链接）</p></li><li><p>格式：</p><p><a href="http://localhost:8080/examples/beauty.jpg?username=Tom">http://localhost:8080/examples/beauty.jpg?username=Tom</a></p><p>协议   主机名    端口号  资源地址                       参数列表</p></li></ol><p>构造器：</p><ol><li><p>public URL (String spec)：通过一个表示URL地址的字符串可以构造一个URL对象。</p><p>例如：URL url &#x3D; new URL (“<a href="http://localhost:8080/examples/beauty.jpg?username=Tom&quot;">http://localhost:8080/examples/beauty.jpg?username=Tom&quot;</a>); </p></li><li><p>public URL(URL context, String spec)：通过基 URL 和相对 URL 构造一个 URL 对象。</p><p>例如：URL downloadUrl &#x3D; new URL(url, “download.html”)</p></li></ol><p>获取给定属性的方法：</p><ol><li>public String getProtocol( ) 获取该URL的协议名</li><li>public String getHost( ) 获取该URL的主机名</li><li>public String getPort( ) 获取该URL的端口号</li><li>public String getPath( ) 获取该URL的文件路径</li><li>public String getFile( ) 获取该URL的文件名</li><li>public String getQuery( ) 获取该URL的查询名（参数列表）</li></ol><h4 id="2-使用举例"><a href="#2-使用举例" class="headerlink" title="2.使用举例"></a>2.使用举例</h4><p>例子：从互联网服务器端下载一张图片到达到本地</p><p>使用URL定位互联网中特定资源。由于演示，将本机当作服务器端，下载本机上的一张图片。打开本机服务器端：cmd打开控制台—输入：catalina  run ，本地机使用的都是Tomcat服务器。</p><p>涉及方法：</p><ol><li><p>openConnection()  打开连接</p><p>URL对象调用返回URLConnection，这里是HttpURLConnection它的子类</p></li><li><p>connect() 连接服务器</p><p>HttpURLConnection对象调用，无返回值</p></li><li><p>getInputStream();  提供输入流–接收数据</p><p>HttpURLConnection对象调用，返回InputStream输入流–接收数据</p></li><li><p>disconnect()</p><p>HttpURLConnection对象调用，无返回值，关闭连接</p></li></ol><p>代码补充演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">URLTest1</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">HttpURLConnection</span> <span class="variable">urlConnection</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.创建URL,将定位的地址放入构造器</span></span><br><span class="line">            <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;http://localhost:8080/examples/beauty.jpg&quot;</span>);</span><br><span class="line">           <span class="comment">//2.调用openConnection()打开连接</span></span><br><span class="line">  urlConnection = (HttpURLConnection) url.openConnection();</span><br><span class="line">            <span class="comment">//3.connect()连接服务器</span></span><br><span class="line">            urlConnection.connect();</span><br><span class="line"><span class="comment">//4.提供输入流--获取数据</span></span><br><span class="line">            is = urlConnection.getInputStream();</span><br><span class="line">            <span class="comment">//5.提供输出流--存入数据到指定位置</span></span><br><span class="line">            fos = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;day10\\beauty3.jpg&quot;</span>);</span><br><span class="line"><span class="comment">//6.读写操作</span></span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">int</span> len;</span><br><span class="line">            <span class="keyword">while</span>((len = is.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">                fos.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;下载完成&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//7.关闭资源</span></span><br><span class="line">            <span class="keyword">if</span>(is != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    is.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(fos != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fos.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//关闭连接</span></span><br><span class="line">            <span class="keyword">if</span>(urlConnection != <span class="literal">null</span>)&#123;</span><br><span class="line">                urlConnection.disconnect();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="二、Java反射机制"><a href="#二、Java反射机制" class="headerlink" title="二、Java反射机制"></a>二、Java反射机制</h1><h3 id="2-1java反射机制的概述"><a href="#2-1java反射机制的概述" class="headerlink" title="2.1java反射机制的概述"></a>2.1java反射机制的概述</h3><h4 id="1-反射说明"><a href="#1-反射说明" class="headerlink" title="1.反射说明"></a>1.反射说明</h4><ol><li><p>Reflection（反射）是被视为<strong>动态语言</strong>的关键，反射机制允许程序在执行期借助于Reflection API取得任何类的内部消息，并能直接操作任意对象的内部属性及方法</p><p>框架   &#x3D;   反射   +    注解    +    设计模式</p></li><li><p>加载完类之后，在堆内存的方法区中就产生了一个Class类型的对象（一个类只有一个Class对象），这个对象就包含了完整的类的结构信息。我们可以通过这个对象看到类的结构。</p></li><li><p><strong>这个对象就像一面镜子，透过这个镜子看到类的结构，所以，我们形象的称之为：反射</strong></p></li></ol><h4 id="2-动态语言和静态语言"><a href="#2-动态语言和静态语言" class="headerlink" title="2.动态语言和静态语言"></a>2.动态语言和静态语言</h4><p>补充：动态语言 vs 静态语言</p><p>1、动态语言</p><ol><li>是一类在运行时可以改变其结构的语言：例如新的函数、对象、甚至代码可以被引进，已有的函数可以被删除或是其他结构上的变化。通俗点说就是在运行时代码可以根据某些条件改变自身结构。</li><li>主要动态语言：Object-C、C#、JavaScript、PHP、Python、Erlang。</li></ol><p>2、静态语言</p><ul><li>与动态语言相对应的，运行时结构不可变的语言就是静态语言。如Java、C、C++。</li></ul><p>Java不是动态语言，但Java可以称之为“准动态语言”。即Java有一定的动态性，我们可以利用反射机制、字节码操作获得类似动态语言的特性。Java的动态性让编程的时候更加灵活！</p><h4 id="3-Java反射机制提供的功能"><a href="#3-Java反射机制提供的功能" class="headerlink" title="3.Java反射机制提供的功能"></a>3.Java反射机制提供的功能</h4><ol><li>在运行时判断任意一个对象所属的类</li><li>在运行时构造任意一个类的对象</li><li>在运行时判断任意一个类所具有的成员变量和方法</li><li>在运行时获取泛型信息</li><li>在运行时调用任意一个对象的成员变量和方法</li><li>在运行时处理注解</li><li>生成动态代理</li></ol><h4 id="4-反射相关的主要API"><a href="#4-反射相关的主要API" class="headerlink" title="4.反射相关的主要API"></a>4.反射相关的主要API</h4><ol><li><strong>java.lang.Class:代表一个类</strong> </li><li>java.lang.reflect.Method:代表类的方法</li><li>java.lang.reflect.Field:代表类的成员变量</li><li>java.lang.reflect.Constructor:代表类的构造器</li></ol><h3 id="2-2Class类的使用！"><a href="#2-2Class类的使用！" class="headerlink" title="2.2Class类的使用！"></a>2.2Class类的使用！</h3><h4 id="1-Class类的理解"><a href="#1-Class类的理解" class="headerlink" title="1.Class类的理解"></a>1.Class类的理解</h4><p>关于java.lang.Class类的理解</p><p>1、类的加载过程：</p><ol><li>程序经过<strong>javac.exe命令</strong>以后，会生成一个或多个<strong>字节码文件</strong>(.class结尾)。</li><li>接着我们使用java.exe命令对某个字节码文件进行<strong>解释运行</strong>。相当于将某个字节码文件<strong>加载到内存中</strong>。此过程就称为<strong>类的加载</strong>。</li><li>加载到内存中的类，我们就称为<strong>运行时类</strong>，此<strong>运行时类，就作为Class的一个实例</strong>。</li></ol><p>2、换句话说，<strong>Class的实例就对应着一个运行时类</strong>。</p><p>3、加载到内存中的<strong>运行时类，会缓存一定的时间</strong>。在此时间之内，<strong>我们可以通过不同的方式来获取此运行时类。</strong></p><h4 id="2-获取Class的实例方式"><a href="#2-获取Class的实例方式" class="headerlink" title="2.获取Class的实例方式"></a>2.获取Class的实例方式</h4><p>获取Class的实例的方式（前三种方式需要掌握、四种方式获取Person运行时类，地址都相同，都是同一个）</p><ol><li><p>方式一：调用运行时类的属性：. class</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clazz1</span> <span class="operator">=</span> Person.class;</span><br><span class="line">System.out.println(clazz1);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>方式二：通过运行时类的对象,调用getClass()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="type">Class</span> <span class="variable">clazz2</span> <span class="operator">=</span> p1.getClass();</span><br><span class="line">System.out.println(clazz2);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>方式三：调用Class的静态方法：forName(String classPath)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clazz3</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.atguigu.java.Person&quot;</span>);</span><br><span class="line"><span class="comment">//clazz3 = Class.forName(&quot;java.lang.String&quot;);</span></span><br><span class="line">        System.out.println(clazz3);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>方式四：使用类的加载器：ClassLoader  (了解)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ReflectionTest.class 当前类</span></span><br><span class="line"><span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> ReflectionTest.class.getClassLoader();</span><br><span class="line"><span class="type">Class</span> <span class="variable">clazz4</span> <span class="operator">=</span> classLoader.loadClass(<span class="string">&quot;com.atguigu.java.Person&quot;</span>);</span><br><span class="line">System.out.println(clazz4);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h4 id="3-Class实例可以是哪些结构"><a href="#3-Class实例可以是哪些结构" class="headerlink" title="3.Class实例可以是哪些结构"></a>3.Class实例可以是哪些结构</h4><p>再次理解：万事万物皆对象？</p><ul><li>都是面向对象进行的：对象.xxx,File,URL,反射,前端、数据库操作</li><li>所有类都可作为Class类的对象，Class类本身也可作为Class类的对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Class实例可以是哪些结构的说明：</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Class</span> <span class="variable">c1</span> <span class="operator">=</span> Object.class;</span><br><span class="line">    <span class="type">Class</span> <span class="variable">c2</span> <span class="operator">=</span> Comparable.class;</span><br><span class="line">    <span class="type">Class</span> <span class="variable">c3</span> <span class="operator">=</span> String[].class;</span><br><span class="line">    <span class="type">Class</span> <span class="variable">c4</span> <span class="operator">=</span> <span class="type">int</span>[][].class;</span><br><span class="line">    <span class="type">Class</span> <span class="variable">c5</span> <span class="operator">=</span> ElementType.class;</span><br><span class="line">    <span class="type">Class</span> <span class="variable">c6</span> <span class="operator">=</span> Override.class;</span><br><span class="line">    <span class="type">Class</span> <span class="variable">c7</span> <span class="operator">=</span> <span class="type">int</span>.class;</span><br><span class="line">    <span class="type">Class</span> <span class="variable">c8</span> <span class="operator">=</span> <span class="keyword">void</span>.class;</span><br><span class="line">    <span class="type">Class</span> <span class="variable">c9</span> <span class="operator">=</span> Class.class;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>[] a = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="type">int</span>[] b = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">100</span>];</span><br><span class="line">    <span class="type">Class</span> <span class="variable">c10</span> <span class="operator">=</span> a.getClass();</span><br><span class="line">    <span class="type">Class</span> <span class="variable">c11</span> <span class="operator">=</span> b.getClass();</span><br><span class="line">    <span class="comment">// 只要数组的元素类型与维度一样，就是同一个Class</span></span><br><span class="line">    System.out.println(c10 == c11);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-反射使用前后对比"><a href="#4-反射使用前后对比" class="headerlink" title="4.反射使用前后对比"></a>4.反射使用前后对比</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectionTest</span> &#123;</span><br><span class="line"><span class="comment">//反射之前，对于Person的操作**********************</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.创建Person类的对象</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Tom&quot;</span>, <span class="number">12</span>);</span><br><span class="line">        <span class="comment">//2.通过对象，调用其内部的属性、方法</span></span><br><span class="line">        p1.age = <span class="number">10</span>;</span><br><span class="line">        System.out.println(p1.toString());</span><br><span class="line">        p1.show();</span><br><span class="line">      <span class="comment">//在Person类外部，不可以通过Person类的对象调用其内部私有结构。</span></span><br><span class="line">        <span class="comment">//比如：name、showNation()以及私有的构造器</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//反射之后，对于Person的操作***********************</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Person.class;</span><br><span class="line">        <span class="comment">//1.通过反射，创建Person类的对象</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">cons</span> <span class="operator">=</span> clazz.getConstructor(String.class,<span class="type">int</span>.class);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> cons.newInstance(<span class="string">&quot;Tom&quot;</span>, <span class="number">12</span>);</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> (Person) obj;</span><br><span class="line">        System.out.println(p.toString());</span><br><span class="line">        <span class="comment">//2.通过反射，调用对象指定的属性、方法</span></span><br><span class="line">        <span class="comment">//调用属性</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">age</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">        age.set(p,<span class="number">10</span>);</span><br><span class="line">        System.out.println(p.toString());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用方法</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">show</span> <span class="operator">=</span> clazz.getDeclaredMethod(<span class="string">&quot;show&quot;</span>);</span><br><span class="line">        show.invoke(p);</span><br><span class="line">        </span><br><span class="line">   System.out.println(<span class="string">&quot;*******************************&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过反射，可以调用Person类的私有结构的。比如：私有的构造器、方法、属性</span></span><br><span class="line">        <span class="comment">//调用私有的构造器</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">cons1</span> <span class="operator">=</span> clazz.getDeclaredConstructor(String.class);</span><br><span class="line">        cons1.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> (Person) cons1.newInstance(<span class="string">&quot;Jerry&quot;</span>);</span><br><span class="line">        System.out.println(p1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用私有的属性</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">name</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        name.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        name.set(p1,<span class="string">&quot;HanMeimei&quot;</span>);</span><br><span class="line">        System.out.println(p1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用私有的方法</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">showNation</span> <span class="operator">=</span> clazz.getDeclaredMethod(<span class="string">&quot;showNation&quot;</span>, String.class);</span><br><span class="line">        showNation.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">nation</span> <span class="operator">=</span> (String) showNation.invoke(p1,<span class="string">&quot;中国&quot;</span>);<span class="comment">//相当于String nation = p1.showNation(&quot;中国&quot;)</span></span><br><span class="line">        System.out.println(nation);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>疑问1：通过直接new的方式或反射的方式都可以调用公共的结构，开发中到底用那个？</p><ul><li>建议：直接new的方式。</li><li>什么时候会使用：反射的方式。 反射的特征：动态性</li></ul><p>疑问2：反射机制与面向对象中的封装性是不是矛盾的？如何看待两个技术？<br>不矛盾。</p><h3 id="2-3类的加载与ClassLoader的理解"><a href="#2-3类的加载与ClassLoader的理解" class="headerlink" title="2.3类的加载与ClassLoader的理解"></a>2.3类的加载与ClassLoader的理解</h3><h4 id="1-类的加载"><a href="#1-类的加载" class="headerlink" title="1.类的加载"></a>1.类的加载</h4><p>类的加载过程：</p><p><img src="/2022/10/05/Java%E9%AB%98%E7%BA%A7-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-%E5%8F%8D%E5%B0%84-8%E6%96%B0%E7%89%B9%E6%80%A7/Snipaste_2022-02-09_17-04-47.png" alt="Snipaste_2022-02-09_17-04-47"></p><p>程序运行过程：</p><p><img src="/2022/10/05/Java%E9%AB%98%E7%BA%A7-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-%E5%8F%8D%E5%B0%84-8%E6%96%B0%E7%89%B9%E6%80%A7/Snipaste_2022-02-09_17-05-42.png" alt="Snipaste_2022-02-09_17-05-42"></p><p>类加载器的作用：</p><ol><li>类加载的作用：将class文件字节码内容加载到内存中，并<strong>将这些静态数据转换成方法区的运行时数据结构</strong>，然后在<strong>堆中生成一个代表这个类的java.lang.Class对象</strong>，<strong>作为方法区中类数据的访问入口</strong>。 </li><li>类缓存：标准的JavaSE类加载器可以按要求查找类，但一旦某个类被加载到类加载器中，它将<strong>维持加载（缓存）一段时间</strong>。不过JVM垃圾回收机制可以回收这些Class对象</li></ol><h4 id="2-ClassLoader加载器"><a href="#2-ClassLoader加载器" class="headerlink" title="2.ClassLoader加载器"></a>2.ClassLoader加载器</h4><p>1、类加载器作用是用来把类(class)装载进内存的。JVM 规范定义了<strong>如下类型的类的加载器。</strong></p><ol><li>引导类加载器：用C++编写的，是JVM自带的类加载器，负责Java平台核心库，用来<strong>装载核心类库</strong>。<strong>该加载器无法直接获取</strong></li><li>扩展类加载器：负责jre&#x2F;lib&#x2F;ext目录下的jar包或 –D java.ext.dirs 指定目录下的jar包装入工作库</li><li>系统类加载器：负责java –classpath 或 –D java.class.path所指的目录下的类与jar包装入工作 ，是<strong>最常用的加载器</strong></li></ol><p>2、获取上述加载器：</p><ol><li><p>获取一个系统类加载器</p><p>ClassLoader classloader &#x3D; ClassLoader.<strong>getSystemClassLoader()</strong>;</p><p>System.out.println(classloader);</p></li><li><p>获取系统类加载器的父类加载器，即扩展类加载器</p><p>classloader &#x3D; classloader.<strong>getParent()</strong>;</p><p>System.out.println(classloader);</p></li><li><p>获取扩展类加载器的父类加载器，即引导类加载器</p><p>classloader &#x3D; classloader.getParent();</p><p>System.out.println(classloader); &#x2F;&#x2F;<strong>null,这是无法获取的</strong></p><ul><li>调用扩展类加载器的getParent()：无法获取引导类加载器</li><li>引导类加载器主要负责加载java的核心类库，无法加载自定义类的。</li></ul></li></ol><p>3、<strong>对于自定义类，使用系统类加载器进行加载</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassLoaderTest</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span>  <span class="comment">//获取自定义类的系统加载器getClassLoader()</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> ClassLoaderTest.class.getClassLoader();</span><br><span class="line">System.out.println(classLoader);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>4、测试当前类由哪个类加载器进行加载</p><ol><li><p>classloader &#x3D; Class.forName(“exer2.ClassloaderDemo”).getClassLoader();</p><p>System.out.println(classloader);</p></li></ol><p>5、测试JDK提供的Object类由哪个类加载器加载</p><ol><li><p>classloader &#x3D; Class.forName(“java.lang.Object”).getClassLoader();</p><p>System.out.println(classloader);</p></li></ol><p>6、关于类加载器的一个主要方法：getResourceAsStream(String str):获取类路径下的指定文件的输入流</p><ul><li>InputStream in &#x3D; null;</li><li>in&#x3D;this.getClass().getClassLoader().<strong>getResourceAsStream</strong>(“jdbc1.properties”);</li><li>System.out.println(in);</li></ul><h4 id="3-类加载器读取配置文件"><a href="#3-类加载器读取配置文件" class="headerlink" title="3.类加载器读取配置文件!"></a>3.类加载器读取配置文件!</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    Properties：用来读取配置文件。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassLoaderTest</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">pros</span> <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        <span class="comment">//此时的文件默认在当前的module下。</span></span><br><span class="line">        <span class="comment">//读取配置文件的方式一：</span></span><br><span class="line"><span class="comment">//        FileInputStream fis = new FileInputStream(&quot;jdbc.properties&quot;);</span></span><br><span class="line"><span class="comment">//        FileInputStream fis = new FileInputStream(&quot;src\\jdbc1.properties&quot;);</span></span><br><span class="line"><span class="comment">//        pros.load(fis);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//读取配置文件的方式二：使用ClassLoader</span></span><br><span class="line">        <span class="comment">//配置文件默认识别为：当前module的src下</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> ClassLoaderTest.class.getClassLoader();</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> classLoader.getResourceAsStream(<span class="string">&quot;jdbc1.properties&quot;</span>);</span><br><span class="line">        pros.load(is);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;user = &quot;</span> + user + <span class="string">&quot;,password = &quot;</span> + password);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-4创建运行时类对象！"><a href="#2-4创建运行时类对象！" class="headerlink" title="2.4创建运行时类对象！"></a>2.4创建运行时类对象！</h3><h4 id="1-理解-反射的动态性"><a href="#1-理解-反射的动态性" class="headerlink" title="1.理解-反射的动态性"></a>1.理解-反射的动态性</h4><p>Class代表运行时类，该类的对象也称做运行时类对象，这里主要讲解：<strong>调用Class对象的newInstance()方法创建类的对象</strong>。要想此方法正常的创建运行时类的对象要<strong>满足两个要求</strong>： </p><ol><li>运行时类必须提供空参的构造器</li><li>空参的构造器的访问权限得够。通常，设置为public。</li></ol><p>举例：在javabean中要求提供一个public的空参构造器。原因：<br>1.便于通过反射，创建运行时类的对象<br>2.便于子类继承此运行时类时，默认调用super()时，保证父类有此构造器</p><p><strong>代码演示：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//体会反射的动态性</span></span><br><span class="line"><span class="comment">//解释：这里创建一个方法，该方法用来实现创建对象，通过调用此方法，随机发送不同的指定的全类名就可以创建对象--体现反射的动态性</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NewInstanceTest</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; <span class="number">100</span>;i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">3</span>);<span class="comment">//0,1,2</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">classPath</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">switch</span>(num)&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                    classPath = <span class="string">&quot;java.util.Date&quot;</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                    classPath = <span class="string">&quot;java.lang.Object&quot;</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                    classPath = <span class="string">&quot;com.atguigu.java.Person&quot;</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123; <span class="comment">//调用创建方法</span></span><br><span class="line">                <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> getInstance(classPath);</span><br><span class="line">                System.out.println(obj);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    创建一个指定类的对象。</span></span><br><span class="line"><span class="comment">    classPath:指定类的全类名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getInstance</span><span class="params">(String classPath)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">       <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span>  Class.forName(classPath);</span><br><span class="line">       <span class="keyword">return</span> clazz.newInstance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="2-补充一个问题"><a href="#2-补充一个问题" class="headerlink" title="2.补充一个问题"></a>2.补充一个问题</h4><p>难道没有无参的构造器就不能创建对象了吗？</p><ul><li><p>不是！只要在操作的时候明确的调用类中的构造器，并将参数传递进去之后，才可以实例化操作。</p></li><li><p>创建运行时对象是为了体现反射的动态性，这里会将创建方式复杂化，体现不了反射动态性</p></li><li><p>步骤如下：</p></li><li><p>根据全类名获取对应的Class对象</p><p>String name &#x3D; “atguigu.java.Person”;</p><p>Class clazz &#x3D; null;</p><p>clazz &#x3D; Class.forName(name);</p></li><li><p>调用指定参数结构的构造器，生成Constructor的实例</p><p>Constructor con &#x3D; clazz.getConstructor(String.class,Integer.class);</p></li><li><p>通过Constructor的实例创建对应类的对象，并初始化类属性</p><p>Person p2 &#x3D; (Person) con.newInstance(“Peter”,20);</p><p>System.out.println(p2);</p></li></ul><h4 id="3-创建类的对象的方式总结"><a href="#3-创建类的对象的方式总结" class="headerlink" title="3.创建类的对象的方式总结"></a>3.创建类的对象的方式总结</h4><p>方式一：new  +  构造器</p><p>方式二：要创建Xxx类的对象，可以考虑：Xxx、Xxxs、XxxFactory、XxxBuilder类中查看是否有静态方法的存在。可以调用其静态方法，创建Xxx对象。</p><p>方式三：通过反射</p><h3 id="2-5获取运行时类的完整结构"><a href="#2-5获取运行时类的完整结构" class="headerlink" title="2.5获取运行时类的完整结构"></a>2.5获取运行时类的完整结构</h3><p>（大部分为暂时了解）除了获取运行时类的带泛型的父类的泛型和获取运行时类实现的接口–后面会用到</p><h4 id="1-获取当前运行时类的属性结构"><a href="#1-获取当前运行时类的属性结构" class="headerlink" title="1.获取当前运行时类的属性结构"></a>1.获取当前运行时类的属性结构</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取当前运行时类的属性结构</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shkstart</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2019 下午 3:23</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FieldTest</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Person.class;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取属性结构</span></span><br><span class="line">        <span class="comment">//getFields():获取当前运行时类及其父类中声明为public访问权限的属性</span></span><br><span class="line">        Field[] fields = clazz.getFields();</span><br><span class="line">        <span class="keyword">for</span>(Field f : fields)&#123;</span><br><span class="line">            System.out.println(f);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//getDeclaredFields():获取当前运行时类中声明的所有属性。（不包含父类中声明的属性）</span></span><br><span class="line">        Field[] declaredFields = clazz.getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span>(Field f : declaredFields)&#123;</span><br><span class="line">            System.out.println(f);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//权限修饰符  数据类型 变量名</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Person.class;</span><br><span class="line">        Field[] declaredFields = clazz.getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span>(Field f : declaredFields)&#123;</span><br><span class="line">            <span class="comment">//1.权限修饰符</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">modifier</span> <span class="operator">=</span> f.getModifiers();</span><br><span class="line">            System.out.print(Modifier.toString(modifier) + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//2.数据类型</span></span><br><span class="line">            <span class="type">Class</span> <span class="variable">type</span> <span class="operator">=</span> f.getType();</span><br><span class="line">            System.out.print(type.getName() + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//3.变量名</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">fName</span> <span class="operator">=</span> f.getName();</span><br><span class="line">            System.out.print(fName);</span><br><span class="line"></span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="2-获取运行时类的方法结构"><a href="#2-获取运行时类的方法结构" class="headerlink" title="2.获取运行时类的方法结构"></a>2.获取运行时类的方法结构</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取运行时类的方法结构</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shkstart</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2019 下午 3:37</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Person.class;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//getMethods():获取当前运行时类及其所有父类中声明为public权限的方法</span></span><br><span class="line">        Method[] methods = clazz.getMethods();</span><br><span class="line">        <span class="keyword">for</span>(Method m : methods)&#123;</span><br><span class="line">            System.out.println(m);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="comment">//getDeclaredMethods():获取当前运行时类中声明的所有方法。（不包含父类中声明的方法）</span></span><br><span class="line">        Method[] declaredMethods = clazz.getDeclaredMethods();</span><br><span class="line">        <span class="keyword">for</span>(Method m : declaredMethods)&#123;</span><br><span class="line">            System.out.println(m);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    @Xxxx</span></span><br><span class="line"><span class="comment">    权限修饰符  返回值类型  方法名(参数类型1 形参名1,...) throws XxxException&#123;&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Person.class;</span><br><span class="line">        Method[] declaredMethods = clazz.getDeclaredMethods();</span><br><span class="line">        <span class="keyword">for</span>(Method m : declaredMethods)&#123;</span><br><span class="line">            <span class="comment">//1.获取方法声明的注解</span></span><br><span class="line">            Annotation[] annos = m.getAnnotations();</span><br><span class="line">            <span class="keyword">for</span>(Annotation a : annos)&#123;</span><br><span class="line">                System.out.println(a);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//2.权限修饰符</span></span><br><span class="line">            System.out.print(Modifier.toString(m.getModifiers()) + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//3.返回值类型</span></span><br><span class="line">            System.out.print(m.getReturnType().getName() + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//4.方法名</span></span><br><span class="line">            System.out.print(m.getName());</span><br><span class="line">            System.out.print(<span class="string">&quot;(&quot;</span>);</span><br><span class="line">            <span class="comment">//5.形参列表</span></span><br><span class="line">            Class[] parameterTypes = m.getParameterTypes();</span><br><span class="line">            <span class="keyword">if</span>(!(parameterTypes == <span class="literal">null</span> &amp;&amp; parameterTypes.length == <span class="number">0</span>))&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; parameterTypes.length;i++)&#123;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span>(i == parameterTypes.length - <span class="number">1</span>)&#123;</span><br><span class="line">                        System.out.print(parameterTypes[i].getName() + <span class="string">&quot; args_&quot;</span> + i);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                 System.out.print(parameterTypes[i].getName() + <span class="string">&quot; args_&quot;</span> + i + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.print(<span class="string">&quot;)&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//6.抛出的异常</span></span><br><span class="line">            Class[] exceptionTypes = m.getExceptionTypes();</span><br><span class="line">            <span class="keyword">if</span>(exceptionTypes.length &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;throws &quot;</span>);</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; exceptionTypes.length;i++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(i == exceptionTypes.length - <span class="number">1</span>)&#123;</span><br><span class="line">                        System.out.print(exceptionTypes[i].getName());</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                   System.out.print(exceptionTypes[i].getName() + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="3-获取构造器结构"><a href="#3-获取构造器结构" class="headerlink" title="3.获取构造器结构"></a>3.获取构造器结构</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">获取构造器结构</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Person.class;</span><br><span class="line">    <span class="comment">//getConstructors():获取当前运行时类中声明为public的构造器</span></span><br><span class="line">    Constructor[] constructors = clazz.getConstructors();</span><br><span class="line">    <span class="keyword">for</span>(Constructor c : constructors)&#123;</span><br><span class="line">        System.out.println(c);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">    <span class="comment">//getDeclaredConstructors():获取当前运行时类中声明的所有的构造器</span></span><br><span class="line">    Constructor[] declaredConstructors = clazz.getDeclaredConstructors();</span><br><span class="line">    <span class="keyword">for</span>(Constructor c : declaredConstructors)&#123;</span><br><span class="line">        System.out.println(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="4-获取运行时类的父类"><a href="#4-获取运行时类的父类" class="headerlink" title="4.获取运行时类的父类"></a>4.获取运行时类的父类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">获取运行时类的父类</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Person.class;</span><br><span class="line"></span><br><span class="line">    <span class="type">Class</span> <span class="variable">superclass</span> <span class="operator">=</span> clazz.getSuperclass();</span><br><span class="line">    System.out.println(superclass);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="5-获取运行时类的带泛型的父类"><a href="#5-获取运行时类的带泛型的父类" class="headerlink" title="5.获取运行时类的带泛型的父类"></a>5.获取运行时类的带泛型的父类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">获取运行时类的带泛型的父类</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Person.class;</span><br><span class="line"></span><br><span class="line">    <span class="type">Type</span> <span class="variable">genericSuperclass</span> <span class="operator">=</span> clazz.getGenericSuperclass();</span><br><span class="line">    System.out.println(genericSuperclass);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="6-获取运行时类的带泛型的父类的泛型"><a href="#6-获取运行时类的带泛型的父类的泛型" class="headerlink" title="6.获取运行时类的带泛型的父类的泛型"></a>6.获取运行时类的带泛型的父类的泛型</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    获取运行时类的带泛型的父类的泛型</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    代码：逻辑性代码  vs 功能性代码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Person.class;</span><br><span class="line"></span><br><span class="line">        <span class="type">Type</span> <span class="variable">genericSuperclass</span> <span class="operator">=</span> clazz.getGenericSuperclass();</span><br><span class="line">        <span class="type">ParameterizedType</span> <span class="variable">paramType</span> <span class="operator">=</span> (ParameterizedType) genericSuperclass;</span><br><span class="line">        <span class="comment">//获取泛型类型</span></span><br><span class="line">        Type[] actualTypeArguments = paramType.getActualTypeArguments();</span><br><span class="line"><span class="comment">//        System.out.println(actualTypeArguments[0].getTypeName());</span></span><br><span class="line">        System.out.println(((Class)actualTypeArguments[<span class="number">0</span>]).getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="7-获取运行时类实现的接口"><a href="#7-获取运行时类实现的接口" class="headerlink" title="7.获取运行时类实现的接口"></a>7.获取运行时类实现的接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">获取运行时类实现的接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test5</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Person.class;</span><br><span class="line"></span><br><span class="line">    Class[] interfaces = clazz.getInterfaces();</span><br><span class="line">    <span class="keyword">for</span>(Class c : interfaces)&#123;</span><br><span class="line">        System.out.println(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println();</span><br><span class="line">    <span class="comment">//获取运行时类的父类实现的接口</span></span><br><span class="line">    Class[] interfaces1 = clazz.getSuperclass().getInterfaces();</span><br><span class="line">    <span class="keyword">for</span>(Class c : interfaces1)&#123;</span><br><span class="line">        System.out.println(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="8-获取运行时类所在的包"><a href="#8-获取运行时类所在的包" class="headerlink" title="8.获取运行时类所在的包"></a>8.获取运行时类所在的包</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    获取运行时类所在的包</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test6</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Person.class;</span><br><span class="line"></span><br><span class="line">    <span class="type">Package</span> <span class="variable">pack</span> <span class="operator">=</span> clazz.getPackage();</span><br><span class="line">    System.out.println(pack);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="9-获取运行时类声明的注解"><a href="#9-获取运行时类声明的注解" class="headerlink" title="9.获取运行时类声明的注解"></a>9.获取运行时类声明的注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   获取运行时类声明的注解</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test7</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Person.class;</span><br><span class="line"></span><br><span class="line">    Annotation[] annotations = clazz.getAnnotations();</span><br><span class="line">    <span class="keyword">for</span>(Annotation annos : annotations)&#123;</span><br><span class="line">        System.out.println(annos);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-6调用运行时类的指定结构！"><a href="#2-6调用运行时类的指定结构！" class="headerlink" title="2.6调用运行时类的指定结构！"></a>2.6调用运行时类的指定结构！</h3><h4 id="1-如何操作运行时类中的指定的属性"><a href="#1-如何操作运行时类中的指定的属性" class="headerlink" title="1.如何操作运行时类中的指定的属性"></a>1.如何操作运行时类中的指定的属性</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">如何操作运行时类中的指定的属性 -- 需要掌握</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testField1</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Person.class;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建运行时类的对象</span></span><br><span class="line">    <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> (Person) clazz.newInstance();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1. getDeclaredField(String fieldName):获取运行时类中指定变量名的属性</span></span><br><span class="line">    <span class="type">Field</span> <span class="variable">name</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.保证当前属性是可访问的</span></span><br><span class="line">    name.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="comment">//3.获取、设置指定对象的此属性值</span></span><br><span class="line">    name.set(p,<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(name.get(p));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="2-如何操作运行时类中的指定的方法"><a href="#2-如何操作运行时类中的指定的方法" class="headerlink" title="2.如何操作运行时类中的指定的方法"></a>2.如何操作运行时类中的指定的方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    如何操作运行时类中的指定的方法 -- 需要掌握</span></span><br><span class="line"><span class="comment">    包含如何调用静态方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testMethod</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Person.class;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建运行时类的对象</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> (Person) clazz.newInstance();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        1.获取指定的某个方法</span></span><br><span class="line"><span class="comment">        getDeclaredMethod():参数1 ：指明获取的方法的名称  参数2：指明获取的方法的形参列表</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">show</span> <span class="operator">=</span> clazz.getDeclaredMethod(<span class="string">&quot;show&quot;</span>, String.class);</span><br><span class="line">        <span class="comment">//2.保证当前方法是可访问的</span></span><br><span class="line">        show.setAccessible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        3. 调用方法的invoke():参数1：方法的调用者  参数2：给方法形参赋值的实参</span></span><br><span class="line"><span class="comment">        invoke()的返回值即为对应类中调用的方法的返回值。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">returnValue</span> <span class="operator">=</span> show.invoke(p,<span class="string">&quot;CHN&quot;</span>); <span class="comment">//String nation = p.show(&quot;CHN&quot;);</span></span><br><span class="line">        System.out.println(returnValue);</span><br><span class="line"></span><br><span class="line">      System.out.println(<span class="string">&quot;*********如何调用静态方法*********&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// private static void showDesc()</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Method</span> <span class="variable">showDesc</span> <span class="operator">=</span> clazz.getDeclaredMethod(<span class="string">&quot;showDesc&quot;</span>);</span><br><span class="line">        showDesc.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">//如果调用的运行时类中的方法没有返回值，则此invoke()返回null</span></span><br><span class="line"><span class="comment">//        Object returnVal = showDesc.invoke(null);</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">returnVal</span> <span class="operator">=</span> showDesc.invoke(Person.class);</span><br><span class="line">        System.out.println(returnVal);<span class="comment">//null</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="4-如何调用运行时类中的指定的构造器"><a href="#4-如何调用运行时类中的指定的构造器" class="headerlink" title="4.如何调用运行时类中的指定的构造器"></a>4.如何调用运行时类中的指定的构造器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">如何调用运行时类中的指定的构造器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testConstructor</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Person.class;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//private Person(String name)</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    1.获取指定的构造器</span></span><br><span class="line"><span class="comment">    getDeclaredConstructor():参数：指明构造器的参数列表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> clazz.getDeclaredConstructor(String.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.保证此构造器是可访问的</span></span><br><span class="line">    constructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.调用此构造器创建运行时类的对象</span></span><br><span class="line">    <span class="type">Person</span> <span class="variable">per</span> <span class="operator">=</span> (Person) constructor.newInstance(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">    System.out.println(per);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-7动态代理"><a href="#2-7动态代理" class="headerlink" title="2.7动态代理"></a>2.7动态代理</h3><h4 id="1-代理模式介绍"><a href="#1-代理模式介绍" class="headerlink" title="1.代理模式介绍"></a>1.代理模式介绍</h4><p>代理设计模式的原理: </p><ol><li>使用一个代理将对象包装起来, 然后用该代理对象取代原始对象。</li><li>任何对原始对象的调用都要通过代理。</li></ol><h4 id="2-静态代理演示"><a href="#2-静态代理演示" class="headerlink" title="2.静态代理演示"></a>2.静态代理演示</h4><p>之前为大家讲解过代理机制的操作，属于<strong>静态代理</strong>，特征是代理类和目标</p><p>对象的类都是在编译期间确定下来，<strong>不利于程序的扩展</strong>。同时，<strong>每一个代</strong></p><p><strong>理类只能为一个接口服务，这样一来程序开发中必然产生过多的代理。最</strong></p><p><strong>好可以通过一个代理类完成全部的代理功能</strong></p><p><strong>代码演示：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">ClothFactory</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">produceCloth</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//代理类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProxyClothFactory</span> <span class="keyword">implements</span> <span class="title class_">ClothFactory</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ClothFactory factory;<span class="comment">//用被代理类对象进行实例化</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ProxyClothFactory</span><span class="params">(ClothFactory factory)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.factory = factory;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">produceCloth</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;代理工厂做一些准备工作&quot;</span>);</span><br><span class="line">        factory.produceCloth();    <span class="comment">//调用被代理类的同名方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;代理工厂做一些后续的收尾工作&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//被代理类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NikeClothFactory</span> <span class="keyword">implements</span> <span class="title class_">ClothFactory</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">produceCloth</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Nike工厂生产一批运动服&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//main方法操作代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticProxyTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建被代理类的对象</span></span><br><span class="line">        <span class="type">ClothFactory</span> <span class="variable">nike</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NikeClothFactory</span>();</span><br><span class="line">        <span class="comment">//创建代理类的对象</span></span><br><span class="line">        <span class="type">ClothFactory</span> <span class="variable">proxyClothFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyClothFactory</span>(nike);</span><br><span class="line"><span class="comment">//通过调用代理类方法，内部在去调用被代理类同名方法</span></span><br><span class="line">        proxyClothFactory.produceCloth();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="3-动态代理及AOP代理演示"><a href="#3-动态代理及AOP代理演示" class="headerlink" title="3.动态代理及AOP代理演示"></a>3.动态代理及AOP代理演示</h4><p><strong>动态代理相比于静态代理的优点：</strong></p><ol><li>动态代理是指客户通过代理类来调用其它对象的方法，并且是在程序运行时根据需要<strong>动态创建目标类的代理对象</strong>。</li><li>抽象角色中（接口）声明的所有方法都被转移到调用处理器一个集中的方法中处理，这样，我们可以更加灵活和统一的处理众多的方法。</li></ol><p>动态代理使用场合: </p><ol><li>调试</li><li>远程方法调用</li></ol><p>Proxy ：专门完成代理的操作类，是所有动态代理类的父类。通过此类为一个或多个接口动态地生成实现类。</p><p>AOP代理：AOP代理里的方法可以在执行目标方法之前、之后插入一些通用处理(现阶段只需做简单了解)</p><ul><li>举例理解：排序算法中都有交换操作，将这些操作封装到一个通用方法里。没有动态代理之前是通过排序算法中调用此通用方法；有了动态代理后，只需代理调用被代理的目标方法时，在执行目标方法之前或之后插入一些通用处理</li></ul><p><strong>具体实现代码演示：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Human</span>&#123;</span><br><span class="line">    String <span class="title function_">getBelief</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">(String food)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//被代理类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SuperMan</span> <span class="keyword">implements</span> <span class="title class_">Human</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getBelief</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;I believe I can fly!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">(String food)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我喜欢吃&quot;</span> + food);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">APO代理：创建一个类，封装一些通用处理的方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HumanUtil</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;====================通用方法一====================&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;====================通用方法二====================&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">要想实现动态代理，需要解决的问题？</span></span><br><span class="line"><span class="comment">问题一：如何根据加载到内存中的被代理类，动态的创建一个代理类及其对象。</span></span><br><span class="line"><span class="comment">问题二：当通过代理类的对象调用方法a时，如何动态的去调用被代理类中的同名方法a。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProxyFactory</span>&#123;</span><br><span class="line">    <span class="comment">//调用此方法，返回一个代理类的对象。解决问题一</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">getProxyInstance</span><span class="params">(Object obj)</span>&#123;<span class="comment">//obj:被代理类的对象</span></span><br><span class="line">        <span class="type">MyInvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyInvocationHandler</span>();</span><br><span class="line">        handler.bind(obj);<span class="comment">//对MyInvocationHandler被代理类的对象进行赋值</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">/*作用：直接创建一个动态代理对象</span></span><br><span class="line"><span class="comment">newProxyInstance(该类加载器，该被代理类实现所有接口，handler)</span></span><br><span class="line"><span class="comment">handler内部在调用InvocationHandler类中invoke方法--解决问题二</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(obj.getClass().getClassLoader(),obj.getClass().getInterfaces(),handler);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">创建一个实现接口InvocationHandler的类，它必须实现invoke方</span></span><br><span class="line"><span class="comment">法，以完成代理的具体操作。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object obj;<span class="comment">//需要使用被代理类的对象进行赋值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bind</span><span class="params">(Object obj)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.obj = obj;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/*当我们通过代理类的对象，调用方法a时，就会自动的调用如下的方法：invoke(代理类的对象，要调用的方法，调用方法时所需的形参)</span></span><br><span class="line"><span class="comment">将被代理类要执行的方法a的功能就声明在invoke()中</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;     </span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">       AOP代理：在实现目标方法前后插入一些通用处理</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">       <span class="type">HumanUtil</span> <span class="variable">util</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanUtil</span>();</span><br><span class="line">        util.method1();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//method:即为代理类对象调用的方法，此方法也就作为了被代理类对象要调用的方法</span></span><br><span class="line">        <span class="comment">//obj:被代理类的对象</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">returnValue</span> <span class="operator">=</span> method.invoke(obj,args);</span><br><span class="line"></span><br><span class="line">        util.method2();</span><br><span class="line">        <span class="keyword">return</span> returnValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//main方法操作</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SuperMan</span> <span class="variable">superMan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SuperMan</span>();</span><br><span class="line">        <span class="comment">//proxyInstance:代理类的对象</span></span><br><span class="line">        <span class="type">Human</span> <span class="variable">proxyInstance</span> <span class="operator">=</span> (Human) ProxyFactory.getProxyInstance(superMan);</span><br><span class="line">        <span class="comment">//当通过代理类对象调用方法时，会自动的调用被代理类中同名的方法</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">belief</span> <span class="operator">=</span> proxyInstance.getBelief();</span><br><span class="line">        System.out.println(belief);</span><br><span class="line">        proxyInstance.eat(<span class="string">&quot;四川麻辣烫&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;*****************************&quot;</span>);</span><br><span class="line">        <span class="type">NikeClothFactory</span> <span class="variable">nikeClothFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NikeClothFactory</span>();</span><br><span class="line">       <span class="type">ClothFactory</span> <span class="variable">proxyClothFactory</span> <span class="operator">=</span> (ClothFactory)      ProxyFactory.getProxyInstance(nikeClothFactory);</span><br><span class="line">        proxyClothFactory.produceCloth();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="三、Java8新特性"><a href="#三、Java8新特性" class="headerlink" title="三、Java8新特性"></a>三、Java8新特性</h1><h3 id="3-1新特性简介"><a href="#3-1新特性简介" class="headerlink" title="3.1新特性简介"></a>3.1新特性简介</h3><h4 id="1-本章思维导图"><a href="#1-本章思维导图" class="headerlink" title="1.本章思维导图"></a>1.本章思维导图</h4><p>![Java 8新特性 尚硅谷-宋红康](Java高级-网络编程-反射-8新特性&#x2F;Java 8新特性 尚硅谷-宋红康.bmp)</p><h4 id="2-新特性的特点"><a href="#2-新特性的特点" class="headerlink" title="2.新特性的特点"></a>2.新特性的特点</h4><ol><li>速度更快</li><li>代码更少(增加了新的语法：Lambda 表达式) </li><li>强大的 Stream API</li><li>便于并行</li><li>最大化减少空指针异常：Optional</li><li>Nashorn引擎，允许在JVM上运行JS应用</li></ol><p>并行流与串行流</p><ol><li>并行流就是把一个内容分成多个数据块，并用不同的线程分别处理每个数据块的流。相比较串行的流，并行的流可以很大程度上提高程序的执行效率。</li><li>Java 8 中将并行进行了优化，我们可以很容易的对数据进行并行操作。</li><li>Stream API 可以声明性地通过 parallel() 与 sequential() 在并行流与顺序流之间进行切换</li></ol><h3 id="3-2Lambda表达式"><a href="#3-2Lambda表达式" class="headerlink" title="3.2Lambda表达式"></a>3.2Lambda表达式</h3><h4 id="1-Lambda表达式的说明"><a href="#1-Lambda表达式的说明" class="headerlink" title="1.Lambda表达式的说明"></a>1.Lambda表达式的说明</h4><ol><li>Lambda 是一个<strong>匿名函数</strong>，我们可以把 Lambda 表达式理解为是一段可以传递的代码</li><li>Lambda表达式来创建<strong>函数式接口</strong>的对象</li><li>格式举例： (o1,o2) -&gt; Integer.compare(o1,o2);</li><li>格式解析：<ol><li>-&gt; :lambda操作符 或 箭头操作符</li><li>-&gt;左边：lambda形参列表 （其实就是接口中的抽象方法的形参列表）</li><li>-&gt;右边：lambda体 （其实就是重写的抽象方法的方法体）</li></ol></li></ol><h4 id="2-Lambda表达式的使用"><a href="#2-Lambda表达式的使用" class="headerlink" title="2.Lambda表达式的使用"></a>2.Lambda表达式的使用</h4><p>Lambda表达式的使用：（分为6种情况介绍）</p><ol><li>无参，无返回值</li><li>Lambda 需要一个参数，但是没有返回值</li><li>数据类型可以省略，因为可由编译器推断得出，称为“类型推断”</li><li>Lambda 若只需要一个参数时，参数的小括号可以省略</li><li>Lambda 需要两个或以上的参数，多条执行语句，并且可以有返回值</li><li>当 Lambda 体只有一条语句时，return 与大括号若有，都可以省略</li></ol><p>总结：</p><ul><li>-&gt;左边：lambda形参列表的参数类型可以省略(类型推断)；如果lambda形参列表只有一个参数，其一对()也可以省略</li><li>-&gt;右边：lambda体应该使用一对{}包裹；如果lambda体只有一条执行语句（可能是return语句），省略这一对{}和return关键字</li></ul><p><strong>6种情况代码演示：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这里的Lambda表达式代替原有的创建匿名子类的方式，由于使用类型推断，写法变得更加简洁，也变的稍难理解</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LambdaTest1</span> &#123;</span><br><span class="line">    <span class="comment">//语法格式一：无参，无返回值</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">r1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;我爱北京天安门&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        r1.run();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;***********************&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">r2</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我爱北京故宫&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        r2.run();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//语法格式二：Lambda 需要一个参数，但是没有返回值。</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">        Consumer&lt;String&gt; con = <span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(String s)</span> &#123;</span><br><span class="line">                System.out.println(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        con.accept(<span class="string">&quot;谎言和誓言的区别是什么？&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;*******************&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Consumer&lt;String&gt; con1 = (String s) -&gt; &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;;</span><br><span class="line">        con1.accept(<span class="string">&quot;一个是听得人当真了，一个是说的人当真了&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//语法格式三：数据类型可以省略，因为可由编译器推断得出，称为“类型推断”</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">        Consumer&lt;String&gt; con1 = (String s) -&gt; &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;;</span><br><span class="line">        con1.accept(<span class="string">&quot;一个是听得人当真了，一个是说的人当真了&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;*******************&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Consumer&lt;String&gt; con2 = (s) -&gt; &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;;</span><br><span class="line">        con2.accept(<span class="string">&quot;一个是听得人当真了，一个是说的人当真了&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();<span class="comment">//类型推断</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;<span class="comment">//类型推断</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//语法格式四：Lambda 若只需要一个参数时，参数的小括号可以省略</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test5</span><span class="params">()</span>&#123;</span><br><span class="line">        Consumer&lt;String&gt; con1 = (s) -&gt; &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;;</span><br><span class="line">        con1.accept(<span class="string">&quot;一个是听得人当真了，一个是说的人当真了&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;*******************&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Consumer&lt;String&gt; con2 = s -&gt; &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;;</span><br><span class="line">        con2.accept(<span class="string">&quot;一个是听得人当真了，一个是说的人当真了&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//语法格式五：Lambda 需要两个或以上的参数，多条执行语句，并且可以有返回值</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test6</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">        Comparator&lt;Integer&gt; com1 = <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span> &#123;</span><br><span class="line">                System.out.println(o1);</span><br><span class="line">                System.out.println(o2);</span><br><span class="line">                <span class="keyword">return</span> o1.compareTo(o2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        System.out.println(com1.compare(<span class="number">12</span>,<span class="number">21</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;*****************************&quot;</span>);</span><br><span class="line">        Comparator&lt;Integer&gt; com2 = (o1,o2) -&gt; &#123;</span><br><span class="line">            System.out.println(o1);</span><br><span class="line">            System.out.println(o2);</span><br><span class="line">            <span class="keyword">return</span> o1.compareTo(o2);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        System.out.println(com2.compare(<span class="number">12</span>,<span class="number">6</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//语法格式六：当 Lambda 体只有一条语句时，return 与大括号若有，都可以省略</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test7</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">        Comparator&lt;Integer&gt; com1 = (o1,o2) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> o1.compareTo(o2);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        System.out.println(com1.compare(<span class="number">12</span>,<span class="number">6</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;*****************************&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Comparator&lt;Integer&gt; com2 = (o1,o2) -&gt; o1.compareTo(o2);</span><br><span class="line"></span><br><span class="line">        System.out.println(com2.compare(<span class="number">12</span>,<span class="number">21</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test8</span><span class="params">()</span>&#123;</span><br><span class="line">        Consumer&lt;String&gt; con1 = s -&gt; &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;;</span><br><span class="line">        con1.accept(<span class="string">&quot;一个是听得人当真了，一个是说的人当真了&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;*****************************&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Consumer&lt;String&gt; con2 = s -&gt; System.out.println(s);</span><br><span class="line"></span><br><span class="line">        con2.accept(<span class="string">&quot;一个是听得人当真了，一个是说的人当真了&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3函数式-Functional-接口"><a href="#3-3函数式-Functional-接口" class="headerlink" title="3.3函数式(Functional)接口"></a>3.3函数式(Functional)接口</h3><h4 id="1-函数式接口说明"><a href="#1-函数式接口说明" class="headerlink" title="1.函数式接口说明"></a>1.函数式接口说明</h4><p><strong>背景理解</strong>：Lambda表达式是借鉴别的语言而产生的，本质是一个”函数“。函数式接口配合Lambda表达式进行<strong>简单</strong>匿名实现类创建对象，此匿名对象也就可作为一个 “函数”使用。</p><ol><li>Lambda表达式的本质：作为函数式接口的实例</li><li>所以以前用匿名实现类创建对象现在都可以用Lambda表达式来写</li><li>如果<strong>一个接口中，只声明了一个抽象方法，则此接口就称为函数式接口</strong>。我们可以在一个接口上使用 @FunctionalInterface 注解，这样做可以检查它是否是一个函数式接口。</li></ol><h4 id="2-自定义函数式接口"><a href="#2-自定义函数式接口" class="headerlink" title="2.自定义函数式接口"></a>2.自定义函数式接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MyNumber</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getValue</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line">函数式接口使用泛型</span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MyFun</span>&lt;T&gt;&#123;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getValue</span><span class="params">(T t)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-Java内置核心函数式接口"><a href="#3-Java内置核心函数式接口" class="headerlink" title="3.Java内置核心函数式接口"></a>3.Java内置核心函数式接口</h4><p>java内置的4大核心函数式接口</p><ul><li>消费型接口 Consumer<T>     void accept(T t)</T></li><li>供给型接口 Supplier<T>     T get()</T></li><li>函数型接口 Function&lt;T,R&gt;   R apply(T t)</li><li>断定型接口 Predicate<T>    boolean test(T t)</T></li></ul><p>代码演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LambdaTest2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">        happyTime(<span class="number">500</span>, <span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;Double&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Double aDouble)</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;学习太累了，去天上人间买了瓶矿泉水，价格为：&quot;</span> + aDouble);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;********************&quot;</span>);</span><br><span class="line"></span><br><span class="line">        happyTime(<span class="number">400</span>,money -&gt; System.out.println(<span class="string">&quot;学习太累了，去天上人间喝了口水，价格为：&quot;</span> + money));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">happyTime</span><span class="params">(<span class="type">double</span> money, Consumer&lt;Double&gt; con)</span>&#123;</span><br><span class="line">        con.accept(money);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;北京&quot;</span>,<span class="string">&quot;南京&quot;</span>,<span class="string">&quot;天津&quot;</span>,<span class="string">&quot;东京&quot;</span>,<span class="string">&quot;西京&quot;</span>,<span class="string">&quot;普京&quot;</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; filterStrs = filterString(list, <span class="keyword">new</span> <span class="title class_">Predicate</span>&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(String s)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> s.contains(<span class="string">&quot;京&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        System.out.println(filterStrs);</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; filterStrs1 = filterString(list,s -&gt; s.contains(<span class="string">&quot;京&quot;</span>));</span><br><span class="line">        System.out.println(filterStrs1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据给定的规则，过滤集合中的字符串。此规则由Predicate的方法决定</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">filterString</span><span class="params">(List&lt;String&gt; list, Predicate&lt;String&gt; pre)</span>&#123;</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;String&gt; filterList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(String s : list)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pre.test(s))&#123;</span><br><span class="line">                filterList.add(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> filterList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-Java内置其他函数式接口"><a href="#4-Java内置其他函数式接口" class="headerlink" title="4.Java内置其他函数式接口"></a>4.Java内置其他函数式接口</h4><ol><li><p>BiFunction&lt;T, U, R&gt;    </p><p>R apply(T t, U u)   对类型为 T, U 参数应用操作，返回 R 类型的结果。</p></li><li><p>UnaryOperator<T>     (Function子接口) </T></p><p>T apply(T t);  对类型为T的对象进行一元运算，并返回T类型的结果。</p></li><li><p>BinaryOperator<T>     (BiFunction 子接口)</T></p><p>T apply(T t1, T t2);   对类型为T的对象进行二元运算，并返回T类型的结果。</p></li><li><p>BiConsumer&lt;T, U&gt;  </p><p>void accept(T t, U u)   对类型为T, U 参数应用操作。</p></li><li><p>BiPredicate&lt;T,U&gt; </p><p>包含方法为： boolean test(T t,U u)</p></li><li><p>分别计算int、long、double值的函数</p><p>ToIntFunction<T>  </T></p><p>ToLongFunction<T>  </T></p><p>ToDoubleFunction<T>  </T></p><p>返回值类型分别为int、long、double，参数都为R</p></li><li><p>参数分别为int、long、double 类型的函数</p><p>IntFunction<R>   </R></p><p>LongFunction<R>  </R></p><p>DoubleFunction<R>  </R></p><p>返回值类型都为R，参数分别为int、long、double</p></li></ol><h3 id="3-4方法引用与构造器引用"><a href="#3-4方法引用与构造器引用" class="headerlink" title="3.4方法引用与构造器引用"></a>3.4方法引用与构造器引用</h3><p>其中还有数组引用</p><h4 id="1-方法引用的使用"><a href="#1-方法引用的使用" class="headerlink" title="1.方法引用的使用"></a>1.方法引用的使用</h4><p>1.使用情境：当要传递给Lambda体的操作，已经有实现的方法了，可以使用方法引用！</p><p>2.方法引用，本质上就是Lambda表达式，而Lambda表达式作为函数式接口的实例。所以方法引用，也是函数式接口的实例。</p><p>3.使用格式：  类(或对象) :: 方法名</p><p>4.具体分为如下的三种情况：</p><ol><li>情况1     对象 :: 非静态方法</li><li>情况2     类 :: 静态方法</li><li>情况3     类 :: 非静态方法</li></ol><p>5.方法引用使用的要求：要求接口中的抽象方法的形参列表和返回值类型与方法引用的方法的形参列表和返回值类型相同！（针对于情况1和情况2）</p><p>代码演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">方法引用对比Lambda表达式使用更多的类型推断，写法变得更加简洁，也变得难于理解。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodRefTest</span> &#123;</span><br><span class="line">   <span class="comment">// 情况一：对象 :: 实例方法</span></span><br><span class="line">   <span class="comment">//Consumer中的void accept(T t)</span></span><br><span class="line">   <span class="comment">//PrintStream中的void println(T t)</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">      Consumer&lt;String&gt; con1 = str -&gt; System.out.println(str);</span><br><span class="line">      con1.accept(<span class="string">&quot;北京&quot;</span>);</span><br><span class="line"></span><br><span class="line">      System.out.println(<span class="string">&quot;*******************&quot;</span>);</span><br><span class="line">      <span class="type">PrintStream</span> <span class="variable">ps</span> <span class="operator">=</span> System.out;</span><br><span class="line">      Consumer&lt;String&gt; con2 = ps::println;</span><br><span class="line">      con2.accept(<span class="string">&quot;beijing&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//Supplier中的T get()</span></span><br><span class="line">   <span class="comment">//Employee中的String getName()</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="type">Employee</span> <span class="variable">emp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">1001</span>,<span class="string">&quot;Tom&quot;</span>,<span class="number">23</span>,<span class="number">5600</span>);</span><br><span class="line"></span><br><span class="line">      Supplier&lt;String&gt; sup1 = () -&gt; emp.getName();</span><br><span class="line">      System.out.println(sup1.get());</span><br><span class="line"></span><br><span class="line">      System.out.println(<span class="string">&quot;*******************&quot;</span>);</span><br><span class="line">      Supplier&lt;String&gt; sup2 = emp::getName;</span><br><span class="line">      System.out.println(sup2.get());</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 情况二：类 :: 静态方法</span></span><br><span class="line">   <span class="comment">//Comparator中的int compare(T t1,T t2)</span></span><br><span class="line">   <span class="comment">//Integer中的int compare(T t1,T t2)</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> &#123;</span><br><span class="line">      Comparator&lt;Integer&gt; com1 = (t1,t2) -&gt; Integer.compare(t1,t2);</span><br><span class="line">      System.out.println(com1.compare(<span class="number">12</span>,<span class="number">21</span>));</span><br><span class="line"></span><br><span class="line">      System.out.println(<span class="string">&quot;*******************&quot;</span>);</span><br><span class="line"></span><br><span class="line">      Comparator&lt;Integer&gt; com2 = Integer::compare;</span><br><span class="line">      System.out.println(com2.compare(<span class="number">12</span>,<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//Function中的R apply(T t)</span></span><br><span class="line">   <span class="comment">//Math中的Long round(Double d)</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span> &#123;</span><br><span class="line">      Function&lt;Double,Long&gt; func = <span class="keyword">new</span> <span class="title class_">Function</span>&lt;Double, Long&gt;() &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="keyword">public</span> Long <span class="title function_">apply</span><span class="params">(Double d)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Math.round(d);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      System.out.println(<span class="string">&quot;*******************&quot;</span>);</span><br><span class="line"></span><br><span class="line">      Function&lt;Double,Long&gt; func1 = d -&gt; Math.round(d);</span><br><span class="line">      System.out.println(func1.apply(<span class="number">12.3</span>));</span><br><span class="line"></span><br><span class="line">      System.out.println(<span class="string">&quot;*******************&quot;</span>);</span><br><span class="line"></span><br><span class="line">      Function&lt;Double,Long&gt; func2 = Math::round;</span><br><span class="line">      System.out.println(func2.apply(<span class="number">12.6</span>));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 情况三：类 :: 实例方法  (有难度)</span></span><br><span class="line">   <span class="comment">// Comparator中的int comapre(T t1,T t2)</span></span><br><span class="line">   <span class="comment">// String中的int t1.compareTo(t2)</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test5</span><span class="params">()</span> &#123;</span><br><span class="line">      Comparator&lt;String&gt; com1 = (s1,s2) -&gt; s1.compareTo(s2);</span><br><span class="line">      System.out.println(com1.compare(<span class="string">&quot;abc&quot;</span>,<span class="string">&quot;abd&quot;</span>));</span><br><span class="line"></span><br><span class="line">      System.out.println(<span class="string">&quot;*******************&quot;</span>);</span><br><span class="line"></span><br><span class="line">      Comparator&lt;String&gt; com2 = String :: compareTo; </span><br><span class="line">      System.out.println(com2.compare(<span class="string">&quot;abd&quot;</span>,<span class="string">&quot;abm&quot;</span>));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//BiPredicate中的boolean test(T t1, T t2);</span></span><br><span class="line">   <span class="comment">//String中的boolean t1.equals(t2)</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test6</span><span class="params">()</span> &#123;</span><br><span class="line">      BiPredicate&lt;String,String&gt; pre1 = (s1,s2) -&gt; s1.equals(s2);</span><br><span class="line">      System.out.println(pre1.test(<span class="string">&quot;abc&quot;</span>,<span class="string">&quot;abc&quot;</span>));</span><br><span class="line"></span><br><span class="line">      System.out.println(<span class="string">&quot;*******************&quot;</span>);</span><br><span class="line">      BiPredicate&lt;String,String&gt; pre2 = String :: equals;</span><br><span class="line">      System.out.println(pre2.test(<span class="string">&quot;abc&quot;</span>,<span class="string">&quot;abd&quot;</span>));</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// Function&lt;T,R&gt;中的R apply(T t)</span></span><br><span class="line">   <span class="comment">// Employee中的String getName();</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test7</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="type">Employee</span> <span class="variable">employee</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">1001</span>, <span class="string">&quot;Jerry&quot;</span>, <span class="number">23</span>, <span class="number">6000</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      Function&lt;Employee,String&gt; func1 = e -&gt; e.getName();</span><br><span class="line">      System.out.println(func1.apply(employee));</span><br><span class="line"></span><br><span class="line">      System.out.println(<span class="string">&quot;*******************&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      Function&lt;Employee,String&gt; func2 = Employee::getName;</span><br><span class="line">      System.out.println(func2.apply(employee));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-构造器引用与数组引用"><a href="#2-构造器引用与数组引用" class="headerlink" title="2.构造器引用与数组引用"></a>2.构造器引用与数组引用</h4><p>一、构造器引用</p><ul><li><p>格式    类名：：new</p></li><li><p>和方法引用类似，函数式接口的抽象方法的形参列表和构造器的形参列表一致。抽象方法的返回值类型即为构造器所属的类的类型</p></li></ul><p>二、数组引用</p><ul><li><p>格式    数组类型[ ] ：：new</p></li><li><p>大家可以把数组看做是一个特殊的类，则写法与构造器引用一致。</p></li></ul><p>代码演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">构造器引用与数组引用对比Lambda表达式使用更多的类型推断，写法变得更加简洁,也变得难于理解</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConstructorRefTest</span> &#123;</span><br><span class="line">   <span class="comment">//构造器引用</span></span><br><span class="line">    <span class="comment">//Supplier中的T get()</span></span><br><span class="line">    <span class="comment">//Employee的空参构造器：Employee()</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">        Supplier&lt;Employee&gt; sup = <span class="keyword">new</span> <span class="title class_">Supplier</span>&lt;Employee&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Employee <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Employee</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(<span class="string">&quot;*******************&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Supplier&lt;Employee&gt;  sup1 = () -&gt; <span class="keyword">new</span> <span class="title class_">Employee</span>();</span><br><span class="line">        System.out.println(sup1.get());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;*******************&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Supplier&lt;Employee&gt;  sup2 = Employee :: <span class="keyword">new</span>;</span><br><span class="line">        System.out.println(sup2.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//Function中的R apply(T t)</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">        Function&lt;Integer,Employee&gt; func1 = id -&gt; <span class="keyword">new</span> <span class="title class_">Employee</span>(id);</span><br><span class="line">        <span class="type">Employee</span> <span class="variable">employee</span> <span class="operator">=</span> func1.apply(<span class="number">1001</span>);</span><br><span class="line">        System.out.println(employee);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;*******************&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Function&lt;Integer,Employee&gt; func2 = Employee :: <span class="keyword">new</span>;</span><br><span class="line">        <span class="type">Employee</span> <span class="variable">employee1</span> <span class="operator">=</span> func2.apply(<span class="number">1002</span>);</span><br><span class="line">        System.out.println(employee1);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="comment">//BiFunction中的R apply(T t,U u)</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">        BiFunction&lt;Integer,String,Employee&gt; func1 = (id,name) -&gt; <span class="keyword">new</span> <span class="title class_">Employee</span>(id,name);</span><br><span class="line">        System.out.println(func1.apply(<span class="number">1001</span>,<span class="string">&quot;Tom&quot;</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;*******************&quot;</span>);</span><br><span class="line"></span><br><span class="line">        BiFunction&lt;Integer,String,Employee&gt; func2 = Employee :: <span class="keyword">new</span>;</span><br><span class="line">        System.out.println(func2.apply(<span class="number">1002</span>,<span class="string">&quot;Tom&quot;</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="comment">//数组引用</span></span><br><span class="line">    <span class="comment">//Function中的R apply(T t)</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span>&#123;</span><br><span class="line">        Function&lt;Integer,String[]&gt; func1 = length -&gt; <span class="keyword">new</span> <span class="title class_">String</span>[length];</span><br><span class="line">        String[] arr1 = func1.apply(<span class="number">5</span>);</span><br><span class="line">        System.out.println(Arrays.toString(arr1));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;*******************&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Function&lt;Integer,String[]&gt; func2 = String[] :: <span class="keyword">new</span>;</span><br><span class="line">        String[] arr2 = func2.apply(<span class="number">10</span>);</span><br><span class="line">        System.out.println(Arrays.toString(arr2));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-5强大的Stream-API"><a href="#3-5强大的Stream-API" class="headerlink" title="3.5强大的Stream API"></a>3.5强大的Stream API</h3><h4 id="1-Stream概述"><a href="#1-Stream概述" class="headerlink" title="1.Stream概述"></a>1.Stream概述</h4><p><strong>说明：</strong></p><ol><li>Java8中有两大最为重要的改变。第一个是 Lambda 表达式；另外一个则是 Stream API。 </li><li>Stream API ( java.util.stream) 把真正的函数式编程风格引入到Java中</li><li>Stream 是 Java8 中处理集合的关键抽象概念，它可以指定你希望对集合进行的操作，可以执行非常复杂的查找、过滤和映射数据等操作。 使用Stream API 对集合数据进行操作，就类似于使用 SQL 执行的数据库查询。也可以使用 Stream API 来并行执行操作。</li></ol><p><strong>为什么使用Stream API：</strong></p><p>实际开发中，项目中多数数据源都来自于Mysql，Oracle（有SQL在内部处理数据）等。但现在数据源可以更多了，有MongDB，Radis（没有SQL处理数据）等，而这些<strong>NoSQL的数据就需要Java层面去处理</strong>。 </p><p><strong>Stream 和 Collection 集合的区别：</strong></p><p>Collection 是一种静态的内存数据结构，主要面向内存，存储在内存中；而 Stream 是有关计算的，主要是面向 CPU，通过 CPU 实现计算</p><h4 id="2-Stream使用说明"><a href="#2-Stream使用说明" class="headerlink" title="2.Stream使用说明"></a>2.Stream使用说明</h4><p>1.总结Stream和集合区别：</p><ul><li><p>Stream关注的是对数据的运算，与CPU打交道</p></li><li><p>集合关注的是数据的存储，与内存打交道</p></li></ul><p>2.使用说明</p><p>①Stream 自己不会存储元素。</p><p>②Stream 不会改变源对象。相反，他们会返回一个持有结果的新Stream。</p><p>③Stream 操作是延迟执行的。这意味着他们会等到需要结果的时候才执行</p><p>3.Stream 执行流程</p><p>① Stream的实例化</p><p>② 一系列的中间操作（过滤、映射、…)</p><p>③ 终止操作</p><p>4.说明：</p><p>4.1 一个中间操作链，对数据源的数据进行处理</p><p>4.2 一旦执行终止操作，就执行中间操作链，并产生结果。之后，不会再被使用</p><h4 id="3-Stream实例化方式"><a href="#3-Stream实例化方式" class="headerlink" title="3.Stream实例化方式"></a>3.Stream实例化方式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建 Stream方式一：通过集合</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">        List&lt;Employee&gt; employees = EmployeeData.getEmployees();</span><br><span class="line"></span><br><span class="line"><span class="comment">//        default Stream&lt;E&gt; stream() : 返回一个顺序流          （顺序流：使用主线程，单线程）</span></span><br><span class="line">        Stream&lt;Employee&gt; stream = employees.stream();</span><br><span class="line"></span><br><span class="line"><span class="comment">//        default Stream&lt;E&gt; parallelStream() : 返回一个并行流   （并行流：多个线程同时运行）</span></span><br><span class="line">        Stream&lt;Employee&gt; parallelStream = employees.parallelStream();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建 Stream方式二：通过数组</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">        <span class="comment">//调用Arrays类的static &lt;T&gt; Stream&lt;T&gt; stream(T[] array): 返回一个流</span></span><br><span class="line">        <span class="type">IntStream</span> <span class="variable">stream</span> <span class="operator">=</span> Arrays.stream(arr);  <span class="comment">//对于Integer、Long、Double会自动识别返回值类型</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Employee</span> <span class="variable">e1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">1001</span>,<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">        <span class="type">Employee</span> <span class="variable">e2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">1002</span>,<span class="string">&quot;Jerry&quot;</span>);</span><br><span class="line">        Employee[] arr1 = <span class="keyword">new</span> <span class="title class_">Employee</span>[]&#123;e1,e2&#125;;</span><br><span class="line">        Stream&lt;Employee&gt; stream1 = Arrays.stream(arr1); <span class="comment">//对于自定义类，返回值类型Stream&lt;Employee&gt;</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建 Stream方式三：通过Stream的of()</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">        Stream&lt;Integer&gt; stream = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建 Stream方式四：创建无限流  （不常用，了解即可）</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//      迭代</span></span><br><span class="line"><span class="comment">//      public static&lt;T&gt; Stream&lt;T&gt; iterate(final T seed, final UnaryOperator&lt;T&gt; f)</span></span><br><span class="line">        <span class="comment">//遍历前10个偶数</span></span><br><span class="line">        Stream.iterate(<span class="number">0</span>, t -&gt; t + <span class="number">2</span>).limit(<span class="number">10</span>).forEach(System.out::println);</span><br><span class="line">     </span><br><span class="line"></span><br><span class="line"><span class="comment">//      生成</span></span><br><span class="line"><span class="comment">//      public static&lt;T&gt; Stream&lt;T&gt; generate(Supplier&lt;T&gt; s)</span></span><br><span class="line">        Stream.generate(Math::random).limit(<span class="number">10</span>).forEach(System.out::println);</span><br><span class="line">      </span><br><span class="line">    </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="4-补充forEach（）"><a href="#4-补充forEach（）" class="headerlink" title="4.补充forEach（）"></a>4.补充forEach（）</h4><p>JDK5.0新增的foreach循环（或增强for循环），用于遍历集合、数组</p><p>Iterator迭代器：外部迭代–操作指针进行的迭代</p><p>Java8新增 forEach( )方法：  内部迭代–内部自己完成迭代</p><ul><li><p>forEach是属于java集合的一个方法，准确来说，集合在java8中拥有一个stream方法，可以得到一个流对象，这个对象拥有很多方法，这些方法可以很方便的对集合进行例如排序，分组，计数，遍历，转换等操作，而<strong>遍历是比较常见的一种，forEach就是用来做这个的</strong>，这里的<strong>forEach就是stream中的forEach</strong>。</p></li><li><p>用法：forEach(System.out::println) ：</p><ol><li>遍历集合，这里相当于集合中的一个方法（看做一个普通的方法）</li><li>遍历Stream流，这里相当于Stream流中的一个终止操作</li></ol></li></ul><p>代码演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">       <span class="comment">//举例一：遍历集合</span></span><br><span class="line">       <span class="comment">//创建list</span></span><br><span class="line">      List&lt;String&gt; list1 = Arrays.asList(<span class="string">&quot;123&quot;</span>,<span class="string">&quot;456&quot;</span>);</span><br><span class="line">      <span class="comment">//输出list里面的每个内容</span></span><br><span class="line">      list1.forEach(System.out::println);</span><br><span class="line">   <span class="comment">//举例二：遍历Stream流</span></span><br><span class="line">List&lt;String&gt; list2 = Arrays.asList(<span class="string">&quot;123&quot;</span>,<span class="string">&quot;456&quot;</span>);</span><br><span class="line">      <span class="comment">//输出list里面的每个内容</span></span><br><span class="line">      list2.stream().forEach(System.out::println);</span><br><span class="line">      <span class="comment">//举例二：Arrays工具类中新增stream，也可以用于遍历数组</span></span><br><span class="line">      <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">      <span class="comment">//for(数组元素的类型 局部变量 : 数组对象)</span></span><br><span class="line">      Arrays.stream(arr).forEach(System.out::println);</span><br></pre></td></tr></table></figure><h4 id="5-Stream中间操作"><a href="#5-Stream中间操作" class="headerlink" title="5.Stream中间操作"></a>5.Stream中间操作</h4><p><strong>说明：</strong></p><p>多个中间操作可以连接起来形成一个流水线，除非流水线上触发终止操作，否则中间操作不会执行任何的处理！而在<strong>终止操作时一次性全部处理</strong>，称为“惰性求值”。</p><p><strong>1.筛选与切片</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">        List&lt;Employee&gt; list = EmployeeData.getEmployees();</span><br><span class="line"><span class="comment">//       1. filter(Predicate p)——接收 Lambda ， 从流中排除某些元素。</span></span><br><span class="line">        Stream&lt;Employee&gt; stream = list.stream();</span><br><span class="line">        <span class="comment">//练习：查询员工表中薪资大于7000的员工信息</span></span><br><span class="line">        stream.filter(e -&gt; e.getSalary() &gt; <span class="number">7000</span>).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line"><span class="comment">//        limit(n)——截断流，使其元素不超过给定数量。</span></span><br><span class="line">        list.stream().limit(<span class="number">3</span>).forEach(System.out::println);</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line"><span class="comment">//       2. skip(n) —— 跳过元素，返回一个扔掉了前 n 个元素的流。若流中元素不足 n 个，则返回一个空流。与 limit(n) 互补</span></span><br><span class="line">        list.stream().skip(<span class="number">3</span>).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line"><span class="comment">//      3.  distinct()——筛选，通过流所生成元素的 hashCode() 和 equals() 去除重复元素</span></span><br><span class="line"><span class="comment">//Employee类需要有hashCode() 和 equals()方法</span></span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">1010</span>,<span class="string">&quot;刘强东&quot;</span>,<span class="number">40</span>,<span class="number">8000</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">1010</span>,<span class="string">&quot;刘强东&quot;</span>,<span class="number">41</span>,<span class="number">8000</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">1010</span>,<span class="string">&quot;刘强东&quot;</span>,<span class="number">40</span>,<span class="number">8000</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">1010</span>,<span class="string">&quot;刘强东&quot;</span>,<span class="number">40</span>,<span class="number">8000</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">1010</span>,<span class="string">&quot;刘强东&quot;</span>,<span class="number">40</span>,<span class="number">8000</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//        System.out.println(list);</span></span><br><span class="line"></span><br><span class="line">        list.stream().distinct().forEach(System.out::println);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>2.映射</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//映射  ：映射内涵：类似与高中的函数，例如 y = 2x 。</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">//      1. map(Function f)——接收一个函数作为参数，将元素转换成其他形式或提取信息，该函数会被应用到每个元素上，并将其映射成一个新的元素。</span></span><br><span class="line">      <span class="comment">//练习：将字母都转换为大写输出</span></span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;aa&quot;</span>, <span class="string">&quot;bb&quot;</span>, <span class="string">&quot;cc&quot;</span>, <span class="string">&quot;dd&quot;</span>);</span><br><span class="line">        list.stream().map(str -&gt; str.toUpperCase()).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="comment">//      练习1：获取员工姓名长度大于3的员工的姓名。</span></span><br><span class="line">      <span class="comment">//一个员工列表，通过map映射只获取员工的名字，在配合filter筛选</span></span><br><span class="line">        List&lt;Employee&gt; employees = EmployeeData.getEmployees();</span><br><span class="line">        Stream&lt;String&gt; namesStream = employees.stream().map(Employee::getName);</span><br><span class="line">        namesStream.filter(name -&gt; name.length() &gt; <span class="number">3</span>).forEach(System.out::println);</span><br><span class="line">        System.out.println();</span><br><span class="line">        </span><br><span class="line">      <span class="comment">//练习2：该练习为演示map和flatMap的区别</span></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">     个人理解：&#123;&quot;aa&quot;, &quot;bb&quot;, &quot;cc&quot;, &quot;dd&quot;&#125;，想把每个字符单独输出，使用map,会将每组字符串看做一个流，在组成一个大流，所以这里会有流的嵌套；使用flatMap,会将每个字符当做一个流，再去掉流，组成一个大流</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">        Stream&lt;Stream&lt;Character&gt;&gt; streamStream = list.stream().map(StreamAPITest1::fromStringToStream);</span><br><span class="line">        streamStream.forEach(s -&gt;&#123;</span><br><span class="line">            s.forEach(System.out::println);</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println();</span><br><span class="line">      </span><br><span class="line"><span class="comment">//      2. flatMap(Function f)——接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流。</span></span><br><span class="line">        Stream&lt;Character&gt; characterStream = list.stream().flatMap(StreamAPITest1::fromStringToStream);</span><br><span class="line">        characterStream.forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将字符串中的多个字符构成的集合转换为对应的Stream的实例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Stream&lt;Character&gt; <span class="title function_">fromStringToStream</span><span class="params">(String str)</span>&#123;<span class="comment">//aa</span></span><br><span class="line">        ArrayList&lt;Character&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(Character c : str.toCharArray())&#123;</span><br><span class="line">            list.add(c);</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="keyword">return</span> list.stream();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">list1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        list1.add(<span class="number">1</span>);</span><br><span class="line">        list1.add(<span class="number">2</span>);</span><br><span class="line">        list1.add(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">list2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        list2.add(<span class="number">4</span>);</span><br><span class="line">        list2.add(<span class="number">5</span>);</span><br><span class="line">        list2.add(<span class="number">6</span>);</span><br><span class="line"><span class="comment">//add()和addAll()就是对应上面的二者区别的一个例子.</span></span><br><span class="line"><span class="comment">//      list1.add(list2);   &#123;1,2,3,&#123;4,5,6&#125;&#125;  不会打开括号，当做一个对象加入</span></span><br><span class="line">        list1.addAll(list2);   <span class="comment">//&#123;1,2,3,4,5,6&#125; 会打开括号</span></span><br><span class="line">        System.out.println(list1);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>3.排序</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//3-排序</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">//      1. sorted()——自然排序</span></span><br><span class="line">        List&lt;Integer&gt; list = Arrays.asList(<span class="number">12</span>, <span class="number">43</span>, <span class="number">65</span>, <span class="number">34</span>, <span class="number">87</span>, <span class="number">0</span>, -<span class="number">98</span>, <span class="number">7</span>);</span><br><span class="line">        list.stream().sorted().forEach(System.out::println);</span><br><span class="line">        <span class="comment">//抛异常，原因:Employee没有实现Comparable接口</span></span><br><span class="line"><span class="comment">//        List&lt;Employee&gt; employees = EmployeeData.getEmployees();</span></span><br><span class="line"><span class="comment">//        employees.stream().sorted().forEach(System.out::println);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//      2. sorted(Comparator com)——定制排序</span></span><br><span class="line"></span><br><span class="line">        List&lt;Employee&gt; employees = EmployeeData.getEmployees();</span><br><span class="line">        employees.stream().sorted( (e1,e2) -&gt; &#123;</span><br><span class="line"></span><br><span class="line">           <span class="type">int</span> <span class="variable">ageValue</span> <span class="operator">=</span> Integer.compare(e1.getAge(),e2.getAge());</span><br><span class="line">           <span class="keyword">if</span>(ageValue != <span class="number">0</span>)&#123;</span><br><span class="line">               <span class="keyword">return</span> ageValue;</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               <span class="keyword">return</span> -Double.compare(e1.getSalary(),e2.getSalary());</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">        &#125;).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-Stream终止操作"><a href="#6-Stream终止操作" class="headerlink" title="6.Stream终止操作"></a>6.Stream终止操作</h4><p>说明：</p><ul><li>终端操作会从流的流水线生成结果。其结果可以是任何不是流的值，例如：List、Integer，甚至是 void 。 </li><li>流进行了终止操作后，不能再次使用</li></ul><p><strong>1.匹配与查找</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>-匹配与查找</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">        List&lt;Employee&gt; employees = EmployeeData.getEmployees();</span><br><span class="line"></span><br><span class="line"><span class="comment">//        allMatch(Predicate p)——检查是否匹配所有元素。</span></span><br><span class="line"><span class="comment">//          练习：是否所有的员工的年龄都大于18</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">allMatch</span> <span class="operator">=</span> employees.stream().allMatch(e -&gt; e.getAge() &gt; <span class="number">18</span>);</span><br><span class="line">        System.out.println(allMatch);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        anyMatch(Predicate p)——检查是否至少匹配一个元素。</span></span><br><span class="line"><span class="comment">//         练习：是否存在员工的工资大于 10000</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">anyMatch</span> <span class="operator">=</span> employees.stream().anyMatch(e -&gt; e.getSalary() &gt; <span class="number">10000</span>);</span><br><span class="line">        System.out.println(anyMatch);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        noneMatch(Predicate p)——检查是否没有匹配的元素。</span></span><br><span class="line"><span class="comment">//          练习：是否存在员工姓“雷”</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">noneMatch</span> <span class="operator">=</span> employees.stream().noneMatch(e -&gt; e.getName().startsWith(<span class="string">&quot;雷&quot;</span>));</span><br><span class="line">        System.out.println(noneMatch);</span><br><span class="line"><span class="comment">//        findFirst——返回第一个元素</span></span><br><span class="line">        Optional&lt;Employee&gt; employee = employees.stream().findFirst();</span><br><span class="line">        System.out.println(employee);</span><br><span class="line"><span class="comment">//        findAny——返回当前流中的任意元素</span></span><br><span class="line">        Optional&lt;Employee&gt; employee1 = employees.parallelStream().findAny();</span><br><span class="line">        System.out.println(employee1);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">        List&lt;Employee&gt; employees = EmployeeData.getEmployees();</span><br><span class="line">        <span class="comment">// count——返回流中元素的总个数</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> employees.stream().filter(e -&gt; e.getSalary() &gt; <span class="number">5000</span>).count();</span><br><span class="line">        System.out.println(count);</span><br><span class="line"><span class="comment">//        max(Comparator c)——返回流中最大值</span></span><br><span class="line"><span class="comment">//        练习：返回最高的工资：</span></span><br><span class="line">        Stream&lt;Double&gt; salaryStream = employees.stream().map(e -&gt; e.getSalary());</span><br><span class="line">        Optional&lt;Double&gt; maxSalary = salaryStream.max(Double::compare);</span><br><span class="line">        System.out.println(maxSalary);</span><br><span class="line"><span class="comment">//        min(Comparator c)——返回流中最小值</span></span><br><span class="line"><span class="comment">//        练习：返回最低工资的员工</span></span><br><span class="line">        Optional&lt;Employee&gt; employee = employees.stream().min((e1, e2) -&gt; Double.compare(e1.getSalary(), e2.getSalary()));</span><br><span class="line">        System.out.println(employee);</span><br><span class="line">        System.out.println();</span><br><span class="line"><span class="comment">//        forEach(Consumer c)——内部迭代</span></span><br><span class="line">        employees.stream().forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用集合的遍历操作</span></span><br><span class="line">        employees.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>2.归约</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2-归约</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">//        reduce(T identity, BinaryOperator)——可以将流中元素反复结合起来，得到一个值。返回 T</span></span><br><span class="line">         <span class="comment">//T identity :起始值， BinaryOperator&lt;T&gt;  T apply(T t1, T t2);  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        练习1：计算1-10的自然数的和</span></span><br><span class="line">        List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">sum</span> <span class="operator">=</span> list.stream().reduce(<span class="number">0</span>, Integer::sum);</span><br><span class="line">        System.out.println(sum);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//        reduce(BinaryOperator) ——可以将流中元素反复结合起来，得到一个值。返回 Optional&lt;T&gt;</span></span><br><span class="line"><span class="comment">//        练习2：计算公司所有员工工资的总和</span></span><br><span class="line">        List&lt;Employee&gt; employees = EmployeeData.getEmployees();</span><br><span class="line">        Stream&lt;Double&gt; salaryStream = employees.stream().map(Employee::getSalary);</span><br><span class="line"><span class="comment">//        Optional&lt;Double&gt; sumMoney = salaryStream.reduce(Double::sum);</span></span><br><span class="line">        Optional&lt;Double&gt; sumMoney = salaryStream.reduce((d1,d2) -&gt; d1 + d2);</span><br><span class="line">        System.out.println(sumMoney.get());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>3.收集</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//3-收集</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">//        collect(Collector c)——将流转换为其他形式。接收一个 Collector接口的实现，用于给Stream中元素做汇总的方法</span></span><br><span class="line"><span class="comment">//        练习1：查找工资大于6000的员工，结果返回为一个List或Set</span></span><br><span class="line"></span><br><span class="line">        List&lt;Employee&gt; employees = EmployeeData.getEmployees();</span><br><span class="line">        List&lt;Employee&gt; employeeList = employees.stream().filter(e -&gt; e.getSalary() &gt; <span class="number">6000</span>).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">        employeeList.forEach(System.out::println);</span><br><span class="line">        System.out.println();</span><br><span class="line">        Set&lt;Employee&gt; employeeSet = employees.stream().filter(e -&gt; e.getSalary() &gt; <span class="number">6000</span>).collect(Collectors.toSet());</span><br><span class="line"></span><br><span class="line">        employeeSet.forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>4.收集中Collectors工具类</strong></p><ul><li><p>Collector 接口中方法的实现决定了如何对流执行收集的操作(如收集到 List、Set、Map)。</p></li><li><p>Collector需要使用Collectors提供实例。</p></li><li><p>另外， Collectors 实用类提供了很多静态方法，可以方便地创建常见收集器实例，</p><p>具体方法与实例如下表：</p></li></ul><p><img src="/2022/10/05/Java%E9%AB%98%E7%BA%A7-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-%E5%8F%8D%E5%B0%84-8%E6%96%B0%E7%89%B9%E6%80%A7/Snipaste_2022-02-11_15-52-42.png" alt="Snipaste_2022-02-11_15-52-42"></p><p><img src="/2022/10/05/Java%E9%AB%98%E7%BA%A7-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-%E5%8F%8D%E5%B0%84-8%E6%96%B0%E7%89%B9%E6%80%A7/Snipaste_2022-02-11_15-52-51.png" alt="Snipaste_2022-02-11_15-52-51"></p><h3 id="3-6Optional类"><a href="#3-6Optional类" class="headerlink" title="3.6Optional类"></a>3.6Optional类</h3><h4 id="1-Optional概述"><a href="#1-Optional概述" class="headerlink" title="1.Optional概述"></a>1.Optional概述</h4><p>Optional<T> 类(java.util.Optional) 是一个<strong>容器类</strong>，它可以<strong>保存类型T的值，代表</strong></T></p><p><strong>这个值存在。或者仅仅保存null，表示这个值不存在</strong>。原来用 null 表示一个值不</p><p>存在，现在 Optional 可以更好的表达这个概念。并且<strong>可以避免空指针异常</strong>。</p><h4 id="2-Optional类中方法"><a href="#2-Optional类中方法" class="headerlink" title="2.Optional类中方法"></a>2.Optional类中方法</h4><p><strong>创建Optional类对象的</strong>方法：</p><ol><li><strong>Optional.of(T t) : 创建一个 Optional 实例，t必须非空；</strong> </li><li><strong>Optional.empty() : 创建一个空的 Optional 实例</strong></li><li><strong>Optional.ofNullable(T t)：t可以为null</strong></li></ol><p><strong>判断Optional容器中是否包含对象</strong>：</p><ol><li><strong>boolean isPresent() : 判断是否包含对象</strong></li><li>void ifPresent(Consumer&lt;? super T&gt; consumer) ：如果有值，就执行Consumer接口的实现代码，并且该值会作为参数传给它。</li></ol><p>获取Optional容器的对象：</p><ol><li><p><strong>T get(): 如果调用对象包含值，返回该值，否则抛异常</strong></p></li><li><p><strong>T orElse(T other) ：如果有值则将其返回，否则返回指定的other对象。</strong></p><p><strong>如果单前的Optional内部封装的t是非空的，则返回内部的t.</strong></p><p><strong>如果内部的t是空的，则返回orElse()方法中的参数other对象.</strong></p></li><li><p>T orElseGet(Supplier&lt;? extends T&gt; other) ：如果有值则将其返回，否则返回由Supplier接口实现提供的对象。</p></li><li><p>T orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier) ：如果有值则将其返回，否则抛出由Supplier接口实现提供的异常。</p></li></ol><h4 id="3-常用方法搭配使用"><a href="#3-常用方法搭配使用" class="headerlink" title="3.常用方法搭配使用"></a>3.常用方法搭配使用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OptionalTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//empty():创建的Optional对象内部的value = null</span></span><br><span class="line">        Optional&lt;Object&gt; op1 = Optional.empty();</span><br><span class="line">      <span class="comment">//isPresent()：Optional封装的数据是否包含数据</span></span><br><span class="line">        <span class="keyword">if</span>(!op1.isPresent())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;数据为空&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(op1);</span><br><span class="line">        System.out.println(op1.isPresent());</span><br><span class="line">        <span class="comment">//如果Optional封装的数据value为空，则get()报错。否则，value不为空时，返回value.</span></span><br><span class="line"><span class="comment">//        System.out.println(op1.get());</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="comment">//        str = null;</span></span><br><span class="line">        <span class="comment">//of(T t):封装数据t生成Optional对象。要求t非空，否则报错。</span></span><br><span class="line">        Optional&lt;String&gt; op1 = Optional.of(str);</span><br><span class="line">        <span class="comment">//get()通常与of()方法搭配使用。用于获取内部的封装的数据value</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> op1.get();</span><br><span class="line">        System.out.println(str1);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;beijing&quot;</span>;</span><br><span class="line">        str = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//ofNullable(T t) ：封装数据t赋给Optional内部的value。不要求t非空</span></span><br><span class="line">        Optional&lt;String&gt; op1 = Optional.ofNullable(str);</span><br><span class="line">        <span class="comment">//orElse(T t1):如果Optional内部的value非空，则返回此value值。如果</span></span><br><span class="line">        <span class="comment">//value为空，则返回t1.</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> op1.orElse(<span class="string">&quot;shanghai&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(str2);<span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-典型例题"><a href="#4-典型例题" class="headerlink" title="4.典型例题"></a>4.典型例题</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OptionalTest</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  Optional出现就是避免空指针，下列调用完getGirlName2(Boy boy)，无论传入的数据空或非空，传出的一定非空</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用Optional类的getGirlName():</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getGirlName2</span><span class="params">(Boy boy)</span>&#123;</span><br><span class="line"></span><br><span class="line">    Optional&lt;Boy&gt; boyOptional = Optional.ofNullable(boy);</span><br><span class="line">    <span class="comment">//此时的boy1一定非空</span></span><br><span class="line">    <span class="type">Boy</span> <span class="variable">boy1</span> <span class="operator">=</span> boyOptional.orElse(<span class="keyword">new</span> <span class="title class_">Boy</span>(<span class="keyword">new</span> <span class="title class_">Girl</span>(<span class="string">&quot;迪丽热巴&quot;</span>)));</span><br><span class="line"></span><br><span class="line">    <span class="type">Girl</span> <span class="variable">girl</span> <span class="operator">=</span> boy1.getGirl();</span><br><span class="line"></span><br><span class="line">    Optional&lt;Girl&gt; girlOptional = Optional.ofNullable(girl);</span><br><span class="line">    <span class="comment">//girl1一定非空</span></span><br><span class="line">    <span class="type">Girl</span> <span class="variable">girl1</span> <span class="operator">=</span> girlOptional.orElse(<span class="keyword">new</span> <span class="title class_">Girl</span>(<span class="string">&quot;古力娜扎&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> girl1.getName();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test5</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Boy</span> <span class="variable">boy</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    boy = <span class="keyword">new</span> <span class="title class_">Boy</span>();</span><br><span class="line">    boy = <span class="keyword">new</span> <span class="title class_">Boy</span>(<span class="keyword">new</span> <span class="title class_">Girl</span>(<span class="string">&quot;苍老师&quot;</span>));</span><br><span class="line">    <span class="type">String</span> <span class="variable">girlName</span> <span class="operator">=</span> getGirlName2(boy);</span><br><span class="line">    System.out.println(girlName);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、网络编程&quot;&gt;&lt;a href=&quot;#一、网络编程&quot; class=&quot;headerlink&quot; title=&quot;一、网络编程&quot;&gt;&lt;/a&gt;一、网络编程&lt;/h1&gt;&lt;h3 id=&quot;1-1网络编程概述&quot;&gt;&lt;a href=&quot;#1-1网络编程概述&quot; class=&quot;headerlink</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Java集合-泛型-IO流</title>
    <link href="http://example.com/2022/10/04/Java%E9%AB%98%E7%BA%A7-%E9%9B%86%E5%90%88-%E6%B3%9B%E5%9E%8B-IO%E6%B5%81/"/>
    <id>http://example.com/2022/10/04/Java%E9%AB%98%E7%BA%A7-%E9%9B%86%E5%90%88-%E6%B3%9B%E5%9E%8B-IO%E6%B5%81/</id>
    <published>2022-10-03T16:00:00.000Z</published>
    <updated>2022-10-05T08:45:08.554Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、集合"><a href="#一、集合" class="headerlink" title="一、集合"></a>一、集合</h2><h3 id="1-1集合的概述"><a href="#1-1集合的概述" class="headerlink" title="1.1集合的概述"></a>1.1集合的概述</h3><h4 id="1-集合与数组"><a href="#1-集合与数组" class="headerlink" title="1.集合与数组"></a>1.集合与数组</h4><ol><li>集合、数组都是对多个数据进行存储操作的结构，简称Java容器。</li><li>说明：此时的存储，主要指的是内存层面的存储，不涉及到持久化的存储（.txt,.jpg,.avi，数据库中）</li></ol><p><strong>数组优缺点：</strong></p><ol><li>数组在存储多个数据方面的特点：<ol><li>一旦初始化以后，其长度就确定了。</li><li>数组一旦定义好，其元素的类型也就确定了。我们也就只能操作指定类型的数据了。比如：String[] arr;int[] arr1;Object[] arr2;</li></ol></li><li>数组在存储多个数据方面的缺点：<ol><li>一旦初始化以后，其长度就不可修改。</li><li>数组中提供的方法非常有限，对于添加、删除、插入数据等操作，非常不便，同时效率不高。</li><li>获取数组中实际元素的个数的需求，数组没有现成的属性或方法可用</li><li>数组存储数据的特点：有序、可重复。对于无序、不可重复的需求，不能满足。</li></ol></li></ol><h4 id="2-集合的框架"><a href="#2-集合的框架" class="headerlink" title="2.集合的框架"></a>2.集合的框架</h4><ol><li><p>Collection接口：单列集合，用来存储一个一个的对象</p><ol><li><p><strong>List接口：存储有序的、可重复的数据</strong>。  –&gt;“动态”数组</p><p>例如：ArrayList、LinkedList、Vector（实现类）</p></li><li><p><strong>Set接口：存储无序的、不可重复的数据</strong>   –&gt;高中讲的“集合”</p><p>例如：HashSet、LinkedHashSet、TreeSet（实现类）</p></li></ol></li><li><p>Map接口：双列集合，用来存储一对(key - value)一对的数据   –&gt;高中函数：y &#x3D; f(x)</p><p>例如：HashMap、LinkedHashMap、TreeMap、Hashtable、Properties（实现类）</p></li></ol><h3 id="1-2Collection接口中方法"><a href="#1-2Collection接口中方法" class="headerlink" title="1.2Collection接口中方法"></a>1.2Collection接口中方法</h3><p>声明方式一：Collection coll &#x3D; new ArrayList()</p><p>声明方式二：调用Arrays的静态方法asList,<strong>形参为可变形参</strong>，返回ArrayList<br>Collection coll1 &#x3D; Arrays.asList(123,456);</p><ol><li><p>add(Object e)</p><p>将元素e添加到集合coll中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Collection</span> <span class="variable">coll</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();    <span class="comment">//集合的声明</span></span><br><span class="line">coll.add(<span class="string">&quot;AA&quot;</span>);</span><br><span class="line">coll.add(<span class="string">&quot;BB&quot;</span>);</span><br><span class="line">coll.add(<span class="number">123</span>);<span class="comment">//自动装箱Integer</span></span><br><span class="line">coll.add(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br></pre></td></tr></table></figure></li><li><p>size()</p><p>获取添加的元素的个数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(coll.size());  <span class="comment">//4</span></span><br></pre></td></tr></table></figure></li><li><p>addAll(Collection coll1)</p><p>将coll1集合中的元素添加到当前的集合中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Collection coll1 = new ArrayList();</span><br><span class="line">coll1.add(456);</span><br><span class="line">coll1.add(&quot;CC&quot;);</span><br><span class="line">coll.addAll(coll1); </span><br></pre></td></tr></table></figure></li><li><p>clear()</p><p>清空集合元素，不是删除集合，而是清空元素</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">coll.clear();  </span><br></pre></td></tr></table></figure></li><li><p>isEmpty()</p><p>判断当前集合是否为空</p></li><li><p>boolean   contains(Object obj)</p><p>判断当前集合中是否包含obj，我们在判断时会调用obj对象所在类的equals()。如果不重写equals方法，则会调用Object中的equals()，使用的是&#x3D;&#x3D;，不同对象比的是地址，所以必须重写equals( )</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">boolean contains = coll.contains(123);</span><br><span class="line"></span><br><span class="line">contain1 = coll.contains(new Person(&quot;Jerry&quot;,20));</span><br></pre></td></tr></table></figure></li><li><p>containsAll(Collection coll1)</p><p>判断形参coll1中的所有元素是否都存在于当前集合中。同样调用equals方法，所以重写equals很重要</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Collection</span> <span class="variable">coll</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        coll.add(<span class="number">456</span>);</span><br><span class="line">        coll.add(<span class="number">123</span>);</span><br><span class="line"><span class="comment">//        Person p = new Person(&quot;Jerry&quot;,20);</span></span><br><span class="line"><span class="comment">//        coll.add(p);</span></span><br><span class="line">        coll.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Jerry&quot;</span>,<span class="number">20</span>));</span><br><span class="line">        coll.add(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Tom&quot;</span>));</span><br><span class="line">        coll.add(<span class="literal">false</span>);</span><br><span class="line">声明方式：调用Arrays的静态方法asList,形参为可变形参，返回ArrayList</span><br><span class="line"><span class="type">Collection</span> <span class="variable">coll1</span> <span class="operator">=</span> Arrays.asList(<span class="number">123</span>,<span class="number">456</span>);</span><br><span class="line">System.out.println(coll.containsAll(coll1));</span><br><span class="line"><span class="type">Collection</span> <span class="variable">coll2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">coll2.add(<span class="number">123</span>);</span><br><span class="line">coll2.add(<span class="number">456</span>);</span><br><span class="line">coll2.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Jerry&quot;</span>,<span class="number">20</span>));</span><br><span class="line">System.out.println(coll.containsAll(coll2));</span><br></pre></td></tr></table></figure></li><li><p>remove(Object obj)</p><p>从当前集合中移除obj元素。无返回值，直接修改当前集合元素</p><p>同样调用equals方法，查找是否存在此元素</p><p>coll.remove(1234);</p></li><li><p>removeAll(Collection coll1)</p><p>差集：从当前集合中移除coll1中所有的元素。移除该集合与形参集合交集部分。也是调用equals方法，查找是否存在此元素，</p></li><li><p>retainAll(Collection coll1)</p><p>交集：获取当前集合和coll1集合的交集，并返回给当前集合。将两集合交集替换当前集合元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Collection</span> <span class="variable">coll1</span> <span class="operator">=</span> Arrays.asList(<span class="number">123</span>,<span class="number">456</span>,<span class="number">789</span>);</span><br><span class="line">   coll.retainAll(coll1);  </span><br><span class="line">     System.out.println(coll); <span class="comment">//123,456</span></span><br></pre></td></tr></table></figure></li><li><p>equals(Object obj)</p><p>要想返回true，需要当前集合和形参集合的元素都相同（加入顺序和集合元素都是相同的）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Collection</span> <span class="variable">coll1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">coll1.add(<span class="number">123</span>);</span><br><span class="line">coll1.add(<span class="number">456</span>);</span><br><span class="line"><span class="type">Collection</span> <span class="variable">coll2</span> <span class="operator">=</span> Arrays.asList(<span class="number">123</span>,<span class="number">456</span>);</span><br><span class="line">System.out.println(coll.equals(coll2));</span><br></pre></td></tr></table></figure></li><li><p>hashCode()</p><p>返回当前对象的哈希值</p></li><li><p>集合 —&gt;数组：  toArray()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Object[] arr = coll.toArray();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; arr.length;i++)&#123;</span><br><span class="line">    System.out.println(arr[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拓展：数组 —&gt;集合:调用Arrays类的静态方法asList(T…..t)   形参为对象的可变形参，看做一个个对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;AA&quot;</span>, <span class="string">&quot;BB&quot;</span>, <span class="string">&quot;CC&quot;</span>&#125;);</span><br><span class="line">System.out.println(list);</span><br><span class="line"></span><br><span class="line"><span class="type">List</span> <span class="variable">arr1</span> <span class="operator">=</span> Arrays.asList(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">123</span>, <span class="number">456</span>&#125;);</span><br><span class="line">System.out.println(arr1.size());<span class="comment">//1 这int数组看做一个对象，所以里面只有 1 </span></span><br><span class="line"></span><br><span class="line"><span class="type">List</span> <span class="variable">arr2</span> <span class="operator">=</span> Arrays.asList(<span class="keyword">new</span> <span class="title class_">Integer</span>[]&#123;<span class="number">123</span>, <span class="number">456</span>&#125;);</span><br><span class="line">System.out.println(arr2.size());<span class="comment">//2  这Integer数组内部成员可看成一个个对象，所以为 2 </span></span><br></pre></td></tr></table></figure></li><li><p>iterator( ）    迭代器</p><p>返回Iterator接口的实例，用于遍历集合元素。放在IteratorTest.java中测试——下一结介绍</p></li></ol><h3 id="1-3iterator-迭代器接口"><a href="#1-3iterator-迭代器接口" class="headerlink" title="1.3iterator 迭代器接口"></a>1.3iterator 迭代器接口</h3><h4 id="1-iterator-）-迭代器"><a href="#1-iterator-）-迭代器" class="headerlink" title="1.iterator(） 迭代器"></a>1.iterator(） 迭代器</h4><p><strong>Collection中的方法：iterator( ）    迭代器</strong></p><p>返回Iterator接口的实例，<strong>用于遍历集合元素。用于集合元素的遍历操作</strong>，使用迭代器Iterator接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Collection</span> <span class="variable">coll</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">coll.add(<span class="number">123</span>);</span><br><span class="line">coll.add(<span class="number">456</span>);</span><br><span class="line"><span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> coll.iterator();</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Iterator接口介绍：</strong></p><ol><li><p>内部的方法：</p><p>hasNext() ： 判断是否还有下一个元素</p><p>  next()   ：①指针下移 ②将下移以后集合位置上的元素返回</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">一般使用方式：用于遍历集合   </span><br><span class="line">    <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> coll.iterator();</span><br><span class="line">       <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">           System.out.println(iterator.next());</span><br><span class="line">   </span><br></pre></td></tr></table></figure></li><li><p>集合对象每次调用iterator()方法都得到一个全新的迭代器对象，默认游标都在集合的第一个元素之前。</p></li><li><p>内部定义了remove(),可以在遍历的时候，删除集合中的元素。此方法不同于集合直接调用remove()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除集合中&quot;Tom&quot;</span></span><br><span class="line"><span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> coll.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">     <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;Tom&quot;</span>.equals(obj))&#123; 防止空指针，将Tom放外面</span><br><span class="line">            iterator.remove();</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">错误方式：</span><br><span class="line">如果还未调用next()或在上一次调用 next 方法之后已经调用了 remove 方法，再调用remove都会报IllegalStateException。</span><br><span class="line"> <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> coll.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line"> 错误一：    iterator.remove();</span><br><span class="line">            <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&quot;Tom&quot;</span>.equals(obj))&#123;</span><br><span class="line"> 错误二：        iterator.remove();</span><br><span class="line">                iterator.remove();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">   </span><br></pre></td></tr></table></figure></li></ol><h4 id="2-foreach循环"><a href="#2-foreach循环" class="headerlink" title="2.foreach循环"></a>2.foreach循环</h4><p>jdk 5.0 新增了forEach循环（或增强for循环），用于遍历集合、数组</p><ol><li><p>格式：for(集合元素的类型 局部变量 : 集合对象)        </p></li><li><p>内部仍然调用了迭代器。（循环过程：集合对象从内部调用迭代器判断并获取，将元素<strong>赋给</strong>局部变量）       </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(Object obj : coll)&#123;</span><br><span class="line">        System.out.println(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    <span class="comment">//for(数组元素的类型 局部变量 : 数组对象)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i : arr)&#123;</span><br><span class="line">    <span class="comment">//i = 3; 修改i不能真正修改集合中元素</span></span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h3 id="1-4List接口实现类及方法"><a href="#1-4List接口实现类及方法" class="headerlink" title="1.4List接口实现类及方法"></a>1.4List接口实现类及方法</h3><h4 id="1-三者实现类的比较"><a href="#1-三者实现类的比较" class="headerlink" title="1.三者实现类的比较"></a>1.三者实现类的比较</h4><p><strong>面试题：</strong>ArrayList、LinkedList、Vector三者的异同？</p><p><strong>相同：</strong>三个类都是实现了List接口，存储数据的特点相同：存储有序的、可重复的数据</p><p><strong>补充使用须知：三者添加的数据，其所在的类一定要重写equals( ) 方法（原因：比如说调用Collection接口中的contains()时会调用所在类的equals，没有重写则会调用Object中的equals，即&#x3D;&#x3D;）</strong></p><p><strong>不同：</strong></p><ol><li>ArrayList：作为List接口的主要实现类；线程不安全的，效率高；底层使用Object[] elementData存储</li><li>LinkedList：对于频繁的插入、删除操作，使用此类效率比ArrayList高；底层使用双向链表存储</li><li>Vector：作为List接口的古老实现类；线程安全的，效率低；底层使用Object[] elementData存储</li></ol><p><strong>三者源码深入分析：</strong></p><p><strong>一、ArrayList的源码分析：</strong></p><p><strong>1.jdk 7情况下</strong></p><ol><li><p>ArrayList list &#x3D; new ArrayList();</p><p><strong>&#x2F;&#x2F;底层创建了长度是10的Object[]数组elementData</strong></p><p>list.add(123);    &#x2F;&#x2F;<strong>底层：elementData[0] &#x3D; new Integer(123);</strong></p><p>…</p><p>list.add(11);&#x2F;&#x2F;<strong>如果此次的添加导致底层elementData数组容量不够，则扩容。</strong></p><p><strong>默认情况下，扩容为原来的容量的1.5倍，同时需要将原有数组中的数据复制到新的数组中。</strong></p><p><strong>结论：建议开发中使用带参的构造器：ArrayList list &#x3D; new ArrayList(int capacity)</strong></p></li></ol><p><strong>2.jdk 8中ArrayList的变化：</strong></p><ol><li><p>ArrayList list &#x3D; new ArrayList();</p><p>&#x2F;&#x2F;<strong>底层Object[] elementData初始化为{}.并没有创建长度为10的数组</strong></p><p>list.add(123);&#x2F;<strong>&#x2F;第一次调用add()时，底层才创建了长度10的数组，并将数据123添加到elementData[0]</strong></p><p>…</p><p><strong>后续的添加和扩容操作与jdk 7 无异。</strong></p></li></ol><p><strong>小结：jdk7中的ArrayList的对象的创建类似于单例的饿汉式，而jdk8中的ArrayList的对象的创建类似于单例的懒汉式，延迟了数组的创建，节省内存。</strong></p><p><strong>二、LinkedList的源码分析：</strong></p><ol><li><p>LinkedList list &#x3D; new LinkedList(); 内部声明了Node类型的first和last属性，默认值为null</p><p>list.add(123);&#x2F;&#x2F;将123封装到Node中，创建了Node对象。其中，Node定义为：体现了LinkedList的双向链表的说法</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">底层源码：</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt; &#123;</span><br><span class="line">    E item;</span><br><span class="line">     Node&lt;E&gt; next;</span><br><span class="line">     Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">     Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">     <span class="built_in">this</span>.item = element;</span><br><span class="line">     <span class="built_in">this</span>.next = next;</span><br><span class="line">     <span class="built_in">this</span>.prev = prev;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>三、Vector的源码分析：</strong></p><p>jdk7和jdk8中通过Vector()构造器创建对象时，底层都创建了长度为10的数组。</p><p>在扩容方面，默认扩容为原来的数组长度的2倍。</p><h4 id="2-List接口中常用方法"><a href="#2-List接口中常用方法" class="headerlink" title="2.List接口中常用方法"></a>2.List接口中常用方法</h4><ol><li><p>void add(int index, Object ele)</p><p>在index位置插入ele元素</p><p>list.add(1,”BB”);</p></li><li><p>boolean addAll(int index, Collection eles)</p><p>从index位置开始将eles中的所有元素添加进来</p><p> List list1 &#x3D; Arrays.asList(1, 2, 3);</p><p>list.addAll(list1);   不写index默认为0</p></li><li><p>Object get(int index)</p><p>获取指定index位置的元素</p></li><li><p>int indexOf(Object obj)</p><p>返回obj在集合中首次出现的位置</p></li><li><p>int lastIndexOf(Object obj)</p><p>返回obj在当前集合中末次出现的位置</p></li><li><p>Object remove(int index)</p><p>移除指定index位置的元素，并返回此元素</p></li><li><p>Object set(int index, Object ele)</p><p>设置指定index位置的元素为ele</p></li><li><p>List subList(int fromIndex, int toIndex)</p><p>返回从fromIndex到toIndex位置的子集合</p></li><li><p>总结：常用方法<br>增：add(Object obj)<br>删：List接口：remove(int index) &#x2F; Collection接口：remove(Object obj)<br>改：set(int index, Object ele)<br>查：get(int index)<br>插：add(int index, Object ele)<br>长度：size()<br>遍历：① Iterator迭代器方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> list.iterator();</span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">    System.out.println(iterator.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​             ② 增强for循环</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(Object obj : list)&#123;</span><br><span class="line">    System.out.println(obj);</span><br><span class="line">&#125;         </span><br></pre></td></tr></table></figure></li></ol><p>​                     ③ 普通的循环</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; list.size();i++)&#123;</span><br><span class="line">    System.out.println(list.get(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-5Set接口及实现类介绍"><a href="#1-5Set接口及实现类介绍" class="headerlink" title="1.5Set接口及实现类介绍"></a>1.5Set接口及实现类介绍</h3><h4 id="1-三个实现类介绍"><a href="#1-三个实现类介绍" class="headerlink" title="1.三个实现类介绍"></a>1.三个实现类介绍</h4><p>Collection接口：单列集合，用来存储一个一个的对象</p><p>Collection接口子Set接口：<strong>存储无序的、不可重复的数据</strong>   –&gt;高中讲的“集合”</p><p><strong>使用须知：HashSet、LinkedHashSet添加的数据，其所在的类一定要重写hashCode()和equals()。TreeSet则需要重写compareTo或compare方法</strong></p><p><strong>说明：</strong></p><ol><li><p>HashSet：<strong>作为Set接口的主要实现类；线程不安全的；可以存储null值</strong></p><p>补充：new HashSet()其实底层是new HashMap() , 但是Set是单列Map是双列，所以用key来保存HashSet元素，value用一个常量来暂时隐蔽起来</p></li><li><p>LinkedHashSet：作为HashSet的子类；遍历其内部数据时，可以按照添加的顺序遍历</p><p>LinkedHashSet的使用<br><strong>LinkedHashSet作为HashSet的子类，在添加数据的同时，每个数据还维护了两个引用，记录此数据前一个数据和后一个数据。</strong>（因此该类迭代效率高于HashSet）<br>优点：对于频繁的遍历操作，LinkedHashSet效率高于HashSet</p><p>底层图示：</p><p><img src="/2022/10/04/Java%E9%AB%98%E7%BA%A7-%E9%9B%86%E5%90%88-%E6%B3%9B%E5%9E%8B-IO%E6%B5%81/Snipaste_2022-02-02_20-12-36.png" alt="Snipaste_2022-02-02_20-12-36"></p></li><li><p>TreeSet：<strong>可以按照添加对象的指定属性，进行排序。遍历时可有序遍历</strong></p><ol><li><p><strong>向TreeSet中添加的数据，要求是同一个类的对象。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">TreeSet</span> <span class="variable">set</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeSet</span>();</span><br><span class="line">set.add(<span class="number">34</span>);</span><br><span class="line">set.add(-<span class="number">34</span>);</span><br><span class="line">set.add(<span class="number">43</span>);</span><br><span class="line">set.add(<span class="number">11</span>);</span><br><span class="line">set.add(<span class="number">8</span>)；输出：按照从从小到大输出</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><strong>TreeSet对属性进行排序使用两种排序方式</strong>：自然排序（实现Comparable接口） 和 定制排序（Comparator）</p><p>1.自然排序中，比较两个对象是否相同的标准为：compareTo()返回0.不再是equals()，<strong>该类要求实现Comparable接口，重写compareTo</strong></p><p><img src="/2022/10/04/Java%E9%AB%98%E7%BA%A7-%E9%9B%86%E5%90%88-%E6%B3%9B%E5%9E%8B-IO%E6%B5%81/image-20220320101407300.png" alt="image-20220320101407300"></p><p>2.定制排序中，比较两个对象是否相同的标准为：compare()返回0.不再是equals()，<strong>TreeSet有形参为Comparator的构造器</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Comparator</span> <span class="variable">com</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Comparator</span>() &#123;</span><br><span class="line">    <span class="comment">//按照年龄从小到大排列</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object o1, Object o2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(o1 <span class="keyword">instanceof</span> User &amp;&amp; o2 <span class="keyword">instanceof</span> User)&#123;</span><br><span class="line">            <span class="type">User</span> <span class="variable">u1</span> <span class="operator">=</span> (User)o1;</span><br><span class="line">            <span class="type">User</span> <span class="variable">u2</span> <span class="operator">=</span> (User)o2;</span><br><span class="line">            <span class="keyword">return</span> Integer.compare(u1.getAge(),u2.getAge());</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;输入的数据类型不匹配&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">TreeSet</span> <span class="variable">set</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeSet</span>(com);</span><br><span class="line">set.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Tom&quot;</span>,<span class="number">12</span>));</span><br><span class="line">set.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Jerry&quot;</span>,<span class="number">32</span>));</span><br><span class="line">set.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Jim&quot;</span>,<span class="number">2</span>));</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol></li></ol><h4 id="2-Set接口介绍"><a href="#2-Set接口介绍" class="headerlink" title="2.Set接口介绍"></a>2.Set接口介绍</h4><p><strong>Set接口使用说明：</strong></p><ol><li><p><strong>Set接口中没有额外定义新的方法，使用的都是Collection中声明过的方法。</strong></p></li><li><p>要求：向Set(主要指：HashSet、LinkedHashSet)中<strong>添加的数据，其所在的类一定要重写hashCode()和equals()</strong></p></li><li><p>要求：重写的hashCode()和equals()尽可能保持一致性：相等的对象必须具有相等的散列码（一般用自动生成）</p></li><li><p>重写两个方法的小技巧：对象中用作 equals() 方法比较的 Field，都应该用来计算 hashCode 值。<br>​</p><p><strong>一、Set：存储无序的、不可重复的数据</strong><br>以HashSet为例说明：</p><ol><li><strong>无序性</strong>：不等于随机性。存储的数据在底层数组中并非按照数组索引的顺序添加，而是根据数据的哈希值决定的。</li><li><strong>不可重复性</strong>：保证添加的元素按照equals()判断时，不能返回true.即：相同的元素只能添加一个。</li></ol><p><strong>二、添加元素的过程介绍两个特性：以HashSet为例：</strong></p><p>我们向HashSet中添加元素a,首先调用元素a所在类的hashCode()方法，计算元素a的哈希值，此哈希值接着通过某种算法计算出在HashSet底层数组中的存放位置（即为：索引位置），判断数组此位置上是否已经有元素：</p><p>1.如果此位置上没有其他元素，则元素a添加成功。 —&gt;情况1<br>2.如果此位置上有其他元素b(或以链表形式存在的多个元素），则比较元素a与元素b的hash值：</p><ol><li>如果hash值不相同，则元素a添加成功。—&gt;情况2</li><li>如果hash值相同，进而需要调用元素a所在类的equals()方法：<ol><li>equals()返回true,元素a添加失败</li><li>equals()返回false,则元素a添加成功。—&gt;情况3</li></ol></li></ol><p><strong>过程总结：先计算hashcode，将元素按某种算法算出下标填入数组，如有重复则进行比较两者hashcode值</strong>（<strong>若不等则就以链表形式一起存在该数组下标，若相等则用equals方法继续比较，还相等则不要，否则就要</strong></p><p><strong>—-小结：hashcode相等两者不一定相等，但两者相等，hashcode一定相等</strong></p><p><strong>—补充特例：首先添加元素为1，后又通过地址修改元素为2，在添加一个元素为2，此时的hashcode值是不同，有位置就直接存入数组了，就存在相同元素了</strong>）</p><p>对于添加成功的情况2和情况3而言：元素a 与已经存在指定索引位置上数据以链表的方式存储。</p><p>jdk 7 :元素a放到数组中，指向原来的元素。<br>jdk 8 :原来的元素在数组中，指向元素a<br>总结：七上八下</p><p>HashSet底层：数组+链表的结构。</p></li></ol><h3 id="1-6Map的实现类及理解"><a href="#1-6Map的实现类及理解" class="headerlink" title="1.6Map的实现类及理解"></a>1.6Map的实现类及理解</h3><h4 id="1-Map的实现类的结构："><a href="#1-Map的实现类的结构：" class="headerlink" title="1.Map的实现类的结构："></a>1.Map的实现类的结构：</h4><p>Map:<strong>双列数据，存储key-value对的数据</strong>   —类似于高中的函数：y &#x3D; f(x)</p><ol><li><p>HashMap:<strong>作为Map的主要实现类；线程不安全的，效率高；存储null的key和value</strong></p></li><li><p>LinkedHashMap<strong>继承于</strong>HashMap:<strong>保证在遍历map元素时，可以按照添加的顺序实现遍历。</strong></p><p>原因：在原有的HashMap底层结构基础上，添加了一对指针，指向前一个和后一个元素。</p><p>对于频繁的遍历操作，此类执行效率高于HashMap。</p></li><li><p>TreeMap:<strong>保证按照添加的key-value对进行排序，实现排序遍历。此时考虑key的自然排序或定制排序。底层使用红黑树</strong></p></li><li><p>Hashtable:作为古老（出现早）的实现类<strong>；线程安全的，效率低；不能存储null的key和value</strong></p></li><li><p>Properties<strong>继承于</strong>Hashtable:<strong>常用来处理配置文件。key和value都是String类型</strong></p></li></ol><p>HashMap的底层：数组+链表  （jdk7及之前）</p><p>数组+链表+红黑树 （jdk 8）</p><p>面试题：</p><p>HashMap的底层实现原理？</p><p>HashMap 和 Hashtable的异同？</p><p>CurrentHashMap 与 Hashtable的异同？（暂时不讲）</p><h4 id="2-Map结构的理解："><a href="#2-Map结构的理解：" class="headerlink" title="2.Map结构的理解："></a>2.Map结构的理解：</h4><p>通俗理解：高中的函数：key &#x3D; x  value &#x3D; y;  x 可是无序的，但不能重复，y也可是无序的，但可以重复（二次函数多个x对一个y)</p><ol><li><p>Map中的key:<strong>无序的、不可重复的，使用Set存储所有的key  —&gt; key所在的类要重写equals()和hashCode() （以HashMap为例）</strong></p></li><li><p>Map中的value:<strong>无序的、可重复的，使用Collection存储所有的value —&gt;value所在的类要重写equals()</strong></p></li><li><p><strong>一个键值对：key-value构成了一个Entry对象。</strong></p></li><li><p><strong>Map中的entry:无序的、不可重复的，使用Set存储所有的entry</strong></p></li><li><p>Entry将键值对的对应关系封装成了对象，即键值对对象，这样我们在遍历Map集合时，就可以从每一个键值对（Entry）对象中获取对应的键与对应的值。</p><p><strong>Entry静态内部嵌套接口，修饰为静态可以通过类名调用。</strong></p><p><strong>Entry中方法：getKey()和getValue(),获取键值对</strong></p></li><li><p>图示：</p><p><img src="/2022/10/04/Java%E9%AB%98%E7%BA%A7-%E9%9B%86%E5%90%88-%E6%B3%9B%E5%9E%8B-IO%E6%B5%81/Snipaste_2022-02-03_10-41-34.png" alt="Snipaste_2022-02-03_10-41-34"></p></li></ol><h4 id="3-HashMap底层实现原理"><a href="#3-HashMap底层实现原理" class="headerlink" title="3.HashMap底层实现原理"></a>3.HashMap底层实现原理</h4><p>面试题：<strong>HashMap的底层实现原理？以jdk7为例说明：</strong></p><ol><li><p>HashMap map &#x3D; new HashMap()</p><p>在实例化以后，底层创建了长度是16的一维数组Entry[] table。</p><p>…可能已经执行过多次put…</p></li><li><p>map.put(key1,value1)</p><p>首先，调用key1所在类的hashCode()计算key1哈希值，此哈希值经过某种算法计算以后，得到在Entry数组中的存放位置。</p><p>1.如果此位置上的数据为空，此时的key1-value1添加成功。 —-情况1</p><p>2.如果此位置上的数据不为空，(意味着此位置上存在一个或多个数据(以链表形式存在)),<strong>比较key1和已经存在的一个或多个数据的哈希值：</strong></p><ol><li>如果key1的哈希值与已经存在的数据的哈希值都不相同，此时key1-value1添加成功。—-情况2</li><li>如果key1的哈希值和已经存在的某一个数据(key2-value2)的哈希值相同，继续比较：<strong>调用key1所在类的equals(key2)方法，比较：</strong><ol><li>如果equals()返回false:此时key1-value1添加成功。—-情况3</li><li><strong>如果equals()返回true:使用value1替换value2。put因此也有修改的作用</strong></li></ol></li><li>补充：关于情况2和情况3：此时key1-value1和原来的数据以链表的方式存储。</li></ol></li></ol><p><strong>扩容问题：</strong></p><p>在不断的添加过程中，会涉及到扩容问题，当超出临界值(且要存放的位置非空–凌临界值不等于数组长度)时，扩容。默认的扩容方式：<strong>扩容为原来容量的2倍，并将原有的数据复制过来</strong>。</p><p><strong>jdk8 相较于jdk7在底层实现方面的不同：</strong></p><ol><li><p>new HashMap():<strong>底层没有创建一个长度为16的数组</strong></p></li><li><p>jdk 8底层的数组是：Node[],而非Entry[]</p></li><li><p><strong>首次调用put()方法时，底层创建长度为16的数组</strong></p></li><li><p><strong>jdk7底层结构只有：数组+链表。jdk8中底层结构：数组+链表+红黑树。</strong></p><p>4.1 形成链表时，<strong>七上八下（jdk7:新的元素指向旧的元素。jdk8：旧的元素指向新的元素）</strong></p><p>4.2 <strong>当数组的某一个索引位置上的元素以链表形式存在的数据个数 &gt; 8 且当前数组的长度 &gt; 64（如小于64则转为扩容）时，此时此索引位置上的所数据改为使用红黑树存储。</strong></p></li></ol><p><strong>底层代码的关键常量：</strong></p><ol><li>DEFAULT_INITIAL_CAPACITY : HashMap的默认容量，16</li><li>DEFAULT_LOAD_FACTOR：HashMap的默认加载因子：0.75</li><li>threshold：<strong>扩容的临界值</strong>，&#x3D;容量*填充因子：16 * 0.75 &#x3D;&gt; 12</li><li>TREEIFY_THRESHOLD：Bucket中链表长度大于该默认值，转化为红黑树:8</li><li>MIN_TREEIFY_CAPACITY：桶中的Node被树化时最小的hash表容量:64</li></ol><h4 id="4-LinkedHashMap的底层实现原理（了解）"><a href="#4-LinkedHashMap的底层实现原理（了解）" class="headerlink" title="4.LinkedHashMap的底层实现原理（了解）"></a>4.LinkedHashMap的底层实现原理（了解）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> 源码中：</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">HashMap</span>.Node&lt;K,V&gt; &#123;</span><br><span class="line">Entry&lt;K,V&gt; before, after;<span class="comment">//能够记录添加的元素的先后顺序</span></span><br><span class="line"> Entry(<span class="type">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">              <span class="built_in">super</span>(hash, key, value, next);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="5-TreeMap实现类使用"><a href="#5-TreeMap实现类使用" class="headerlink" title="5.TreeMap实现类使用"></a>5.TreeMap实现类使用</h4><p>向TreeMap中添加key-value，要求key必须是由同一个类创建的对象<br>因为要按照key进行排序：自然排序 、定制排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自然排序：在User重写compareTo方法</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">TreeMap</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeMap</span>();</span><br><span class="line">    <span class="type">User</span> <span class="variable">u1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Tom&quot;</span>,<span class="number">23</span>);</span><br><span class="line">    <span class="type">User</span> <span class="variable">u2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Jerry&quot;</span>,<span class="number">32</span>);</span><br><span class="line">    <span class="type">User</span> <span class="variable">u3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Jack&quot;</span>,<span class="number">20</span>);</span><br><span class="line">    <span class="type">User</span> <span class="variable">u4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Rose&quot;</span>,<span class="number">18</span>);</span><br><span class="line"></span><br><span class="line">    map.put(u1,<span class="number">98</span>);</span><br><span class="line">    map.put(u2,<span class="number">89</span>);</span><br><span class="line">    map.put(u3,<span class="number">76</span>);</span><br><span class="line">    map.put(u4,<span class="number">100</span>);<span class="comment">//添加类型一致</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//定制排序</span></span><br><span class="line">  <span class="type">TreeMap</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeMap</span>(<span class="keyword">new</span> <span class="title class_">Comparator</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object o1, Object o2)</span> &#123;</span><br><span class="line">         <span class="keyword">if</span>(o1 <span class="keyword">instanceof</span> User &amp;&amp; o2 <span class="keyword">instanceof</span> User)&#123;</span><br><span class="line">             <span class="type">User</span> <span class="variable">u1</span> <span class="operator">=</span> (User)o1;</span><br><span class="line">             <span class="type">User</span> <span class="variable">u2</span> <span class="operator">=</span> (User)o2;</span><br><span class="line">            <span class="keyword">return</span> Integer.compare(u1.getAge(),u2.getAge());</span><br><span class="line">                &#125;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;输入的类型不匹配！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><h4 id="6-Properties实现类子类的使用"><a href="#6-Properties实现类子类的使用" class="headerlink" title="6.Properties实现类子类的使用"></a>6.Properties实现类子类的使用</h4><p>Properties:常用来处理配置文件。key和value都是String类型</p><p>配置文件：是一种计算机文件，可以为一些计算机程序配置参数和初始设置。”</p><p>配置文件的创建：一般创建在整个工程下，创建File 后缀名为properties，也可直接点击Resource  Bundle 创建自动添加后缀名</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先做简单了解：</span></span><br><span class="line"><span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">Properties</span> <span class="variable">pros</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line"></span><br><span class="line">    fis = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;jdbc.properties&quot;</span>);</span><br><span class="line">    pros.load(fis);<span class="comment">//加载流对应的文件</span></span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;name = &quot;</span> + name + <span class="string">&quot;, password = &quot;</span> + password);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="1-7Map接口中常用方法"><a href="#1-7Map接口中常用方法" class="headerlink" title="1.7Map接口中常用方法"></a>1.7Map接口中常用方法</h3><h4 id="1-添加、删除、修改操作："><a href="#1-添加、删除、修改操作：" class="headerlink" title="1.添加、删除、修改操作："></a>1.添加、删除、修改操作：</h4><ol><li><p>Object put(Object key,Object value)</p><p>将指定key-value<strong>添加到(或修改)当前map对象中</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"><span class="comment">//添加</span></span><br><span class="line">map.put(<span class="string">&quot;AA&quot;</span>,<span class="number">123</span>);</span><br><span class="line">map.put(<span class="number">45</span>,<span class="number">123</span>);</span><br><span class="line">map.put(<span class="string">&quot;BB&quot;</span>,<span class="number">56</span>);</span><br><span class="line"><span class="comment">//修改</span></span><br><span class="line">map.put(<span class="string">&quot;AA&quot;</span>,<span class="number">87</span>); <span class="comment">//只看key，如果有相同，则替换为新加的</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>void putAll(Map m)</p><p>将m中的所有key-value对存放到当前map中</p></li><li><p>Object remove(Object key)</p><p>移除指定key的key-value对，并返回value</p></li><li><p>void clear()</p><p>清空当前map中的所有数据</p></li></ol><h4 id="2-元素查询的操作："><a href="#2-元素查询的操作：" class="headerlink" title="2.元素查询的操作："></a>2.元素查询的操作：</h4><ol><li><p>Object get(Object key)</p><p><strong>获取指定key对应的value</strong></p></li><li><p>boolean containsKey(Object key)</p><p>是否包含指定的key</p></li><li><p>boolean containsValue(Object value)</p><p><strong>是否包含指定的value</strong></p></li><li><p>int size()</p><p>返回map中key-value对的个数</p></li><li><p>boolean isEmpty()</p><p>判断当前map是否为空</p></li><li><p>boolean equals(Object obj)</p><p>判断当前map和参数对象obj是否相等</p></li></ol><h4 id="3-元视图及遍历操作"><a href="#3-元视图及遍历操作" class="headerlink" title="3.元视图及遍历操作"></a>3.元视图及遍历操作</h4><p>元视图操作(能够单独取出key集或value集或key-value集)的方法：</p><ol><li><p>Set keySet()：返回所有key构成的Set集合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        map.put(<span class="string">&quot;AA&quot;</span>,<span class="number">123</span>);</span><br><span class="line">        map.put(<span class="number">45</span>,<span class="number">1234</span>);</span><br><span class="line">        map.put(<span class="string">&quot;BB&quot;</span>,<span class="number">56</span>);</span><br><span class="line"><span class="comment">//遍历所有的key集：keySet()</span></span><br><span class="line"><span class="type">Set</span> <span class="variable">set</span> <span class="operator">=</span> map.keySet();</span><br><span class="line">    <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> set.iterator();</span><br><span class="line">    <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">        System.out.println(iterator.next());</span><br></pre></td></tr></table></figure></li><li><p>Collection values()：返回所有value构成的Collection集合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历所有的value集：values()</span></span><br><span class="line"><span class="type">Collection</span> <span class="variable">values</span> <span class="operator">=</span> map.values();</span><br><span class="line"><span class="keyword">for</span>(Object obj : values)&#123;</span><br><span class="line">    System.out.println(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Set entrySet()：返回所有key-value对构成的Set集合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历所有的key-value</span></span><br><span class="line"><span class="comment">//方式一：entrySet()</span></span><br><span class="line"><span class="type">Set</span> <span class="variable">entrySet</span> <span class="operator">=</span> map.entrySet();</span><br><span class="line"><span class="type">Iterator</span> <span class="variable">iterator1</span> <span class="operator">=</span> entrySet.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator1.hasNext())&#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> iterator1.next();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//entrySet集合中的元素都是entry：一个key一个value</span></span><br><span class="line">    Map.<span class="type">Entry</span> <span class="variable">entry</span> <span class="operator">=</span> (Map.Entry) obj; <span class="comment">//强转</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//getKey()getValue()为entry接口内部静态方法</span></span><br><span class="line">    System.out.println(entry.getKey() + <span class="string">&quot;----&gt;&quot;</span> + entry.getValue());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//方式二：利用keySet()和Map中get()配合</span></span><br><span class="line">        <span class="type">Set</span> <span class="variable">keySet</span> <span class="operator">=</span> map.keySet(); 取出集合key</span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">iterator2</span> <span class="operator">=</span> keySet.iterator();</span><br><span class="line">        <span class="keyword">while</span>(iterator2.hasNext())&#123;</span><br><span class="line">           <span class="type">Object</span> <span class="variable">key</span> <span class="operator">=</span> iterator2.next();</span><br><span class="line">           <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> map.get(key);<span class="comment">//key对应value</span></span><br><span class="line">          System.out.println(key + <span class="string">&quot;=====&quot;</span> + value);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h4 id="4-总结：常用方法"><a href="#4-总结：常用方法" class="headerlink" title="4.总结：常用方法"></a>4.总结：常用方法</h4><ul><li>添加：put(Object key,Object value)</li><li>删除：remove(Object key)</li><li>修改：put(Object key,Object value)</li><li>查询：get(Object key)</li><li>长度：size()</li><li>遍历：keySet() &#x2F; values() &#x2F; entrySet()</li></ul><h3 id="1-8Collections工具类"><a href="#1-8Collections工具类" class="headerlink" title="1.8Collections工具类"></a>1.8Collections工具类</h3><h4 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h4><p>Collections 是一个操作Set、List、和Map等集合的工具类。类似于操作数组的工具类：Arrays，其内部方法都是静态方法</p><h4 id="2-常用方法"><a href="#2-常用方法" class="headerlink" title="2.常用方法"></a>2.常用方法</h4><p>Collections:操作Collection、Map的工具类</p><p>面试题：Collection 和 Collections的区别？</p><ol><li><p>void  reverse(List)</p><p>反转 List 中元素的顺序</p></li><li><p>void shuffle(List)</p><p>对 List 集合元素进行<strong>随机排序</strong></p></li><li><p>void  sort(List)    <strong>自然排序</strong></p><p>根据元素的自然顺序对指定 List 集合元素按升序排序</p></li><li><p>void  sort(List，Comparator)    <strong>定制排序</strong></p><p>根据指定的 Comparator 产生的顺序对 List 集合元素进行排序</p></li><li><p>void  swap(List，int， int)</p><p>将指定 list 集合中的 i 处元素和 j 处元素进行交换</p></li><li><p>Object max(Collection)</p><p>根据元素的<strong>自然顺序</strong>，返回给定集合中的最大元素</p></li><li><p>Object max(Collection，Comparator)</p><p>根据 Comparator <strong>指定的顺序</strong>，返回给定集合中的最大元素</p></li><li><p>Object min(Collection)</p></li><li><p>Object min(Collection，Comparator)</p></li><li><p>int frequency(Collection，Object)</p><p>返回指定集合中指定元素的出现次数</p></li><li><p>void copy(List dest,List src)</p><p>将src中的内容复制到dest中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//        List dest = new ArrayList();</span></span><br><span class="line"><span class="comment">//        Collections.copy(dest,list);</span></span><br><span class="line"><span class="comment">//报异常：IndexOutOfBoundsException(&quot;Source does not fit in dest&quot;)内部需要list.size()&lt;=dest.size()才能复制</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//正确的：利用工具类Arrays中asList将一个list.size()数组作为形参建一个的神态</span></span><br><span class="line">  <span class="type">List</span> <span class="variable">dest</span> <span class="operator">=</span> Arrays.asList(<span class="keyword">new</span> <span class="title class_">Object</span>[list.size()]);</span><br><span class="line">        System.out.println(dest.size());<span class="comment">//list.size();</span></span><br><span class="line">        Collections.copy(dest,list);</span><br><span class="line"></span><br><span class="line">        System.out.println(dest);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>boolean replaceAll(List list，Object oldVal，Object newVal)</p><p>使用新值替换 List 对象的所有旧值</p></li><li><p>ArrayList 和 HashMap 都是线程不安全的，如果程序要求线程安全，我们<strong>可以将ArrayList、HashMap转换线程安全的。</strong></p><p>使用<strong>synchronizedList(List  list) 和 synchronizedMap(Map  map)</strong></p></li></ol><h1 id="二、泛型"><a href="#二、泛型" class="headerlink" title="二、泛型"></a>二、泛型</h1><h3 id="2-1为什么要有泛型"><a href="#2-1为什么要有泛型" class="headerlink" title="2.1为什么要有泛型"></a>2.1为什么要有泛型</h3><p><strong>1.生活中例子</strong></p><p>举例：     泛型：标签</p><ol><li>中药店，每个抽屉外面贴着标签</li><li>超市购物架上很多瓶子，每个瓶子装的是什么，有标签</li></ol><p><strong>2.泛型的理解</strong></p><ol><li>把元素的类型设计成一个参数，这个<strong>类型参数</strong>叫做<strong>泛型</strong></li><li>所谓泛型，就是允许<strong>在定义类、接口时通过一个标识</strong>表示类中某个<strong>属性的类型</strong>或者是某个<strong>方法的返回值</strong>及<strong>参数类型</strong>。</li><li>这个类型参数将在使用时（例如，继<strong>承或实现这个接口，用这个类型声明变量、创建对象</strong>时）确定（即传入实际的类型参数，也称为类型实参）。</li></ol><p><strong>3.那么为什么要有泛型呢，直接Object不是也可以存储数据吗？</strong></p><ol><li>解决元素存储的安全性问题，好比商品、药品标签，不会弄错。</li><li>解决获取数据元素时，需要类型强制转换的问题，好比不用每回拿商品、药品都要辨别。</li><li>Java泛型可以保证如果程序在编译时没有发出警告，运行时就不会产生ClassCastException异常。同时，代码更加简洁、健壮。</li><li>由于数据类型的不确定性，因此使用泛型，提高代码的复用性</li></ol><h3 id="2-2集合中使用泛型"><a href="#2-2集合中使用泛型" class="headerlink" title="2.2集合中使用泛型"></a>2.2集合中使用泛型</h3><p>泛型的使用：jdk 5.0新增的特性</p><ol><li><p>在集合没有泛型之前出现的问题：</p><ul><li>问题一：添加数据时，有统一类型的需要，类型可以不一致的集合成为缺点</li><li>问题二：需要强转时，可能会出现类型转换异常ClassCastException</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ArrayList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        <span class="comment">//需求：存放学生的成绩</span></span><br><span class="line">        list.add(<span class="number">78</span>);</span><br><span class="line">        list.add(<span class="number">76</span>);</span><br><span class="line">        list.add(<span class="number">89</span>);</span><br><span class="line">        list.add(<span class="number">88</span>);</span><br><span class="line">        <span class="comment">//问题一：类型不安全</span></span><br><span class="line"><span class="comment">//        list.add(&quot;Tom&quot;);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(Object score : list)&#123;</span><br><span class="line">            <span class="comment">//问题二：强转时，可能出现ClassCastException</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">stuScore</span> <span class="operator">=</span> (Integer) score;</span><br><span class="line"></span><br><span class="line">            System.out.println(stuScore);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li><li><p>使用泛型后，会将这些问题解决。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> ArrayList&lt;Integer&gt; list =  <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">        list.add(<span class="number">78</span>);</span><br><span class="line">        list.add(<span class="number">87</span>);</span><br><span class="line">        list.add(<span class="number">99</span>);</span><br><span class="line">        list.add(<span class="number">65</span>);</span><br><span class="line">        <span class="comment">//编译时，就会进行类型检查，保证数据的安全</span></span><br><span class="line"><span class="comment">//        list.add(&quot;Tom&quot;);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//方式一：直接声明为Integer</span></span><br><span class="line">        <span class="keyword">for</span>(Integer score : list)&#123;</span><br><span class="line">            <span class="comment">//避免了强转操作</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">stuScore</span> <span class="operator">=</span> score;</span><br><span class="line"></span><br><span class="line">            System.out.println(stuScore);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//方式二：Iterator也是声明泛型接口</span></span><br><span class="line">        Iterator&lt;Integer&gt; iterator = list.iterator();</span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">stuScore</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">            System.out.println(stuScore);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>集合接口或集合类在jdk5.0时都修改为带泛型的结构。</p></li><li><p>在实例化集合类时，可以指明具体的泛型类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; list =  <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br></pre></td></tr></table></figure></li><li><p>如有声明多个泛型，则用逗号隔开。以Map接口中key - value为例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String,Integer&gt;();</span><br></pre></td></tr></table></figure></li><li><p>泛型可嵌套—遍历操作</p><p>有泛型的遍历操作：entrySet()返回所有key-value对构成的Set集合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Map.Entry&lt;String,Integer&gt;&gt; entry = map.entrySet();</span><br><span class="line">Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; iterator = entry.iterator();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">    Map.Entry&lt;String, Integer&gt; e = iterator.next();</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> e.getKey();</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">value</span> <span class="operator">=</span> e.getValue();</span><br><span class="line">    System.out.println(key + <span class="string">&quot;----&quot;</span> + value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>指明完以后，在集合类或接口中凡是定义类或接口时，内部结构（比如：方法、构造器、属性等）使用到类的泛型的位置，都指定为实例化的泛型类型。</p><p>比如：内部结构：add(E e)  —&gt;实例化以后：使用时：add(Integer e)</p></li><li><p><strong>注意点：泛型的类型必须是类，不能是基本数据类型。</strong>需要用到基本数据类型的位置，拿包装类替换</p></li><li><p>如果实例化时，没有指明泛型的类型。默认类型为java.lang.Object类型。</p></li></ol><h3 id="2-3自定义泛型结构"><a href="#2-3自定义泛型结构" class="headerlink" title="2.3自定义泛型结构"></a>2.3自定义泛型结构</h3><p>可自定义泛型类、泛型接口、泛型方法</p><h4 id="1-自定义泛型类注意点"><a href="#1-自定义泛型类注意点" class="headerlink" title="1.自定义泛型类注意点"></a>1.自定义泛型类注意点</h4><ol><li><p>泛型类可能有多个参数，此时应将多个参数一起放在尖括号内。比如：&lt;E1,E2,E3&gt;</p></li><li><p>泛型类的声明构造器时不需要加<E>声明</E></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">GenericClass</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//错误的：public GenericClass&lt;E&gt;()&#123;&#125;</span></span><br></pre></td></tr></table></figure><p>形参中是可以用的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">T info ;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(T info)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.info = info; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>实例化后，操作原来泛型位置的结构必须与指定的泛型类型一致。</strong></p></li><li><p><strong>泛型不同的引用不能相互赋值。</strong>尽管在编译时ArrayList<String>和ArrayList<Integer>是两种类型，但是，在运行时只有一个ArrayList被加载到JVM中。</Integer></String></p></li><li><p><strong>泛型如果不指定，将被擦除，泛型对应的类型均按照Object处理，但不等价于Object。</strong></p><p>经验：泛型要使用一路都用。要不用，一路都不要用。</p></li><li><p>如果泛型结构是一个接口或抽象类，则不可创建泛型类的对象。</p><p>本质是接口和抽象类不能实例化，但是能做声明时使用–多态性</p></li><li><p>jdk1.7，泛型的简化操作：ArrayList<Fruit> flist &#x3D; new ArrayList&lt;&gt;();</Fruit></p></li><li><p>泛型的指定中不能使用基本数据类型，可以使用包装类替换。</p></li><li><p><strong>在类&#x2F;接口上声明的泛型，在本类或本接口中即代表某种类型，可以作为非静态属性的类型、非静态方法的参数类型、非静态方法的返回值类型。</strong></p><p>但在<strong>静态方法中不能使用类的泛型</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(T orderT)</span>&#123;  <span class="comment">//编译不通过</span></span><br><span class="line"><span class="comment">//        System.out.println(orderT);</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>异常类不能是泛型的</strong></p><p>错误的：try{ } catch(T e){ }</p></li><li><p><strong>不能直接使用new E[]。</strong></p><p>但是可以：E[] elements &#x3D; (E[])new Object[capacity];</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编译不通过</span></span><br><span class="line">T[] arr = <span class="keyword">new</span> <span class="title class_">T</span>[<span class="number">10</span>];</span><br><span class="line"><span class="comment">//编译通过</span></span><br><span class="line">T[] arr = (T[]) <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">10</span>];</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>参考：ArrayList源码中声明：Object[] elementData，而非泛型参数类型数组。</p></li><li><p><strong>父类有泛型，子类可以选择保留泛型也可以选择指定泛型类型：</strong></p><p>1.子类不保留父类的泛型：按需实现</p><ol><li><p>没有类型 擦除</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span>  <span class="keyword">extends</span> <span class="title class_">Father</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等价于class Son extends Father&lt;Object,Object&gt;&#123;    &#125;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span>&lt;T&gt;  <span class="keyword">extends</span> <span class="title class_">Father</span>&#123;  <span class="comment">//自已定义自己用</span></span><br></pre></td></tr></table></figure></li><li><p>具体类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Son2</span> <span class="keyword">extends</span> <span class="title class_">Father</span>&lt;Integer, String&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son2</span>&lt;A, B&gt; <span class="keyword">extends</span> <span class="title class_">Father</span>&lt;Integer, String&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;   <span class="comment">//自已定义自己用</span></span><br></pre></td></tr></table></figure></li></ol><p>2.子类保留父类的泛型：泛型子类</p><ol><li><p>全部保留</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Son3</span>&lt;T1, T2&gt; <span class="keyword">extends</span> <span class="title class_">Father</span>&lt;T1, T2&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son3</span>&lt;T1, T2, A, B&gt; <span class="keyword">extends</span> <span class="title class_">Father</span>&lt;T1, T2&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;   <span class="comment">//自已定义多余的自己用</span></span><br></pre></td></tr></table></figure></li><li><p>部分保留</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Son4</span>&lt;T2&gt; <span class="keyword">extends</span> <span class="title class_">Father</span>&lt;Integer, T2&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son4</span>&lt;T2, A, B&gt; <span class="keyword">extends</span> <span class="title class_">Father</span>&lt;Integer, T2&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;    <span class="comment">//自已定义多余的自己用</span></span><br></pre></td></tr></table></figure></li></ol><p>结论：子类必须是“富二代”，子类除了指定或保留父类的泛型，还可以增加自己的泛型。</p><p><strong>使用细节：父类有泛型时</strong></p><ol><li><p><strong>子类不保留的泛型，则在继承时父类一定要指明泛型类型，父类中用该泛型声明的变量也就确定了，进而子类继承的是指明后的父类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Son4</span> <span class="keyword">extends</span> <span class="title class_">Father</span>&lt; String&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure></li><li><p><strong>子类保留的泛型，则在继承时只需写出泛型形式<T></T></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Son4</span>&lt;T2&gt; <span class="keyword">extends</span> <span class="title class_">Father</span>&lt; T2&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;     </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son4</span>&lt;T2&gt; <span class="keyword">extends</span> <span class="title class_">Father</span>&lt;Integer, T2&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li></ol></li></ol><h4 id="2-自定义泛型方法"><a href="#2-自定义泛型方法" class="headerlink" title="2.自定义泛型方法"></a>2.自定义泛型方法</h4><p>如下的方法都不是泛型方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">getOrderT</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> orderT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setOrderT</span><span class="params">(T orderT)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.orderT = orderT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>泛型方法：</p><ol><li><p>在方法中出现了泛型的结构，泛型参数与类的泛型参数没有任何关系。</p><p>换句话说，<strong>泛型方法所属的类是不是泛型类都没有关系。</strong></p></li><li><p>泛型方法，<strong>可以声明为静态的。</strong></p><p>原因：泛型参数是在调用方法时确定的。并非在实例化类时确定。</p><ul><li>自定义泛型类中，泛型声明在类的声明中，可提供给属性，非静态方法使用，在new本类对象时指明就不会出错</li><li>自定义泛型类中，泛型方法声明在方法声明中，泛型方法所属的类是不是泛型类都没有关系，所以<strong>泛型方法可以是静态的也可以是非静态的</strong>，泛型参数是在调用方法时确定的。并非在实例化类时确定。</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//格式如下：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt;  List&lt;E&gt; <span class="title function_">copyFromArrayToList</span><span class="params">(E[] arr)</span>&#123; </span><br><span class="line"></span><br><span class="line">    ArrayList&lt;E&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(E e : arr)&#123;</span><br><span class="line">        list.add(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4泛型在继承方面的体现"><a href="#2-4泛型在继承方面的体现" class="headerlink" title="2.4泛型在继承方面的体现"></a>2.4泛型在继承方面的体现</h3><ol><li><p>虽然类A是类B的父类，但是G<A> 和G<B>二者不具备子父类关系，二者是并列关系。</B></A></p></li><li><p>面向对象–具有子父类关系的可以相互赋值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">   <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">   obj = str;</span><br><span class="line">   </span><br><span class="line">   Object[] arr1 = <span class="literal">null</span>;</span><br><span class="line">   String[] arr2 = <span class="literal">null</span>;</span><br><span class="line">   arr1 = arr2; </span><br></pre></td></tr></table></figure><p>以下使用情况–二者是并列关系。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Object&gt; list1 = <span class="literal">null</span>;</span><br><span class="line">List&lt;String&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line"><span class="comment">//此时的list1和list2的类型不具有子父类关系</span></span><br><span class="line"><span class="comment">//编译不通过</span></span><br><span class="line"><span class="comment">//    list1 = list2;</span></span><br></pre></td></tr></table></figure></li><li><p>补充：类A是类B的父类，A<G> 是 B<G> 的父类</G></G></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list2 = <span class="literal">null</span>;</span><br><span class="line">ArrayList&lt;String&gt; list3 = <span class="literal">null</span>;</span><br><span class="line">   list2 = list3;</span><br></pre></td></tr></table></figure></li></ol><h3 id="2-5通配符的使用"><a href="#2-5通配符的使用" class="headerlink" title="2.5通配符的使用"></a>2.5通配符的使用</h3><p>1.出现背景</p><p>由于泛型不体现多态性，在调用方法方法形参和实参只能一对一，因此引入通配符，多个不同泛型对象可以使用一个通配符，这样就这可实现一个方法对多个对象了</p><p>2.说明</p><p>  通配符：?</p><p>  类A是类B的父类，G<A>和G<B>是没有关系的，二者共同的父类是：G&lt;?&gt;</B></A></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    List&lt;Object&gt; list1 = <span class="literal">null</span>;</span><br><span class="line">    List&lt;String&gt; list2 = <span class="literal">null</span>;</span><br><span class="line">    List&lt;?&gt; list = <span class="literal">null</span>;</span><br><span class="line">    list = list1;</span><br><span class="line">    list = list2;</span><br><span class="line">    <span class="comment">//编译通过</span></span><br><span class="line"><span class="comment">//    print(list1);</span></span><br><span class="line"><span class="comment">//    print(list2);</span></span><br><span class="line"><span class="comment">//此print方法声明：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(List&lt;?&gt; list)</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​     </p><p>3.使用通配符声明后的操作说明</p><ol><li><p><strong>添加(写入)：对于List&lt;?&gt;就不能向其内部添加数据。</strong></p><p>除了添加null之外。</p><p>list.add(“DD”);</p><p>list.add(‘?’);</p><p>list.add(null);</p></li><li><p><strong>获取(读取)：允许读取数据，读取的数据类型为Object</strong>。<br>Object o &#x3D; list.get(0);<br>System.out.println(o);</p></li></ol><p>4.有限制条件的通配符的使用</p><ol><li><p>? extends A:      理解：? &lt;&#x3D;  A  小于等于</p><p>G&lt;? extends A&gt; 可以作为G<A>和G<B>的父类，其中B是A的子类</B></A></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;? <span class="keyword">extends</span> <span class="title class_">Person</span>&gt; list1 = <span class="literal">null</span>;</span><br><span class="line">List&lt;Student&gt; list3 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Student&gt;();</span><br><span class="line">List&lt;Person&gt; list4 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Person&gt;();</span><br><span class="line">List&lt;Object&gt; list5 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Object&gt;();</span><br><span class="line">list1 = list3;</span><br><span class="line">list1 = list4</span><br></pre></td></tr></table></figure></li><li><p>? super A:         理解：? &gt;&#x3D;  A  大于等于</p><p>G&lt;? super A&gt; 可以作为G<A>和G<B>的父类，其中B是A的父类</B></A></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;? <span class="built_in">super</span> Person&gt; list2 = <span class="literal">null</span>;</span><br><span class="line">list2 = list4;</span><br><span class="line">list2 = list5;</span><br></pre></td></tr></table></figure></li><li><p>有限制条件通配符读取和写入数据 </p><p>读取数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> List&lt;? <span class="keyword">extends</span> <span class="title class_">Person</span>&gt; list1 = <span class="literal">null</span>;</span><br><span class="line"> List&lt;? <span class="built_in">super</span> Person&gt; list2 = <span class="literal">null</span>;</span><br><span class="line"> List&lt;Student&gt; list3 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Student&gt;();</span><br><span class="line"> List&lt;Person&gt; list4 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Person&gt;();</span><br><span class="line"> List&lt;Object&gt; list5 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Object&gt;();</span><br><span class="line"> list1 = list3;</span><br><span class="line"> <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> list1.get(<span class="number">0</span>);</span><br><span class="line"> <span class="comment">//编译不通过:返回值小于等于Person，因此用Person接收</span></span><br><span class="line">    <span class="comment">//Student s = list1.get(0);</span></span><br><span class="line">    list2 = list4;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> list2.get(<span class="number">0</span>);</span><br><span class="line">`</span><br><span class="line">    <span class="comment">//编译不通过：返回值大于等于Person，因此用Object接收</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">//Person obj = list2.get(0);</span></span><br></pre></td></tr></table></figure><p>写入数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编译不通过：list1不能写入数据，由于父类不能赋给子类，而？ extend A 小于等于A 所以当？是Student的子类不能赋Student</span></span><br><span class="line"><span class="comment">//  list1.add(new Student());</span></span><br><span class="line"><span class="comment">//编译通过：list2都可以写，由于大于等于，所以？是Person或Person的父类，所以可以赋Person和Person的子类</span></span><br><span class="line"> list2.add(<span class="keyword">new</span> <span class="title class_">Person</span>());</span><br><span class="line"> list2.add(<span class="keyword">new</span> <span class="title class_">Student</span>());</span><br></pre></td></tr></table></figure></li></ol><h2 id="三、IO流"><a href="#三、IO流" class="headerlink" title="三、IO流"></a>三、IO流</h2><h3 id="3-1File类的使用"><a href="#3-1File类的使用" class="headerlink" title="3.1File类的使用"></a>3.1File类的使用</h3><h4 id="1-介绍-1"><a href="#1-介绍-1" class="headerlink" title="1.介绍"></a>1.介绍</h4><ol><li>File类的一个对象，代表一个文件或一个文件目录(俗称：文件夹)</li><li>File类声明在java.io包下</li><li>File类中涉及到关于文件或文件目录的创建、删除、重命名、修改时间、文件大小等方法，并未涉及到写入或读取文件内容的操作。如果需要读取或写入文件内容，必须使用IO流来完成。后续File类的对象常会作为参数传递到流的构造器中，指明读取或写入的”终点”.</li></ol><h4 id="2-构造器介绍"><a href="#2-构造器介绍" class="headerlink" title="2.构造器介绍"></a>2.构造器介绍</h4><p><strong>1.两种路径说明</strong></p><ol><li><p>相对路径：相较于某个路径下，指明的路径。</p><p>File file1 &#x3D; new File(“hello.txt”);</p></li><li><p>绝对路径：包含盘符在内的文件或文件目录的路径</p><p>File file2 &#x3D;  new File(“D:\workspace_idea1\JavaSenior\day08\he.txt”);</p></li></ol><p>相对路径说明：</p><p>IDEA中：开发中使用JUnit单元测试方法测试，相对路径即为当前Module下。如果使用main( ) 测试，相对路径即为当前的Project下。</p><p>Eclipse中：不管使用单元测试还是使用main( ) 测试，相对路径都是当前的Project</p><p><strong>2.路径分隔符</strong><br> windows: \ <br> unix: &#x2F;</p><p> <strong>3.如何创建File类的实例</strong></p><ol><li><p>File(String filePath)—构造器1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">file1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;hello.txt&quot;</span>);<span class="comment">//相对于当前module</span></span><br><span class="line"><span class="type">File</span> <span class="variable">file2</span> <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\workspace_idea1\\JavaSenior\\day08\\he.txt&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>File(String parentPath,String childPath)—构造器2</p><p>File file3 &#x3D; new File(“D:\workspace_idea1”,”JavaSenior”);</p></li><li><p>File(File parentFile,String childPath)—构造器3</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">File file4 = new File(file3,&quot;hi.txt&quot;);</span><br><span class="line">   </span><br></pre></td></tr></table></figure></li></ol><h4 id="3-File中的常用方法"><a href="#3-File中的常用方法" class="headerlink" title="3.File中的常用方法"></a>3.File中的常用方法</h4><p><strong>1.获取File基本信息</strong></p><ol><li><p>public String getAbsolutePath()</p><p>获取绝对路径</p></li><li><p>public String getPath() </p><p>获取路径</p></li><li><p>public String getName() </p><p>获取名称</p></li><li><p>public String getParent()</p><p>获取上层文件目录路径。若无，返回null</p></li><li><p>public long length() </p><p>获取文件长度（即：字节数）。不能获取目录的长度。</p></li><li><p>public long lastModified() </p><p>获取最后一次的修改时间，毫秒值–可用Date接收显示</p></li></ol><p><strong>2.获取文件目录</strong></p><ol><li>public String[] list() ：获取指定目录下的所有文件或者文件目录的名称数组</li><li>public File[] listFiles() ：获取指定目录下的所有文件或者文件目录的File数组</li></ol><p><strong>3.重命名文件路径</strong></p><p> public boolean renameTo(File dest):把文件重命名为指定的文件路径</p><p>比如：file1.renameTo(file2)为例：要想保证返回true,需要file1在硬盘中是存在的，且file2不能在硬盘中存在。</p><p><strong>4.判断File基本信息</strong></p><ol><li>public boolean isDirectory()：判断是否是文件目录</li><li>public boolean isFile() ：判断是否是文件</li><li>public boolean exists() ：判断是否存在</li><li>public boolean canRead() ：判断是否可读</li><li>public boolean canWrite() ：判断是否可写</li><li>public boolean isHidden() ：判断是否隐藏</li></ol><p><strong>5.创建硬盘中对应的文件或文件目录</strong></p><ol><li><p>public  boolean createNewFile() —会报异常</p><p>创建文件。若文件存在，则不创建，返回false</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">file1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;hi.txt&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(!file1.exists())&#123;</span><br><span class="line">     <span class="comment">//文件的创建</span></span><br><span class="line">     file1.createNewFile();</span><br><span class="line">     System.out.println(<span class="string">&quot;创建成功&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>public boolean mkdir() </p><p>创建文件目录。如果此文件目录存在，就不创建了。<strong>如果此文件目录的上层目录不存在，也不创建。</strong></p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//文件目录的创建</span></span><br><span class="line"><span class="type">File</span> <span class="variable">file1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:\\io\\io1\\io3&quot;</span>);</span><br><span class="line"> <span class="type">boolean</span> <span class="variable">mkdir</span> <span class="operator">=</span> file1.mkdir();</span><br><span class="line">  <span class="keyword">if</span>(mkdir)&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;创建成功1&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li><p>public boolean mkdirs() </p><p>创建文件目录。如果此文件目录存在，就不创建了。<strong>如果上层文件目录不存在，一并创建</strong></p></li></ol><p><strong>6.删除磁盘中的文件或文件目录</strong></p><p>public boolean delete()：删除文件或者文件夹</p><p>删除注意事项：</p><ol><li>Java中的删除不走回收站。</li><li>删除目录：只能删除空目录，该目录下不能有子目录或文件</li></ol><h3 id="3-2-IO原理及流的分类"><a href="#3-2-IO原理及流的分类" class="headerlink" title="3.2 IO原理及流的分类"></a>3.2 IO原理及流的分类</h3><h4 id="1-IO原理介绍"><a href="#1-IO原理介绍" class="headerlink" title="1.IO原理介绍"></a>1.IO原理介绍</h4><ol><li>I&#x2F;O是Input&#x2F;Output的缩写， I&#x2F;O技术是非常实用的技术，<strong>用于处理设备之间的数据传输</strong>。如读&#x2F;写文件，网络通讯等。</li><li>Java程序中，对于数据的输入&#x2F;输出操作以“流(stream)” 的方式进行。</li><li>java.io包下提供了各种“流”类和接口，用以获取不同种类的数据，并<strong>通过标准的方法</strong>输入或输出数据</li><li>输入（读入）input：<strong>读取外部数据</strong>（磁盘、光盘等存储设备的数据）<strong>到程序（内存）中</strong>。</li><li>输出（写出）output：<strong>将程序（内存）数据输出到磁盘、光盘等存储设备</strong>中</li></ol><h4 id="2-流的分类"><a href="#2-流的分类" class="headerlink" title="2.流的分类"></a>2.流的分类</h4><p><strong>1.流的分类</strong></p><ol><li><p>按操作<strong>数据单位</strong>不同分为：字节流(8 bit)，字符流(16 bit)</p><p>字节流：是操作进制数表示的数据（如：图片）</p><p>字符流：是来操作字符数据（如：文件）</p></li><li><p>按数据流的<strong>流向</strong>不同分为：输入流，输出流</p></li><li><p>按流的<strong>角色</strong>的不同分为：节点流，处理流</p><p>节点流：直接操作流的传输</p><p>处理流：对流的传输加以修饰（如：加速传输）</p></li></ol><p><strong>图示：在操作中的位置</strong></p><p><img src="/2022/10/04/Java%E9%AB%98%E7%BA%A7-%E9%9B%86%E5%90%88-%E6%B3%9B%E5%9E%8B-IO%E6%B5%81/Snipaste_2022-02-06_20-59-41.png" alt="Snipaste_2022-02-06_20-59-41"></p><p><strong>字节流和字符流使用结论：</strong></p><ol><li>对于文本文件(.txt,.java,.c,.cpp)，使用字符流处理</li><li>对于非文本文件(.jpg,.mp3,.mp4,.avi,.doc,.ppt,…)，使用字节流处理</li><li><strong>如果只是单纯的复制文本文件，字节流也可处理，只不过用字符流更高效</strong></li></ol><p><strong>2.流的体系结构</strong></p><p>一、Java的IO流共涉及40多个类，实际上非常规则，<strong>都是从如下4个抽象基类派生的。</strong></p><table><thead><tr><th>抽象基类</th><th>字节流</th><th>字符流</th></tr></thead><tbody><tr><td>输入流</td><td>InputStream</td><td>Reader</td></tr><tr><td>输出流</td><td>OutputStream</td><td>Writer</td></tr></tbody></table><p>二、由这四个类派生出来的子类名称都是以其父类名作为子类名后缀</p><p><img src="/2022/10/04/Java%E9%AB%98%E7%BA%A7-%E9%9B%86%E5%90%88-%E6%B3%9B%E5%9E%8B-IO%E6%B5%81/Snipaste_2022-02-07_21-34-55.png" alt="Snipaste_2022-02-07_21-34-55"></p><p>三、列举最基本的流</p><p>抽象基类</p><ol><li>InputStream</li><li>OutputStream</li><li>Reader</li><li>Writer</li></ol><p>节点流（或文件流） –后加使用时对应的读写方法</p><ol><li>FileInputStream  (read(byte[] buffer))</li><li>FileOutputStream    (write(byte[] buffer,0,len)</li><li>FileReader    (read(char[] cbuf))</li><li>FileWriter    (write(char[] cbuf,0,len)</li></ol><p>缓冲流（处理流的一种）–后加使用时对应的读写方法</p><ol><li>BufferedInputStream    (read(byte[] buffer))</li><li>BufferedOutputStream    (write(byte[] buffer,0,len) &#x2F; flush()</li><li>BufferedReader    (read(char[] cbuf) &#x2F; readLine())</li><li>BufferedWriter    (write(char[] cbuf,0,len) &#x2F; flush()</li></ol><h3 id="3-3节点流-或文件流"><a href="#3-3节点流-或文件流" class="headerlink" title="3.3节点流(或文件流)"></a>3.3节点流(或文件流)</h3><h4 id="1-共有四种节点流"><a href="#1-共有四种节点流" class="headerlink" title="1.共有四种节点流"></a>1.共有四种节点流</h4><ol><li><p>字节流读入写出</p><p>FileInputStream  ： (read(byte[] buffer))          </p><p>FileOutputStream  ：(write(byte[] buffer,0,len)  </p></li><li><p>字符流读入写出</p><p>FileReader ：(read(char[] cbuf))                 </p><p>FileWriter： (write(char[] cbuf,0,len))</p></li></ol><h4 id="2-字符流读写演示"><a href="#2-字符流读写演示" class="headerlink" title="2.字符流读写演示"></a>2.字符流读写演示</h4><p>读写方法：</p><ol><li>read()返回Ascll码值，没有返回-1&#x2F;writer(String str)</li><li>read(char[] cbuf)&#x2F;write(char[] cbuf,0,len) – 常用这个</li></ol><p><strong>1.FileReader</strong></p><p><strong>说明点：</strong></p><ol><li>read()的理解：返回读入的一个字符。如果达到文件末尾，返回-1</li><li>异常的处理：为了保证流资源一定可以执行关闭操作。需要使用try-catch-finally处理</li><li>读入的文件一定要存在，否则就会报FileNotFoundException。</li></ol><p>代码及步骤演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">一般不使用read（）空参方法，而是使用带参重载的</span><br><span class="line"></span><br><span class="line"><span class="comment">//将day09下的hello.txt文件内容读入程序中，并输出到控制台</span></span><br><span class="line"><span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.实例化File类的对象，指明要操作的文件</span></span><br><span class="line">            <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;hello.txt&quot;</span>);<span class="comment">//相较于当前Module</span></span><br><span class="line">            <span class="comment">//2.提供具体的流</span></span><br><span class="line">            fr = <span class="keyword">new</span> <span class="title class_">FileReader</span>(file);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//3.数据的读入</span></span><br><span class="line">            <span class="comment">//read():返回读入的一个字符。如果达到文件末尾，返回-1   </span></span><br><span class="line">            <span class="type">int</span> data;</span><br><span class="line">            <span class="keyword">while</span>((data = fr.read()) != -<span class="number">1</span>)&#123;</span><br><span class="line">                System.out.print((<span class="type">char</span>)data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//4.流的关闭操作</span></span><br><span class="line">            <span class="keyword">if</span>(fr != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fr.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>由于上述对操作每次只读一个字符速度过慢，可使用read()操作升级：使用read的重载方法read(char[] cbuf)读入字符数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"> 对read()操作升级：使用read的重载方法</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFileReader1</span><span class="params">()</span>  &#123;</span><br><span class="line">        <span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.File类的实例化</span></span><br><span class="line">            <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//2.FileReader流的实例化</span></span><br><span class="line">            fr = <span class="keyword">new</span> <span class="title class_">FileReader</span>(file);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//3.读入的操作</span></span><br><span class="line">            <span class="comment">//read(char[] cbuf):返回每次读入cbuf数组中的字符的个数。如果达到文件末尾，返回-1</span></span><br><span class="line"> 由于最后读入的数据可能不超过<span class="number">5</span>，防止最后输出之前输出过的数据，所以用len记录个数便于输出</span><br><span class="line">            <span class="type">char</span>[] cbuf = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">5</span>];</span><br><span class="line">            <span class="type">int</span> len;</span><br><span class="line">            <span class="keyword">while</span>((len = fr.read(cbuf)) != -<span class="number">1</span>)&#123;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//正确的写法--for循环</span></span><br><span class="line"><span class="comment">//                for(int i = 0;i &lt; len;i++)&#123;</span></span><br><span class="line"><span class="comment">//                    System.out.print(cbuf[i]);</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line">   </span><br><span class="line">                <span class="comment">//正确的写法--使用String给的构造器</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(cbuf,<span class="number">0</span>,len);</span><br><span class="line">                System.out.print(str);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(fr != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="comment">//4.资源的关闭</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fr.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>2.FileWriter</strong></p><p><strong>说明：</strong></p><ol><li>输出操作，对应的File可以不存在的。并不会报异常</li><li>File对应的硬盘中的文件如果不存在，在输出的过程中，会自动创建此文件。</li><li>File对应的硬盘中的文件如果存在：<ol><li>如果流使用的构造器是：FileWriter(file,false) &#x2F; FileWriter(file):对原有文件的覆盖</li><li>如果流使用的构造器是：FileWriter(file,true):不会对原有文件覆盖，而是在原有文件基础上追加内容</li></ol></li></ol><p>代码演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从内存中写出数据到硬盘的文件里。</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFileWriter</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//1.提供File类的对象，指明写出到的文件</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;hello1.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.提供FileWriter的对象，用于数据的写出</span></span><br><span class="line">        fw = <span class="keyword">new</span> <span class="title class_">FileWriter</span>(file,<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.写出的操作</span></span><br><span class="line">        fw.write(<span class="string">&quot;I have a dream!\n&quot;</span>);</span><br><span class="line">        fw.write(<span class="string">&quot;you need to have a dream!&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//4.流资源的关闭</span></span><br><span class="line">        <span class="keyword">if</span>(fw != <span class="literal">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fw.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>3.复制文本数据操作</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFileReaderFileWriter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.创建File类的对象，指明读入和写出的文件</span></span><br><span class="line">            <span class="type">File</span> <span class="variable">srcFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line">            <span class="type">File</span> <span class="variable">destFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;hello2.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//不能使用字符流来处理图片等字节数据</span></span><br><span class="line"><span class="comment">//            File srcFile = new File(&quot;爱情与友情.jpg&quot;);</span></span><br><span class="line"><span class="comment">//            File destFile = new File(&quot;爱情与友情1.jpg&quot;);</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//2.创建输入流和输出流的对象</span></span><br><span class="line">            fr = <span class="keyword">new</span> <span class="title class_">FileReader</span>(srcFile);</span><br><span class="line">            fw = <span class="keyword">new</span> <span class="title class_">FileWriter</span>(destFile);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//3.数据的读入和写出操作</span></span><br><span class="line">            <span class="type">char</span>[] cbuf = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">5</span>];</span><br><span class="line">            <span class="type">int</span> len;<span class="comment">//记录每次读入到cbuf数组中的字符的个数</span></span><br><span class="line">            <span class="keyword">while</span>((len = fr.read(cbuf)) != -<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">//每次写出len个字符</span></span><br><span class="line">                fw.write(cbuf,<span class="number">0</span>,len);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//4.关闭流资源</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(fw != <span class="literal">null</span>)</span><br><span class="line">                    fw.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(fr != <span class="literal">null</span>)</span><br><span class="line">                    fr.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="3-字节流读入演示"><a href="#3-字节流读入演示" class="headerlink" title="3.字节流读入演示"></a>3.字节流读入演示</h4><p>读写方法：</p><p>read(byte[] buffer)   和  write(byte[] buffer,0,len)</p><h5 id="1-FileInputStream"><a href="#1-FileInputStream" class="headerlink" title="1.FileInputStream"></a>1.FileInputStream</h5><p> FileOutputStream操作在复制图片演示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用字节流FileInputStream处理文本文件，可能出现乱码。</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFileInputStream</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//1. 造文件</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.造流</span></span><br><span class="line">        fis = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.读数据</span></span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">5</span>];</span><br><span class="line">        <span class="type">int</span> len;<span class="comment">//记录每次读取的字节的个数</span></span><br><span class="line">        <span class="keyword">while</span>((len = fis.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(buffer,<span class="number">0</span>,len);</span><br><span class="line">            System.out.print(str);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(fis != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//4.关闭资源</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fis.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="2-复制图片数据"><a href="#2-复制图片数据" class="headerlink" title="2.复制图片数据"></a>2.复制图片数据</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFileInputOutputStream</span><span class="params">()</span>  &#123;</span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">srcFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;爱情与友情.jpg&quot;</span>);</span><br><span class="line">        <span class="type">File</span> <span class="variable">destFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;爱情与友情2.jpg&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        fis = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(srcFile);</span><br><span class="line">        fos = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(destFile);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//复制的过程</span></span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">5</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span>((len = fis.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            fos.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(fos != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(fis != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fis.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-4缓冲流-处理流之一"><a href="#3-4缓冲流-处理流之一" class="headerlink" title="3.4缓冲流(处理流之一)"></a>3.4缓冲流(处理流之一)</h3><h4 id="1-共有四种缓冲流"><a href="#1-共有四种缓冲流" class="headerlink" title="1.共有四种缓冲流"></a>1.共有四种缓冲流</h4><p>1.缓冲流（处理流的一种）–后加使用时对应的读写方法</p><ol><li>BufferedInputStream    (read(byte[] buffer))</li><li>BufferedOutputStream    (write(byte[] buffer,0,len) &#x2F; flush()</li><li>BufferedReader    (read(char[] cbuf) &#x2F; readLine())</li><li>BufferedWriter    (write(char[] cbuf,0,len) &#x2F; flush()</li></ol><p>flush() : 刷新缓冲区 —writer内部方法已经调用为加速写出，这里只作了解</p><p>readLine() : 读入一行文本数据，但不自动换行，以下是换行方法</p><ol><li>readLine(流 + “\n”)</li><li>在使用后调用一次newLine()</li></ol><p>2.作用：提供流的读取、写入的速度</p><p>提高读写速度的原因：内部提供了一个缓冲区</p><p>3.处理流，就是“套接”在已有的流的基础上。</p><h4 id="2-复制非文本文件"><a href="#2-复制非文本文件" class="headerlink" title="2.复制非文本文件"></a>2.复制非文本文件</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">实现非文本文件的复制 BufferedInputStream和BufferedOutputStream </span><br><span class="line">   </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">BufferedStreamTest</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        <span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.造文件</span></span><br><span class="line">            <span class="type">File</span> <span class="variable">srcFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;爱情与友情.jpg&quot;</span>);</span><br><span class="line">            <span class="type">File</span> <span class="variable">destFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;爱情与友情3.jpg&quot;</span>);</span><br><span class="line">            <span class="comment">//2.造流</span></span><br><span class="line">            <span class="comment">//2.1 造节点流</span></span><br><span class="line">      <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>((srcFile));</span><br><span class="line">      <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(destFile);</span><br><span class="line">            <span class="comment">//2.2 造缓冲流</span></span><br><span class="line">            bis = <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(fis);</span><br><span class="line">            bos = <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(fos);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//3.复制的细节：读取、写入</span></span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">10</span>];</span><br><span class="line">            <span class="type">int</span> len;</span><br><span class="line">            <span class="keyword">while</span>((len = bis.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">                bos.write(buffer,<span class="number">0</span>,len);</span><br><span class="line"><span class="comment">//                bos.flush();//刷新缓冲区--不需要调用</span></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//4.资源关闭</span></span><br><span class="line">            <span class="comment">//要求：先关闭外层的流，再关闭内层的流</span></span><br><span class="line">            <span class="keyword">if</span>(bos != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    bos.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(bis != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    bis.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//说明：关闭外层流的同时，内层流也会自动的进行关闭。关于内层流的关闭，我们可以省略.</span></span><br><span class="line"><span class="comment">//        fos.close();</span></span><br><span class="line"><span class="comment">//        fis.close();</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="3-复制文本文件"><a href="#3-复制文本文件" class="headerlink" title="3.复制文本文件"></a>3.复制文本文件</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    使用BufferedReader和BufferedWriter实现文本文件的复制</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testBufferedReaderBufferedWriter</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建文件和相应的流---匿名方式简单创建</span></span><br><span class="line">         br = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;dbcp.txt&quot;</span>)));</span><br><span class="line">         bw = <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;dbcp1.txt&quot;</span>)));</span><br><span class="line"></span><br><span class="line">            <span class="comment">//读写操作</span></span><br><span class="line">            <span class="comment">//方式一：使用char[]数组</span></span><br><span class="line"><span class="comment">//            char[] cbuf = new char[1024];</span></span><br><span class="line"><span class="comment">//            int len;</span></span><br><span class="line"><span class="comment">//            while((len = br.read(cbuf)) != -1)&#123;</span></span><br><span class="line"><span class="comment">//                bw.write(cbuf,0,len);</span></span><br><span class="line"><span class="comment">//    //            bw.flush();</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"> </span><br><span class="line">            <span class="comment">//方式二：使用String   readLine()</span></span><br><span class="line">            String data;</span><br><span class="line">            <span class="keyword">while</span>((data = br.readLine()) != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="comment">//方法一：</span></span><br><span class="line"><span class="comment">//                bw.write(data + &quot;\n&quot;);//data中不包含换行符</span></span><br><span class="line">                <span class="comment">//方法二：</span></span><br><span class="line">                bw.write(data);<span class="comment">//data中不包含换行符</span></span><br><span class="line">                bw.newLine();<span class="comment">//提供换行的操作</span></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//关闭资源</span></span><br><span class="line">            <span class="keyword">if</span>(bw != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    bw.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(br != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    br.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="4-复制视频及对比节点流和缓冲流速度"><a href="#4-复制视频及对比节点流和缓冲流速度" class="headerlink" title="4.复制视频及对比节点流和缓冲流速度"></a>4.复制视频及对比节点流和缓冲流速度</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">这里只列举了缓冲流复制视频，也有测试结果<span class="comment">//618 和 176</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">copyFileWithBuffered</span><span class="params">(String srcPath,String destPath)</span>&#123;</span><br><span class="line">        <span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.造文件</span></span><br><span class="line">            <span class="type">File</span> <span class="variable">srcFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(srcPath);</span><br><span class="line">            <span class="type">File</span> <span class="variable">destFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(destPath);</span><br><span class="line">            <span class="comment">//2.造流</span></span><br><span class="line">            <span class="comment">//2.1 造节点流</span></span><br><span class="line">            <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>((srcFile));</span><br><span class="line">            <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(destFile);</span><br><span class="line">            <span class="comment">//2.2 造缓冲流</span></span><br><span class="line">            bis = <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(fis);</span><br><span class="line">            bos = <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(fos);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//3.复制的细节：读取、写入</span></span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">int</span> len;</span><br><span class="line">            <span class="keyword">while</span>((len = bis.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">                bos.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//4.资源关闭</span></span><br><span class="line">            <span class="comment">//要求：先关闭外层的流，再关闭内层的流</span></span><br><span class="line">            <span class="keyword">if</span>(bos != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    bos.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(bis != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    bis.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testCopyFileWithBuffered</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">srcPath</span> <span class="operator">=</span> <span class="string">&quot;C:\\Users\\Administrator\\Desktop\\01-视频.avi&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">destPath</span> <span class="operator">=</span> <span class="string">&quot;C:\\Users\\Administrator\\Desktop\\03-视频.avi&quot;</span>;</span><br><span class="line"></span><br><span class="line">        copyFileWithBuffered(srcPath,destPath);</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;复制操作花费的时间为：&quot;</span> + (end - start));<span class="comment">//618 - 176</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="5-课后练习题之加密解密图片"><a href="#5-课后练习题之加密解密图片" class="headerlink" title="5.课后练习题之加密解密图片"></a>5.课后练习题之加密解密图片</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//图片的加密</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        fis = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;爱情与友情.jpg&quot;</span>);</span><br><span class="line">        fos = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;爱情与友情secret.jpg&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">20</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = fis.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">     <span class="comment">//主要代码：利用异或，同0不同1 有规律的改变字节       </span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">                buffer[i] = (<span class="type">byte</span>) (buffer[i] ^ <span class="number">5</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fos.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (fos != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (fis != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fis.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//图片的解密</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123; <span class="comment">//调换位置</span></span><br><span class="line">        fis = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;爱情与友情secret.jpg&quot;</span>);</span><br><span class="line">        fos = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;爱情与友情4.jpg&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">20</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = fis.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">         <span class="comment">//在用异或一次相同数，就可进行解密</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">                buffer[i] = (<span class="type">byte</span>) (buffer[i] ^ <span class="number">5</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fos.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (fos != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (fis != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fis.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="6-获取文本上字符出现的次数"><a href="#6-获取文本上字符出现的次数" class="headerlink" title="6.获取文本上字符出现的次数"></a>6.获取文本上字符出现的次数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">练习<span class="number">3</span>:获取文本上字符出现的次数,把数据写入文件</span><br><span class="line"> *</span><br><span class="line"> * 思路：</span><br><span class="line"> * <span class="number">1.</span>遍历文本每一个字符</span><br><span class="line"> * <span class="number">2.</span>字符出现的次数存在Map中</span><br><span class="line"> *</span><br><span class="line"> * Map&lt;Character,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Character,Integer&gt;();</span><br><span class="line"> * map.put(<span class="string">&#x27;a&#x27;</span>,<span class="number">18</span>);</span><br><span class="line"> * map.put(<span class="string">&#x27;你&#x27;</span>,<span class="number">2</span>);</span><br><span class="line"> *</span><br><span class="line"> * <span class="number">3.</span>把map中的数据写入文件</span><br><span class="line"> *</span><br><span class="line"> * <span class="meta">@author</span> shkstart</span><br><span class="line"> * <span class="meta">@create</span> <span class="number">2019</span> 下午 <span class="number">3</span>:<span class="number">47</span></span><br><span class="line"> */</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WordCount</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    说明：如果使用单元测试，文件相对路径为当前module</span></span><br><span class="line"><span class="comment">          如果使用main()测试，文件相对路径为当前工程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testWordCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.创建Map集合</span></span><br><span class="line">            Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Character, Integer&gt;();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//2.遍历每一个字符,每一个字符出现的次数放到map中</span></span><br><span class="line">            fr = <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;dbcp.txt&quot;</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((c = fr.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">//int 还原 char</span></span><br><span class="line">                <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> (<span class="type">char</span>) c;</span><br><span class="line">                <span class="comment">// 判断char是否在map中第一次出现</span></span><br><span class="line">                <span class="keyword">if</span> (map.get(ch) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    map.put(ch, <span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    map.put(ch, map.get(ch) + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//3.把map中数据存在文件count.txt</span></span><br><span class="line">            <span class="comment">//3.1 创建Writer</span></span><br><span class="line">            bw = <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;wordcount.txt&quot;</span>));</span><br><span class="line"></span><br><span class="line">            <span class="comment">//3.2 遍历map,再写入数据</span></span><br><span class="line">            Set&lt;Map.Entry&lt;Character, Integer&gt;&gt; entrySet = map.entrySet();</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;Character, Integer&gt; entry : entrySet) &#123;</span><br><span class="line">                <span class="keyword">switch</span> (entry.getKey()) &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27; &#x27;</span>:</span><br><span class="line">                        bw.write(<span class="string">&quot;空格=&quot;</span> + entry.getValue());</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;\t&#x27;</span>:<span class="comment">//\t表示tab 键字符</span></span><br><span class="line">                       bw.write(<span class="string">&quot;tab键=&quot;</span> + entry.getValue());</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;\r&#x27;</span>:</span><br><span class="line">                        bw.write(<span class="string">&quot;回车=&quot;</span> + entry.getValue());</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;\n&#x27;</span>:</span><br><span class="line">                        bw.write(<span class="string">&quot;换行=&quot;</span> + entry.getValue());</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">          bw.write(entry.getKey() + <span class="string">&quot;=&quot;</span> + entry.getValue());</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                bw.newLine();<span class="comment">//每次弄一次换行</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//4.关流</span></span><br><span class="line">            <span class="keyword">if</span> (fr != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fr.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (bw != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    bw.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-5转换流-处理流之二"><a href="#3-5转换流-处理流之二" class="headerlink" title="3.5转换流(处理流之二)"></a>3.5转换流(处理流之二)</h3><h4 id="1-转换流介绍"><a href="#1-转换流介绍" class="headerlink" title="1.转换流介绍"></a>1.转换流介绍</h4><p><strong>1.转换流：属于字符流—看后缀</strong></p><ol><li>InputStreamReader：将一个字节的输入流转换为字符的输入流</li><li>OutputStreamWriter：将一个字符的输出流转换为字节的输出流</li></ol><p><strong>2.作用：</strong></p><ol><li>提供字节流与字符流之间的转换</li><li>字节流中的数据都是字符时，转成字符流操作更高效。 </li><li>很多时候我们使用转换流来处理文件乱码问题。实现编码和解码的功能<ol><li>解码：字节、字节数组  —&gt;字符数组、字符串</li><li>编码：字符数组、字符串 —&gt; 字节、字节数组</li></ol></li></ol><p>3.转换过程图示：</p><p><img src="/2022/10/04/Java%E9%AB%98%E7%BA%A7-%E9%9B%86%E5%90%88-%E6%B3%9B%E5%9E%8B-IO%E6%B5%81/Snipaste_2022-02-07_17-43-10.png" alt="Snipaste_2022-02-07_17-43-10"></p><h4 id="2-转换流的使用"><a href="#2-转换流的使用" class="headerlink" title="2.转换流的使用"></a>2.转换流的使用</h4><p>一、InputStreamReader的使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">为清晰看代码此时处理异常的话，仍然应该使用<span class="keyword">try</span>-<span class="keyword">catch</span>-<span class="keyword">finally</span></span><br><span class="line">InputStreamReader的使用，实现字节的输入流到字符的输入流的转换</span><br><span class="line">     */</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">     <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;dbcp.txt&quot;</span>);</span><br><span class="line"><span class="comment">//   InputStreamReader isr = new InputStreamReader(fis);//使用系统默认的字符集</span></span><br><span class="line"><span class="comment">//参数2指明了字符集，具体使用哪个字符集，取决于文件dbcp.txt保存时使用的字符集，这里使用系统默认的字符集</span></span><br><span class="line"><span class="type">InputStreamReader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(fis,<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">      </span><br><span class="line">        <span class="type">char</span>[] cbuf = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">20</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span>((len = isr.read(cbuf)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(cbuf,<span class="number">0</span>,len);</span><br><span class="line">            System.out.print(str);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        isr.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>二、综合使用InputStreamReader和OutputStreamWriter</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">此时处理异常的话，仍然应该使用try-catch-finally</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">综合使用InputStreamReader和OutputStreamWriter</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">//1.造文件、造流</span></span><br><span class="line">    <span class="type">File</span> <span class="variable">file1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;dbcp.txt&quot;</span>);</span><br><span class="line">    <span class="type">File</span> <span class="variable">file2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;dbcp_gbk.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file1);</span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(file2);</span><br><span class="line"></span><br><span class="line"> <span class="type">InputStreamReader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(fis,<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line"> <span class="type">OutputStreamWriter</span> <span class="variable">osw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(fos,<span class="string">&quot;gbk&quot;</span>);</span><br><span class="line"><span class="comment">//写出时可自己选择字符集</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.读写过程</span></span><br><span class="line">    <span class="type">char</span>[] cbuf = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="keyword">while</span>((len = isr.read(cbuf)) != -<span class="number">1</span>)&#123;</span><br><span class="line">        osw.write(cbuf,<span class="number">0</span>,len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.关闭资源</span></span><br><span class="line">    isr.close();</span><br><span class="line">    osw.close();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="3-多种字符编码集"><a href="#3-多种字符编码集" class="headerlink" title="3.多种字符编码集"></a>3.多种字符编码集</h4><p>1.常见种类</p><ol><li>ASCII：美国标准信息交换码，用一个字节的7位可以表示。</li><li>ISO8859-1：拉丁码表。欧洲码表，用一个字节的8位表示。</li><li>GB2312：中国的中文编码表，最多两个字节编码所有字符</li><li>GBK：中国的中文编码表升级，融合了更多的中文文字符号。最多两个字节编码</li><li>Unicode：国际标准码，融合了目前人类使用的所有字符。为每个字符分配唯一的字符码。所有的文字都用两个字节来表示。</li><li>UTF-8：变长的编码方式，可用1-4个字节来表示一个字符。</li></ol><p>2.Unicode和UTF-8</p><p>一、Unicode不完美，这里就有三个问题</p><ol><li><p>一个是，我们已经知道，英文字母只用一个字节表示就够了</p></li><li><p>第二个问题是如何才能区别Unicode和ASCII？计算机怎么知道两个字节表示一个符号，而不是分别表示两个符号呢？</p></li><li><p>第三个，如果和GBK等双字节编码方式一样，用最高位是1或0表示两个字节和一个字节，就少了很多值无法用于表示字符，不够表示所有字符。Unicode在很长一段时间内无法推广，直到互联网的出现。</p></li></ol><p>二、面向传输的众多 UTF（UCS Transfer Format）标准出现了，顾名思义，UTF- </p><p>8就是每次8个位传输数据，而UTF-16就是每次16个位。这是为传输而设计的</p><p>编码，并使编码无国界，这样就可以显示全世界上所有文化的字符了。</p><p>三、Unicode只是定义了一个庞大的、全球通用的字符集，并为每个字符规定了唯</p><p>一确定的编号，具体存储成什么样的字节流，取决于字符编码方案。推荐的</p><p>Unicode编码是UTF-8和UTF-16</p><p>四、Unicode转换到UTF-8</p><p><img src="/2022/10/04/Java%E9%AB%98%E7%BA%A7-%E9%9B%86%E5%90%88-%E6%B3%9B%E5%9E%8B-IO%E6%B5%81/Snipaste_2022-02-07_20-20-05.png" alt="Snipaste_2022-02-07_20-20-05"></p><p>五、所有字符编码集关系</p><p><img src="/2022/10/04/Java%E9%AB%98%E7%BA%A7-%E9%9B%86%E5%90%88-%E6%B3%9B%E5%9E%8B-IO%E6%B5%81/Snipaste_2022-02-07_20-20-19.png" alt="Snipaste_2022-02-07_20-20-19"></p><h3 id="3-6标准输入输出流"><a href="#3-6标准输入输出流" class="headerlink" title="3.6标准输入输出流"></a>3.6标准输入输出流</h3><h4 id="1-介绍-2"><a href="#1-介绍-2" class="headerlink" title="1.介绍"></a>1.介绍</h4><p>System.in和System.out分别代表了系统标准的输入和输出设备</p><ol><li>默认输入设备是：键盘，输出设备是：显示器</li><li>System.in的类型是InputStream</li><li>System.out的类型是PrintStream，其是OutputStream的子类FilterOutputStream 的子类</li></ol><p>重定向：通过System类的setIn，setOut方法对默认设备进行改变。（<strong>重新指定一个流进行读取写出。例如从文件中读数据而不是键盘中输入，输出数据到指定文件中而不是控制台）</strong></p><ol><li>public static void setIn(InputStream in)</li><li>public static void setOut(PrintStream out)</li></ol><h4 id="2-练习演示1"><a href="#2-练习演示1" class="headerlink" title="2.练习演示1"></a>2.练习演示1</h4><p>从键盘输入字符串，要求将读取到的整行字符串转成大写输出。然后继续进行输入操作，直至当输入“e”或者“exit”时，退出程序。</p><p>方法一：使用Scanner实现，调用next()返回一个字符串<br>方法二：使用System.in实现。System.in  —&gt;  转换流 —&gt; BufferedReader的readLine()</p><p>代码演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法二：使用System.in实现。System.in  ---&gt;  转换流 ---&gt; BufferedReader的readLine()</span></span><br><span class="line"><span class="comment">//想用用字符流的缓冲流中readLine(),由于System.in是字节流，所以可以放入转换流构造器中</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="type">InputStreamReader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in);</span><br><span class="line">        br = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(isr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;请输入字符串：&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> br.readLine();</span><br><span class="line">            <span class="comment">//equalsIgnoreCase(data)忽略大小写</span></span><br><span class="line">           <span class="keyword">if</span> (<span class="string">&quot;e&quot;</span>.equalsIgnoreCase(data) || <span class="string">&quot;exit&quot;</span>.equalsIgnoreCase(data)) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;程序结束&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">String</span> <span class="variable">upperCase</span> <span class="operator">=</span> data.toUpperCase();</span><br><span class="line">            System.out.println(upperCase);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (br != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                br.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="3-练习2"><a href="#3-练习2" class="headerlink" title="3.练习2"></a>3.练习2</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyInput.java: Contain the methods for reading int, double, float, boolean, short, byte and</span></span><br><span class="line"><span class="comment">// string values from the keyboard</span></span><br><span class="line">相当于创建一个System.in输入类，调用方法，从键盘中输入获取想要类型的值</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyInput</span> &#123;</span><br><span class="line">    <span class="comment">// Read a string from the keyboard</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">readString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Declare and initialize the string</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">string</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Get the string from the keyboard</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            string = br.readLine();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            System.out.println(ex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Return the string obtained from the keyboard</span></span><br><span class="line">        <span class="keyword">return</span> string;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read an int value from the keyboard</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">readInt</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.parseInt(readString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read a double value from the keyboard</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">readDouble</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Double.parseDouble(readString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read a byte value from the keyboard</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">readByte</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Byte.parseByte(readString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read a short value from the keyboard</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">readShort</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Short.parseShort(readString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read a long value from the keyboard</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">readLong</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Long.parseLong(readString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read a float value from the keyboard</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">readFloat</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Float.parseFloat(readString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-7打印流-了解"><a href="#3-7打印流-了解" class="headerlink" title="3.7打印流(了解)"></a>3.7打印流(了解)</h3><p>实现将基本数据类型的数据格式转化为字符串输出</p><ol><li><strong>打印流：PrintStream和PrintWriter</strong></li><li><strong>提供了一系列重载的print()和println()方法，用于多种数据类型的输出</strong></li><li>PrintStream和PrintWriter的输出不会抛出IOException异常</li><li>PrintStream和PrintWriter有自动flush功能</li><li>PrintStream 打印的所有字符都使用平台的默认字符编码转换为字节。</li><li>在需要写入字符而不是写入字节的情况下，应该使用 PrintWriter 类。 </li><li><strong>System.out返回的是PrintStream的实例</strong></li></ol><p>练习演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">PrintStream</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\IO\\text.txt&quot;</span>));</span><br><span class="line">        <span class="comment">// 创建打印输出流,设置为自动刷新模式(写入换行符或字节 &#x27;\n&#x27; 时都会刷新输出缓冲区)</span></span><br><span class="line">        ps = <span class="keyword">new</span> <span class="title class_">PrintStream</span>(fos, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">if</span> (ps != <span class="literal">null</span>) &#123;<span class="comment">// 把标准输出流(控制台输出)改成文件</span></span><br><span class="line">            System.setOut(ps);</span><br><span class="line">        &#125;</span><br><span class="line">  <span class="comment">//此时输出流被改为输出到指定文件</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= <span class="number">255</span>; i++) &#123; <span class="comment">// 输出ASCII字符</span></span><br><span class="line">            System.out.print((<span class="type">char</span>) i);</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">50</span> == <span class="number">0</span>) &#123; <span class="comment">// 每50个数据一行</span></span><br><span class="line">                System.out.println(); <span class="comment">// 换行</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ps != <span class="literal">null</span>) &#123;</span><br><span class="line">            ps.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-8数据流-了解"><a href="#3-8数据流-了解" class="headerlink" title="3.8数据流(了解)"></a>3.8数据流(了解)</h3><p>1.为了方便地操作Java语言的基本数据类型和String的数据，可以使用数据流。</p><p>2.数据流有两个类：用于读取和写出基本数据类型、String类的数据</p><p>3.DataInputStream 和 DataOutputStream分别“套接”在 InputStream 和 OutputStream 子类的流上 </p><p>DataInputStream中的方法</p><ol><li>boolean readBoolean() </li><li>byte readByte()</li><li>char readChar() </li><li>float readFloat()</li><li>double readDouble() </li><li>short readShort()</li><li>long readLong() </li><li>int readInt()</li><li>String readUTF() void readFully(byte[] b)</li></ol><p>DataOutputStream中的方法</p><p>将上述的方法的read改为相应的write即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">练习：将内存中的字符串、基本数据类型的变量写出到文件中。</span><br><span class="line">注意：处理异常的话，仍然应该使用<span class="keyword">try</span>-<span class="keyword">catch</span>-<span class="keyword">finally</span>.</span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//1.</span></span><br><span class="line">        <span class="type">DataOutputStream</span> <span class="variable">dos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;data.txt&quot;</span>));</span><br><span class="line">        <span class="comment">//2.</span></span><br><span class="line">        dos.writeUTF(<span class="string">&quot;刘建辰&quot;</span>);</span><br><span class="line">        dos.flush();<span class="comment">//刷新操作，将内存中的数据写入文件</span></span><br><span class="line">        dos.writeInt(<span class="number">23</span>);</span><br><span class="line">        dos.flush();</span><br><span class="line">        dos.writeBoolean(<span class="literal">true</span>);</span><br><span class="line">        dos.flush();</span><br><span class="line">        <span class="comment">//3.</span></span><br><span class="line">        dos.close();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    将文件中存储的基本数据类型变量和字符串读取到内存中，保存在变量中。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    注意点：读取不同类型的数据的顺序要与当初写入文件时，保存的数据的顺序一致！</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//1.</span></span><br><span class="line">        <span class="type">DataInputStream</span> <span class="variable">dis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;data.txt&quot;</span>));</span><br><span class="line">        <span class="comment">//2.</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> dis.readUTF();</span><br><span class="line">        <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> dis.readInt();</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isMale</span> <span class="operator">=</span> dis.readBoolean();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;name = &quot;</span> + name);</span><br><span class="line">        System.out.println(<span class="string">&quot;age = &quot;</span> + age);</span><br><span class="line">        System.out.println(<span class="string">&quot;isMale = &quot;</span> + isMale);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.</span></span><br><span class="line">        dis.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-9对象流"><a href="#3-9对象流" class="headerlink" title="3.9对象流"></a>3.9对象流</h3><h4 id="1-介绍-3"><a href="#1-介绍-3" class="headerlink" title="1.介绍"></a>1.介绍</h4><p>对象流涵盖了数据流，它不仅可以用于存储和读取基本数据类型数据且存储和读取对象。</p><p>ObjectInputStream和OjbectOutputSteam</p><ul><li>用于存储和读取基本数据类型数据或对象的处理流。它的强大之处就是可以把Java中的对象写入到数据源中，也能把对象从数据源中还原回来。</li></ul><p>序列化：用ObjectOutputStream类保存基本类型数据或对象的机制</p><p>反序列化：用ObjectInputStream类读取基本类型数据或对象的机制</p><h4 id="2-对象流的使用"><a href="#2-对象流的使用" class="headerlink" title="2.对象流的使用"></a>2.对象流的使用</h4><p><strong>1.使用步骤：</strong></p><p>序列化：  —-<strong>用String举例：String类本身也实现了Serializable 接口</strong></p><ol><li><p>若某个<strong>类实现了 Serializable 接口</strong>，该类的对象就是可序列化的：</p></li><li><p><strong>创建一个 ObjectOutputStream流</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ObjectOutputStream</span>  <span class="variable">oos</span> <span class="operator">=</span>   <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;object.dat&quot;</span>)); </span><br><span class="line"><span class="comment">//文件后缀可自选</span></span><br></pre></td></tr></table></figure></li><li><p>调用 ObjectOutputStream 对象的 writeObject(对象) 方法输出可序列化对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">oos.writeObject(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;我爱北京天安门&quot;</span>));<span class="comment">//这里将String类型序列化</span></span><br></pre></td></tr></table></figure></li><li><p>注意写出一次，操作flush()一次</p><p>oos.flush();&#x2F;&#x2F;刷新操作</p></li><li><p>关闭流</p><p>oos.close()</p></li><li><p>仍需要用try-catch-finally解决异常</p></li></ol><p>反序列化：</p><ol><li><p>创建一个 ObjectInputStream</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ObjectInputStream</span>  <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;object.dat&quot;</span>));</span><br></pre></td></tr></table></figure></li><li><p>调用 readObject() 方法读取流中的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> ois.readObject();</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> (String) obj;</span><br><span class="line">System.out.println(str);</span><br></pre></td></tr></table></figure></li><li><p>关闭流</p><p>ois.close()</p></li><li><p>仍需要用try-catch-finally解决异常</p></li></ol><p><strong>详细代码演示：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//提醒：一般只序列化一种类型，但是有多种类型时，反序列化时得按照序列化时的优先顺序--这也是所有流读入写出时遇到多种类型时需要遵守的</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testObjectOutputStream</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//1.</span></span><br><span class="line">                oos = <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;object.dat&quot;</span>));</span><br><span class="line">                <span class="comment">//2.</span></span><br><span class="line">                oos.writeObject(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;我爱北京天安门&quot;</span>));</span><br><span class="line">                oos.flush();<span class="comment">//刷新操作</span></span><br><span class="line"></span><br><span class="line">                oos.writeObject(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;王铭&quot;</span>,<span class="number">23</span>));</span><br><span class="line">                oos.flush();</span><br><span class="line"></span><br><span class="line">                oos.writeObject(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;张学良&quot;</span>,<span class="number">23</span>,<span class="number">1001</span>,<span class="keyword">new</span> <span class="title class_">Account</span>(<span class="number">5000</span>)));</span><br><span class="line">                oos.flush();</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(oos != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//3.</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                oos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">反序列化：将磁盘文件中的对象还原为内存中的一个java对象</span></span><br><span class="line"><span class="comment">使用ObjectInputStream来实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testObjectInputStream</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ois = <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;object.dat&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> ois.readObject();</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> (String) obj;</span><br><span class="line"></span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> (Person) ois.readObject();</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> (Person) ois.readObject();</span><br><span class="line"></span><br><span class="line">        System.out.println(str);</span><br><span class="line">        System.out.println(p);</span><br><span class="line">        System.out.println(p1);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(ois != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ois.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>2.自定义类可序列化</strong></p><p>Person需要满足如下的要求，方可序列化</p><ol><li><p>需要实现接口：Serializable</p></li><li><p>当前类提供一个全局常量（<strong>序列版本号</strong>）：serialVersionUID</p><p>意思是给每个序列化指定一个ID区分，不写的话，系统会自动分配，但是建议写上</p></li><li><p>除了当前Person类需要实现Serializable接口之外，还必须保证其内部所有属性也必须是可序列化的。（默认情况下，基本数据类型可序列化）</p><p>强调：如果某个类声明的属性不是基本数据类型或 String 类型，而是另一个引用类型，那么这个引用类型必须是可序列化的，否则拥有该类型的Field 的类也不能序列化</p></li></ol><p><strong>补充</strong>：ObjectOutputStream和ObjectInputStream不能序列化static和transient修饰的成员变量</p><ol><li>static ：本身属于类而不是属于对象，所以不能序列化</li><li>transient：用于修饰不想被序列化的属性</li></ol><p>代码演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码简化：只需要看有没有满足可序列条件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span>&#123; <span class="number">1.</span>实现接口</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">475463534532L</span>;                               <span class="number">2.</span>提供一个全局常量</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="type">int</span> age;  <span class="number">4.</span>不想被序列化，可用该关键字修饰</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> Account acct;      <span class="number">3.</span>如果有引用类型声明的属性，那么该引用类型也是可序列化的</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age, <span class="type">int</span> id, Account acct)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.acct = acct;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">4754534532L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> balance;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-10随机存取文件流"><a href="#3-10随机存取文件流" class="headerlink" title="3.10随机存取文件流"></a>3.10随机存取文件流</h3><h4 id="1-介绍-4"><a href="#1-介绍-4" class="headerlink" title="1.介绍"></a>1.介绍</h4><p>一、RandomAccessFile 类</p><ol><li>RandomAccessFile 声明在java.io包下，但直接继承于java.lang.Object类。并且它实现了DataInput、DataOutput这两个接口，也就意味着这个类既可以读也可以写。</li><li>RandomAccessFile 类支持 “随机访问” 的方式，程序可以直接跳到文件的任意地方来读、写文件<ol><li>支持只访问文件的部分内容</li><li>可以向已存在的文件后追加内容</li></ol></li></ol><p>二、细节使用</p><ol><li>RandomAccessFile 对象包含一个记录指针，用以标示当前读写处的位置。</li><li>RandomAccessFile 类对象可以自由移动记录指针：<ol><li>long getFilePointer()：获取文件记录指针的当前位置</li><li>void seek(long pos)：将文件记录指针定位到 pos 位置</li></ol></li></ol><p>三、构造器</p><ol><li>public RandomAccessFile(File file, String mode) </li><li>public RandomAccessFile(String name, String mode)</li></ol><p>四、构造器mode参数说明</p><p>创建 RandomAccessFile 类实例需要指定一个 mode 参数，该参数指定 RandomAccessFile 的访问模式：</p><ol><li>r: 以只读方式打开</li><li>rw：打开以便读取和写入</li><li>rwd:打开以便读取和写入；同步文件内容的更新</li><li>rws:打开以便读取和写入；同步文件内容和元数据的更新</li></ol><p>五、四种访问模式使用区别</p><p>r 和 rw：如果模式为只读r。则不会创建文件，而是会去读取一个已经存在的文件，如果读取的文件不存在则会出现异常。 如果模式为rw读写。如果文件不存在则会去创建文件，如果存在则不会创建。</p><p>rw和rwd：JDK 1.6 上面写的每次write数据时，“rw”模式，数据不会立即写到硬盘中；而“rwd”，写数据会被立即写入硬盘中。好处是如果写数据过程发生异常，“rwd”模式中已被write的数据被保存带硬盘中，而“rw”则全部丢失</p><h4 id="2-RandomAccessFile使用"><a href="#2-RandomAccessFile使用" class="headerlink" title="2.RandomAccessFile使用"></a>2.RandomAccessFile使用</h4><p>说明：</p><ol><li><p>RandomAccessFile直接继承于java.lang.Object类，实现了DataInput和DataOutput接口</p></li><li><p>RandomAccessFile既可以作为一个输入流，又可以作为一个输出流。</p><p><strong>代码演示一–说明</strong></p></li><li><p>如果RandomAccessFile作为输出流时，写出到的文件如果不存在，则在执行过程中自动创建。</p><p>如果写出到的文件存在，则会对原有文件内容进行覆盖。（默认情况下，从头覆盖）—-<strong>-代码演示二–说明</strong></p></li><li><p>可以通过相关的操作，实现RandomAccessFile“插入”数据的效果，满足一些需求而不在是覆盖 —-<strong>-代码演示三–说明</strong></p></li></ol><p>代码演示 一：(RandomAccessFile既可作为输入流，又可作为输出流)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RandomAccessFileTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span>   <span class="comment">//复制图片</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">RandomAccessFile</span> <span class="variable">raf1</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">RandomAccessFile</span> <span class="variable">raf2</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.造文件造流</span></span><br><span class="line">raf1 = <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;爱情与友情.jpg&quot;</span>),<span class="string">&quot;r&quot;</span>);</span><br><span class="line">raf2 = <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;爱情与友情1.jpg&quot;</span>),<span class="string">&quot;rw&quot;</span>);</span><br><span class="line">            <span class="comment">//2.读入写出过程</span></span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">int</span> len;</span><br><span class="line">            <span class="keyword">while</span>((len = raf1.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">                raf2.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//3.关闭流</span></span><br><span class="line">            <span class="keyword">if</span>(raf1 != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    raf1.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(raf2 != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    raf2.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>代码演示二：如果写出到的文件存在，则会对原有文件内容进行覆盖。（默认情况下，从头覆盖）–也可使用seek()指定角标位置进行覆盖</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span> <span class="comment">//为笔记清晰，省略使用try-catch-finally</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">RandomAccessFile</span> <span class="variable">raf1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;hello.txt&quot;</span>,<span class="string">&quot;rw&quot;</span>);</span><br><span class="line"></span><br><span class="line">    raf1.seek(<span class="number">3</span>);<span class="comment">//将指针调到角标为3的位置</span></span><br><span class="line">    raf1.write(<span class="string">&quot;xyz&quot;</span>.getBytes());<span class="comment">//这里write形参是byte数组</span></span><br><span class="line"><span class="comment">//不是字符串</span></span><br><span class="line">    raf1.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>代码演示三：可以通过相关的操作，实现RandomAccessFile“插入”数据的效果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">使用RandomAccessFile实现数据的插入效果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">RandomAccessFile</span> <span class="variable">raf1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;hello.txt&quot;</span>,<span class="string">&quot;rw&quot;</span>);</span><br><span class="line">    <span class="comment">//方式一：使用StringBuilder</span></span><br><span class="line">    raf1.seek(<span class="number">3</span>);<span class="comment">//将指针调到角标为3的位置</span></span><br><span class="line">    <span class="comment">//保存指针3后面的所有数据到StringBuilder中</span></span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>((<span class="type">int</span>) <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;hello.txt&quot;</span>).length());</span><br><span class="line">    </span><br><span class="line">    <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="keyword">while</span>((len = raf1.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">        builder.append(<span class="keyword">new</span> <span class="title class_">String</span>(buffer,<span class="number">0</span>,len)) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//调回指针，写入“xyz”</span></span><br><span class="line">    raf1.seek(<span class="number">3</span>);</span><br><span class="line">    raf1.write(<span class="string">&quot;xyz&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将StringBuilder中的数据写入到文件中</span></span><br><span class="line">    raf1.write(builder.toString().getBytes());</span><br><span class="line"></span><br><span class="line">    raf1.close();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方式二：思考：将StringBuilder替换为ByteArrayOutputStream</span></span><br><span class="line"><span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line"><span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> len;</span><br><span class="line"><span class="keyword">while</span>((len = raf1.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">baos.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">&#125;</span><br><span class="line">raf1.seek(<span class="number">5</span>);</span><br><span class="line">raf1.write(<span class="string">&quot;xyz&quot;</span>.getBytes());</span><br><span class="line">raf1.write(baos.toString().getBytes());</span><br><span class="line">baos.close();</span><br><span class="line">raf1.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-11NIO-2中Path、Paths、Files类的使用"><a href="#3-11NIO-2中Path、Paths、Files类的使用" class="headerlink" title="3.11NIO.2中Path、Paths、Files类的使用"></a>3.11NIO.2中Path、Paths、Files类的使用</h3><p>由于难度跳跃且暂时用不到，这里暂做了解</p><h4 id="1-NIO概述"><a href="#1-NIO概述" class="headerlink" title="1.NIO概述"></a>1.NIO概述</h4><ol><li>Java NIO (New IO，Non-Blocking IO)是从Java 1.4版本开始引入的一套新 的IO API，可以替代标准的Java IO API。NIO与原来的IO有同样的作用和目的，但是使用的方式完全不同，NIO支持面向缓冲区的(IO是面向流的)、基于通道的IO操作。NIO将以更加高效的方式进行文件的读写操作</li><li>Java API中提供了两套NIO，一套是针对标准输入输出NIO，另一套就是网络编程NIO。 </li><li>java.nio.channels.Channel</li><li>FileChannel:处理本地文件</li><li>SocketChannel：TCP网络编程的客户端的Channel</li><li>ServerSocketChannel:TCP网络编程的服务器端的Channel</li><li>DatagramChannel：UDP网络编程中发送端和接收端的Channel</li></ol><h4 id="2-NIO-2概述"><a href="#2-NIO-2概述" class="headerlink" title="2.NIO.2概述"></a>2.NIO.2概述</h4><ol><li>随着 JDK 7 的发布，Java对NIO进行了极大的扩展，增强了对文件处理和文件系统特性的支持，以至于我们称他们为 NIO.2。</li><li>因为 NIO 提供的一些功能，NIO已经成为文件处理中越来越重要的部分。</li><li>早期的Java只提供了一个File类来访问文件系统，但File类的功能比较有限，所提供的方法性能也不高。而且，大多数方法在出错时仅返回失败，并不会提供异常信息。</li><li>NIO. 2为了弥补这种不足，引入了Path接口，代表一个平台无关的平台路径，描述了目录结构中文件的位置。<strong>Path可以看成是File类的升级版本</strong>，实际引用的资源也可以不存在。</li></ol><p>Path、Paths和Files核心API</p><ul><li>同时，NIO.2在java.nio.file包下还提供了Files、Paths工具类，Files包含了大量静态的工具方法来操作文件；Paths则包含了两个返回Path的静态工厂方法。</li></ul><p>Paths 类提供的静态 get() 方法用来获取 Path 对象：</p><ol><li>static Path get(String first, String … more) : 用于将多个字符串串连成路径</li><li>static Path get(URI uri): 返回指定uri对应的Path路径</li></ol><h4 id="3-Path接口"><a href="#3-Path接口" class="headerlink" title="3.Path接口"></a>3.Path接口</h4><p>说明：Path替换File</p><p>如何实例化：</p><p>Paths 类提供的静态 get() 方法用来获取 Path 对象：</p><ol><li>static Path get(String first, String … more) : 用于将多个字符串串连成路径</li><li>static Path get(URI uri): 返回指定uri对应的Path路径</li></ol><p>常用方法：</p><p>Path 常用方法：</p><ol><li>String toString() ： 返回调用 Path 对象的字符串表示形式</li><li>boolean startsWith(String path) : 判断是否以 path 路径开始</li><li>boolean endsWith(String path) : 判断是否以 path 路径结束</li><li>boolean isAbsolute() : 判断是否是绝对路径</li><li>Path getParent() ：返回Path对象包含整个路径，不包含 Path 对象指定的文件路径</li><li>Path getRoot() ：返回调用 Path 对象的根路径</li><li>Path getFileName() : 返回与调用 Path 对象关联的文件名</li><li>int getNameCount() : 返回Path 根目录后面元素的数量</li><li>Path getName(int idx) : 返回指定索引位置 idx 的路径名称</li><li>Path toAbsolutePath() : 作为绝对路径返回调用 Path 对象</li><li>Path resolve(Path p) :合并两个路径，返回合并后的路径对应的Path对象</li><li>File toFile(): 将Path转化为File类的对象</li></ol><h4 id="4-Files工具类"><a href="#4-Files工具类" class="headerlink" title="4.Files工具类"></a>4.Files工具类</h4><p>作用：java.nio.file.Files 用于操作文件或目录的工具类。</p><p>常用方法：</p><ol><li>Path copy(Path src, Path dest, CopyOption … how) : 文件的复制</li><li>Path createDirectory(Path path, FileAttribute&lt;?&gt; … attr) : 创建一个目录</li><li>Path createFile(Path path, FileAttribute&lt;?&gt; … arr) : 创建一个文件</li><li>void delete(Path path) : 删除一个文件&#x2F;目录，如果不存在，执行报错</li><li>void deleteIfExists(Path path) : Path对应的文件&#x2F;目录如果存在，执行删除</li><li>Path move(Path src, Path dest, CopyOption…how) : 将 src 移动到 dest 位置</li><li>long size(Path path) : 返回 path 指定文件的大小</li></ol><p>Files常用方法：用于判断</p><ol><li>boolean exists(Path path, LinkOption … opts) : 判断文件是否存在</li><li>boolean isDirectory(Path path, LinkOption … opts) : 判断是否是目录</li><li>boolean isRegularFile(Path path, LinkOption … opts) : 判断是否是文件</li><li>boolean isHidden(Path path) : 判断是否是隐藏文件</li><li>boolean isReadable(Path path) : 判断文件是否可读</li><li>boolean isWritable(Path path) : 判断文件是否可写</li><li>boolean notExists(Path path, LinkOption … opts) : 判断文件是否不存在</li></ol><p>Files常用方法：用于操作内容</p><ol><li>SeekableByteChannel newByteChannel(Path path, OpenOption…how) : 获取与指定文件的连接，how 指定打开方式。</li><li>DirectoryStream<Path> newDirectoryStream(Path path) : 打开 path 指定的目录</Path></li><li>InputStream newInputStream(Path path, OpenOption…how):获取 InputStream 对象</li><li>OutputStream newOutputStream(Path path, OpenOption…how) : 获取 OutputStream 对象</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、集合&quot;&gt;&lt;a href=&quot;#一、集合&quot; class=&quot;headerlink&quot; title=&quot;一、集合&quot;&gt;&lt;/a&gt;一、集合&lt;/h2&gt;&lt;h3 id=&quot;1-1集合的概述&quot;&gt;&lt;a href=&quot;#1-1集合的概述&quot; class=&quot;headerlink&quot; title=&quot;1</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Java多线程-常用类-枚举类与注解</title>
    <link href="http://example.com/2022/10/03/Java%E9%AB%98%E7%BA%A7-%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%B8%B8%E7%94%A8%E7%B1%BB-%E6%9E%9A%E4%B8%BE%E7%B1%BB%E4%B8%8E%E6%B3%A8%E8%A7%A3/"/>
    <id>http://example.com/2022/10/03/Java%E9%AB%98%E7%BA%A7-%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%B8%B8%E7%94%A8%E7%B1%BB-%E6%9E%9A%E4%B8%BE%E7%B1%BB%E4%B8%8E%E6%B3%A8%E8%A7%A3/</id>
    <published>2022-10-02T16:00:00.000Z</published>
    <updated>2022-10-05T08:45:15.052Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、多线程"><a href="#一、多线程" class="headerlink" title="一、多线程"></a>一、多线程</h1><h3 id="1-1基本概念"><a href="#1-1基本概念" class="headerlink" title="1.1基本概念"></a>1.1基本概念</h3><h4 id="1-程序"><a href="#1-程序" class="headerlink" title="1.程序"></a>1.程序</h4><p><strong>程序(program)是为完成特定任务、用某种语言编写的一组指令的集合</strong>。即指一段静态的代码，静态对象。</p><h4 id="2-进程"><a href="#2-进程" class="headerlink" title="2.进程"></a>2.进程</h4><ol><li>进程(process)是程序的一次执行过程，或是正在运行的一个程序。是一个动态的过程：有它自身的产生、存在和消亡的过程。——生命周期</li><li>如：运行中的QQ，运行中的MP3播放器</li><li>程序是静态的，进程是动态的</li><li>进程作为资源分配的单位，系统在运行时会为每个进程分配不同的内存区域</li></ol><h4 id="3-线程"><a href="#3-线程" class="headerlink" title="3.线程"></a>3.线程</h4><ol><li>线程(thread)，进程可进一步细化为线程，是<strong>一个程序内部的一条执行路径</strong>。</li><li>若<strong>一个进程同一时间并行执行多个线程</strong>，就是支持多线程的</li><li><strong>线程作为调度和执行的单位，每个线程拥有独立的运行栈和程序计数器(pc)，线程切换的开销小</strong> </li><li><strong>一个进程中的多个线程共享相同的内存单元&#x2F;内存地址空间它们从同一堆中分配对象，可以访问相同的变量和对象。</strong>这就使得线程间通信更简便、高效。但<strong>多个线程操作共享的系统资源可能就会带来安全的隐患。</strong></li></ol><p>内存结构：</p><p><strong>每个线程，拥有自己独立的：栈、程序计数器</strong></p><p><strong>多个线程，共享同一个进程中的结构：方法区、堆</strong></p><p><img src="/2022/10/03/Java%E9%AB%98%E7%BA%A7-%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%B8%B8%E7%94%A8%E7%B1%BB-%E6%9E%9A%E4%B8%BE%E7%B1%BB%E4%B8%8E%E6%B3%A8%E8%A7%A3/Snipaste_2022-01-10_13-24-41.png" alt="Snipaste_2022-01-10_13-24-41"></p><h4 id="4-单核和多核CPU理解"><a href="#4-单核和多核CPU理解" class="headerlink" title="4.单核和多核CPU理解"></a>4.单核和多核CPU理解</h4><ol><li><strong>单核CPU，其实是一种假的多线程</strong>，因为在一个时间单元内，也只能执行一个线程的任务。例如：一个干多份活，但是由于动作熟练和切换快速，使人感觉有好多人同时在干活</li><li>如果是多核的话，才能更好的发挥多线程的效率。（现在的服务器都是多核的）</li><li>一<strong>个Java应用程序java.exe，其实至少有三个线程：main()主线程，gc()垃圾回收线程，异常处理线程</strong>。当然如果发生异常，会影响主线程。</li></ol><h4 id="5-并行与并发"><a href="#5-并行与并发" class="headerlink" title="5.并行与并发"></a>5.并行与并发</h4><ol><li>并行：多个CPU同时执行多个任务。比如：多个人同时做不同的事。 </li><li>并发：一个CPU(采用时间片)同时执行多个任务。比如：秒杀、多个人做同一件事。</li></ol><h4 id="6-多线程程序的优点"><a href="#6-多线程程序的优点" class="headerlink" title="6.多线程程序的优点"></a>6.多线程程序的优点</h4><ol><li>提高应用程序的响应。对图形化界面更有意义，可增强用户体验。</li><li>提高计算机系统CPU的利用率</li><li>改善程序结构。将既长又复杂的进程分为多个线程，独立运行，利于理解和修改</li></ol><h4 id="7-何时需要多线程"><a href="#7-何时需要多线程" class="headerlink" title="7.何时需要多线程"></a>7.何时需要多线程</h4><ol><li>程序需要同时执行两个或多个任务。</li><li>程序需要实现一些需要等待的任务时，如用户输入、文件读写操作、网络操作、搜索等。</li><li>需要一些后台运行的程序时</li></ol><h3 id="1-2多线程的创建和使用"><a href="#1-2多线程的创建和使用" class="headerlink" title="1.2多线程的创建和使用"></a>1.2多线程的创建和使用</h3><h4 id="1-方式一继承于Thread类"><a href="#1-方式一继承于Thread类" class="headerlink" title="1.方式一继承于Thread类"></a>1.方式一继承于Thread类</h4><p><strong>1.继承于Thread类</strong></p><ol><li>创建一个继承于Thread类的子类</li><li>重写Thread类的run() —&gt;将此线程执行的操作声明在run() 中</li><li>创建Thread类的子类的对象</li><li>通过此对象调用 start () 方法</li></ol><p>2.代码演示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123; <span class="comment">//创建一个继承于Thread类的子类</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;  <span class="comment">//重写Thread类的run() </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span> ; i&lt;<span class="number">100</span> ; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">fristCode</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">mt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(); <span class="comment">//创建Thread类的子类的对象</span></span><br><span class="line">        mt.start();通过此对象调用 start () 方法</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>3.问题</strong></p><ol><li><p>我们不能直接调用run() 的方式启动线程</p></li><li><p>每个线程对象只能调用一次，不可以再让已经start () 的线程去执行。会报错，我们需要重新创建一个线程的对象</p></li><li><p>&#96;&#96;&#96;java<br>MyThread mt &#x3D; new MyThread();<br>mt.start();<br>MyThread mv &#x3D; new MyThread();<br>mv.start();</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 2.创建Thread类的匿名子类的方式一</span><br><span class="line"></span><br><span class="line">继承于Thread类的方式去创建匿名子类</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">new Thread() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        for (int i = 0; i &lt; 100; i++) &#123;</span><br><span class="line">            if (i % 2 != 0) &#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.start();</span><br></pre></td></tr></table></figure></li></ol><h4 id="3-Thread类中的常用方法"><a href="#3-Thread类中的常用方法" class="headerlink" title="3.Thread类中的常用方法"></a>3.Thread类中的常用方法</h4><ol><li><p>start ()：启动当前线程，调用当前线程的run()</p></li><li><p>run ()：通常需要重写Thread类中的此方法，将创建的线程要执行的操作声明在此方法中</p></li><li><p>currentThread() ：静态方法，返回执行当前代码的线程（在方法中调用）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//public static native Thread currentThread();</span></span><br><span class="line">Thread.currentThread()；</span><br><span class="line"><span class="comment">//在什么方法中调用就返回什么方法的线程</span></span><br></pre></td></tr></table></figure></li><li><p>getName()：获取当前线程的名字</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span> ; i&lt;<span class="number">100</span> ; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">     <span class="comment">//三者是一样的 ，都是获取当前线程的名字 </span></span><br><span class="line">        <span class="comment">//System.out.println(Thread.currentThread().getName());                        //System.out.println(getName());</span></span><br><span class="line">        System.out.println(<span class="built_in">this</span>.getName());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>setName()：设置当前线程的名字</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">fristCode</span> &#123;</span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">   </span><br><span class="line">           Thread.currentThread().setName(<span class="string">&quot;主线程&quot;</span>);  System.out.println(Thread.currentThread().getName());</span><br><span class="line">   </span><br><span class="line">           <span class="type">MyThread</span> <span class="variable">mt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">           mt.setName(<span class="string">&quot;线程一&quot;</span>);</span><br><span class="line">           System.out.println( mt.getName());</span><br><span class="line"></span><br><span class="line"><span class="number">6.</span> yield()：释放当前CPU的执行权，（释放执行权后cup会重新分配执行任务）</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span> ; i&lt;<span class="number">100</span> ; i++)&#123;</span><br><span class="line">       <span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">           System.out.println(i);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(i==<span class="number">20</span>)&#123;</span><br><span class="line">           yield();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li><p>join()：在线程 a 中调用线程 b . join() ，此时线程a 就进入阻塞状态 ，直到线程b完全执行完以后，线程a才结束阻塞</p><p>会报错   ； 有形参 join(1000) 遇到此方法的其他线程要等待该方法的主人1000毫秒</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//在主方法中</span></span><br><span class="line"> <span class="type">MyThread</span> <span class="variable">mt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line"> mt.start(); <span class="comment">//此时有mt线程和main线程同时在跑</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">     System.out.println(<span class="string">&quot;主方法&quot;</span> + i);</span><br><span class="line">     <span class="keyword">if</span> (i == <span class="number">30</span>) &#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             mt.join();  <span class="comment">//mt.join()放在main()相当于main线程会碰到（调用）之后等mt线程结束之后才开启</span></span><br><span class="line">         &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">             e.printStackTrace();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> <span class="comment">//在run中</span></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span> ; i&lt;<span class="number">100</span> ; i++)&#123;</span><br><span class="line">     <span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">         System.out.println(i);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span>(i==<span class="number">20</span>)&#123;<span class="comment">//20处停止，执行别的线程</span></span><br><span class="line">         <span class="keyword">try</span> &#123;<span class="comment">//由于join会报异常，所以解决异常</span></span><br><span class="line">             join();</span><br><span class="line">         &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">             e.printStackTrace();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ol start="8"><li><p>stop()：已过时。当执行此方法时，强制结束当前线程</p></li><li><p>sleep(long  millitime)：让当前线程“睡眠”指定的millitime毫秒。在指定的millitime 的毫秒时间内，当前线程是阻塞状态<br>例如：限流、降低网页加载速度</p></li><li><p>isAlive()：判断当前线程是否存活–（返回boolean类型）</p></li></ol><h4 id="4-线程的优先级"><a href="#4-线程的优先级" class="headerlink" title="4.线程的优先级"></a>4.线程的优先级</h4><ol><li><p>MAX_PRIORITY  :  10</p></li><li><p>MIN_PRIORITY   :   1</p></li><li><p>NORM_PRIORITY  :  5—&gt;默认优先级</p></li><li><p>如何获取和设置当前线程的优先级：</p><p>getPriority( ) : 获取线程的优先级</p><p>setPriority ( ) : 设置线程的优先级</p></li><li><p>说明</p><p><strong>高优先级的线程只是抢到CPU执行权的概率上高，不意味着低优先级不能执行在高优先级之前</strong></p></li><li><p>&#96;&#96;&#96;java<br>HelloThread h1 &#x3D; new HelloThread();<br>    h1.setName(“线程一”);<br>    &#x2F;&#x2F;设置分线程的优先级<br>    h1.setPriority(Thread.MAX_PRIORITY);<br>    h1.start();<br><br>    &#x2F;&#x2F;给主线程命名<br>    Thread.currentThread().setName(“主线程”);  Thread.currentThread().setPriority(Thread.MIN_PRIORITY);</p></li></ol><h4 id="5-方式二实现Runnable-接口"><a href="#5-方式二实现Runnable-接口" class="headerlink" title="5.方式二实现Runnable( ) 接口"></a>5.方式二实现Runnable( ) 接口</h4><p>1.实现Runnable( ) 接口</p><ol><li><p>创建一个实现类Runnable接口的类</p></li><li><p>实现类去实现Runnable 中的抽象方法：run（）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建实现类的对象</p></li><li><p>将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//底层代码</span></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Thread</span><span class="params">(Runnable target)</span> &#123;</span><br><span class="line">       init(<span class="literal">null</span>, target, <span class="string">&quot;Thread-&quot;</span> + nextThreadNum(), <span class="number">0</span>);</span><br><span class="line">&#125;<span class="comment">//将实现类的对象传给Runnable类型的target，因为可以传递实现类的对象--多态性</span></span><br></pre></td></tr></table></figure></li><li><p>通过Thread类的对象调用start （）</p><p>这个在去调用target . run（），此run是实现重写的（private Runnable target;）</p></li></ol><p>2.代码演示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 创建一个实现了Runnable接口的类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 实现类去实现Runnable中的抽象方法：run()</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//3. 创建实现类的对象</span></span><br><span class="line">        <span class="type">MThread</span> <span class="variable">mThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MThread</span>();</span><br><span class="line">        <span class="comment">//4. 将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(mThread);</span><br><span class="line">        t1.setName(<span class="string">&quot;线程1&quot;</span>);</span><br><span class="line">        <span class="comment">//5. 通过Thread类的对象调用start():① 启动线程 ②调用当前线程的run()--&gt;调用了Runnable类型的target的run()</span></span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//再启动一个线程，遍历100以内的偶数</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(mThread);</span><br><span class="line">        t2.setName(<span class="string">&quot;线程2&quot;</span>);</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3.方式二好处</strong></p><p>只需要创建一次实现类的对象，可以创建多个线程的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Window1</span> <span class="variable">w</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Window1</span>();</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(w);</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(w);</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(w);</span><br><span class="line"></span><br><span class="line">t1.setName(<span class="string">&quot;窗口1&quot;</span>);</span><br><span class="line">t2.setName(<span class="string">&quot;窗口2&quot;</span>);</span><br><span class="line">t3.setName(<span class="string">&quot;窗口3&quot;</span>);</span><br><span class="line"></span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br><span class="line">t3.start();</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="6-创建Thread类的匿名子类的方式二"><a href="#6-创建Thread类的匿名子类的方式二" class="headerlink" title="6.创建Thread类的匿名子类的方式二"></a>6.创建Thread类的匿名子类的方式二</h4><p>实现Runnable接口的方式去创建匿名子类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>()&#123;<span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125; ).start();</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="7-比较两种方式"><a href="#7-比较两种方式" class="headerlink" title="7.比较两种方式"></a>7.比较两种方式</h4><p>比较创建线程的两种方式。</p><p><strong>开发中：优先选择：实现Runnable接口的方式</strong></p><p><strong>原因：</strong></p><ol><li><p>实现的方式没有类的单继承性的局限性  （实现方式：可以在去实现别的接口或继承父类。继承方式：只能继承一个，操作局限）</p></li><li><p>实现的方式更适合来处理多个线程有共享数据的情况。</p><p>Window w &#x3D; new Window();&#x2F;&#x2F; 只new一个实现类，下面都共用<br>Thread t1 &#x3D; new Thread(w);<br>Thread t2 &#x3D; new Thread(w);<br>Thread t3 &#x3D; new Thread(w);</p></li><li><p>卖票问题：继承方式：票得声明成static ，实现方式：票不用声明成static</p></li></ol><p><strong>两种方式的联系：</strong>public class Thread implements Runnable（<strong>都直接或间接的实现了Runnable接口</strong>）</p><p><strong>相同点：</strong>两种方式都需要重写run(),将线程要执行的逻辑声明在run()中。</p><p>​                  都是调用Thread类中start() 方法启动线程</p><h4 id="8-总结"><a href="#8-总结" class="headerlink" title="8.总结"></a>8.总结</h4><p>程序是一段静态的代码，进程是正在运行的程序（相对于程序是动态的），线程是进程中执行的任务（例如：360卫士，同时清理垃圾、扫描病毒、检测电脑）</p><p>在java程序中的线程，是通过Thread类去体现的：</p><ol><li>继承Thread</li><li>实现Runnable接口</li><li>Thread类也是通过实现了Runnable接口</li><li>都要重写Runnable接口中的run方法</li><li>都是调用Thread类中start() 方法启动线程</li><li>在Java代码运行中相当于只有一个CPU，去给每个线程不断分配执行权，所以可能两个操作无规律的交错进行</li></ol><h3 id="1-3线程的生命周期"><a href="#1-3线程的生命周期" class="headerlink" title="1.3线程的生命周期"></a>1.3线程的生命周期</h3><p><img src="/2022/10/03/Java%E9%AB%98%E7%BA%A7-%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%B8%B8%E7%94%A8%E7%B1%BB-%E6%9E%9A%E4%B8%BE%E7%B1%BB%E4%B8%8E%E6%B3%A8%E8%A7%A3/Snipaste_2022-01-23_15-11-45.png" alt="Snipaste_2022-01-23_15-11-45"></p><h3 id="1-4线程的同步"><a href="#1-4线程的同步" class="headerlink" title="1.4线程的同步"></a>1.4线程的同步</h3><h4 id="1-火车卖票问题"><a href="#1-火车卖票问题" class="headerlink" title="1.火车卖票问题"></a>1.火车卖票问题</h4><p>1.引入例子：</p><p><strong>使用实现Runnable类的方式</strong>，创建三个窗口卖票，总票数为100张</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Windows</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">//Thread.sleep(100); --sleep会抛异常，写时得解决     System.out.println(Thread.currentThread().getName() + &quot;票号：&quot; + ticket);</span></span><br><span class="line">                ticket--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">sellTticket</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">Windows</span> <span class="variable">win</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Windows</span>();</span><br><span class="line"></span><br><span class="line">      <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(win);</span><br><span class="line">      <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(win);</span><br><span class="line">      <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(win);</span><br><span class="line">      t1.setName(<span class="string">&quot;窗口一&quot;</span>);</span><br><span class="line">      t2.setName(<span class="string">&quot;窗口二&quot;</span>);</span><br><span class="line">      t3.setName(<span class="string">&quot;窗口三&quot;</span>);</span><br><span class="line">      t1.start();</span><br><span class="line">      t2.start();</span><br><span class="line">      t3.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>使用继承于Thread类的方式</strong>，创建三个窗口卖票，总票数为100张</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WindowTwo</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">ticket1</span> <span class="operator">=</span> <span class="number">100</span>; <span class="comment">//为了保证多个窗口票数同步，使用static</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ticket1 &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;票号：&quot;</span> + ticket1);</span><br><span class="line">                ticket1--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">sellTticket</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">WindowTwo</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WindowTwo</span>();</span><br><span class="line">        <span class="type">WindowTwo</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WindowTwo</span>();</span><br><span class="line">        <span class="type">WindowTwo</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WindowTwo</span>();</span><br><span class="line"></span><br><span class="line">        t1.setName(<span class="string">&quot;窗口一&quot;</span>);</span><br><span class="line">        t2.setName(<span class="string">&quot;窗口二&quot;</span>);</span><br><span class="line">        t3.setName(<span class="string">&quot;窗口三&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>2.存在问题：</strong></p><ol><li><p>问题：</p><ul><li><p><strong>卖票过程中，都出现重票、错票–&gt;出现了线程的安全问题</strong></p></li><li><p><strong>可以在卖票过程中加个阻塞，问题更加明显</strong></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">       <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">       Thread.sleep(<span class="number">100</span>); <span class="comment">//sleep会抛异常，写时得解决    System.out.println(Thread.currentThread().getName() + &quot;票号：&quot; + ticket);</span></span><br><span class="line">            ticket--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>出现问题的原因：当某个线程操作车票的过程中，尚未操作完成，其他线程参与进来，操作车票</p></li><li><p>如何解决：；当一个线程a在操作ticket的时候，其他线程不能参与进来。直到线程a操作完成ticket时，其他线程才可以开始操作，这种情况即使线程a出现了阻塞，也不能改变。（相当于给厕所装个锁）</p></li></ol><h4 id="2-解决问题方式一"><a href="#2-解决问题方式一" class="headerlink" title="2.解决问题方式一"></a>2.解决问题方式一</h4><p><strong>1.介绍</strong></p><p>在Java中，我们通过同步机制，来解决线程的安全问题</p><p><strong>《方式一：同步代码块》</strong></p><p>synchronized (同步监视器){</p><p>&#x2F;&#x2F;需要被同步的代码—-<strong>不能多也不能少</strong></p><p><strong>包少：一些共享数据还是会出现线程安全问题</strong></p><p><strong>包多：首先单线程效率会变低，其次，例如：卖票问题，如果包了while(true),就会一个窗口把票都卖了，不满足题意</strong></p><p>}</p><p>说明：</p><ol><li><p>操作<strong>共享数据</strong>的代码，即为需要被同步的代码</p></li><li><p>共享数据：多个线程共同操作的变量。比如：ticket就是共享数据</p></li><li><p>同步监视器，俗称：锁。<strong>任何一个类的对象</strong>，都可以充当锁</p><p>要求：<strong>多个线程必须要共用同一把锁</strong>（不能声明在run方法）</p></li></ol><p><strong>2.解决实现类的卖票</strong></p><p>该方式的问题通常在处理同步监视器，以及括号包含的需要被同步的代码上，不能多也不能少。</p><p>同步监视器：实现类可以直接使用this关键字充当当前对象，因为在main方法中只创建了一个该类的对象，所以多个线程使用的是同一个this。当然，也可以通过造一个对象在该类中</p><p>代码演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span>  <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span> ( ) ;<span class="comment">//不能声明在方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;    </span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"><span class="comment">//    synchronized( obj )&#123;   //方式一 使用万能的obj</span></span><br><span class="line">    <span class="keyword">synchronized</span>( <span class="built_in">this</span> )&#123;   <span class="comment">//方式二  直接使用当前对象 this （不用在去new对象）</span></span><br><span class="line">        <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="comment">//Thread.sleep(100); --sleep会抛异常，写时得解决     System.out.println(Thread.currentThread().getName() + &quot;票号：&quot; + ticket);</span></span><br><span class="line">            ticket--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3.解决继承Thread卖票</strong></p><p>因为其一个窗口造一个对象，使用造新对象的方式充当当前对象去作为同步监视器，该对象得声明成static类型的，这样多个窗口才能使用同一个对象</p><p>当然，<strong>也有不用造新对象的方法，直接用 “ 类名 . class ” 充当当前对象作为同步监视器 ，因为类只加载一次，也可以充当对象使用–即所有都是面向对象</strong></p><p>代码演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Object <span class="type">static</span>  <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span> ( ) ;<span class="comment">//不能声明在方法，static的</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"><span class="comment">//    synchronized( obj )&#123;   //方式一  造object对象</span></span><br><span class="line"><span class="keyword">synchronized</span>( WindowTwo.class )&#123;   <span class="comment">//方式二  使用此类对象充当当前对象</span></span><br><span class="line"> <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="comment">//Thread.sleep(100); --sleep会抛异常，写时得解决     System.out.println(Thread.currentThread().getName() + &quot;票号：&quot; + ticket);</span></span><br><span class="line">  ticket--;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="3-解决问题方式二"><a href="#3-解决问题方式二" class="headerlink" title="3.解决问题方式二"></a>3.解决问题方式二</h4><p><strong>1.介绍</strong></p><p>此方式为《同步方法》同样说明与《同步代码块》一样，也是使用的synchronized，也是得有共享数据。也是要求synchronized覆盖的括号内不能有代码不能多也不能少。</p><p>关于同步方法的总结：</p><ol><li><p><strong>同步方法仍然涉及到同步监视器</strong>，只是<strong>不需要我们显式的声明</strong></p></li><li><p><strong>非静态的同步方法，同步监视器是：this</strong></p><p><strong>静态的同步方法，同步监视器是：当前类本身</strong></p></li></ol><p><strong>2.解决实现类的卖票</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//run中无多余代码-------使用非静态的同步方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">run</span> <span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//共享数据被操作的代码</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//如果run又包含了多余的代码，则需要将共享数据被操作的代码封装到另外的方法中，且在该方法声明使用时synchronized。然后在run中调用此方法。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">void</span>  <span class="title function_">run</span> <span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            show();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;<span class="comment">//同步监视器：this</span></span><br><span class="line"><span class="comment">//共享数据被操作的代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>2.解决继承Thread卖票</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//run中无多余代码-------使用静态的同步方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">run</span> <span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//共享数据被操作的代码</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果run又包含了多余的代码，则需要将共享数据被操作的代码封装到另外的方法中，且在该方法声明使用时synchronized。然后在run中调用此方法。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">void</span>  <span class="title function_">run</span> <span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            show();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;<span class="comment">//同步监视器：当前类本身</span></span><br><span class="line"><span class="comment">//共享数据被操作的代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="4-解决问题的利弊"><a href="#4-解决问题的利弊" class="headerlink" title="4.解决问题的利弊"></a>4.解决问题的利弊</h4><p>同步的方式，解决了线程的安全问题。—-好处</p><p>操作同步代码时，只能有一个线程参与，其他线程等待。相当于是一个单线程的过程，效率低——坏处</p><h4 id="5-在谈单例模式懒汉式"><a href="#5-在谈单例模式懒汉式" class="headerlink" title="5.在谈单例模式懒汉式"></a>5.在谈单例模式懒汉式</h4><p>由于面向对象（下）讲过单例模式的懒汉式，其中<strong>存在线程不安全问题，现在利用线程同步的解决不安全问题</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bank</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Bank</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Bank</span>  <span class="variable">instance</span>  <span class="operator">=</span> <span class="literal">null</span> ;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Bank <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Bank</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">//多个线程可能同时进入，造了多个对象</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>方式一同步代码块改进：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bank</span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Bank</span>  <span class="variable">instance</span>  <span class="operator">=</span> <span class="literal">null</span> ;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Bank</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">//第一种：效率稍低</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Bank <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(Bank.class)&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123; </span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Bank</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">//因为一个线程拿到锁后造了对象走了，其他线程还在等待，后再拿锁</span></span><br><span class="line">    </span><br><span class="line">     <span class="comment">//第二种：效率稍高</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> Bank <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(instance == <span class="literal">null</span>)</span><br><span class="line">    <span class="keyword">synchronized</span>(Bank.class)&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Bank</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;<span class="comment">//因为一个线程拿锁造对象走了，别的线程判断一下就走了，不用在等待拿锁</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方式二同步方法改进：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bank</span> &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Bank</span>  <span class="variable">instance</span>  <span class="operator">=</span> <span class="literal">null</span> ;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Bank</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Bank <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Bank</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="6-死锁问题"><a href="#6-死锁问题" class="headerlink" title="6.死锁问题"></a>6.死锁问题</h4><p><strong>1.介绍</strong></p><p><strong>不同线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁</strong></p><p><strong>2.说明</strong></p><ol><li>出现死锁后，不会出现异常，不会出现提示，知识所有的线程都处于阻塞状态，无法继续</li><li>我们使用同步时，要避免出现死锁</li></ol><p>解决方法：</p><ol><li>专门的算法、原则</li><li><strong>尽量减少同步资源</strong>的定义</li><li><strong>尽量避免嵌套同步</strong></li></ol><p>代码演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="type">Object</span> <span class="variable">obj2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(obj1)&#123;</span><br><span class="line">     <span class="comment">// 执行一些代码</span></span><br><span class="line">      <span class="keyword">synchronized</span>(obj2)&#123;  <span class="comment">//拿了1等2</span></span><br><span class="line">    <span class="comment">//    在执行一些代码</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.start();</span><br><span class="line"><span class="comment">//上面拿了obj1下面拿了obj2，接下来又嵌套了一层，且他们需要的锁相反，都在等待对方先给锁----这演示的是最简单的死锁--可以将一个锁封装为方法，调用</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>()&#123;<span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(obj2)&#123;</span><br><span class="line">      <span class="comment">//执行一些代码</span></span><br><span class="line">      <span class="keyword">synchronized</span>(obj1)&#123;  <span class="comment">//拿了2等1</span></span><br><span class="line">       <span class="comment">// 在执行一些代码</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; ).start();</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="7-解决问题方式三"><a href="#7-解决问题方式三" class="headerlink" title="7.解决问题方式三"></a>7.解决问题方式三</h4><p>解决线程安全问题的方式三：Lock锁—-JDK 5.0新增</p><ol><li><strong>实例化ReentrantLock(若是继承的方式，则实例化对象得是static的)</strong></li><li>调用锁定方法Lock( ) </li><li>调用解锁方法unlock</li></ol><p>代码演示：</p><p>下面实现类方式演示，(若是继承的方式，则实例化对象得是static的，为了使每个线程的Lock一样）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Window</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="comment">//实例化ReentrantLock</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>( );</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;    </span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"><span class="keyword">try</span>&#123;  <span class="comment">//用try包裹共享数据被操作的代码，最后用finally调用方法解锁</span></span><br><span class="line">lock.lock();<span class="comment">//调用锁定方法Lock( ) </span></span><br><span class="line">    <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">//Thread.sleep(100); --sleep会抛异常，写时得解决     System.out.println(Thread.currentThread().getName() + &quot;票号：&quot; + ticket);</span></span><br><span class="line">              ticket--;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">     lock.unlock();<span class="comment">//调用解锁方法unlock</span></span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>面试题：</p><ol><li><p>synchronized 与Lock 的异同？</p><p>相同：二者都可以解决线程安全问题</p><p>不同：synchronized机制在执行完相应的同步代码以后，自动的释放同步锁</p><p>​            Lock 需要手动的启动同步（Lock( ) ），同时结束同步也需要手动释放</p></li><li><p>如何解决线程安全问题？有几种方式</p></li></ol><p><strong>优先使用顺序：</strong></p><p><strong>Lock —&gt; 同步代码块（已经进入了方法体，分配了相应资源）—&gt;同步方法</strong>                                                                                                                                                                                                                                                                                                                                        </p><h3 id="1-5线程的通信"><a href="#1-5线程的通信" class="headerlink" title="1.5线程的通信"></a>1.5线程的通信</h3><h4 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h4><ol><li>线程之间通信的两个基本问题是互斥和同步。</li><li>线程同步是指线程之间所具有的一种制约关系，<strong>一个线程的执行依赖另一个线程的消息</strong>，当它没有得到另一个线程的消息时应等待，直到消息到达时才被唤醒。</li><li>线程互斥是指对于共享的操作系统资源，在各线程访问时的排它性。当有若干个线程都要使用某一共享资源时，任何时刻最多只允许一个线程去使用，其它要使用该资源的线程必须等待，直到占用资源者释放该资源。</li></ol><h4 id="2-涉及三个方法"><a href="#2-涉及三个方法" class="headerlink" title="2.涉及三个方法"></a>2.涉及三个方法</h4><p>1.wati() :一旦执行此方法，当前<strong>线程就进入阻塞状态，并释放同步监视器</strong></p><p>2.notify() ：一旦执行此方法，就会<strong>唤醒被wait 的一个</strong>线程，如有多个线程被wait ，就唤醒优先级高的线程</p><p>3.notifyAll()：一旦执行此方法，就会<strong>唤醒所有</strong>被wait 的线程</p><p>说明：</p><ol><li><p>wait() 、notify()、notifyAll(<strong>) 三个方法必须使用在同步代码块中或同步方法中</strong></p></li><li><p>wait() 、notify()、notifyAll() 三个方法的<strong>调用者必须是同步代码块或同步方法中的同步监视器</strong>，否则，会出现IllegalMonitorStateExcption异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (<span class="built_in">this</span>)&#123;</span><br><span class="line"><span class="comment">//或synchronized (obj)</span></span><br><span class="line">    <span class="built_in">this</span>.notify();。</span><br><span class="line">  <span class="comment">//或  obj.wait();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>wait() 、notify()、notifyAll() 三个方法是定义在java.lang.Object类中</strong>（因为这三个方法只能在同步代码块或同步方法中使用，又同步监视器可以是任何的一个类，所以就将这三方法定义在Object类中）</p></li></ol><h4 id="3-sleep-和wait-的区别"><a href="#3-sleep-和wait-的区别" class="headerlink" title="3.sleep()和wait()的区别"></a>3.sleep()和wait()的区别</h4><ol><li>相同点：一旦执行方法，都可以使得当前的<strong>线程进入阻塞状态</strong></li><li>不同点：<ol><li><strong>两个方法声明的位置不同</strong>：sleep() 声明在Thread类中，wait() 声明在Object类中</li><li><strong>调用的要求不同</strong>：sleep() 可以在任何需要的场景下调用。wait() 必须在同步代码块或同步方法中</li><li><strong>关于是否释放同步监视器</strong>：如果两个方法都使用在同步代码块或同步方法中，sleep()不会释放锁，wait()会释放锁（同步监视器）。</li></ol></li></ol><h4 id="4-生产者和消费者例题"><a href="#4-生产者和消费者例题" class="headerlink" title="4.生产者和消费者例题"></a>4.生产者和消费者例题</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">线程通信的应用：经典例题：生产者/消费者问题</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 生产者(Productor)将产品交给店员(Clerk)，而消费者(Customer)从店员处取走产品，</span></span><br><span class="line"><span class="comment">* 店员一次只能持有固定数量的产品(比如:20），如果生产者试图生产更多的产品，店员</span></span><br><span class="line"><span class="comment">* 会叫生产者停一下，如果店中有空位放产品了再通知生产者继续生产；如果店中没有产品</span></span><br><span class="line"><span class="comment">* 了，店员会告诉消费者等一下，如果店中有产品了再通知消费者来取走产品。</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 分析：</span></span><br><span class="line"><span class="comment">* 1. 是否是多线程问题？是，生产者线程，消费者线程</span></span><br><span class="line"><span class="comment">* 2. 是否有共享数据？是，店员（或产品）</span></span><br><span class="line"><span class="comment">* 3. 如何解决线程的安全问题？同步机制,有三种方法</span></span><br><span class="line"><span class="comment">* 4. 是否涉及线程的通信？是</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>代码演示：</p><p>讲解：细节在于两者class Clerk中的两个方法。生产者消费者Clerk是同一个对象，使用同步方法解决线程安全问题，生产者消费者用的也是同一个同步监视器this，因此生产消费不会同时进行。</p><p>根据题目供给关系，产多不产，没了不卖。即当产品大于20，生产者被wait，释放锁。这时消费者拿锁，生产完后notify解锁一个生产者去生产，若生产速度等于消费速度，则会保持平衡</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Clerk</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">productCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//生产产品</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">produceProduct</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(productCount &lt; <span class="number">20</span>)&#123;</span><br><span class="line">            productCount++;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:开始生产第&quot;</span> + productCount + <span class="string">&quot;个产品&quot;</span>);</span><br><span class="line"></span><br><span class="line">            notify();</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//等待</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//消费产品</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">consumeProduct</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(productCount &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:开始消费第&quot;</span> + productCount + <span class="string">&quot;个产品&quot;</span>);</span><br><span class="line">            productCount--;</span><br><span class="line"></span><br><span class="line">            notify();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//等待</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Producer</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;<span class="comment">//生产者</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Clerk clerk;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Producer</span><span class="params">(Clerk clerk)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.clerk = clerk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(getName() + <span class="string">&quot;:开始生产产品.....&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            clerk.produceProduct();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Consumer</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;<span class="comment">//消费者</span></span><br><span class="line">    <span class="keyword">private</span> Clerk clerk;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Consumer</span><span class="params">(Clerk clerk)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.clerk = clerk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(getName() + <span class="string">&quot;:开始消费产品.....&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">20</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            clerk.consumeProduct();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Clerk</span> <span class="variable">clerk</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Clerk</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Producer</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Producer</span>(clerk);</span><br><span class="line">        p1.setName(<span class="string">&quot;生产者1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Consumer</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Consumer</span>(clerk);</span><br><span class="line">        c1.setName(<span class="string">&quot;消费者1&quot;</span>);</span><br><span class="line">        <span class="type">Consumer</span> <span class="variable">c2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Consumer</span>(clerk);</span><br><span class="line">        c2.setName(<span class="string">&quot;消费者2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        p1.start();</span><br><span class="line">        c1.start();</span><br><span class="line">        c2.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="5-会释放锁的操作"><a href="#5-会释放锁的操作" class="headerlink" title="5.会释放锁的操作"></a>5.会释放锁的操作</h4><ul><li>当前线程的同步方法、同步代码块执行结束。</li><li>当前线程在同步代码块、同步方法中遇到break、return终止了该代码块、该方法的继续执行。</li><li>当前线程在同步代码块、同步方法中出现了未处理的Error或Exception，导致异常结束。</li><li>当前线程在同步代码块、同步方法中执行了线程对象的waito）方法，当前线程暂停，并释放锁。</li></ul><h4 id="6-不会释放锁的操作"><a href="#6-不会释放锁的操作" class="headerlink" title="6.不会释放锁的操作"></a>6.不会释放锁的操作</h4><ul><li>线程执行同步代码块或同步方法时，程序调用Thread.sleep ( ) 、Thread.yield ( )方法暂停当前线程的执行</li><li>线程执行同步代码块时，其他线程调用了该线程的suspend ( ) 方法将该线程挂起，该线程不会释放锁（同步监视器）。</li></ul><blockquote><p>应尽量避免使用suspend（）和resume（）来控制线程</p></blockquote><h3 id="1-6创建线程的方式三"><a href="#1-6创建线程的方式三" class="headerlink" title="1.6创建线程的方式三"></a>1.6创建线程的方式三</h3><h4 id="1-实现Callable接口"><a href="#1-实现Callable接口" class="headerlink" title="1.实现Callable接口"></a>1.实现Callable接口</h4><p>实现Callable接口。 — JDK 5.0新增</p><p>说明：</p><ol><li><p><strong>创建实现类实现Callable接口，并重写call方法</strong>（该方法返回值类型是Object，所以是可以返回任何类型，且是可以抛出异常的。）</p></li><li><p>new一个实现类对象，将实现类对象作为实参new一个FutureTask对象。</p></li><li><p>将FutureTask对象作为实参，new一个Thread来调用start()方法。（Thread构造器也是用Runnable类型接受的，实际上FutureTask也实现了Runnable接口）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">NumThread</span> <span class="variable">numThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NumThread</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">FutureTask</span> <span class="variable">futureTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FutureTask</span>(numThread);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask).start();</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h4 id="2-代码演示"><a href="#2-代码演示" class="headerlink" title="2.代码演示"></a>2.代码演示</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建一个实现Callable的实现类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NumThread</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&#123;</span><br><span class="line">    <span class="comment">//2.实现call方法，将此线程需要执行的操作声明在call()中</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadNew</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//3.创建Callable接口实现类的对象</span></span><br><span class="line">        <span class="type">NumThread</span> <span class="variable">numThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NumThread</span>();</span><br><span class="line">        <span class="comment">//4.将此Callable接口实现类的对象作为传递到FutureTask构造器中，创建FutureTask的对象</span></span><br><span class="line">        <span class="type">FutureTask</span> <span class="variable">futureTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FutureTask</span>(numThread);</span><br><span class="line">        <span class="comment">//5.将FutureTask的对象作为参数传递到Thread类的构造器中，创建Thread对象，并调用start()</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//6.获取Callable中call方法的返回值，如不想有返回值，可以在重写call方法时返回null。</span></span><br><span class="line">            <span class="comment">//get()返回值即为FutureTask构造器参数Callable实现类重写的call()的返回值。</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">sum</span> <span class="operator">=</span> futureTask.get();</span><br><span class="line">            System.out.println(<span class="string">&quot;总和为：&quot;</span> + sum);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-7创建线程的方式四"><a href="#1-7创建线程的方式四" class="headerlink" title="1.7创建线程的方式四"></a>1.7创建线程的方式四</h3><h4 id="1-线程池"><a href="#1-线程池" class="headerlink" title="1.线程池"></a>1.线程池</h4><p><strong>背景</strong>：经常创建和销毁、使用量特别大的资源，比如并发情况下的线程，</p><p>对性能影响很大。 </p><p><strong>思路</strong>：提前创建好多个线程，放入线程池中，使用时直接获取，使用完</p><p>放回池中。可以避免频繁创建销毁、实现重复利用。类似生活中的公共交</p><p>通工具。</p><p><strong>好处</strong>：</p><ol><li>提高响应速度（减少了创建新线程的时间）</li><li>降低资源消耗（重复利用线程池中线程，不需要每次都创建）</li><li>便于线程管理<ol><li>corePoolSize：核心池的大小</li><li>maximumPoolSize：最大线程数 </li><li>keepAliveTime：线程没有任务时最多保持多长时间后会终止</li></ol></li></ol><h4 id="2-说明："><a href="#2-说明：" class="headerlink" title="2.说明："></a>2.说明：</h4><p>1.创建线程池：提供指定线程数量的线程池</p><p>方式一：</p><ul><li>ThreadPoolExecutor service &#x3D; new ThreadPoolExecutor(CORE_POOL_SIZE)</li></ul><p>方式二：</p><ul><li><p>Executors 工具类，可以直接调用里面的静态方法（newFixedThreadPool）。返回值是ThreadPoolExecutor，它继承了AbstractExecutorService，这个类实现了ExecutorService接口</p></li><li><p>ExecutorService接口（execute()、submit()、shutdown()、shutdownNow()都是这个接口中的方法）</p></li></ul><ol start="2"><li>向线程池提交任务（实现Runnable接口的run方法的类）–可提交多次</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">service.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;适合使用于Runnable</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    ... <span class="comment">// 线程执行的任务</span></span><br><span class="line">&#125;&#125;);</span><br><span class="line"> <span class="comment">//service.submit(Callable callable);//适合使用于Callable</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>3.关闭线程池</p><p>service.shutdown(); </p><ul><li><strong>设置线程池的状态为SHUTDOWN，然后中断所有没有正在执行任务的线程</strong></li></ul><p>service.shutdownNow(); </p><ul><li><strong>设置线程池的状态为 STOP，然后尝试停止所有的正在执行或暂停任务的线程，并返回等待执行任务的列表</strong></li></ul><h4 id="3-代码演示"><a href="#3-代码演示" class="headerlink" title="3.代码演示"></a>3.代码演示</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumberThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt;= <span class="number">100</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: &quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NumberThread1</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt;= <span class="number">100</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> != <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: &quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPool</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//1. 提供指定线程数量的线程池</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">service1</span> <span class="operator">=</span> (ThreadPoolExecutor) service;</span><br><span class="line">        <span class="comment">//设置线程池的属性</span></span><br><span class="line"><span class="comment">//        System.out.println(service.getClass());</span></span><br><span class="line"><span class="comment">//        service1.setCorePoolSize(15);</span></span><br><span class="line"><span class="comment">//        service1.setKeepAliveTime();</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.执行指定的线程的操作。需要提供实现Runnable接口或Callable接口实现类的对象</span></span><br><span class="line">        service.execute(<span class="keyword">new</span> <span class="title class_">NumberThread</span>());<span class="comment">//适合适用于Runnable</span></span><br><span class="line">        service.execute(<span class="keyword">new</span> <span class="title class_">NumberThread1</span>());<span class="comment">//适合适用于Runnable</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        service.submit(Callable callable);//适合使用于Callable</span></span><br><span class="line">        <span class="comment">//3.关闭连接池</span></span><br><span class="line">        service.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="二、常用类"><a href="#二、常用类" class="headerlink" title="二、常用类"></a>二、常用类</h1><h3 id="2-1String"><a href="#2-1String" class="headerlink" title="2.1String"></a>2.1String</h3><h4 id="1-String详细介绍"><a href="#1-String详细介绍" class="headerlink" title="1.String详细介绍"></a>1.String详细介绍</h4><ol><li><p>String:字符串，使用一对””引起来表示。</p></li><li><p>String声明为final的，不可被继承</p></li><li><p>String实现了Serializable接口：表示字符串是支持序列化的。</p><p>​          实现了Comparable接口：表示String可以比较大小</p></li><li><p>String内部定义了final char[] value用于存储字符串数据</p></li><li><p>String:代表不可变的字符序列。简称：不可变性。</p><p><strong>体现：</strong> </p><ol><li><p>当对字符串<strong>重新赋值</strong>时，<strong>需要重写指定内存区域赋值</strong>，不能使用原有的value进行赋值。</p><p>String s1 &#x3D; “abc”;   s1 &#x3D; “hello”;</p></li><li><p>当对现有的字符串进行<strong>连接操作</strong>时，也<strong>需要重新指定内存区域赋值</strong>，不能使用原有的value进行赋值。</p><p>String s3 &#x3D; “ wwe;   s3 +&#x3D;s1;</p></li><li><p>当调用String的replace()方法<strong>修改指定字符或字符串</strong>时，<strong>也需要重新指定内存区域赋值</strong>，不能使用原有的value进行赋值。  String s4 &#x3D; “abc”;  String s5 &#x3D; s4.replace(‘a’, ‘m’);&#x2F;&#x2F;左老右新</p></li></ol></li><li><p>通过<strong>字面量的方式（区别于new）</strong>给一个字符串赋值，此时的字符串值声明在字符串常量池中。（下结详细讲解）</p></li><li><p><strong>字符串常量池中是不会存储相同内容的字符串的（有复用性）</strong>。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;<span class="comment">//字面量的定义方式</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">System.out.println(s1 == s2); <span class="literal">true</span><span class="comment">//比较s1和s2的地址值</span></span><br><span class="line">s1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">System.out.println(s1 == s2); <span class="literal">false</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="2-String两种实例化区别"><a href="#2-String两种实例化区别" class="headerlink" title="2.String两种实例化区别"></a>2.String两种实例化区别</h4><p>String的实例化方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式一：通过字面量定义的方式</span></span><br><span class="line"><span class="type">String</span>  <span class="variable">s1</span>  <span class="operator">=</span>  <span class="string">&quot;javaEE &quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式二：通过new + 构造器的方式</span></span><br><span class="line"><span class="type">String</span>  <span class="variable">s3</span>  <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">String</span> ( <span class="string">&quot;javaEE &quot;</span> );</span><br></pre></td></tr></table></figure><p> 不同点：</p><ol><li>字面量定义的方式是在方法区常量池中开辟空间存放字符，<strong>栈空间中声明的对象直接指向常量池的字符串</strong></li><li>构造器方式是在方法区常量池中查找有无一样的字符串，没有则开辟新空间存放字符，栈空间指向堆中新造的对象实例，堆空间String类对象实例指向常量池中声明char数组存储的字符串</li></ol><p>相同点：<strong>字符都是存放在常量池中，只不过一个直接获取，一个是间接获取</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;java&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">System.out.print(str1==str2); <span class="comment">//false str1是常量池中字符串地址，str2是堆空间中对象实例的地址</span></span><br></pre></td></tr></table></figure><p><img src="/2022/10/03/Java%E9%AB%98%E7%BA%A7-%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%B8%B8%E7%94%A8%E7%B1%BB-%E6%9E%9A%E4%B8%BE%E7%B1%BB%E4%B8%8E%E6%B3%A8%E8%A7%A3/Snipaste_2022-01-26_10-21-28.png" alt="Snipaste_2022-01-26_10-21-28">面试题：</p><ol><li><p>面试题：String s &#x3D; new String(“abc”);方式创建对象，在内存中创建了几个对象？两个。一个是堆空间中new结构，另一个是char[]对应的常量池中的数据：”abc”</p></li><li><p><strong>引用数据类型通过值传递来改变本身数据，值传递传的是地址。但是对于String类型有不可变性，传递地址到形参，修改数据也只是在常量池新造的，原本的数据没有被修改</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">面试题：</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;good&quot;</span>);</span><br><span class="line">    <span class="type">char</span>[] ch = &#123; <span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;s&#x27;</span>, <span class="string">&#x27;t&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">(String str, <span class="type">char</span> ch[])</span> &#123;</span><br><span class="line">        str = <span class="string">&quot;test ok&quot;</span>;</span><br><span class="line">        ch[<span class="number">0</span>] = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">StringTest</span> <span class="variable">ex</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringTest</span>();</span><br><span class="line">        ex.change(ex.str, ex.ch);</span><br><span class="line">        System.out.println(ex.str);<span class="comment">//good</span></span><br><span class="line">        System.out.println(ex.ch);<span class="comment">//best</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h4 id="3-String不同连接操作"><a href="#3-String不同连接操作" class="headerlink" title="3.String不同连接操作"></a>3.String不同连接操作</h4><p>结论：</p><ol><li><p><strong>常量与常量的拼接结果在常量池</strong>。且常量池中不会存在相同内容的常量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;javaEEhadoop&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;javaEE&quot;</span> + <span class="string">&quot;hadoop&quot;</span>;</span><br><span class="line">System.out.println(s3 == s4);<span class="comment">//true 地址一样</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><strong>只要其中有一个是变量，结果就在堆中</strong>。（相当于new的方式）</p><p>内存解析：在方法区常量池中查找有无一样的字符串，没有则开辟新空间存放字符，栈空间指向堆中新造的对象实例，堆空间String类对象实例指向常量池中声明char数组存储的字符串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;javaEE&quot;</span>;</span><br><span class="line">   <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;hadoop&quot;</span>;</span><br><span class="line">   <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;javaEEhadoop&quot;</span>;</span><br><span class="line">   <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> s1 + <span class="string">&quot;hadoop&quot;</span>;</span><br><span class="line">   <span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> <span class="string">&quot;javaEE&quot;</span> + s2;</span><br><span class="line">   <span class="type">String</span> <span class="variable">s6</span> <span class="operator">=</span> s1 + s2;</span><br><span class="line">   <span class="comment">//3、4、5、6、地址值各不相同。带变量的相当于new了空间在堆中</span></span><br><span class="line">   </span><br></pre></td></tr></table></figure></li><li><p><strong>拼接问题调用intern()方法（String中的方法），字符返回值就在常量池中</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">   <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;javaEE&quot;</span>;</span><br><span class="line">   <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;javaEEhadoop&quot;</span>;</span><br><span class="line">   <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> s1 + <span class="string">&quot;hadoop&quot;</span>;</span><br><span class="line">   <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> s3.intern();<span class="comment">//返回值得到的s4使用的常量池中已经存在的“javaEEhadoop”</span></span><br><span class="line">   System.out.println(s4 == s2);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">####  面试题：</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line"><span class="type">String</span>  <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;javaEEhadoop&quot;</span> ;</span><br><span class="line"><span class="keyword">final</span>  <span class="type">String</span>  <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;javaEE&quot;</span> ;  <span class="comment">//加上final 就成常量了</span></span><br><span class="line"><span class="type">String</span>  <span class="variable">s3</span>  <span class="operator">=</span>  s2  +  <span class="string">&quot;hadoop&quot;</span> ; <span class="comment">//这里相加就是在常量池中的，地址值一样</span></span><br><span class="line"></span><br><span class="line">System.out.println(s1 == s3);  <span class="comment">//true</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="4-JVM字符串常量池存放位置说明"><a href="#4-JVM字符串常量池存放位置说明" class="headerlink" title="4.JVM字符串常量池存放位置说明"></a>4.JVM字符串常量池存放位置说明</h4><p>JDK 1.6(JDK 6.0 ,java 6.0)：字符串常量池存储在方法区（具体体现是：永久区）</p><p>JDK 1.7 ：字符串常量池存储在堆空间</p><p>JDK 1.8 ：字符串常量池存储在方法区（改名为元空间）</p><h4 id="5-String常用方法"><a href="#5-String常用方法" class="headerlink" title="5.String常用方法"></a>5.String常用方法</h4><p><strong>1.一档</strong></p><ol><li><p>int length()：</p><p>返回字符串的<strong>长度</strong>： return value.length</p><p>String s1 &#x3D; “aBc” ;  int len &#x3D; s1.length();</p></li><li><p>char charAt(int index)：</p><p>返回某<strong>索引处的字符</strong>return value[index]</p><p>String s1 &#x3D; “aBc” ;  char ch &#x3D; charAt(0) ; &#x2F;&#x2F;a</p></li><li><p>boolean isEmpty()：</p><p>判断<strong>是否是空</strong>字符串：return value.length &#x3D;&#x3D; 0</p><p>String s1 &#x3D; “aBc” ;  boolean bo &#x3D; s1.isEmpty(); &#x2F;&#x2F; fasle</p></li><li><p>String toLowerCase()：</p><p>使用默认语言环境，将 String 中的所有字符转换为<strong>小写</strong>   String   s2 &#x3D; s1.toLowerCase();</p></li><li><p>String toUpperCase()：</p><p>使用默认语言环境，将 String 中的所有字符转换为<strong>大写</strong>String   s2 &#x3D; s1.toUpperCase();</p></li><li><p>String trim()：</p><p>返回字符串的副本，忽略前导空白和尾部空白</p><p><strong>去掉字符串头尾的空格</strong></p></li><li><p>boolean equals(Object obj)：</p><p>比较字符串的<strong>内容是否相同</strong></p></li><li><p>boolean equalsIgnoreCase(String anotherString)：</p><p>与equals方法类似，<strong>忽略大小写</strong></p></li><li><p>String concat(String str):</p><p>将指定<strong>字符串连接到此字符串的结尾</strong>。 等价于用“+”</p></li><li><p>int compareTo(String anotherString)：</p><p>比较两个<strong>字符串的大小</strong></p><p>s1.compareTo(s2);</p><p>比较Ascll值，用调用者减实参，返回正数，调用者大，否则实参大</p></li><li><p>String substring(int beginIndex)：</p><p><strong>返回一个新的字符串，它是此字符串的从beginIndex开始截取到最后的一个子字符串。</strong></p></li><li><p>String substring(int beginIndex, int endIndex) ：</p><p>返回一个新字符串，它是此<strong>字符串从beginIndex开始截取到endIndex(不包含)的一个子字符串。[ a ,  b)</strong></p></li></ol><p><strong>2.二档</strong></p><ol><li><p>boolean endsWith(String suffix)：</p><p>测试此字符串是否以指定的后缀结束<br>String str1 &#x3D; “hellowworld”;<br>boolean b1 &#x3D; str1.endsWith(“rld”);&#x2F;&#x2F;可是多个字符</p></li><li><p>boolean startsWith(String prefix)：</p><p>测试此字符串是否以指定的前缀开始</p></li><li><p>boolean startsWith(String prefix, int toffset)：</p><p>测试此字符串从指定索引 ( 包含 ) 开始的子字符串是否以指定前缀开始</p></li><li><p>boolean contains(CharSequence s)：</p><p>当且仅当此字符串包含指定的 char 值序列时（字符匹配），返回 true<br>String str1 &#x3D; “hellowworld”;<br>String str2 &#x3D; “wor”;<br>System.out.println(str1.contains(str2));&#x2F;&#x2F;ture</p></li><li><p>int indexOf(String str)：</p><p>返回指定子字符串在此字符串中第一次出现处的索引（从左往右）</p></li><li><p>int indexOf(String str, int fromIndex)：</p><p>返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始</p></li><li><p>int lastIndexOf(String str)：</p><p>返回指定子字符串在此字符串中最右边出现处的索引</p></li><li><p>int lastIndexOf(String str, int fromIndex)：</p><p>返回指定子字符串在此字符串中最后一次出现处的索引，从指定的索引开始反向搜索</p></li><li><p>注：indexOf和lastIndexOf方法如果未找到都是返回-1</p></li><li><p>什么情况下，indexOf(str)和lastIndexOf(str)返回值相同？<br>情况一：存在唯一的一个str。情况二：不存在str</p></li></ol><p><strong>3.三档</strong></p><p><strong>替换：</strong></p><ol><li><p>String replace(char oldChar, char newChar)：</p><p>返回一个新的字符串，它是通过用 newChar <strong>替换此字符串中出现的所有 oldChar 得到的。</strong><br>String str1 &#x3D; “北京尚硅谷教育北京”;<br>String str2 &#x3D; str1.replace(‘北’, ‘东’);</p></li><li><p>String replace(CharSequence target, CharSequence replacement)：</p><p>使用指定的字面值替换序列替换此字符串所有匹配字面值目标序列的子字符串。<br>String str3 &#x3D; str1.replace(“北京”, “上海”);</p></li><li><p>String replaceAll(String regex, String replacement)：</p><p>使用给定的 replacement 替换此字符串所有匹配给定的<strong>正则表达式</strong>的子字符串。<br>&#x2F;&#x2F;把字符串中的数字替换成,，如果结果中开头和结尾有，的话去掉<br>String str &#x3D; “12hello34world5java7891mysql456”;<br>String string &#x3D; str.replaceAll(“\d+”, “,”).replaceAll(“^,|,$”, “”);<br>System.out.println(string);</p></li><li><p>String replaceFirst(String regex, String replacement)：</p><p>使用给定的 replacement 替换此字符串匹配给定的<strong>正则表达式</strong>的第一个子字符串。</p></li></ol><p><strong>匹配:</strong></p><p>​      boolean matches(String regex)： 告知此字符串是否匹配给定的正则表达式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str = <span class="string">&quot;12345&quot;</span>;</span><br><span class="line"><span class="comment">//判断str字符串中是否全部有数字组成，即有1-n个数字组成</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">matches</span> <span class="operator">=</span> str.matches(<span class="string">&quot;\\d+&quot;</span>);</span><br><span class="line">System.out.println(matches);</span><br></pre></td></tr></table></figure><p><strong>切片：</strong></p><ol><li><p>String[] split(String regex)：</p><p>根据给定正则表达式的匹配拆分此字符串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str = <span class="string">&quot;hello|world|java&quot;</span>;</span><br><span class="line">String[] strs = str.split(<span class="string">&quot;\\|&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; strs.length; i++) &#123;</span><br><span class="line">    System.out.println(strs[i])</span><br></pre></td></tr></table></figure></li><li><p>String[] split(String regex, int limit)：</p><p>根据匹配给定的正则表达式来拆分此字符串，最多不超过limit个，如果超过了，剩下的全部都放到最后一个元素中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">str2 = <span class="string">&quot;hello.world.java&quot;</span>;</span><br><span class="line">String[] strs2 = str2.split(<span class="string">&quot;\\.&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; strs2.length; i++) &#123;</span><br><span class="line">    System.out.println(strs2[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="6-String-与其他类型的转换"><a href="#6-String-与其他类型的转换" class="headerlink" title="6.String 与其他类型的转换"></a>6.String 与其他类型的转换</h4><p><strong>1.复习与包装类的转换</strong></p><p>复习：String 与基本数据类型、包装类之间的转换。</p><ol><li><p>String –&gt; 基本数据类型、包装类：调用包装类的静态方法：parseXxx(str)</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;123&quot;</span>;</span><br><span class="line"><span class="comment">//      int num = (int)str1;//错误的</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> Integer.parseInt(str1);</span><br></pre></td></tr></table></figure></li><li><p>基本数据类型、包装类 –&gt; String:调用String重载的valueOf(xxx)</p></li></ol>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> String.valueOf(num);<span class="comment">//&quot;123&quot; 方式一</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> num + <span class="string">&quot;&quot;</span>; <span class="comment">//方式二</span></span><br></pre></td></tr></table></figure><p><strong>2.与char[ ]</strong></p><p>String 与 char[]之间的转换</p><ol><li><p>String –&gt; char[]:调用String的toCharArray()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;abc123&quot;</span>;  <span class="comment">//题目： a21cb3</span></span><br><span class="line"><span class="type">char</span>[] charArray = str1.toCharArray();</span><br></pre></td></tr></table></figure></li><li><p>char[] –&gt; String:调用String的构造器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>[] arr = <span class="keyword">new</span> <span class="title class_">char</span>[]&#123;<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;o&#x27;</span>&#125;;</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(arr);</span><br></pre></td></tr></table></figure></li></ol><p><strong>3.与byte [ ]</strong></p><p>String 与 byte[]之间的转换</p><ol><li><p>编码：String –&gt; byte[]</p><p>调用String的getBytes()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;abc123中国&quot;</span>;</span><br><span class="line"><span class="type">byte</span>[] bytes = str1.getBytes();<span class="comment">//使用默认的字符集，进行编码。</span></span><br><span class="line">System.out.println(Arrays.toString(bytes));</span><br><span class="line"><span class="type">byte</span>[] gbks = str1.getBytes(<span class="string">&quot;gbk&quot;</span>);<span class="comment">//使用gbk字符集进行编码。由于会写错编码集，所以会有异常。</span></span><br><span class="line">System.out.println(Arrays.toString(gbks));</span><br></pre></td></tr></table></figure></li><li><p>解码：byte[] –&gt; String</p><p>调用String的构造器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bytes);<span class="comment">//使用默认的字符集，进行解码。</span></span><br><span class="line">System.out.println(str2);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(gbks);</span><br><span class="line">System.out.println(str3);<span class="comment">//出现乱码。原因：编码集和解码集不一致！</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(gbks, <span class="string">&quot;gbk&quot;</span>);</span><br><span class="line">System.out.println(str4);<span class="comment">//没有出现乱码。原因：编码集和解码集一致！</span></span><br></pre></td></tr></table></figure></li></ol><p>编码与解码：</p><ol><li>编码：字符串 –&gt;字节  (看得懂 —&gt;看不懂的二进制数据)</li><li>解码：编码的逆过程，字节 –&gt; 字符串 （看不懂的二进制数据 —&gt; 看得懂）</li><li>说明：解码时，要求解码使用的字符集必须与编码时使用的字符集一致，否则会出现乱码。</li></ol><h3 id="2-2StringBuffer及Builder"><a href="#2-2StringBuffer及Builder" class="headerlink" title="2.2StringBuffer及Builder"></a>2.2StringBuffer及Builder</h3><h4 id="1-面试题-三者String异同"><a href="#1-面试题-三者String异同" class="headerlink" title="1.面试题: 三者String异同"></a>1.面试题: 三者String异同</h4><p>面试题：String、StringBuffer、StringBuilder三者的异同？</p><ol><li>String:<strong>不可变的字符序列</strong>；底层使用<strong>char[]存储</strong></li><li>StringBuffer:<strong>可变</strong>的字符序列；<strong>线程安全</strong>的（使用synchronized同步方法），效率低；底层使用<strong>char[]存储</strong></li><li>StringBuilder:<strong>可变</strong>的字符序列；jdk5.0新增的，<strong>线程不安全</strong>的，效率高；底层使用<strong>char[]存储</strong></li><li><strong>StringBuffer、StringBuilder只区别在线程是否安全</strong></li></ol><p><strong>可变性理解：声明一个确定的字符串，可修改原有的字符串</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuffer</span> <span class="variable">sb1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;abc&quot;</span>); <span class="comment">//声明方式</span></span><br><span class="line">sb1.setCharAt(<span class="number">0</span>,<span class="string">&#x27;m&#x27;</span>); <span class="comment">//此方法无返回值</span></span><br><span class="line">System.out.println(sb1); <span class="comment">//mbc </span></span><br></pre></td></tr></table></figure><p><strong>源码分析：底层的具体区别</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>();<span class="comment">//char[] value = new char[0];</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);<span class="comment">//char[] value =  new char[]&#123;&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">sb1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line"><span class="comment">//char[] value = new char[16];底层创建了一个长度是16的数组。</span></span><br><span class="line">System.out.println(sb1.length());<span class="comment">//0</span></span><br><span class="line">sb1.append(<span class="string">&#x27;a&#x27;</span>);   <span class="comment">//value[0] = &#x27;a&#x27;;</span></span><br><span class="line">sb1.append(<span class="string">&#x27;b&#x27;</span>);   <span class="comment">//value[1] = &#x27;b&#x27;;</span></span><br><span class="line"></span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">sb2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line"><span class="comment">//char[] value = new char[&quot;abc&quot;.length() + 16];底层结构</span></span><br><span class="line">System.out.println(sb2.length());<span class="comment">//输出具体存在的字符个数：3</span></span><br></pre></td></tr></table></figure><p><strong>扩容问题:</strong>    sb1.append(‘a’); </p><ol><li><p>如果要添加的数据底层数组盛不下了，那就需要扩容底层的数组。</p></li><li><p>默认情况下，扩容为原来容量的2倍 + 2，同时将<strong>原有数组中的元素复制到新的数组中。</strong></p></li><li><p>指导意义：</p><p>由于在超出容量，添加新容量复制数组会降低效率，开发中建议大家使用：StringBuffer(int capacity) 或 StringBuilder(int capacity)</p><p><strong>提前指定好所需的容量</strong></p></li></ol><h4 id="2-StringBuffer常用方法"><a href="#2-StringBuffer常用方法" class="headerlink" title="2.StringBuffer常用方法"></a>2.StringBuffer常用方法</h4><p>由于StringBuffer、StringBuilder在方法上差别不大，只区别在线程安全与否，这里只举StringBuffer的方法</p><p>StringBuffer的常用方法：</p><ol><li><p>StringBuffer  append(xxx)</p><p>提供了很多的append()方法，用于进行字符串拼接</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuffer</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">s1.append(<span class="number">1</span>);</span><br><span class="line">s1.append(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">System.out.println(s1); <span class="comment">//abc11</span></span><br></pre></td></tr></table></figure><ol start="2"><li><p>StringBuffer delete(int start,int end)</p><p>删除指定位置的内容 [ a  ,   b ) 左闭右开的</p><p>s1.delete(2,4);</p></li><li><p>StringBuffer replace(int start, int end, String str)</p><p>把 [ start , end ) 位置替换为str</p><p> s1.replace(2,4,”hello”);</p></li><li><p>StringBuffer insert(int offset, xxx)</p><p>在指定位置插入xxx</p><p>s1.insert(2,”wwe”);</p></li><li><p>StringBuffer reverse() </p><p>把当前字符序列逆转</p><p>s1.reverse();</p></li><li><p>public int indexOf(String str) </p><p>返回指定字符串位置索引，没有返回 -1。</p><p>System.out.println(s1.indexOf(“b”));</p></li><li><p>public String substring(int start,int end)</p><p>返回一个从start开始到end索引结束的左闭右开区间的子字符串</p><p>String s2 &#x3D; s1.substring(1, 3);</p></li><li><p>public int length()  </p><p>长度  s1.length();</p></li><li><p>public char charAt(int n )</p><p>返回指定索引字符：从 0 开始</p></li><li><p>public void setCharAt(int n ,char ch)</p><p>无返回值，添加指定在指定索引处</p></li></ol><p>总结：重点注意一下方法</p><p>增：append(xxx)<br>删：delete(int start,int end)<br>改：setCharAt(int n ,char ch) &#x2F; replace(int start, int end, String str)</p><p>查：charAt(int n )</p><p>插：insert(int offset, xxx)<br>长度：length();<br>*遍历：for() + charAt() &#x2F; toString()</p><h4 id="3-三者效率对比"><a href="#3-三者效率对比" class="headerlink" title="3.三者效率对比"></a>3.三者效率对比</h4><p>对比String、StringBuffer、StringBuilder三者的效率：</p><p>从高到低排列：StringBuilder &gt; StringBuffer &gt; String</p><p>测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//初始设置</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">    <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="comment">//开始对比</span></span><br><span class="line">    startTime = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20000</span>; i++) &#123;</span><br><span class="line">        buffer.append(String.valueOf(i));</span><br><span class="line">    &#125;</span><br><span class="line">    endTime = System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;StringBuffer的执行时间：&quot;</span> + (endTime - startTime));</span><br><span class="line"></span><br><span class="line">startTime = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20000</span>; i++) &#123;</span><br><span class="line">    builder.append(String.valueOf(i));</span><br><span class="line">&#125;</span><br><span class="line">endTime = System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">&quot;StringBuilder的执行时间：&quot;</span> + (endTime - startTime));</span><br><span class="line"></span><br><span class="line">startTime = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20000</span>; i++) &#123;</span><br><span class="line">    text = text + i;</span><br><span class="line">&#125;</span><br><span class="line">endTime = System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">&quot;String的执行时间：&quot;</span> + (endTime - startTime));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-String与两者的之间转换"><a href="#4-String与两者的之间转换" class="headerlink" title="4.String与两者的之间转换"></a>4.String与两者的之间转换</h4><ol><li><p>String —&gt; StringBuffer、StringBuilder </p><p>调用StringBuffer、StringBuilder 构造器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span>  <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="type">StringBuffer</span>  <span class="variable">sb1</span>  <span class="operator">=</span>  <span class="keyword">new</span>   <span class="title class_">StringBuffer</span>(s1);</span><br></pre></td></tr></table></figure></li><li><p>StringBuffer、StringBuilder —&gt;String </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式一：调用String构造器</span></span><br><span class="line"><span class="type">StringBuffer</span>  <span class="variable">sb1</span>  <span class="operator">=</span>  <span class="keyword">new</span>   <span class="title class_">StringBuffer</span>(<span class="string">&quot;abcc&quot;</span>);</span><br><span class="line"><span class="type">String</span>  <span class="variable">s1</span> <span class="operator">=</span>  <span class="keyword">new</span>  <span class="title class_">String</span>(sb1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式二：StringBuffer、StringBuilder的toString( ) </span></span><br><span class="line"><span class="type">StringBuffer</span>  <span class="variable">sb1</span>  <span class="operator">=</span>  <span class="keyword">new</span>   <span class="title class_">StringBuffer</span>(<span class="string">&quot;abcc&quot;</span>);</span><br><span class="line"><span class="type">String</span>  <span class="variable">s1</span> <span class="operator">=</span> sb1.toString() ;  </span><br></pre></td></tr></table></figure></li></ol><h3 id="2-3关于String常见算法题"><a href="#2-3关于String常见算法题" class="headerlink" title="2.3关于String常见算法题"></a>2.3关于String常见算法题</h3><h4 id="1-指定字符反转"><a href="#1-指定字符反转" class="headerlink" title="1.指定字符反转"></a>1.指定字符反转</h4><p>将一个字符串进行反转。将字符串中指定部分进行反转。比如“abcdefg”反转为“abcfedcg”</p><p>具体代码演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式一：转换为char数组，在转回</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">reverse1</span><span class="params">(String str, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (str != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">char</span>[] c1 = str.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start, j = end; i &lt; j; j--, i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">temp</span> <span class="operator">=</span> c1[i];</span><br><span class="line">            c1[i] = c1[j];</span><br><span class="line">            c1[j] = temp;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(c1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式二:利用String连接</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">reverse2</span><span class="params">(String str, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (str != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> str.substring(<span class="number">0</span>, start);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> end; i &gt;= start; i--) &#123;</span><br><span class="line">            s1 += str.charAt(i);</span><br><span class="line">        &#125;</span><br><span class="line">        s1 += str.substring(end + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> s1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式三：效率更高，利用StringBuilder可变性直接连接</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">reverse3</span><span class="params">(String str, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(str!=<span class="literal">null</span>)&#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">stringBuffer</span> <span class="operator">=</span> newStringBuilder(str.length());</span><br><span class="line">        stringBuffer.append(str.substring(<span class="number">0</span>,start));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=end ;i&gt;=start ; i--)&#123;</span><br><span class="line">            stringBuffer.append(str.charAt(i));</span><br><span class="line">        &#125;</span><br><span class="line">        stringBuffer.append(str.substring(end+<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">return</span> stringBuffer.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-字符串中出现的次数"><a href="#2-字符串中出现的次数" class="headerlink" title="2.字符串中出现的次数"></a>2.字符串中出现的次数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">获取一个字符串在另一个字符串中出现的次数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">number</span><span class="params">(String str,String str1)</span>&#123;</span><br><span class="line">   <span class="type">int</span> <span class="variable">mainStr</span> <span class="operator">=</span> str.length();</span><br><span class="line">   <span class="type">int</span> <span class="variable">subStr</span> <span class="operator">=</span>  str1.length();</span><br><span class="line">   <span class="type">int</span> index=<span class="number">0</span>,count=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">if</span>(mainStr&gt;=subStr)&#123;</span><br><span class="line">       <span class="keyword">while</span>((index=str.indexOf(str1,index))!=-<span class="number">1</span>)&#123;</span><br><span class="line">           count++;</span><br><span class="line">           index+=subStr;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> count;</span><br><span class="line">   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-获取两个字符串中最大相同子串"><a href="#3-获取两个字符串中最大相同子串" class="headerlink" title="3.获取两个字符串中最大相同子串"></a>3.获取两个字符串中最大相同子串</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment"> 情况一：只有一个最大字符子串</span></span><br><span class="line"><span class="comment">    获取两个字符串中最大相同子串</span></span><br><span class="line"><span class="comment">    str1=&quot;abcwerthelloyuiodef&quot; str2 = &quot;cvhellobnm&quot;</span></span><br><span class="line"><span class="comment">    提示：将短的那个串进行长度依次递减的子串与较长的串比较</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getMaxSameString</span><span class="params">(String str1,String str2)</span>&#123;</span><br><span class="line"> <span class="keyword">if</span>(str1!=<span class="literal">null</span> &amp;&amp; str2!=<span class="literal">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">   <span class="type">String</span> <span class="variable">maxStr</span> <span class="operator">=</span> (str1.length()&gt;=str2.length())?str1:str2;</span><br><span class="line">    <span class="type">String</span> <span class="variable">minStr</span> <span class="operator">=</span> (str1.length()&lt;str2.length())?str1:str2;</span><br><span class="line">         <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> minStr.length();</span><br><span class="line">          <span class="comment">//每一轮都少一个，在第二层循环从左往右移动对比。</span></span><br><span class="line">         <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span> ; i&lt;minStr.length() ; i++) &#123; </span><br><span class="line">          <span class="comment">//因subString是左闭右开，所以包括length</span></span><br><span class="line">             <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>, y = length - i; y &lt;= length; x++, y++) &#123;</span><br><span class="line">             <span class="type">String</span> <span class="variable">subStr</span> <span class="operator">=</span> minStr.substring(x,y);</span><br><span class="line">             <span class="keyword">if</span>(maxStr.contains(subStr))&#123;</span><br><span class="line">                 <span class="keyword">return</span> subStr;</span><br><span class="line">             &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">// 情况二：如果存在多个长度相同的最大相同子串</span></span><br><span class="line">    <span class="comment">// 此时先返回String[]，后面可以用集合中的ArrayList替换，较方便</span></span><br><span class="line">    <span class="keyword">public</span> String[] getMaxSameString1(String str1, String str2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (str1 != <span class="literal">null</span> &amp;&amp; str2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">StringBuffer</span> <span class="variable">sBuffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">            <span class="type">String</span> <span class="variable">maxString</span> <span class="operator">=</span> (str1.length() &gt; str2.length()) ? str1 : str2;</span><br><span class="line">            <span class="type">String</span> <span class="variable">minString</span> <span class="operator">=</span> (str1.length() &gt; str2.length()) ? str2 : str1;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> minString.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>, y = len - i; y &lt;= len; x++, y++) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">subString</span> <span class="operator">=</span> minString.substring(x, y);</span><br><span class="line">                <span class="keyword">if</span> (maxString.contains(subString)) &#123;</span><br><span class="line">                    sBuffer.append(subString + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//                System.out.println(sBuffer);</span></span><br><span class="line">                <span class="keyword">if</span> (sBuffer.length() != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            String[] split = sBuffer.toString().replaceAll(<span class="string">&quot;,$&quot;</span>, <span class="string">&quot;&quot;</span>).split(<span class="string">&quot;\\,&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> split;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4JDK-8之前日期和时间"><a href="#2-4JDK-8之前日期和时间" class="headerlink" title="2.4JDK 8之前日期和时间"></a>2.4JDK 8之前日期和时间</h3><p>JDK 8之前日期和时间的API测试</p><h4 id="1-System类"><a href="#1-System类" class="headerlink" title="1.System类"></a>1.System类</h4><p>System类中的currentTimeMillis()</p><p>返回当前时间与1970年1月1日0时0分0秒之间以毫秒为单位的时间差。</p><p>称为时间戳</p><p>long time &#x3D; System.currentTimeMillis();<br>System.out.println(time);</p><h4 id="2-date类"><a href="#2-date类" class="headerlink" title="2.date类"></a>2.date类</h4><p>java.util.Date类 是 java.sql.Date类 的 父类（前者是java程序中常用的，后者是数据库中常用的时间）</p><p>1.两个构造器的使用</p><ol><li><p>构造器一：Date()：创建一个对应当前时间的Date对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Date</span> <span class="variable">date1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">System.out.println(date1.toString());</span><br><span class="line"><span class="comment">//Sat Feb 16 16:35:31 GMT+08:00 2019</span></span><br><span class="line">System.out.println(date1.getTime());</span><br><span class="line"><span class="comment">//1550306204104 从1970年1月1日0时0分0秒</span></span><br></pre></td></tr></table></figure></li><li><p>构造器二：创建指定毫秒数的Date对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Date</span> <span class="variable">date2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">155030620410L</span>);</span><br><span class="line"><span class="comment">//也是从1970年1月1日0时0分0秒计算</span></span><br><span class="line">System.out.println(date2.toString());</span><br></pre></td></tr></table></figure></li></ol><p>2.两个方法的使用</p><ol><li><p>toString():显示当前的年、月、日、时、分、秒</p><p>System.out.println(date1.toString());<br>输出格式：Sat Feb 16 16:35:31 GMT+08:00 2019</p></li><li><p>getTime():获取当前Date对象对应的毫秒数。（时间戳）</p><p>System.out.println(date1.getTime());<br>输出格式：1550306204104</p></li></ol><p>3.java.sql.Date对应着数据库中的日期类型的变量</p><ol><li><p>如何实例化？  </p><p>只能用指定毫秒数的构造器了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java.sql.<span class="type">Date</span> <span class="variable">date3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">java</span>.sql.Date(<span class="number">355325345L</span>);</span><br><span class="line">System.out.println(date3);</span><br><span class="line"><span class="comment">//其toString输出格式1971-02-13  区别于util包下的</span></span><br></pre></td></tr></table></figure></li><li><p>如何将java.util.Date对象转换为java.sql.Date对象</p><p>情况一：声明父类，new子类—（强转）多态性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Date</span> <span class="variable">date4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">java</span>.sql.Date(<span class="number">2343243242323L</span>);</span><br><span class="line">java.sql.<span class="type">Date</span> <span class="variable">date5</span> <span class="operator">=</span> (java.sql.Date)date4;</span><br></pre></td></tr></table></figure></li></ol><p>​     情况二：声明父类，new父类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Date</span> <span class="variable">date6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">  java.sql.<span class="type">Date</span> <span class="variable">date7</span> <span class="operator">=</span>  <span class="keyword">new</span>  <span class="title class_">java</span>.sql.Date(date6.getTime());</span><br></pre></td></tr></table></figure><p>   ​</p><h4 id="3-SimpleDateFormat类"><a href="#3-SimpleDateFormat类" class="headerlink" title="3.SimpleDateFormat类"></a>3.SimpleDateFormat类</h4><p>SimpleDateFormat的使用：<strong>SimpleDateFormat对日期Date类的格式化和解析</strong></p><p>1.两个操作：</p><ol><li><p>格式化：日期 —&gt;字符串 </p><p>String  format(Date date )</p></li><li><p>解析：格式化的逆过程，字符串 —&gt; 日期</p><p>Date  parse(String  string )  该字符串日期格式是与构造器对应格式</p></li></ol><p>2.类型一：默认构造器，格式化日期单一</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实例化SimpleDateFormat :  使用默认的构造器</span></span><br><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">sdf</span>  <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>();</span><br><span class="line"><span class="comment">//格式化：日期 ---&gt;字符串</span></span><br><span class="line"><span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">System.out.println(date);<span class="comment">//Thu Jan 27 20:03:38 CST 2022</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">format</span> <span class="operator">=</span> sdf.format(date);</span><br><span class="line">System.out.println(format);<span class="comment">//22-1-27 下午8:03</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//解析：格式化的逆过程，字符串 ---&gt; 日期</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;19-12-18 上午11:43&quot;</span>; <span class="comment">//只能是这种格式</span></span><br><span class="line"><span class="type">Date</span> <span class="variable">date1</span> <span class="operator">=</span> sdf.parse(str);</span><br><span class="line">System.out.println(date1);<span class="comment">//Wed Dec 18 11:43:00 CST 2019</span></span><br></pre></td></tr></table></figure><p>3.类型二：调用带参构造器，可选择合适的日期格式的构造器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">sdf1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>);<span class="comment">//y年，M月，d天，h小时，m分钟，s秒</span></span><br><span class="line">    <span class="comment">//格式化</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">format1</span> <span class="operator">=</span> sdf1.format(date);</span><br><span class="line">    System.out.println(format1);<span class="comment">//2019-02-18 11:48:27</span></span><br><span class="line">    <span class="comment">//解析:要求字符串必须是符合SimpleDateFormat识别的格式(通过构造器参数体现),否则，抛异常</span></span><br><span class="line">    <span class="type">Date</span> <span class="variable">date2</span> <span class="operator">=</span> sdf1.parse(<span class="string">&quot;2020-02-18 11:48:27&quot;</span>);</span><br><span class="line">    System.out.println(date2);<span class="comment">//Tue Feb 18 11:48:27 CST 2020</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-Calendar日历类"><a href="#4-Calendar日历类" class="headerlink" title="4.Calendar日历类"></a>4.Calendar日历类</h4><p>Calendar日历类(抽象类：不能new对象）的使用：</p><p><strong>1.实例化</strong></p><ol><li><p>方式一：创建其子类（GregorianCalendar）的对象</p></li><li><p>方式二：调用其静态方法getInstance()</p><p>其实第二种方式也是new的GregorianCalendar对象，方式二容易记住</p><p><strong>Calendar  calendar  &#x3D;  Calendar.getInstance();</strong></p></li></ol><p><strong>2.常用方法</strong></p><p>注意：</p><p>获取月份时：一月是0，二月是1….12月是11</p><p>获取星期时：周日是1，周一是2…周六是7</p><ol><li><p>int  get()</p><p>获取指定信息：YEAR、MONTH、DAY_OF_YEAR等等</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Calendar</span>  <span class="variable">calendar</span>  <span class="operator">=</span>  Calendar.getInstance();</span><br><span class="line"><span class="type">int</span> <span class="variable">days</span> <span class="operator">=</span> calendar.get(Calendar.DAY_OF_MONTH); <span class="comment">//这月的第几天</span></span><br><span class="line">System.out.println(days);</span><br><span class="line"><span class="comment">//这年的第几天：DAY_OF_YEAR</span></span><br></pre></td></tr></table></figure></li><li><p>void  set()</p><p>修改指定信息     ，calendar可变性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Calendar</span>  <span class="variable">calendar</span>  <span class="operator">=</span>  Calendar.getInstance();</span><br><span class="line">calendar.set(Calendar.DAY_OF_MONTH,<span class="number">22</span>);</span><br><span class="line">days = calendar.get(Calendar.DAY_OF_MONTH);</span><br><span class="line">System.out.println(days);<span class="comment">//22</span></span><br></pre></td></tr></table></figure></li><li><p>void  add()</p><p>增加指定信息个数，负数为减少个数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> calendar.add(Calendar.DAY_OF_MONTH,-<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">Calendar</span>  <span class="variable">calendar</span>  <span class="operator">=</span>  Calendar.getInstance();</span><br><span class="line">calendar.add(Calendar.DAY_OF_MONTH,-<span class="number">3</span>);</span><br><span class="line">days = calendar.get(Calendar.DAY_OF_MONTH);</span><br><span class="line">System.out.println(days);</span><br></pre></td></tr></table></figure></li><li><p>Date  getTime()</p><p><strong>获取Date类型的日期：日历类—&gt; Date</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Calendar</span>  <span class="variable">calendar</span>  <span class="operator">=</span>  Calendar.getInstance();</span><br><span class="line"><span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> calendar.getTime();</span><br><span class="line">System.out.println(date);</span><br></pre></td></tr></table></figure></li><li><p>void  setTime()</p><p><strong>Date类 —&gt; 日历类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Calendar</span>  <span class="variable">calendar</span>  <span class="operator">=</span>  Calendar.getInstance();</span><br><span class="line"><span class="type">Date</span> <span class="variable">date1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">calendar.setTime(date1); <span class="comment">//不用返回值，对象可变</span></span><br><span class="line"> days = calendar.get(Calendar.DAY_OF_MONTH);</span><br><span class="line">    System.out.println(days);</span><br></pre></td></tr></table></figure></li></ol><p><strong>3.练习</strong></p><p>练习一：字符串”2020-09-08”转换为java.sql.Date</p><p>字符串–&gt;SimpleDateFormat类–&gt;util.Date类—&gt;sql.Date类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">birth</span> <span class="operator">=</span> <span class="string">&quot;2020-09-08&quot;</span>;</span><br><span class="line"> <span class="type">SimpleDateFormat</span> <span class="variable">sdf1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line"> <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> sdf1.parse(birth);</span><br><span class="line">java.sql.<span class="type">Date</span> <span class="variable">birthDate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">java</span>.sql.Date(date.getTime());</span><br><span class="line">System.out.println(birthDate);</span><br></pre></td></tr></table></figure><p>练习二：”三天打渔两天晒网”   1990-01-01  xxxx-xx-xx 打渔？晒网？</p><p>举例：2020-09-08 ？ 总天数</p><p>总天数 % 5 &#x3D;&#x3D; 1,2,3 : 打渔<br>总天数 % 5 &#x3D;&#x3D; 4,0 : 晒网</p><p>总天数的计算？<br>方式一：( date2.getTime() - date1.getTime()) &#x2F; (1000 * 60 * 60 * 24) + 1<br>方式二：1990-01-01  –&gt; 2019-12-31  +  2020-01-01 –&gt;2020-09-08</p><h3 id="2-5JDK8中日期和时间"><a href="#2-5JDK8中日期和时间" class="headerlink" title="2.5JDK8中日期和时间"></a>2.5JDK8中日期和时间</h3><h4 id="1-总体介绍"><a href="#1-总体介绍" class="headerlink" title="1.总体介绍"></a>1.总体介绍</h4><ol><li>java.time  包含值对象的基础包</li><li>java.time.chrono  提供对不同日历系统的访问</li><li>java.time.format   格式化和解析时间和日期</li><li>java.time.temporal    包括底层框架和扩展特性</li><li>java.time.zone    包含时区支持的类</li></ol><p>说明：</p><p>大多数开发者只会用到基础包和format包，也可能会用到temporal包。因此，尽管有68个新的公开类型，大多数开发者，大概只会用到其中的三分之一</p><h4 id="2-LocalDate-x2F-Time-x2F-DateTime"><a href="#2-LocalDate-x2F-Time-x2F-DateTime" class="headerlink" title="2.LocalDate&#x2F;Time&#x2F;DateTime"></a>2.LocalDate&#x2F;Time&#x2F;DateTime</h4><p><strong>1.出现背景</strong></p><p>JDK 1.0中包含了一个java.util.Date类，但是它的大多数方法已经在JDK 1.1引入Calendar类之后被弃用了。而Calendar并不比Date好多少。<strong>它们面临的问题是</strong>：</p><ol><li><p>可变性：像日期和时间这样的类应该是<strong>不可变</strong>的。</p></li><li><p>偏移性：<strong>Date中的年份是从1900开始</strong>的，而<strong>月份都从0开始</strong>。</p><p>Date date1 &#x3D; new Date(2020 - 1900,9 - 1,8);<br>System.out.println(date1);&#x2F;&#x2F;Tue Sep 08 00:00:00 GMT+08:00 2020</p></li><li><p>格式化：格式化只对Date有用，Calendar则不行。</p></li><li><p>此外，它们也不是线程安全的；不能处理闰秒等</p></li></ol><p><strong>2.主要介绍及方法</strong></p><p>LocalDate（只有日期）、LocalTime（只有时间）、LocalDateTime （日期加时间）的使用</p><p>说明：</p><ol><li><p><strong>LocalDateTime</strong>相较于LocalDate、LocalTime，使用频率要高</p></li><li><p>类似于Calendar</p></li></ol><p><strong>主要方法使用</strong>：主要以LocalDateTime举例</p><ol><li><p><strong>now()  —–静态方法（实例化方式一）</strong></p><p><strong>获取当前的日期、时间、日期+时间</strong></p><p>LocalDate localDate &#x3D; LocalDate.now();<br>LocalTime localTime &#x3D; LocalTime.now();<br>LocalDateTime localDateTime &#x3D; LocalDateTime.now();</p></li><li><p><strong>of()   —–静态方法（实例化方式二）</strong></p><p><strong>设置指定的年、月、日、时、分、秒。没有偏移量</strong></p><p>LocalDateTime localDateTime1 &#x3D; LocalDateTime.of(2020, 10, 6, 13, 23, 43);</p></li><li><p><strong>getXxx()：获取相关的属性</strong></p><p> System.out.println(localDateTime.getDayOfMonth());<br> System.out.println(localDateTime.getDayOfWeek());<br> System.out.println(localDateTime.getMonth());<br> System.out.println(localDateTime.getMonthValue());<br> System.out.println(localDateTime.getMinute());</p></li><li><p>withXxx()：设置相关的属性—有返回值，体现不可变性</p><p> LocalDate localDate1 &#x3D; localDate.withDayOfMonth(22);<br> System.out.println(localDate);18–原来的不变<br> System.out.println(localDate1);20 </p></li><li><p>plusMonths(3)：加个数—-有返回值，体现不可变性</p><p> LocalDateTime localDateTime3 &#x3D; localDateTime.plusMonths(3);<br>System.out.println(localDateTime);<br>System.out.println(localDateTime3);</p></li><li><p>minusDays(6)：减个数—–有返回值，体现不可变性</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LocalDateTime</span> <span class="variable">localDateTime4</span> <span class="operator">=</span> localDateTime.minusDays(<span class="number">6</span>);</span><br><span class="line">System.out.println(localDateTime);</span><br><span class="line">System.out.println(localDateTime4);</span><br></pre></td></tr></table></figure><h4 id="3-Instan类瞬时"><a href="#3-Instan类瞬时" class="headerlink" title="3.Instan类瞬时"></a>3.Instan类瞬时</h4><p><strong>说明：</strong></p><ol><li><p><strong>时间线上的一个瞬时点。 这可能被用来记录应用程序中的事件时间戳。</strong></p></li><li><p>类似于 java.util.Date类</p></li></ol><p><strong>主要方法使用：</strong></p><ol><li><p><strong>now()  —–静态方法（实例化方式）</strong></p><p>获取本初子午线对应的标准时间(0时线，和北京时间差8小时)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Instant</span> <span class="variable">instant</span> <span class="operator">=</span> Instant.now();</span><br><span class="line">System.out.println(instant);<span class="comment">//2019-02-18T07:29:41.719Z</span></span><br></pre></td></tr></table></figure></li><li><p>atOffset(ZoneOffset.ofHours(8))</p><p>添加时间的偏移量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">OffsetDateTime</span> <span class="variable">offsetDateTime</span>   <span class="operator">=</span>  instant.atOffset(ZoneOffset.ofHours(<span class="number">8</span>));</span><br><span class="line">System.out.println(offsetDateTime);<span class="comment">//2019-02-18T15:32:50.611+08:00</span></span><br></pre></td></tr></table></figure></li><li><p>toEpochMilli(long  Milli)</p><p>获取自1970年1月1日0时0分0秒（UTC）开始的毫秒数  —&gt; Date类的getTime()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">milli</span> <span class="operator">=</span> instant.toEpochMilli();</span><br><span class="line">System.out.println(milli);</span><br></pre></td></tr></table></figure></li><li><p>ofEpochMilli()</p><p>通过给定的毫秒数，获取Instant实例  –&gt;Date(long millis)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Instant</span> <span class="variable">instant1</span> <span class="operator">=</span> Instant.ofEpochMilli(<span class="number">1550475314878L</span>);</span><br><span class="line">System.out.println(instant1);</span><br></pre></td></tr></table></figure></li></ol><h4 id="4-DateTimeFormatter-类"><a href="#4-DateTimeFormatter-类" class="headerlink" title="4.DateTimeFormatter 类"></a>4.DateTimeFormatter 类</h4><p>java.time.format.DateTimeFormatter 类</p><p><strong>该类提供了三种格式化方法：</strong></p><ol><li><p>预定义的标准格式ISO_LOCAL_DATE_TIME;ISO_LOCAL_DATE;ISO_LOCAL_TIME</p></li><li><p>本地化相关的格式</p><p>ofLocalizedDateTime(FormatStyle.LONG)</p></li><li><p>自定义的格式</p><p><strong>ofPattern(“yyyy-MM-dd hh:mm:ss”)</strong></p></li></ol><p><strong>使用说明：</strong></p><ol><li><p><strong>预定义的标准格式</strong></p><p>ISO_LOCAL_DATE_TIME    日期+时间</p><p>ISO_LOCAL_DATE               日期</p><p>ISO_LOCAL_TIME               时间</p><p><strong>实例化：</strong></p><p>DateTimeFormatter  formatter  &#x3D;  DateTimeFormatter.ISO_LOCAL_DATE_TIME;</p><p><strong>format( ) 格式化:日期–&gt;字符串</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="type">LocalDateTime</span> <span class="variable">localDateTime</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> formatter.format(localDateTime);</span><br><span class="line">System.out.println(localDateTime);<span class="comment">// 2019-02-18T15:42:18.797</span></span><br><span class="line">System.out.println(str1); <span class="comment">// 2019-02-18T15:42:18.797</span></span><br></pre></td></tr></table></figure><p><strong>parse() 解析：字符串 –&gt;日期 返回值类型为TemporalAccessor</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">TemporalAccessor</span> <span class="variable">parse</span> <span class="operator">=</span> formatter.parse(<span class="string">&quot;2019-02-18T15:42:18.797&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(parse);<span class="comment">//2019-02-18T15:42:18.797</span></span><br></pre></td></tr></table></figure></li><li><p><strong>本地化相关的格式  –解析方式一样，不列举</strong></p><p><strong>适用于LocalDateTime（日期+时间形式）：</strong></p><p>ofLocalizedDateTime(FormatStyle.SHORT);</p><ol><li>FormatStyle.LONG   2022年1月28日 上午11时56分26秒</li><li>FormatStyle.MEDIUM   2022-1-28 11:57:15</li><li>FormatStyle.SHORT      22-1-28 上午11:57</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DateTimeFormatter</span> <span class="variable">formatter1</span> <span class="operator">=</span> DateTimeFormatter.ofLocalizedDateTime(FormatStyle.SHORT);</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> formatter1.format(localDateTime);</span><br><span class="line">System.out.println(str2);<span class="comment">//2019年2月18日 下午03时47分16秒</span></span><br></pre></td></tr></table></figure><p><strong>适用于LocalizedDate()（日期）：</strong></p><p>ofLocalizedDate(FormatStyle.FULL);</p><ol><li><p>FormatStyle.LONG       2022年1月28日</p></li><li><p>FormatStyle.MEDIUM    2022-1-28</p></li><li><p>FormatStyle.SHORT       22-1-28</p></li><li><p>FormatStyle.FULL    2022年1月28日 星期五</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DateTimeFormatter</span> <span class="variable">formatter2</span> <span class="operator">=</span> DateTimeFormatter.ofLocalizedDate(FormatStyle.FULL);</span><br><span class="line"><span class="comment">//格式化</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span>formatter2.format(LocalDate.now());</span><br><span class="line">System.out.println(str3);<span class="comment">//2019-2-18  </span></span><br></pre></td></tr></table></figure></li></ol></li><li><p><strong>自定义的格式</strong></p><p><strong>ofPattern(“yyyy-MM-dd hh:mm:ss”)</strong></p><p>yyyy-MM-dd hh:mm:ss   2019-02-18 03:52:09</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DateTimeFormatter</span> <span class="variable">formatter3</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>);</span><br><span class="line"><span class="comment">//格式化</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> formatter3.format(LocalDateTime.now());</span><br><span class="line">System.out.println(str4);<span class="comment">//2019-02-18 03:52:09</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//解析</span></span><br><span class="line"><span class="type">TemporalAccessor</span> <span class="variable">accessor</span> <span class="operator">=</span> formatter3.parse(<span class="string">&quot;2019-02-18 03:52:09&quot;</span>);</span><br><span class="line">System.out.println(accessor);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-6Java比较器"><a href="#2-6Java比较器" class="headerlink" title="2.6Java比较器"></a>2.6Java比较器</h3><h4 id="1-介绍-1"><a href="#1-介绍-1" class="headerlink" title="1.介绍"></a>1.介绍</h4><p>在Java中经常会涉及到对象数组的排序问题，那么就涉及到对象之间的比较问题。 </p><p>Java实现对象排序的方式有两种：</p><ol><li>自然排序：java.lang.Comparable</li><li>定制排序：java.util.Comparator</li></ol><p><strong>一、说明：</strong></p><p>Java中的对象，正常情况下，只能进行比较：&#x3D;&#x3D;  或  !&#x3D; 。不能使用 &gt; 或 &lt; 的但是在开发场景中，我们需要对多个对象进行排序，言外之意，就需要比较对象的大小。</p><p><strong>如何实现？</strong></p><p>使用两个接口中的任何一个：Comparable 或 Comparator</p><p><strong>二、Comparable接口与Comparator的使用的对比：</strong></p><p>Comparable<strong>接口的方式一旦一定，保证Comparable接口实现类的对象在任何位置都可以比较大小。</strong></p><p>Comparator接口属于<strong>临时性的比较</strong>。</p><h4 id="2-Comparable自然排序"><a href="#2-Comparable自然排序" class="headerlink" title="2.Comparable自然排序"></a>2.Comparable自然排序</h4><p>Comparable接口的使用举例：  自然排序</p><p> <strong>通过Collections.sort 或Arrays.sort内部调用此重写的compareTo进行排序</strong></p><ol><li><p>像String、包装类等实现了Comparable接口，重写了compareTo(obj)方法，给出了比较两个对象大小的方式。</p></li><li><p>像String、包装类重写compareTo()方法以后，默认进行了从小到大的排列</p></li><li><p><strong>重写compareTo(obj)的规则  (默认由小到大) ：</strong></p><ol><li>如果当前对象this大于形参对象obj，则返回正整数，</li><li>如果当前对象this小于形参对象obj，则返回负整数，</li><li>如果当前对象this等于形参对象obj，则返回零。</li></ol></li><li><p>对于<strong>自定义类</strong>来说，如果需要排序，我们可以让<strong>自定义类实现Comparable接口，重写compareTo(obj)方法。</strong>在compareTo(obj)方法中指明如何排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//指明商品比较大小的方式:按照价格从低到高排序,再按照产品名称从高到低排序</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Object o)</span> &#123;</span><br><span class="line"><span class="comment">//        System.out.println(&quot;**************&quot;);</span></span><br><span class="line">        <span class="keyword">if</span>(o <span class="keyword">instanceof</span> Goods)&#123;</span><br><span class="line">            <span class="type">Goods</span> <span class="variable">goods</span> <span class="operator">=</span> (Goods)o;</span><br><span class="line">            <span class="comment">//方式一：</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">this</span>.price &gt; goods.price)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">this</span>.price &lt; goods.price)&#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//            return 0;</span></span><br><span class="line"><span class="comment">//          价格相同的按照名称字符大小排序</span></span><br><span class="line">          <span class="keyword">return</span> -<span class="built_in">this</span>.name.compareTo(goods.name);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//方式二：调用包装类已有的compare</span></span><br><span class="line"><span class="comment">//           return Double.compare(this.price,goods.price);</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        return 0;</span></span><br><span class="line"><span class="comment">//如果传入的不是本类型的数据，抛出个提示异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;传入的数据类型不一致！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> */</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">    String[] arr = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;AA&quot;</span>,<span class="string">&quot;CC&quot;</span>,<span class="string">&quot;KK&quot;</span>,<span class="string">&quot;MM&quot;</span>,<span class="string">&quot;GG&quot;</span>,<span class="string">&quot;JJ&quot;</span>,<span class="string">&quot;DD&quot;</span>&#125;;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    Arrays.sort(arr);</span><br><span class="line"></span><br><span class="line">    System.out.println(Arrays.toString(arr)); <span class="comment">//[AA, CC, DD, GG, JJ, KK, MM]</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">    Goods[] arr = <span class="keyword">new</span> <span class="title class_">Goods</span>[<span class="number">5</span>];</span><br><span class="line">    arr[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">Goods</span>(<span class="string">&quot;lenovoMouse&quot;</span>,<span class="number">34</span>);</span><br><span class="line">    arr[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">Goods</span>(<span class="string">&quot;dellMouse&quot;</span>,<span class="number">43</span>);</span><br><span class="line">    arr[<span class="number">2</span>] = <span class="keyword">new</span> <span class="title class_">Goods</span>(<span class="string">&quot;xiaomiMouse&quot;</span>,<span class="number">12</span>);</span><br><span class="line">    arr[<span class="number">3</span>] = <span class="keyword">new</span> <span class="title class_">Goods</span>(<span class="string">&quot;huaweiMouse&quot;</span>,<span class="number">65</span>);</span><br><span class="line">    arr[<span class="number">4</span>] = <span class="keyword">new</span> <span class="title class_">Goods</span>(<span class="string">&quot;microsoftMouse&quot;</span>,<span class="number">43</span>);</span><br><span class="line"></span><br><span class="line">    Arrays.sort(arr);<span class="comment">//内部调用Goods重写CompareTo方法</span></span><br><span class="line"></span><br><span class="line">    System.out.println(Arrays.toString(arr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="3-Comparator定制排序"><a href="#3-Comparator定制排序" class="headerlink" title="3.Comparator定制排序"></a>3.Comparator定制排序</h4><p><strong>1.背景：</strong></p><p>当元素的类型<strong>没有实现java.lang.Comparable接口</strong>而又不方便修改代码（String类内重写的方法不能修改），或者实现了java.lang.Comparable接口的排序规则不适合当前的操作，那么可以考虑使用 Comparator 的对象<strong>临时创建一个排序规则来排序</strong></p><p>**2.重写compare(Object o1,Object o2)规则  ( 默认由小到大 )  ： **</p><p>比较o1和o2的大小：</p><ol><li>如果方法返回正整数，则表示o1大于o2；</li><li>如果返回0，表示相等；</li><li>返回负整数，表示o1小于o2。</li></ol><h4 id="3-自定义Comparator类"><a href="#3-自定义Comparator类" class="headerlink" title="3.自定义Comparator类"></a>3.自定义Comparator类</h4><p> <strong>通过Collections.sort 或Arrays.sort内部调用此重写的compare进行排序</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">String[] arr = <span class="keyword">new</span> <span class="title class_">String</span>[ ] &#123; <span class="string">&quot;AA&quot;</span>,<span class="string">&quot;CC&quot;</span>,<span class="string">&quot;KK&quot;</span>,<span class="string">&quot;MM&quot;</span>,<span class="string">&quot;GG&quot;</span>,<span class="string">&quot;JJ&quot;</span>,<span class="string">&quot;DD&quot;</span> &#125; ;</span><br><span class="line">   Arrays.sort(arr, <span class="keyword">new</span> <span class="title class_">Comparator</span>()&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>  <span class="type">int</span>  <span class="title function_">compare</span><span class="params">(Object o1, Object o2)</span> &#123;</span><br><span class="line"><span class="comment">//1. 如果方法返回正整数，则表示o1大于o2；</span></span><br><span class="line"><span class="comment">//2. 如果返回0，表示相等；</span></span><br><span class="line"><span class="comment">//3. 返回负整数，表示o1小于o2。</span></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">&#125; ) ;</span><br></pre></td></tr></table></figure><p><strong>具体代码演示：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line"> String[] arr = <span class="keyword">new</span> <span class="title class_">String</span>[]      &#123;<span class="string">&quot;AA&quot;</span>,<span class="string">&quot;CC&quot;</span>,<span class="string">&quot;KK&quot;</span>,<span class="string">&quot;MM&quot;</span>,<span class="string">&quot;GG&quot;</span>,<span class="string">&quot;JJ&quot;</span>,<span class="string">&quot;DD&quot;</span>&#125;;</span><br><span class="line">   Arrays.sort(arr,<span class="keyword">new</span> <span class="title class_">Comparator</span>()&#123;</span><br><span class="line">            <span class="comment">//按照字符串从大到小的顺序排列</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object o1, Object o2)</span> &#123;</span><br><span class="line">     <span class="keyword">if</span>(o1 <span class="keyword">instanceof</span> String &amp;&amp; o2 <span class="keyword">instanceof</span>  String)&#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> (String) o1;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> (String) o2;</span><br><span class="line">                    <span class="keyword">return</span> -s1.compareTo(s2);</span><br><span class="line">                &#125;</span><br><span class="line"><span class="comment">//                return 0;</span></span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;输入的数据类型不一致&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-7System类"><a href="#2-7System类" class="headerlink" title="2.7System类"></a>2.7System类</h3><h4 id="1-介绍-2"><a href="#1-介绍-2" class="headerlink" title="1.介绍"></a>1.介绍</h4><ol><li>System类代表系统，系统级的很多属性和控制方法都放置在该类的内部。</li><li>该类位于java.lang包。 </li><li><strong>由于该类的构造器是private的，所以无法创建该类的对象，也就是无法实例化该类。其内部的成员变量和成员方法都是static的，所以也可以很方便的进行调用。</strong></li></ol><h4 id="2-成员方法"><a href="#2-成员方法" class="headerlink" title="2.成员方法"></a>2.成员方法</h4><ol><li><p>native long currentTimeMillis()</p><p>该方法的作用是返回当前的计算机时间，时间的表达格式为当前计算机时</p><p>间和GMT时间(格林威治时间)1970年1月1号0时0分0秒所差的毫秒数</p></li><li><p>void exit(int status)</p><p>该方法的作用是退出程序。其中status的值为0代表正常退出，非零代表</p><p>异常退出。使用该方法可以在图形界面编程中实现程序的退出功能等</p></li><li><p>void gc()</p><p>该方法的作用是请求系统进行垃圾回收。至于系统是否立刻回收，则</p><p>取决于系统中垃圾回收算法的实现以及系统执行时的情况</p></li><li><p>String getProperty(String key)</p><p>方法的作用是获得系统中属性名为key的属性对应的值。系统中常见</p><p>的属性名以及属性的作用</p><p>java . version  java 运行环境版本</p><p>java.home    java安装目录</p><p>os . version      操作系统的版本</p><p>os . name     操作系统的名称</p><p>user . name    用户的账户名称</p><p>user . home   用户的主目录</p><p>user.dir        用户的当前工作目录</p></li></ol><h3 id="2-8Math类"><a href="#2-8Math类" class="headerlink" title="2.8Math类"></a>2.8Math类</h3><h4 id="1-介绍-3"><a href="#1-介绍-3" class="headerlink" title="1.介绍"></a>1.介绍</h4><p>java.lang.Math提供了一系列静态方法用于科学计算。其方法的参数和返回值类型一般为double型。</p><h4 id="2-常用方法"><a href="#2-常用方法" class="headerlink" title="2.常用方法"></a>2.常用方法</h4><ol><li>abs（） 绝对值</li><li>acos,asin,atan,cos,sin,tan 三角函数</li><li>sqrt（） 平方根</li><li>pow(double a,doble b) a的b次幂</li><li>log（） 自然对数</li><li>exp（） e为底指数</li><li>max(double a,double b)</li><li>min(double a,double b)</li><li>random() 返回0.0到1.0的随机数</li><li>long round(double a) double型数据a转换为long型（四舍五入）</li><li>toDegrees(double angrad) 弧度—&gt;角度</li><li>toRadians(double angdeg) 角度—&gt;弧度</li></ol><h3 id="2-9BigInteger类"><a href="#2-9BigInteger类" class="headerlink" title="2.9BigInteger类"></a>2.9BigInteger类</h3><h4 id="1-介绍-4"><a href="#1-介绍-4" class="headerlink" title="1.介绍"></a>1.介绍</h4><ol><li>Integer类作为int的包装类，能存储的最大整型值为231-1，Long类也是有限的，最大为263-1。如果要表示再大的整数，不管是基本数据类型还是他们的包装类都无能为力，更不用说进行运算了。</li><li>java.math包的BigInteger可以表示不可变的任意精度的整数。BigInteger 提供所有 Java 的基本整数操作符的对应物，并提供 java.lang.Math 的所有相关方法。另外，BigInteger 还提供以下运算：模算术、GCD 计算、质数测试、素数生成、位操作以及一些其他操作。</li></ol><p>构造器 ：BigInteger(String val)：根据字符串构建BigInteger对象</p><p>BigInteger bi &#x3D; new BigInteger(“1243323434343434241123”);</p><h4 id="2-常用方法-1"><a href="#2-常用方法-1" class="headerlink" title="2.常用方法"></a>2.常用方法</h4><ol><li><p><strong>public BigInteger abs()</strong></p><p>返回此 BigInteger 的绝对值的 BigInteger。 </p></li><li><p><strong>BigInteger add(BigInteger val)</strong> </p><p>返回其值为 (this + val) 的 BigInteger</p></li><li><p><strong>BigInteger subtract(BigInteger val)</strong> </p><p>返回其值为 (this - val) 的 BigInteger</p></li><li><p><strong>BigInteger multiply(BigInteger val)</strong> </p><p>返回其值为 (this * val) 的 BigInteger</p></li><li><p><strong>BigInteger divide(BigInteger val)</strong> </p><p>返回其值为 (this &#x2F; val) 的 BigInteger。整数相除只保留整数部分。 </p></li><li><p><strong>BigInteger remainder(BigInteger val)</strong> </p><p>返回其值为 (this % val) 的 BigInteger。 </p></li><li><p><strong>BigInteger[] divideAndRemainder(BigInteger val)</strong></p><p>返回包含 (this &#x2F; val) 后跟(this % val) 的两个 BigInteger 的数组。 </p></li><li><p><strong>BigInteger pow(int exponent)</strong> </p><p>返回其值为 (thisexponent) 的 BigInteger。</p></li></ol><h3 id="2-10BigDecimal类"><a href="#2-10BigDecimal类" class="headerlink" title="2.10BigDecimal类"></a>2.10BigDecimal类</h3><h4 id="1-介绍-5"><a href="#1-介绍-5" class="headerlink" title="1.介绍"></a>1.介绍</h4><ol><li>一般的Float类和Double类可以用来做科学计算或工程计算，但在商业计算中，要求数字精度比较高，故用到java.math.BigDecimal类。 </li><li>BigDecimal类支持不可变的、任意精度的有符号十进制定点数。</li></ol><p>构造器 :   </p><ol><li>public BigDecimal(double val) </li><li>public BigDecimal(String val)</li></ol><h4 id="2-常用方法-2"><a href="#2-常用方法-2" class="headerlink" title="2.常用方法"></a>2.常用方法</h4><ol><li><p>public BigDecimal add(BigDecimal augend)</p><p>加法</p></li><li><p>public BigDecimal subtract(BigDecimal subtrahend)</p><p>减法</p></li><li><p>public BigDecimal multiply(BigDecimal multiplicand)</p><p>乘法</p></li><li><p>public BigDecimal divide(BigDecimal divisor, int scale, int roundingMode)</p><p>除法 （BigDecimal对象 ， 保留几位小数  ， 是否四舍五入）</p><p>BigDecimal.ROUND_HALF_UP   要四舍五入BigDecimal.ROUND_HALF_DOWN  不四舍五入</p><p>代码演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">   <span class="type">BigDecimal</span> <span class="variable">bd1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;12435.351&quot;</span>);</span><br><span class="line">   <span class="type">BigDecimal</span> <span class="variable">bd2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;11&quot;</span>);</span><br><span class="line">   </span><br><span class="line">   System.out.println(bi);   <span class="comment">//12435.351</span></span><br><span class="line">   <span class="comment">// System.out.println(bd1.divide(bd2));</span></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">System.out.println(bd1.divide(bd2, BigDecimal.ROUND_HALF_UP));</span><br><span class="line">   System.out.println(bd1.divide(bd2, <span class="number">15</span>, BigDecimal.ROUND_HALF_UP));</span><br></pre></td></tr></table></figure></li></ol><h2 id="3-枚举类与注解"><a href="#3-枚举类与注解" class="headerlink" title="3.枚举类与注解"></a>3.枚举类与注解</h2><h3 id="1-枚举类的使用"><a href="#1-枚举类的使用" class="headerlink" title="1.枚举类的使用"></a>1.枚举类的使用</h3><h4 id="1-介绍-6"><a href="#1-介绍-6" class="headerlink" title="1.介绍"></a>1.介绍</h4><ol><li>枚举类的理解：<strong>类的对象只有有限个，确定的</strong>。我们称此类为枚举类</li><li><strong>当需要定义一组常量时，强烈建议使用枚举类</strong></li><li>如果枚举类中只有一个对象，则可以作为单例模式的实现方式。</li><li>如一下的用处：<ol><li>星期：Monday(星期一)、……、Sunday(星期天) </li><li>性别：Man(男)、Woman(女) </li><li>季节：Spring(春节)……Winter(冬天) </li><li>支付方式：Cash（现金）、WeChatPay（微信）、Alipay(支付宝)、BankCard(银行卡)、CreditCard(信用卡) </li><li>就职状态：Busy、Free、Vocation、Dimission</li><li>订单状态：Nonpayment（未付款）、Paid（已付款）、Delivered（已发货）、</li><li>Return（退货）、Checked（已确认）Fulfilled（已配货）、</li><li>线程状态：创建、就绪、运行、阻塞、死亡</li></ol></li></ol><h4 id="2-自定义枚举类"><a href="#2-自定义枚举类" class="headerlink" title="2.自定义枚举类"></a>2.自定义枚举类</h4><h5 id="1-如何自定义枚举类"><a href="#1-如何自定义枚举类" class="headerlink" title="1.如何自定义枚举类"></a>1.如何自定义枚举类</h5><p>方式一：jdk5.0之前，自定义枚举类</p><ol><li><p>声明当前枚举类对象中的属性: private final修饰</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String seasonName;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String seasonDesc;</span><br></pre></td></tr></table></figure></li><li><p>私有化类的构造器,并给对象属性赋值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="title function_">Season</span><span class="params">(String seasonName,String seasonDesc)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.seasonName = seasonName;</span><br><span class="line"><span class="built_in">this</span>.seasonDesc = seasonDesc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>提供当前枚举类的多个对象：public static final的（<strong>在枚举类内部new全局常量的对象</strong>）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">SPRING</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;春天&quot;</span>,<span class="string">&quot;春暖花开&quot;</span>);</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">SUMMER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;夏天&quot;</span>,<span class="string">&quot;夏日炎炎&quot;</span>);</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">AUTUMN</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;秋天&quot;</span>,<span class="string">&quot;秋高气爽&quot;</span>);</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">WINTER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;冬天&quot;</span>,<span class="string">&quot;冰天雪地&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>其他诉求：获取枚举类对象的属性  或  提供toString()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">getSeasonName</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> seasonName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getSeasonDesc</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> seasonDesc;</span><br><span class="line">&#125; <span class="comment">//或重写toString方法去提供用户所需的常量</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><p>全部代码演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义枚举类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Season</span>&#123;</span><br><span class="line">    <span class="comment">//1.声明Season对象的属性:private final修饰</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonDesc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.私有化类的构造器,并给对象属性赋值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Season</span><span class="params">(String seasonName,String seasonDesc)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.seasonName = seasonName;</span><br><span class="line">        <span class="built_in">this</span>.seasonDesc = seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.提供当前枚举类的多个对象：public static final的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">SPRING</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;春天&quot;</span>,<span class="string">&quot;春暖花开&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">SUMMER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;夏天&quot;</span>,<span class="string">&quot;夏日炎炎&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">AUTUMN</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;秋天&quot;</span>,<span class="string">&quot;秋高气爽&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">WINTER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;冬天&quot;</span>,<span class="string">&quot;冰天雪地&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.其他诉求1：获取枚举类对象的属性</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSeasonName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> seasonName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSeasonDesc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4.其他诉求1：提供toString()</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Season&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;seasonName=&#x27;&quot;</span> + seasonName + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, seasonDesc=&#x27;&quot;</span> + seasonDesc + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>2.声明调用自定义枚举类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Season</span> <span class="variable">spring</span> <span class="operator">=</span> Season.SPRING;   <span class="comment">//“  类名 . 内部new的全局常量  ”</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span>  <span class="variable">s1</span>  <span class="operator">=</span>   spring . getSeasonDesc( ) ;</span><br></pre></td></tr></table></figure><h4 id="3-enum关键字定义枚举类"><a href="#3-enum关键字定义枚举类" class="headerlink" title="3.enum关键字定义枚举类"></a>3.enum关键字定义枚举类</h4><p><strong>1.如何定义enum类</strong></p><p>方式二：jdk5.0，可以使用enum关键字定义枚举类</p><p>说明：定义的枚举类默认继承于java.lang.Enum类</p><ol><li><p>enum定义的枚举类区别于自定义枚举类在于，这里首先的得提供当前枚举类的多个或单个对象，<strong>由于这些对象在枚举类中都是全局常量，所以省略了多余的代码，只需写对象名后加“（属性赋值）”，如有多个则用逗号隔开，最后一个用分号</strong></p><p>代码演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">enum</span> <span class="title class_">Season</span>&#123;  <span class="comment">//--   enum + 类名  来定义类</span></span><br><span class="line">       SPRING(<span class="string">&quot;春天&quot;</span>,<span class="string">&quot;春暖花开&quot;</span>),</span><br><span class="line">       SUMMER(<span class="string">&quot;夏天&quot;</span>,<span class="string">&quot;夏日炎炎&quot;</span>),</span><br><span class="line">       AUTUMN(<span class="string">&quot;秋天&quot;</span>,<span class="string">&quot;秋高气爽&quot;</span>),</span><br><span class="line">       WINTER(<span class="string">&quot;冬天&quot;</span>,<span class="string">&quot;冰天雪地&quot;</span>);</span><br><span class="line">       <span class="comment">//如果没有属性：</span></span><br><span class="line">       SPRING,</span><br><span class="line">       SUMMER,</span><br><span class="line">       AUTUMN,</span><br><span class="line">       WINTER;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>声明当前枚举类对象中的属性: private final修饰</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String seasonName;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String seasonDesc;</span><br></pre></td></tr></table></figure></li><li><p>私有化类的构造器,并给对象属性赋值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="title function_">Season</span><span class="params">(String seasonName,String seasonDesc)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.seasonName = seasonName;</span><br><span class="line"></span><br><span class="line"><span class="built_in">this</span>.seasonDesc = seasonDesc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><strong>2.enum类中常用方法</strong></p><ol><li><p>values()</p><p><strong>返回枚举类型的对象数组</strong>。该方法可以很方便地遍历所有的枚举值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Season1[] values = Season1.values();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; values.length;i++)&#123;</span><br><span class="line">    System.out.println(values[i]);</span><br><span class="line">    <span class="comment">//输出：SPRIN GSUMMER AUTUMN WINTER</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>valueOf(String str)   —<strong>声明一个枚举类对象方式</strong></p><p>可以把一个字符串转为对应的枚举类对象。要求字符串必须是枚举类对象 的“名字”。如不是，会有运行时异常：IllegalArgumentException。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//valueOf(String objName):返回枚举类中对象名是objName的对象。</span></span><br><span class="line">        <span class="type">Season1</span> <span class="variable">winter</span> <span class="operator">=</span> Season1.valueOf(<span class="string">&quot;WINTER&quot;</span>); <span class="comment">//传入的参数必须存在于枚举类中</span></span><br><span class="line"><span class="comment">//如果没有objName的枚举类对象，则抛异常：     IllegalArgumentException</span></span><br><span class="line"><span class="comment">//   Season1 winter = Season1.valueOf(&quot;WINTER1&quot;);</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>toString()    — 也可考虑重写</p><p>返回当前枚举类对象常量的名称</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(winter.toString()); <span class="comment">//WINTER</span></span><br></pre></td></tr></table></figure></li></ol><p><strong>3.enum枚举类实现接口</strong></p><p>情况一：<strong>实现接口，在enum类中实现抽象方法</strong></p><ol><li>&#96;&#96;&#96;java<br>enum Season1 implements Info{<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">2. 重写接口中抽象方法</span><br><span class="line"></span><br><span class="line">3. **这里多个对象都共用一个重写的方法 （这不是重点讲的）**</span><br><span class="line"></span><br><span class="line">情况二：**让枚举类的对象分别实现接口中的抽象方法**</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">enum Season1 implements Info&#123;</span><br><span class="line">SPRING(&quot;春天&quot;,&quot;春暖花开&quot;)&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void show() &#123;</span><br><span class="line">        System.out.println(&quot;春天在哪里？&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">SUMMER(&quot;夏天&quot;,&quot;夏日炎炎&quot;)&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void show() &#123;</span><br><span class="line">        System.out.println(&quot;宁夏&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">AUTUMN(&quot;秋天&quot;,&quot;秋高气爽&quot;)&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void show() &#123;</span><br><span class="line">        System.out.println(&quot;秋天不回来&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">WINTER(&quot;冬天&quot;,&quot;冰天雪地&quot;)&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void show() &#123;</span><br><span class="line">        System.out.println(&quot;大约在冬季&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><h1 id="三、注解Annotation"><a href="#三、注解Annotation" class="headerlink" title="三、注解Annotation"></a>三、注解Annotation</h1><h3 id="3-1注解的概述"><a href="#3-1注解的概述" class="headerlink" title="3.1注解的概述"></a>3.1注解的概述</h3><p>① jdk 5.0 新增的功能</p><p>② Annotation 其实就是代码里的特殊标记, <strong>这些标记可以在编译, 类加载, 运行时被读取, 并执行相应的处理</strong>。通过使用 Annotation,程序员可以在不改变原有逻辑的情况下, 在源文件中嵌入一些补充信息。</p><p>③在JavaSE中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等。在JavaEE&#x2F;Android中注解占据了更重要的角色，例如用来配置应用程序的任何切面，代替JavaEE旧版中所遗留的繁冗代码和XML配置等。</p><p>.框架  &#x3D;  注解  +  反射机制  +  设计模式</p><h3 id="3-2Annocation使用示例"><a href="#3-2Annocation使用示例" class="headerlink" title="3.2Annocation使用示例"></a>3.2Annocation使用示例</h3><p>示例一：生成文档相关的注解</p><ol><li>@author <strong>标明开发该类模块的作者</strong>，多个作者之间使用,分割</li><li>@version 标明该类模块的版本</li><li>@see 参考转向，也就是相关主题</li><li>@since 从哪个版本开始增加的</li><li>@param 对方法中某参数的说明，如果没有参数就不能写</li><li>@return 对方法返回值的说明，如果方法的返回值类型是void就不能写</li><li>@exception 对方法可能抛出的异常进行说明 ，如果方法没有用throws显式抛出的异常就不能写</li></ol><p>示例二：在编译时进行格式检查(JDK内置的三个基本注解)</p><ol><li><p>@Override: 限定<strong>重写父类方法</strong>, 该注解只能用于方法</p></li><li><p>@Deprecated: 用于表示所修饰的元素(类, 方法等)已过时。通常是因为所修饰<strong>的结构危险</strong>或<strong>存在更好的选择</strong></p></li><li><p>@SuppressWarnings: <strong>抑制编译器警告</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;unused&quot;)</span> <span class="comment">//提示声明还未使用</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="meta">@SuppressWarnings(&#123; &quot;unused&quot;, &quot;rawtypes&quot; &#125;)</span></span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br></pre></td></tr></table></figure></li></ol><p>示例三：跟踪代码依赖性，实现替代配置文件功能</p><h3 id="3-3如何自定义注解"><a href="#3-3如何自定义注解" class="headerlink" title="3.3如何自定义注解"></a>3.3如何自定义注解</h3><p>参照@SuppressWarnings定义</p><ol><li><p><strong>注解声明为：@interface</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>内部定义成员，通常使用value表示</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>可以指定成员的默认值，使用default定义  ，有单个成员时可在声明时指定值</p><p><strong>使用default在内部初始值</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>有单个成员时可在声明时指定值</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MyAnnotation(value=&quot;abc&quot;)</span> <span class="comment">//value可加可不加</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">.....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果<strong>自定义注解没有成员，表明是一个标识作用</strong>。</p></li></ol><p><strong>注意：</strong></p><ol><li>如果注解有成员，在使用注解时，需要指明成员的值。</li><li>自定义注解必须配上注解的信息处理流程(使用反射)才有意义。</li><li>自定义注解通过都会指明两个元注解：Retention、Target</li></ol><h3 id="3-4jdk-提供的4种元注解"><a href="#3-4jdk-提供的4种元注解" class="headerlink" title="3.4jdk 提供的4种元注解"></a>3.4jdk 提供的4种元注解</h3><p><strong>元注解：对现有的注解进行解释说明的注解</strong></p><ol><li><p>Retention：指定所修饰的 Annotation 的生命周期：SOURCE（没编译时就不在了）\CLASS（默认行为–编译时还在）\RUNTIME （运行时还在）</p><p><strong>只有声明为RUNTIME生命周期的注解，才能通过反射获取</strong>。</p></li><li><p>Target  :  用于指定被修饰的 Annotation 能用于修饰哪些程序元素</p><p>以下的出现的频率较低</p></li><li><p>Documented  :  表示所修饰的注解在被javadoc解析时，保留下来。</p><p>一般情况以下被javadoc解析为.class文件中没有注解，但是加上这个注解可将注解保留下来</p></li><li><p>Inherited  :  被它修饰的 Annotation 将具有继承性。</p><p>用它注解时，该类的子类也拥有同父类一样的注解</p></li><li><p>代码演示：</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">   <span class="meta">@Inherited</span></span><br><span class="line">   <span class="meta">@Repeatable(MyAnnotations.class)</span></span><br><span class="line">   <span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line">   <span class="meta">@Target(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE,TYPE_PARAMETER,TYPE_USE&#125;)</span></span><br><span class="line">   <span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line"></span><br><span class="line">String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="3-5通过反射获取注解信息"><a href="#3-5通过反射获取注解信息" class="headerlink" title="3.5通过反射获取注解信息"></a>3.5通过反射获取注解信息</h3><p>—到反射内容时系统讲解</p><p>6.jdk 8 中注解的新特性：</p><p><strong>1.可重复注解</strong></p><p>需求：使用两个同名的注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MyAnnotation(value=&quot;hi&quot;)</span></span><br><span class="line"><span class="meta">@MyAnnotation(value=&quot;abc&quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>① 在MyAnnotation上声明@Repeatable，成员值为MyAnnotations.class</p><p>② MyAnnotation的Target和Retention<strong>等元注解</strong>与MyAnnotations<strong>相同</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Inherited</span>  <span class="comment">//---原来的注解</span></span><br><span class="line"><span class="meta">@Repeatable(MyAnnotations.class)</span><span class="comment">//---操作一</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE,TYPE_PARAMETER,TYPE_USE&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line"></span><br><span class="line">String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Inherited</span>   <span class="comment">//-----重复的注解 </span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotations &#123;</span><br><span class="line"></span><br><span class="line">MyAnnotation[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.类型注解</strong></p><p>类型注解：能在多个类型中注解</p><p>ElementType.TYPE_PARAMETER 表示该注解能写在类型变量的声明语句中（如：泛型声明。)<br>ElementType.TYPE_USE 表示该注解能写在使用类型的任何语句中。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、多线程&quot;&gt;&lt;a href=&quot;#一、多线程&quot; class=&quot;headerlink&quot; title=&quot;一、多线程&quot;&gt;&lt;/a&gt;一、多线程&lt;/h1&gt;&lt;h3 id=&quot;1-1基本概念&quot;&gt;&lt;a href=&quot;#1-1基本概念&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Java编程基础</title>
    <link href="http://example.com/2022/10/02/%E5%B0%9A%E7%A1%85%E8%B0%B7java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    <id>http://example.com/2022/10/02/%E5%B0%9A%E7%A1%85%E8%B0%B7java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/</id>
    <published>2022-10-01T16:00:00.000Z</published>
    <updated>2022-10-05T08:44:45.933Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、Java概述"><a href="#一、Java概述" class="headerlink" title="一、Java概述"></a>一、Java概述</h1><h3 id="1-1Java通识介绍"><a href="#1-1Java通识介绍" class="headerlink" title="1.1Java通识介绍"></a>1.1Java通识介绍</h3><p>(1)Java基础是学习JavaEE、大数据、Android开发的基石！</p><p>(2)人机交互方式：1.图形化界面GUI简单直观易于上手    2.命令行方式CLI需要一个控制台，输入特定的指令，让计算机完成一些</p><p>(3)Java    API 文档：习惯上将语言提供的 类库称为API，API文档是解释如何是这些泪流的说明书</p><h3 id="1-2常用的DOS命令"><a href="#1-2常用的DOS命令" class="headerlink" title="1.2常用的DOS命令"></a>1.2常用的DOS命令</h3><p>d: （进入D盘盘符)、cd（进入指定目录，可以直接进入也可一步一步进）、cd..（退回到上一级）、cd\（退回到根目录）、del（删除文件）、rd（删除目录，直接rd有文件的目录可选择删除该文件下的所有文件）、md（创建目录）、dir（列出当前目录下的文件及文件夹）、del *.txt（星花表示所有的意思）</p><h3 id="1-3-编写HelloWorld"><a href="#1-3-编写HelloWorld" class="headerlink" title="1.3 编写HelloWorld"></a>1.3 编写HelloWorld</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HelloChina</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Hello,World&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>首先创建一个java文件，在文件中写入内容（如以上格式），cmd命令操作进入到文件所在位置写入 <strong>编译</strong>操作javac  文件名.java，此时会自动生成一个HelloChina.class文件，在写入<strong>运行</strong>操作java  文件名（class的文件名)</p></li><li><p>在一个java源文件中可以声明多个class。但是只能最多有一个类声明为public的。而且要求声明为public的类的类名必须与源文件名相同。</p></li><li><p>程序的入口是main（）方法，格式是固定的</p></li><li><p>输出语句：</p><p>System.out.println();  先输出数据后换行，单写就是换行</p><p>System.out.print();       只输出数据</p></li><li><p>每一行语句执行都以分号“；”结束</p></li><li><p>编译的过程：编译以后，会生成一个或多个字结码文件</p></li></ol><p>注意：Java严格区分大小写</p><h3 id="1-4-注释（comment）"><a href="#1-4-注释（comment）" class="headerlink" title="1.4 注释（comment）"></a>1.4 注释（comment）</h3><ol><li><p>​         &#x2F;&#x2F;单行注释    </p></li><li><p>​         &#x2F;* 多行注释 *&#x2F;</p></li><li><p>​           文档注释 Java特有的  </p><p>   &#x2F;** </p><p>@author 指定Java程序作者</p><p>@version 指定源文件版本</p><p> *&#x2F;</p><p>注释内容可以被JDK提供的工具javadoc所解析，生成一套以网页文件形式体现的该程序的说明文档</p><p>操作码为Javadoc  -d  目录名  -author  -version 文件名.java（需要解析的文件）</p></li></ol><h1 id="二、java基础语法"><a href="#二、java基础语法" class="headerlink" title="二、java基础语法"></a>二、java基础语法</h1><h3 id="2-1关键字与保留字"><a href="#2-1关键字与保留字" class="headerlink" title="2.1关键字与保留字"></a>2.1关键字与保留字</h3><p>  定义：被java语言赋予特殊含义，用做专门用途的字符串</p><p>  特点：关键字中所有字母都为小写</p><ol><li><p>用于定义整型类型的关键字    class\interface\enum\byte\short\int\long\float\double\char\boolean\void</p></li><li><p>用于定义流程控制的关键字</p></li></ol><p>​     if\else\switch\case\default\while\do\for\break\continue\return</p><ol start="3"><li>用于定义访问权限修饰符的关键字</li></ol><p>   private\protected\public</p><ol start="4"><li><p>用于定义类、函数、变量修饰符的关键字</p><p>abstract\final\static\synchronized</p></li><li><p>用于定义类与类之间关系的关键字  </p><p>extends\implements\</p></li><li><p>用于定义建议实例及引用实例，判断实例的关键字</p><p>new\this\super\instanceof</p></li><li><p>用于异常处理的关键字</p><p>try\catch\finally\throw\throws</p></li><li><p>用于包的关键字</p><p>package\import</p></li><li><p>其他修饰符关键字</p><p>native\strictfp\transient\volatile\assert</p></li><li><p>用于定义数据类型值的字面值（不属于关键字）</p></li></ol><p>  true\false\null</p><ol start="11"><li>保留字goto、const</li></ol><h3 id="2-2-标识符"><a href="#2-2-标识符" class="headerlink" title="2.2 标识符"></a>2.2 标识符</h3><ol><li>定义：凡是自己可以起名字的地方都叫标识符</li></ol><p>​             比如：类名、变量名、方法名、接口名、包名</p><ol start="2"><li>标识符的命名规则（不规则影响运行）</li></ol><p>​            由26个英文字母大小写、0-9、__ 、或$组成</p><p>​            数字不可以开头</p><p>​            不可以使用关键字和保留字，但能包含</p><p>​            Java严格区分大小写，长度无限制</p><p>​            标识符不能包含空格</p><ol start="3"><li>Java中的名称命名的规范(不规范不影响运行，影响美观和可读性)</li></ol><p>​              包名：多组单词组成时所有字母都小写：xxxxyyzzz</p><p>​              类名、接口名：多组单词组成时，所有单词的首字母大写：XxxYyyZzz</p><p>​             变量名、方法名：多组单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写：xxYyyZzz</p><p>​             常量名：左右字母都大写，多单词时每个单词用下划线连接：XXX_YYY_ZZZ</p><h3 id="2-3变量"><a href="#2-3变量" class="headerlink" title="2.3变量"></a>2.3变量</h3><h4 id="1-变量的概念"><a href="#1-变量的概念" class="headerlink" title="1.变量的概念"></a>1.变量的概念</h4><p>​       变量是程序中最基本的存储单元，包含变量类型、变量名和存储的值，内存中的一个存储区域，用于在内存中保存数据</p><h4 id="2-使用变量注意："><a href="#2-使用变量注意：" class="headerlink" title="2.使用变量注意："></a>2.使用变量注意：</h4><p>2.1java 中每个变量必须先声明并赋值（a&#x3D;0），后使用</p><p>2.2使用变量名访问这块区域的数据，只能在作用域才有效，也就是{  }中</p><p>2.3同一个作用域内，不能定义重名的变量</p><h4 id="3-基本数据类型"><a href="#3-基本数据类型" class="headerlink" title="3.基本数据类型"></a>3.基本数据类型</h4><p>1.整型：</p><p>​          byte\short\int\long </p><p>​         byte（1字节&#x3D;8bit）\short（2字节）\int（4字节）\long （8字节）</p><p>​         byte范围：-128 ~ 127</p><p>​         声明long型变量：必须以“l”或者“L”结尾  （long  b&#x3D; 1234L）</p><p>​          通常使用int类型</p><p>2.浮点型：</p><p>​                    float\double</p><p>​                      float（4字节）\double（8字节）</p><p>​                    浮点型表示带小数点的数值</p><p>​                     float表示数值范围比long还大</p><p>​                    定义float类型变量时，变量要以“f”或者“F”结尾</p><p>​                     通常使用double型</p><p>3.字符型：</p><p>​    char  （1字符 &#x3D; 2字节）</p><p>​     定义char型变量，通常用一对 ‘ ’ ，内部只能写一个字符  a&#x3D;‘b’ 。也可用直接用数字</p><ol><li><p>当是char &#x3D; ‘A’ 时</p><p>直接输出，就是A</p><p>如果做运算在输出，这是对应的Ascll码值做运算后的数：’A’ &#x3D;65  ‘A’ -1&#x3D;64;</p></li><li><p>当是char  &#x3D;  65</p><p>直接输出就是对应的A（字符）</p><p>做运算后就是数</p></li><li><p>&#x3D;&#x3D;比较的是Ascll码值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> <span class="variable">num5</span> <span class="operator">=</span><span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"><span class="type">char</span> <span class="variable">num6</span> <span class="operator">=</span><span class="number">65</span>;</span><br><span class="line">System.out.println(num5==num6);</span><br><span class="line"><span class="comment">//true</span></span><br></pre></td></tr></table></figure></li></ol><blockquote><p>  转义字符：\b退格符\n换行符\r回车符\t制表符大空格&quot;引号\\反斜杠</p></blockquote><p>4.布尔型：</p><p>  boolean</p><ul><li>ture、false（常用于条件判断，循环结构中使用）</li></ul><h4 id="4-引用数据类型"><a href="#4-引用数据类型" class="headerlink" title="4.引用数据类型"></a>4.引用数据类型</h4><p>补充：引用类型变量，只可能存储两类值：null  或  地址值（含变量类型）</p><p>1.类：class</p><p>2.接口：interface</p><p>3.数组：array</p><ol><li><p>强制转换</p><p>需要强制转换符（），注意转换时可能会导致精度损失</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> d1=<span class="number">12.9</span>;</span><br><span class="line"><span class="type">int</span> i=(<span class="type">int</span>)d1;</span><br></pre></td></tr></table></figure></li><li><p>自动类型提升</p><p>结论：当容量小的数据类型变量与容量大的数据类型变量做运算时，结果自动提升为容量大的数据类型</p><p>byte\char\short--&gt;int–&gt;long–&gt;float–&gt;double</p><p>特别地，当byte\char\short做运算时结果都为int</p></li></ol><p>4.String类型变量</p><ol><li><p>String属于引用数据类型，意思是  字符串</p></li><li><p>声明String类型变量时，使用一对“”</p></li><li><p>String可以和八种数据类型变量做运算，且运算只能是连接运算 +  </p></li><li><p>在String之后的运算结果仍然是String类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> “ hello”</span><br><span class="line"><span class="type">int</span>  <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>；</span><br><span class="line"><span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span>  <span class="number">2</span>；</span><br><span class="line">s +  i  +j  =hello12</span><br><span class="line">i + j  +  s = 3hello </span><br><span class="line"><span class="comment">//注意定义</span></span><br><span class="line"> <span class="type">String</span>  <span class="variable">s2</span> <span class="operator">=</span> “”；  <span class="comment">//可为空</span></span><br><span class="line"> <span class="type">char</span>  <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&#x27;&#x27;</span>  <span class="comment">//不可为空</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="2-4进制转换"><a href="#2-4进制转换" class="headerlink" title="2.4进制转换"></a>2.4进制转换</h3><p>对于整数，有四种表达方式：</p><ol><li><p>二进制    满二进一，以0b或0B开头</p></li><li><p>十进制      满十进一</p></li><li><p>八进制      满八进一  以数字0开头表示</p></li><li><p>十六进制   满十六进一   以0x或0X开头 </p></li><li><p>二进制转换其他进制 0  、1 ，满二进一，以0b或0B开头</p><ol><li><p>十进制</p><p>1011&#x3D;1*2的0次方+1 *2的1次方+0 *2的2次方+1 *2的3次方&#x3D; 11</p><p><strong>注意</strong>有小数点时：1011.01 先计算整数部分剩余0.01&#x3D;0 *2的0次方+1 *2的-1次方&#x3D;0.5</p></li><li><p>八进制</p><p>1011看成三位一组001-011&#x3D;&gt;1+3&#x3D;4</p></li><li><p>十六进制</p><p>1011看成四位一组1011&#x3D;&gt;B</p></li></ol></li><li><p>十进制转换其他进制  0—9</p><p>​         想转什么进制就除什么倒取余法</p><p>​         <strong>注意</strong>转二进制有小数点时：先计算整数部分，如剩余0.5，不断乘2取整，直到小数部分为零0.5对应的二进制是0.1,0.25对应0.01</p></li><li><p>八进制转换其他进制 0—-7</p><ol><li><p>二进制</p><p>每个数看成三个位数一组的二进制</p></li><li><p>十进制</p><p>先转成二进制在二转十</p></li><li><p>十六进制</p><p>先转二在转十六</p></li></ol></li><li><p>十六进制转换其他进制 0—-F（A&#x3D;10….F&#x3D;15)</p><ol><li><p>二进制</p><p>每个数看成四个位数一组的二进制</p></li><li><p>十进制</p><p>先转成二进制在二转十</p></li><li><p>八进制</p><p>先转成二进制在二转八</p></li></ol><p>计算机底层以补码形式存储数据，注意给的码为原码要转补码进行计算，如果最高位为0则为正数，原码反码补码都一样，若最高位为1则为负数</p><p>则原码除最高位字符数不懂其余取反加一为补码</p></li><li><p>补充代码：十转十六(传统方法，一般直接调用类来算)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>  <span class="variable">p1</span> <span class="operator">=</span> <span class="number">60</span> ;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>  <span class="variable">p2</span> <span class="operator">=</span> p1&amp;<span class="number">15</span>;  <span class="comment">//由于60底层是二进制存储，和15逻辑与1111，保留了前四位数</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">j</span> <span class="operator">=</span> (p2&gt;<span class="number">9</span>)?(<span class="type">char</span>)(p2-<span class="number">10</span>+<span class="string">&#x27;A&#x27;</span>)+<span class="string">&quot;&quot;</span> : p2+<span class="string">&quot;&quot;</span> ;  <span class="comment">//若大于9，则用字母表示</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> p1&gt;&gt;&gt; <span class="number">4</span>;  <span class="comment">//右移4位，将后四位移到前面</span></span><br><span class="line"></span><br><span class="line">p2 = temp &amp; <span class="number">15</span>;     <span class="comment">//在次保留了后四位</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span>   <span class="variable">k</span> <span class="operator">=</span>  (p2&gt;<span class="number">9</span>)?(<span class="type">char</span>)(p2-<span class="number">10</span>+<span class="string">&#x27;A&#x27;</span>)+<span class="string">&quot;&quot;</span> : p2+ <span class="string">&quot;&quot;</span> ;  </span><br><span class="line"></span><br><span class="line">System.out.println(k+<span class="string">&quot;&quot;</span>+j);   <span class="comment">// 3 C</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="2-5-运算符"><a href="#2-5-运算符" class="headerlink" title="2.5 运算符"></a>2.5 运算符</h3><h4 id="1-算术运算符"><a href="#1-算术运算符" class="headerlink" title="1.算术运算符"></a>1.算术运算符</h4><p>+正号-负号+加号-减号*乘号&#x2F;除号%取余号 ，++,–,</p><p>(前)++，先自增1，后运算</p><p>(后)–，先运算后，自增1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">short</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="number">10</span> ；</span><br><span class="line"><span class="comment">//s1 = s1 + 1 //编译失败，加 2 变为整型int</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：s++ 不会改变本身的数据类型</p></blockquote><h4 id="2-赋值运算符"><a href="#2-赋值运算符" class="headerlink" title="2.赋值运算符"></a>2.赋值运算符</h4><p>&#x3D;      +&#x3D;    -&#x3D;     *&#x3D;    &#x2F;&#x3D;    %&#x3D;</p><ol><li><p>int i &#x3D; 10 ;      int  j &#x3D; 10;</p></li><li><p>int i , j ;           i&#x3D;j&#x3D;10  ;</p></li><li><p>int i&#x3D;10,j&#x3D;10;</p></li><li><p>n +&#x3D;2     &#x2F;&#x2F; n &#x3D;  n  +   2</p></li><li><p>&#x2F;&#x2F;s1 &#x3D; s1 + 2 &#x2F;&#x2F;编译失败，加 2 变为整型int</p><p>注意：s1 +&#x3D; 2   不会改变本身的数据类型</p></li></ol><h4 id="3-比较运算符（关系运算符）"><a href="#3-比较运算符（关系运算符）" class="headerlink" title="3.比较运算符（关系运算符）"></a>3.比较运算符（关系运算符）</h4><p>&#x3D;&#x3D;     !&#x3D;   &gt;    &lt;     &gt;&#x3D;     &lt;&#x3D;    instanceof</p><p>比较运算符的结果是 boolean 类型 </p><p>   &lt;  &gt;   &gt;&#x3D;     &lt;&#x3D;  ：只能使用在数值类型的数据之间</p><p>&#x3D;&#x3D;     !&#x3D;     ：不仅可以使用在数值类型数据之间，还可以使用在引用类型变量之间</p><h4 id="4-逻辑运算符"><a href="#4-逻辑运算符" class="headerlink" title="4.逻辑运算符"></a>4.逻辑运算符</h4><p>&amp; （逻辑与）&amp;&amp;（短路与）  都一样 ，遇到false为false</p><blockquote><p>&amp;：前面表达式为真时，继续执行后面的表达式</p><p>&amp;&amp;：遇到false 不会执行后面的表达式</p></blockquote><p>|    （逻辑或）  ||    （短路或） 都一样 ， 遇到true 为true</p><blockquote><p>|：前面表达式为真时，继续执行后面的表达式</p><p>||：遇到true 不会执行后面的表达式</p></blockquote><p>！ （逻辑非）   ^    （逻辑异或） 异或一样则错，不同则对</p><h4 id="5-三元运算符"><a href="#5-三元运算符" class="headerlink" title="5.三元运算符"></a>5.三元运算符</h4><ol><li>结构： （条件表达式）？ 表达式1 ： 表达式2</li><li>说明：<ol><li>条件表达式结果为boolean </li><li>条件表达式为真选表达式1，反之2</li><li>表达式1和表达式2类型要求是一致的</li><li>三元运算符可以嵌套使用</li></ol></li><li>凡是可以使用三元运算符的地方，都可以改写为if -  else  反之不成立</li><li>如果程序两者都可用，优先选择三元运算符，原因：简洁，执行效率高</li></ol><p>举例：</p><p><img src="/2022/10/02/%E5%B0%9A%E7%A1%85%E8%B0%B7java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/Snipaste_2022-01-14_21-02-00.png" alt="Snipaste_2022-01-14_21-02-00"></p><h4 id="6-位运算符"><a href="#6-位运算符" class="headerlink" title="6.位运算符"></a>6.位运算符</h4><ol><li><p>位运算符操作都是整型操作的数据,二进制形式移动</p></li><li><p>&lt;&lt; :  空位补0，被移除的高位丢弃，空缺位补0</p><p>在一定范围内， 每向左移一位，相当于  乘2</p></li><li><p>(&gt;&gt;) : 被位移的二进制最高位是0，右移后空位缺位补0；最高位是1，空缺补1</p><p> 在一定范围内，每向右移一位，相当于  除二</p></li><li><p>面试题 ： 最高效方式计算 2 *  8  ?   2&lt;&lt; 3 或者  8&lt;&lt; 1</p></li><li><p>(&gt;&gt;&gt;): 被右移二进制最高位无论是0或者是1 ，空缺位都用零补</p></li><li><p>二进制运算  &amp; 有0则都为0   | 有1则都为1      ^  同则0 不同则1   ~ 取反</p></li></ol><h3 id="2-6-程序流程控制"><a href="#2-6-程序流程控制" class="headerlink" title="2.6 程序流程控制"></a>2.6 程序流程控制</h3><p>注意：以下流程控制语句都是可嵌套使用的</p><h4 id="1-if–else"><a href="#1-if–else" class="headerlink" title="1.if–else"></a>1.if–else</h4><p>第一种</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>（条件表达式）&#123;</span><br><span class="line">执行表达式</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>（条件表达式）&#123;</span><br><span class="line">执行表达式</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">执行表达式<span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三种（满足一个则终止下面的判断）多选一</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>（条件表达式）&#123;</span><br><span class="line">执行表达式<span class="number">1</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>（条件表达式）&#123;</span><br><span class="line">执行表达式<span class="number">2</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>（条件表达式）&#123;</span><br><span class="line">执行表达式<span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line">....</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">     执行表达式n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：if–else可嵌套使用</p></blockquote><h4 id="2-java中的输入，需要使用Scanner类"><a href="#2-java中的输入，需要使用Scanner类" class="headerlink" title="2.java中的输入，需要使用Scanner类"></a>2.java中的<strong>输入，需要使用Scanner类</strong></h4><p>具体操作步骤：</p><ol><li><p>导包： import java.util.Scanner;</p></li><li><p>Scanner的实例化：Scanner scan &#x3D; new Scanner(System.in);</p></li><li><p>调用Scanner类的相关方法（next（）这是输入String类型特殊&#x2F;nextXxx（）这是输入其他类型的)</p></li><li><p>注意：需要根据相应的类型来从键盘输入指定类型的值，否则会报错</p></li><li><p>代码示范：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ScannerTest</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">scan</span> <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    <span class="type">int</span> <span class="variable">test</span> <span class="operator">=</span> scan.nextInt();</span><br><span class="line">    <span class="comment">//第二种</span></span><br><span class="line">    <span class="type">int</span> test=<span class="number">0</span>;</span><br><span class="line">    test =  scan.nextInt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>对于char型的获取，Scanner没有提供相应的方法。一般只用String代替。如要获取则有如下方法</p><p>将String字符串中取出一个字符放入char中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">p</span> <span class="operator">=</span> “安娜娜”；</span><br><span class="line"><span class="type">char</span>  <span class="variable">q</span> <span class="operator">=</span> p.charAt(<span class="number">0</span>);  <span class="comment">//第一个字符从零开始  q=‘安’</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="3-switch-表达式"><a href="#3-switch-表达式" class="headerlink" title="3.switch(表达式){"></a>3.switch(表达式){</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式)&#123;</span><br><span class="line">   <span class="keyword">case</span> x：执行语句；</span><br><span class="line">           <span class="keyword">break</span>；</span><br><span class="line">   <span class="keyword">case</span> m：</span><br><span class="line"> ....</span><br><span class="line">   <span class="keyword">default</span>：执行语句； </span><br><span class="line">      <span class="keyword">break</span>；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>根据switch表达式中的值，依次匹配各个case中的<strong>常量</strong>。一旦匹配成功，则进入相应case结构中，调用其执行语句。执行本语句结束后，<strong>继续向下调</strong>用其余case结构中的执行语句，直到遇到break关键字或者直到switch末尾结束。</p></li><li><p>break与default是可加可不加的，default是没有其他选择后最后的选择</p></li><li><p>switch结构中的表达式，只能是这6种数据类型之一：</p><p>byte、short、char、int、枚举类型JDK5.0新增、String类型JDK7.0新增</p></li><li><p>switch两种情况测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(constant)&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>: a=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>: a=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>: a=<span class="number">3</span>;</span><br><span class="line"><span class="keyword">default</span>:a=<span class="number">4</span>;</span><br><span class="line">&#125;<span class="comment">//输入1，遍历1 语句后没有break，向下遍历，最终a=4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span>(constant)&#123;</span><br><span class="line"><span class="keyword">default</span>:a=<span class="number">4</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>: a=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>: a=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>: a=<span class="number">3</span>;</span><br><span class="line">&#125;    <span class="comment">//  输入1 ，没有break，直到末尾a=3，没有遍历default</span></span><br><span class="line">System.out.println(a);</span><br></pre></td></tr></table></figure></li><li><p>判断闰年：可以被4整除并且不可以被100整除或可以被400整除</p></li></ol><h4 id="4-for-循环语句"><a href="#4-for-循环语句" class="headerlink" title="4.for 循环语句"></a>4.for 循环语句</h4><ol><li><p>条件：</p><ol><li>初始条件</li><li>循环条件—–&gt;是boolean类型</li><li>循环体（执行语句）</li><li>迭代条件</li></ol></li><li><p>for 循环的结构:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>( <span class="number">1</span>初始条件 ;  <span class="number">2</span>循环条件   ;  <span class="number">4</span>迭代条件  )&#123;</span><br><span class="line">        <span class="number">3</span>循环体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>&#96;&#96;&#96;java<br>for（int i &#x3D; 1 ;  i&lt;&#x3D;5 ; i++){<br>System.out.println(“Hello,world!”);<br>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   &gt; **注意：i在for循环内有效**。出了for循环就失效，无法在调用。</span><br><span class="line"></span><br><span class="line">#### 5.while循环语句</span><br><span class="line"></span><br><span class="line">1. 循环结构四个要素条件：</span><br><span class="line"></span><br><span class="line">   1. 初始条件</span><br><span class="line">   2. 循环条件-----&gt;是boolean类型</span><br><span class="line">   3. 循环体（执行语句）</span><br><span class="line">   4. 迭代条件</span><br><span class="line"></span><br><span class="line">2. while循环的结构</span><br><span class="line"></span><br><span class="line">   ```java</span><br><span class="line">   int i = 1；</span><br><span class="line">   while（i&lt;=100）</span><br><span class="line">   &#123;</span><br><span class="line">   执行语句；......</span><br><span class="line">   迭代条件 i + +</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>由于算法要求有限性，所以要避免死循环</p></blockquote><h4 id="6-do-–while循环"><a href="#6-do-–while循环" class="headerlink" title="6.do –while循环"></a>6.do –while循环</h4><ol><li><p>循环结构四个要素条件：</p><ol><li>初始条件</li><li>循环条件—–&gt;是boolean类型</li><li>循环体（执行语句）</li><li>迭代条件</li></ol></li><li><p>do—while循环结构</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>初始条件</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line"><span class="number">3</span>循环体（执行语句）；</span><br><span class="line"><span class="number">4</span>迭代条件；</span><br><span class="line">&#125;<span class="keyword">while</span>（<span class="number">2</span>循环条件）；</span><br></pre></td></tr></table></figure></li><li><p>说明：</p><p>do—while循环至少会执行一次循环体！</p><p>开发中，使用for和while更多一些，较少使用do—while</p></li></ol><h3 id="2-7此节的一些零碎要点"><a href="#2-7此节的一些零碎要点" class="headerlink" title="2.7此节的一些零碎要点"></a>2.7此节的一些零碎要点</h3><h5 id="1-计算程序运行时间"><a href="#1-计算程序运行时间" class="headerlink" title="1.计算程序运行时间"></a>1.计算程序运行时间</h5><p>利用System.currentTimeMillis();</p><p>这返回的是1970-01-01 00:00:00long型的毫秒数时间：</p><p>long start &#x3D; System.currentTimeMillis();</p><p>需要计算的程序放中间</p><p>long end  &#x3D; System.currentTimeMillis();</p><p>用end - start得到的就是运行程序所需的时间</p><h5 id="2-Math-sqrt-i"><a href="#2-Math-sqrt-i" class="headerlink" title="2.Math.sqrt(i);"></a>2.Math.sqrt(i);</h5><p> 对i进行开根号</p><h5 id="3-关键字：return"><a href="#3-关键字：return" class="headerlink" title="3.关键字：return"></a>3.关键字：return</h5><p>并非专门用于结束循环的，它的功能是结束一个方法（函数）</p><h5 id="4-关键字：break和continue"><a href="#4-关键字：break和continue" class="headerlink" title="4.关键字：break和continue"></a>4.关键字：break和continue</h5><table><thead><tr><th></th><th align="left">使用范围</th><th>循环中的不同</th><th>相同点</th></tr></thead><tbody><tr><td>break</td><td align="left">循环结构中以及switchcase</td><td>结束当前循环</td><td>关键字后面不能在写语句</td></tr><tr><td>continue</td><td align="left">循环结构中</td><td>结束当次循环</td><td>关键字后面不能在写语句</td></tr></tbody></table><h5 id="5-Math-random-产生随机数"><a href="#5-Math-random-产生随机数" class="headerlink" title="5.Math.random()产生随机数"></a>5.Math.random()产生随机数</h5><p><strong>Math.random()<strong>这函数</strong>产生的随机数</strong>是double类型的范围是[0.0,1.0)</p><p>如何获取一个随机数10-99：</p><p>int  value &#x3D; (int)(Math.random()*90+10)</p><p>乘90范围变为[0.0,90.0)，加十[10.0,100.0)，强转int后[10,99]</p><p>得出公式：[a,b]：(int)(Math.random()*(b-a+1)+a)</p><p>注意：</p><ol><li><p>默认结束包裹此关键字最近的一层循环</p></li><li><p>&#96;&#96;&#96;java<br>label:for(int i&#x3D;1; i&lt;&#x3D;4;i++)<br>if (i%4&#x3D;&#x3D;0)<br> break label ; &#x2F;&#x2F;结束指定标识的一层循环结构<br>continue label; &#x2F;&#x2F;结束指定标识的一层循环结构当次循环</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##### 6.补充：衡量一个功能代码的优劣</span><br><span class="line"></span><br><span class="line">1. 正确性</span><br><span class="line">2. 可读性</span><br><span class="line">3. 健壮性</span><br><span class="line">4. 高效率与低存储：时间复杂度、空间复杂度（衡量算法的好坏）</span><br><span class="line"></span><br><span class="line"># 三、数组</span><br><span class="line"></span><br><span class="line">### 3.1数组的概述</span><br><span class="line"></span><br><span class="line">#### 1. 数组的理解：</span><br><span class="line"></span><br><span class="line">数组（Array），是多个相同类型数据按一定顺序排序的集合，并使用一个名字命名，并通过编号的方式对这些数据进行统一管理。</span><br><span class="line"></span><br><span class="line">#### 2.数组的相关概念：</span><br><span class="line"></span><br><span class="line">1. 数组名</span><br><span class="line">2. 元素</span><br><span class="line">3. 角标、下标、索引</span><br><span class="line">4. 数组的长度：元素个数</span><br><span class="line"></span><br><span class="line">#### 3.数组的特点：</span><br><span class="line"></span><br><span class="line">1. 数组是有序的</span><br><span class="line">2. 数组属于引用数据类型的变量。数组元素，既可以是基本数据类型，也可以是引用数据类型</span><br><span class="line">3. 创建数组对象会存在中开辟一整块连续的空间</span><br><span class="line">4. 数组的长度一旦确定，就不能修改</span><br><span class="line"></span><br><span class="line">#### 4.数组的分类：</span><br><span class="line"></span><br><span class="line">1. 按维数：一维数组、二维数组..........</span><br><span class="line">2. 按照数组元素的类型，基本数据元素的数组、引用数据类型元素的数组</span><br><span class="line"></span><br><span class="line">### 3.2一维数组的使用</span><br><span class="line"></span><br><span class="line">#### 1.一维数组的声明和初始化</span><br><span class="line"></span><br><span class="line">1.**静态**初始化：数组的初始化和数组元素的赋值操作**同时进行**</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">(1)</span><br><span class="line">int[ ]  ids;</span><br><span class="line">ids = new  int[ ]&#123;1,3,4,5,6,7&#125;;</span><br><span class="line">(2)</span><br><span class="line">int[ ]  ids= new  int[ ]&#123;1,3,4,5,6,7&#125;;</span><br><span class="line">(3)</span><br><span class="line">int[ ]  ids = &#123;1,2,3,4,5,6,7&#125;</span><br><span class="line">(4)语法不错误，但不建议</span><br><span class="line">int  ids[ ] = &#123;1,2,3,4,5,6,7&#125;</span><br></pre></td></tr></table></figure></li></ol><p>2.<strong>动态</strong>初始化：数组的初始化和数组元素的赋值操作<strong>分开进行</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String[ ]  names = <span class="keyword">new</span>  <span class="title class_">String</span> [<span class="number">5</span>];</span><br></pre></td></tr></table></figure><h4 id="2-如何调用数组的指定位置的元素"><a href="#2-如何调用数组的指定位置的元素" class="headerlink" title="2.如何调用数组的指定位置的元素"></a>2.如何调用数组的指定位置的元素</h4><p>通过角标的方式调用。</p><p>角标从0开始的，到数组长度-1结束</p><h4 id="3-如何获取数组的长度"><a href="#3-如何获取数组的长度" class="headerlink" title="3.如何获取数组的长度"></a>3.如何获取数组的长度</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[ ]  ids;</span><br><span class="line">ids = <span class="keyword">new</span>  <span class="title class_">int</span>[ ]&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;;</span><br><span class="line"><span class="comment">//长度 =  ids.length</span></span><br></pre></td></tr></table></figure><h4 id="4-如何遍历数组"><a href="#4-如何遍历数组" class="headerlink" title="4.如何遍历数组"></a>4.如何遍历数组</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span> ; i&lt;ids.length ; i++)&#123;</span><br><span class="line">System.out,println(ids[ i ]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-数组元素的默认初始化值"><a href="#5-数组元素的默认初始化值" class="headerlink" title="5.数组元素的默认初始化值"></a>5.数组元素的默认初始化值</h4><p>数组元素是整型：0</p><p>数组元素是浮点型：0.0</p><p>数组元素是char型：0，而非’0’</p><p>数组元素是boolean型：false</p><h4 id="6-数组的内存解析"><a href="#6-数组的内存解析" class="headerlink" title="6.数组的内存解析"></a>6.数组的内存解析</h4><p><img src="/2022/10/02/%E5%B0%9A%E7%A1%85%E8%B0%B7java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/Snipaste_2022-01-07_17-12-47.png" alt="Snipaste_2022-01-07_17-12-47"></p><p><img src="/2022/10/02/%E5%B0%9A%E7%A1%85%E8%B0%B7java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/Snipaste_2022-01-07_18-06-56.png" alt="Snipaste_2022-01-07_18-06-56"></p><h3 id="3-3二维数组的使用："><a href="#3-3二维数组的使用：" class="headerlink" title="3.3二维数组的使用："></a>3.3二维数组的使用：</h3><h4 id="1-理解："><a href="#1-理解：" class="headerlink" title="1.理解："></a>1.理解：</h4><p>我们可以看成是一维数组array1又作为另一个一维数组array2的元素而存在</p><p>其实，从数组底层的运行机制来看，其实没有多维数组</p><p>见解：一维数组套另外一个一维数组</p><h4 id="2-二维数组的声明和初始化"><a href="#2-二维数组的声明和初始化" class="headerlink" title="2.二维数组的声明和初始化"></a>2.二维数组的声明和初始化</h4><p><strong>静态初始化：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>)</span><br><span class="line"><span class="type">int</span>[ &#125;[ ] ids;</span><br><span class="line">ids = <span class="keyword">new</span>  <span class="title class_">int</span>[ &#125;[ ]&#123; &#123;<span class="number">1</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;,&#123;<span class="number">7</span>&#125; &#125;;</span><br><span class="line">(<span class="number">2</span>)</span><br><span class="line"><span class="type">int</span>[ &#125;[ ]  ids= <span class="keyword">new</span>  <span class="title class_">int</span>[ &#125;[ ]&#123; &#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>&#125;,&#123;<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125; &#125;;</span><br><span class="line">(<span class="number">3</span>)</span><br><span class="line"><span class="type">int</span>[ &#125;[ ]  ids = &#123; &#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>&#125;,&#123;<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125; &#125;;</span><br><span class="line">(<span class="number">4</span>)语法不错误，但不建议</span><br><span class="line"><span class="type">int</span> []  arr[] =<span class="keyword">new</span>  <span class="title class_">int</span>[ &#125;[ ]&#123; &#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>&#125;,&#123;<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125; &#125;;</span><br><span class="line">(<span class="number">5</span>)语法不错误，但不建议</span><br><span class="line"><span class="type">int</span> []  arr[] = [ &#125;[ ]&#123; &#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>&#125;,&#123;<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125; &#125;;</span><br></pre></td></tr></table></figure><p><strong>动态初始化：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>)</span><br><span class="line">String[ &#125;[ ]  names = <span class="keyword">new</span>  <span class="title class_">String</span> [<span class="number">5</span>&#125;[<span class="number">4</span>];</span><br><span class="line">(<span class="number">2</span>)</span><br><span class="line">String[ &#125;[ ]  names = <span class="keyword">new</span>  <span class="title class_">String</span> [<span class="number">5</span>&#125;[ ];<span class="comment">//不能不写左边只写右边，根据内存解析更容易理解</span></span><br><span class="line">names[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">4</span>];</span><br><span class="line"><span class="comment">//单独将第一行所指的一维数组创建出来</span></span><br></pre></td></tr></table></figure><h4 id="3-如何调用数组的指定位置的元素"><a href="#3-如何调用数组的指定位置的元素" class="headerlink" title="3.如何调用数组的指定位置的元素"></a>3.如何调用数组的指定位置的元素</h4><p>arr【i】【j】</p><h4 id="4-如何获取数组的长度"><a href="#4-如何获取数组的长度" class="headerlink" title="4.如何获取数组的长度"></a>4.如何获取数组的长度</h4><p>arr.length是行数一维数组的长度</p><p>arr[1].length是指定第一行所指的一维数组的长度</p><h4 id="5-如何遍历数组"><a href="#5-如何遍历数组" class="headerlink" title="5.如何遍历数组"></a>5.如何遍历数组</h4><p>for(int i&#x3D;0 ; i&lt;arr.length ; i++){</p><p>​for(int j&#x3D;0 ; j&lt;arr[i].length ; j++)</p><p>​              System.out.print(arr[i}[j]);</p><p>}</p><h4 id="6-数组元素的默认初始化值"><a href="#6-数组元素的默认初始化值" class="headerlink" title="6.数组元素的默认初始化值"></a>6.数组元素的默认初始化值</h4><p>情况一：int[}[]  arr &#x3D; new int [4}[3];</p><p>外层元素初始化值：地址值</p><p>内层元素初始化值：与一维数组初始化情况相同</p><p>情况二：int[}[]  arr &#x3D; new int [4}[];</p><p>外层元素初始化：null</p><p>内层元素初始化值：不能调用，会报错</p><h4 id="7-数组的内存解析"><a href="#7-数组的内存解析" class="headerlink" title="7.数组的内存解析"></a>7.数组的内存解析</h4><p><img src="/2022/10/02/%E5%B0%9A%E7%A1%85%E8%B0%B7java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/Snipaste_2022-01-07_21-00-01.png" alt="Snipaste_2022-01-07_21-00-01"></p><h3 id="3-4-数组中涉及到常见算法"><a href="#3-4-数组中涉及到常见算法" class="headerlink" title="3.4 数组中涉及到常见算法"></a>3.4 数组中涉及到常见算法</h3><h4 id="1-数组元素的赋值"><a href="#1-数组元素的赋值" class="headerlink" title="1.数组元素的赋值"></a>1.数组元素的<strong>赋值</strong></h4><p>（杨辉三角、回形数等）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] array1,array2;   </span><br><span class="line"><span class="type">int</span>[]  array1 =  <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;;   </span><br><span class="line">array2  =   array1;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在栈空间中创建了两个数组类型的指针</span></span><br><span class="line"><span class="comment">//new 的话，就是在堆空间创建了数组实体，array2 没有new，所以没有自己的数组实体</span></span><br></pre></td></tr></table></figure><blockquote><p>过程理解：将array1保存的数组的地址值赋给了array2，使得array1和array2共同指向堆空间中的同一个数组实体</p></blockquote><h4 id="2-求数组中元素的最大值、最小值、平均数、总和"><a href="#2-求数组中元素的最大值、最小值、平均数、总和" class="headerlink" title="2.求数组中元素的最大值、最小值、平均数、总和"></a>2.求数组中元素的最大值、最小值、平均数、总和</h4><h4 id="3-数组的复制、反转、查找（线性查找、二分查找）"><a href="#3-数组的复制、反转、查找（线性查找、二分查找）" class="headerlink" title="3.数组的复制、反转、查找（线性查找、二分查找）"></a>3.数组的<strong>复制</strong>、反转、查找（线性查找、二分查找）</h4><p>数组的复制：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[]  array1 =  <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;;</span><br><span class="line"><span class="type">int</span>[]  array2 = <span class="keyword">new</span> <span class="title class_">int</span>[array1.length];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span> ; i&lt;array2.length ; i++)&#123;</span><br><span class="line">    array2[i]  =  array1[i] ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数组的反转：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span> ; i&lt;arr.length / <span class="number">2</span> ; i++)&#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">arr[i] = arr[arr.length-<span class="number">1</span>-i];</span><br><span class="line">arr[arr.length-<span class="number">1</span>-i] = temp;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数组的二分查找：</p><h4 id="4-数组元素的排序算法"><a href="#4-数组元素的排序算法" class="headerlink" title="4.数组元素的排序算法"></a>4.数组元素的排序算法</h4><p>十大内部排序算法：</p><ol><li>选择排序：直接选择排序、<u>堆排序</u>（次要）</li><li>交换排序：<strong>冒泡排序、快速排序</strong>（重点了解）</li><li>插入排序：直接插入排序、折半插入排序、希尔shell排序</li><li><u>归并排序</u>（次要）</li><li>桶式排序</li><li>基数排序</li></ol><p><strong>冒泡排序：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>（<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i&lt;arr.length -<span class="number">1</span> ;  i++)&#123;</span><br><span class="line"><span class="keyword">for</span>( <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span> ;  j&lt;arr.length-<span class="number">1</span>-i  ;   j++)</span><br><span class="line">      <span class="keyword">if</span> ( arr[ j ] &gt; arr[ j + <span class="number">1</span> ])&#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[ j ];</span><br><span class="line">arr[ j ] =  arr[ j + <span class="number">1</span>] ;</span><br><span class="line">arr[ j + <span class="number">1</span> ] = temp ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>快速排序 时间复杂度 O(olog n )   归并和堆排序也是一样</p><p>冒泡排序时间复杂度 O( n^2 )</p></blockquote><h3 id="3-5零碎知识："><a href="#3-5零碎知识：" class="headerlink" title="3.5零碎知识："></a>3.5零碎知识：</h3><h4 id="1-排序算法的分类："><a href="#1-排序算法的分类：" class="headerlink" title="1.排序算法的分类："></a>1.排序算法的分类：</h4><p>内部排序：不借助外部存储器（如磁盘），所有排序操作都在内存中完成</p><p>外部排序：参与排序数据非常多，数据量非常大，计算机无法把整个排序过程在内存中完成，必须借助于外部存储器（如磁盘）。最常见的是多路归并排序。可以认为外部排序是由多次内部排序组成的。</p><h4 id="2-算法的5大特征"><a href="#2-算法的5大特征" class="headerlink" title="2.算法的5大特征"></a>2.算法的5大特征</h4><p>输入、输出、有穷性（有限性）、确定性（明确性算法中每一步都有确定的含义）、可行性、</p><h4 id="3-数据结构"><a href="#3-数据结构" class="headerlink" title="3.数据结构:"></a>3.数据结构:</h4><ol><li><p>数据与数据之间的逻辑关系：集合、一对一、一对多、多对多</p></li><li><p>数据的存储结构;线性表、树形结构、图形结构</p></li><li><p>算法：</p><p>排序算法、搜索（查找）算法</p></li></ol><h4 id="4-小习题："><a href="#4-小习题：" class="headerlink" title="4.小习题："></a>4.小习题：</h4><p>​            声明一维数组x[]、二维数组y[}[]</p><ol><li><p>x[0] &#x3D; y  ;   no -&gt;一维数组值不能存放二维数组的地址</p></li><li><p>y[0]  &#x3D;  x ;  yes -&gt; 二维数组的外层本来就是放一维数组地址的，因此可以放x的地址</p></li><li><p>y[0}[0] &#x3D; x ; no -&gt; 二维数组的内层放的就是值，不能放地址了</p></li><li><p>x[0}[0] &#x3D;  y ;  no -&gt; x是一维数组，计算机是可以分辨的</p></li><li><p>y[0}[0]  &#x3D;  x[0]  yes -&gt; 两个都是值，可以相互赋值</p></li><li><p>x &#x3D;y ;  no -&gt; 一维数组不能指向二维数组</p><p>总结：创建数组过程：声明（在栈空间中创建了地址）&#x3D;&gt;有new的话（在堆空间中创建数组实体内存（栈空间的声明指向它）如果是二维数组外层一维数组存放自己对应内层一维数组的地址值</p></li></ol><h3 id="3-5Arrays工具类的使用"><a href="#3-5Arrays工具类的使用" class="headerlink" title="3.5Arrays工具类的使用"></a>3.5Arrays工具类的使用</h3><p><strong>需要调用这个类import java.util.Arrays;</strong></p><ol><li><p>boolean   equals(int[] a , int[] b )   前面是返回值类型&#x2F;&#x2F;判断两个数组是否相等</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> [] arr1=  <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">int</span> [] arr2=  <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span>  <span class="variable">isEquals</span> <span class="operator">=</span> Arrays.equals(arr1,arr2);</span><br></pre></td></tr></table></figure></li><li><p>String   toString(int[]  a)          输出数组信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Arrays.toString(arr1));</span><br></pre></td></tr></table></figure></li><li><p>void   fill(int[] a ,  int val)      将数组中的值都换成指定值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.fill(arr1,<span class="number">10</span>);</span><br></pre></td></tr></table></figure></li><li><p>void  sort (int[] a)              对数组进行排序（快速排序）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(arr1);</span><br></pre></td></tr></table></figure></li><li><p>int  binarySearch(int[]  a , int  key)    对排序后的数组进行二分法查找指定的值  ，没找到会返回一个负数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> [] arr2=  <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">index</span>  <span class="operator">=</span>Arrays.binarySeatch(arr2,<span class="number">10</span>);</span><br></pre></td></tr></table></figure></li></ol><h3 id="3-6数组中常见的异常"><a href="#3-6数组中常见的异常" class="headerlink" title="3.6数组中常见的异常"></a>3.6数组中常见的异常</h3><ol><li><p>数组角标越界的异常：ArrayIndexOutOfBoundsEception</p><p>合理范围：[ 0 , arr.length - 1 ]</p><p>越界： arr[-1]…  ,   arr[arr.length]</p></li><li><p>空指针异常：NullPointerEception</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[]  arr  =   <span class="literal">null</span> ; </span><br><span class="line">arr[<span class="number">0</span>];</span><br></pre></td></tr></table></figure><blockquote><p>二维数组的外层为空null，在调用内层时就是空指针异常</p><p>注意： 一旦程序出现异常，未处理时，就终止执行。</p></blockquote></li></ol><h1 id="四、面向对象（上）"><a href="#四、面向对象（上）" class="headerlink" title="四、面向对象（上）"></a>四、面向对象（上）</h1><h3 id="4-1-Java面向对象学习三条主线（4-6章）"><a href="#4-1-Java面向对象学习三条主线（4-6章）" class="headerlink" title="4.1 Java面向对象学习三条主线（4-6章）"></a>4.1 Java面向对象学习三条主线（4-6章）</h3><ol><li>Java类及类的成员：属性、方法、构造器、代码块、内部类</li><li>面向对象的三大特性：封装性、继承性、多态性、（抽象性）</li><li>其他关键字：this、 super、 static、 final、 abstract、 interface、 package、 import等。</li></ol><h3 id="4-2面向过程与面向对象："><a href="#4-2面向过程与面向对象：" class="headerlink" title="4.2面向过程与面向对象："></a>4.2面向过程与面向对象：</h3><h4 id="1-面向过程："><a href="#1-面向过程：" class="headerlink" title="1.面向过程："></a>1.面向过程：</h4><p>强调的是功能行为，以函数为最小单位，考虑怎么做</p><p>把冰箱门打开</p><p>抬起大象，塞进冰箱</p><p>把冰箱门关闭</p><h4 id="2-面向对象："><a href="#2-面向对象：" class="headerlink" title="2.面向对象："></a>2.面向对象：</h4><p>强调具备了功能的对象，以类&#x2F;&#x2F;对象为最小单位，考虑谁来做。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">人&#123;</span><br><span class="line"></span><br><span class="line">打开（冰箱）&#123;</span><br><span class="line">冰箱.开门</span><br><span class="line">&#125;</span><br><span class="line">        抬起（大象）&#123;</span><br><span class="line">大象.进入（冰箱）</span><br><span class="line">&#125;</span><br><span class="line">关闭（冰箱）&#123;</span><br><span class="line">冰箱.关门</span><br><span class="line">&#125;</span><br><span class="line">冰箱&#123;</span><br><span class="line">开门</span><br><span class="line">关门</span><br><span class="line">&#125;</span><br><span class="line">大象&#123;</span><br><span class="line">进入</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序员从面向过程的<strong>执行者</strong>转化成了面向对象的<strong>指挥者</strong></p><h4 id="3-面向对象的思想概述"><a href="#3-面向对象的思想概述" class="headerlink" title="3.面向对象的思想概述"></a>3.面向对象的思想概述</h4><p>类 &#x3D; 现实世界中抽象具有属性和行为的事物 ；对一类事物抽象的描述</p><p> 对象 &#x3D;  计算机世界的实体  是实际存在的该类事物的每个个体，也称为<strong>实例</strong></p><p>对象，是由类new( 造 )出来的</p><p>面向对象<strong>程序设计的重点</strong>是<strong>类的设计</strong></p><p>类的设计， <strong>其实就是类成员的设计</strong></p><h3 id="4-3-类和对象"><a href="#4-3-类和对象" class="headerlink" title="4.3 类和对象"></a>4.3 类和对象</h3><h4 id="1-JVM-内存结构"><a href="#1-JVM-内存结构" class="headerlink" title="1.JVM 内存结构"></a>1.JVM 内存结构</h4><p>编译完源程序以后，生成一个或多个字节码文件。</p><p>我们使用JVM中的类的加载器和解释器堆生成的字节码文件进行解释运行。意味着，需要将字节码文件对应的类的加载到内存中，涉及到内存解析。<img src="/2022/10/02/%E5%B0%9A%E7%A1%85%E8%B0%B7java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/Snipaste_2022-01-10_13-24-41.png" alt="Snipaste_2022-01-10_13-24-41"></p><p>虚拟机栈，即为平时提到的栈结构。我们将局部变量存储到栈结构中</p><p>堆，我们将new出来的结构（比如：数组、对象）加载在堆空间中 。补充：对象的属性（非static的）加载在堆空间中</p><p>方法区：类的加载信息、常量池、静态域</p><h4 id="2-关键字-return："><a href="#2-关键字-return：" class="headerlink" title="2.关键字 return："></a>2.关键字 return：</h4><ol><li>使用范围：使用在方法体中</li><li>作用： <ol><li>结束方法</li><li>针对于返回值类型的方法，使用“return   数据”方法返回所要的数据</li><li>注意点：return 关键字后面不可以在声明执行语句</li></ol></li></ol><h4 id="3-java类及类的成员"><a href="#3-java类及类的成员" class="headerlink" title="3.java类及类的成员"></a>3.java类及类的成员</h4><p>初识理解：<strong>类</strong>相似与C语言的结构体； 而这个结构体中有变量和函数</p><p>一个程序可以有很多类，只能有一个public公共类，类中基本的成员是属性（成员变量）和方法。但是只能有一个main方法（函数）也叫程序的入口。</p><p>属性 &#x3D; 成员变量 &#x3D;  field &#x3D;  域、字段</p><p>方法 &#x3D; 成员方法 &#x3D; 函数 &#x3D;  method </p><p>创建类的对象 &#x3D;  类的实例化 &#x3D; 实例化类</p><h4 id="4-类和类对象的创建和使用"><a href="#4-类和类对象的创建和使用" class="headerlink" title="4.类和类对象的创建和使用"></a>4.类和类对象的创建和使用</h4><p>（面向对象思想落地的实现）</p><ol><li><p>创建类，设计类成员</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span>  <span class="title class_">Person</span>&#123;</span><br><span class="line">String name;</span><br><span class="line"><span class="type">int</span> age;           <span class="comment">//属性</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title function_">eat</span><span class="params">()</span> &#123;        <span class="comment">//行为或方法</span></span><br><span class="line">  System.out.print(<span class="string">&quot;吃面条&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建类的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span>  <span class="variable">p1</span>  <span class="operator">=</span>  <span class="keyword">new</span>  <span class="title class_">Person</span>() ; </span><br><span class="line"><span class="type">Person</span>  <span class="variable">p2</span>  <span class="operator">=</span>  <span class="keyword">new</span>  <span class="title class_">Person</span>() ;   <span class="comment">//（**非static的**）两个是独立的个体，互不影响</span></span><br><span class="line"><span class="comment">//数组类型的对象</span></span><br><span class="line">Person[]   p4 =  <span class="keyword">new</span> <span class="title class_">Person</span>[<span class="number">20</span>]; </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span> ; i &lt; p4.length ; i++)&#123;</span><br><span class="line">p4[ i ] =  <span class="keyword">new</span>  <span class="title class_">Person</span>(); <span class="comment">//给数组元素赋值，也是给属性new空间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>通过“对象 . 属性”或“对象 . 方法”调用对象的结构</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p1.name = <span class="string">&quot;Tom&quot;</span>;</span><br><span class="line">p1. age = <span class="number">2</span>;</span><br><span class="line">p1. eat() ;  <span class="comment">// 输出“吃面条”</span></span><br><span class="line">p4[ <span class="number">1</span> ].name =<span class="string">&quot; katrina&quot;</span>;</span><br><span class="line">p4[ <span class="number">1</span> ].age = <span class="number">18</span>;</span><br><span class="line">p4[ <span class="number">1</span> ].eat() ;<span class="comment">// 输出“吃面条”</span></span><br></pre></td></tr></table></figure></li><li><p>Person  p3 &#x3D; p1 ;</p><p>p3没有new，有new在堆空间中才有自己的实体，否则只是在栈空间中创建了一个指针</p><p>将p1变量保存的对象地址值赋给p3，导致p1和p3指向了堆空间中的同一个对象实体</p></li><li><p>后期补充：static  和非static</p><p>非static是以上提到的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">newclassTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"> newClass.walk();   <span class="comment">//不用new 也能用 ，类名. 方法名</span></span><br><span class="line">    newClass.age;<span class="comment">//错  只能调用方法，属性不能调用</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">newClass</span>&#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">walk</span><span class="params">()</span>&#123;  <span class="comment">//方法声明时加static</span></span><br><span class="line">    System.out.println(<span class="string">&quot;走路上学！&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="5-对象的创建和使用：内存解析"><a href="#5-对象的创建和使用：内存解析" class="headerlink" title="5.对象的创建和使用：内存解析"></a>5.对象的创建和使用：内存解析</h4><p><img src="/2022/10/02/%E5%B0%9A%E7%A1%85%E8%B0%B7java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/Snipaste_2022-01-09_17-04-02.png" alt="Snipaste_2022-01-09_17-04-02"></p><ol><li><p>创建对象：在栈空间中创建指针将可存放类的地址</p></li><li><p>创建类及类的属性：在堆空间中创建带有地址的类实体</p><p>​    实体中存放属性</p></li><li><p>创建对象为数组类型：</p><p>​Student[] stus &#x3D; new Student[20];  &#x2F;&#x2F;在堆空间中创建数组实体，但是每个数组元素存放的是类中的属性的地址值</p><p>因此还需要在给每个数组元素new创建属性，也叫给数组元素赋值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span> ; i&lt;stus.length ; i++)&#123;</span><br><span class="line"><span class="comment">//给数组元素赋值</span></span><br><span class="line">stus[i] = <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br></pre></td></tr></table></figure><p><img src="/2022/10/02/%E5%B0%9A%E7%A1%85%E8%B0%B7java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/Snipaste_2022-01-10_11-52-53.png" alt="Snipaste_2022-01-10_11-52-53"></p></li></ol><h3 id="4-4类的结构–属性"><a href="#4-4类的结构–属性" class="headerlink" title="4.4类的结构–属性"></a>4.4类的结构–属性</h3><p>​             （属性）成员变量  VS   局部变量</p><ol><li><p>相同点：</p><p>定义变量的格式：数据类型  变量名  &#x3D;   变量值</p><p>先声明，后使用</p><p>变量都有对应的作用域。（只在指定范围内可用）</p></li><li><p>不同点：</p><ol><li><p>在类中声明的位置不同</p><p>属性：直接定义在类的一对{   }内</p><p>局部变量：声明在方法内、方法形参、代码块内、构造器形参、构造器内部的变量</p></li><li><p>关于权限修饰符的不同</p><p>属性：可以子啊声明属性时，指明其权限，使用权限修饰符</p><p>常用的权限修饰符：private、public、缺省（什么都不写）、protected–&gt;封装性在细讲</p><p>局部变量：不可以使用权限修饰符</p><p><strong>权限修饰符理解</strong>：允许调用的范围程度</p><p>private最小译为私人的，public最大译为公共</p></li><li><p>作用域：</p><p>属性：在类中和类中方法里</p><p>局部变量：方法中</p></li><li><p>初始化值</p><p>属性的初始值：String -null 、整型 -0、浮点型 - 0.0 、boolean - false；</p><p>局部变量：没默认初始化值，调用之前必须赋值。特别地，形参可以在调用时赋值即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">u1.talk(<span class="string">&quot;中国话&quot;</span>)；<span class="comment">//用时赋值</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">talk</span><span class="params">(String  language)</span>&#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">newAge</span> <span class="operator">=</span> <span class="number">10</span>；<span class="comment">//提前赋值</span></span><br><span class="line">   System.out.print(language)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>内存的加载位置：</p><p>属性：加载到堆空间中（非static)</p><p>局部变量：加载到栈空间</p></li></ol></li></ol><h3 id="4-5类的结构–方法"><a href="#4-5类的结构–方法" class="headerlink" title="4.5类的结构–方法"></a>4.5类的结构–方法</h3><ol><li><p>方法的声明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">权限修饰符  返回值类型  方法名（形参列表）&#123;</span><br><span class="line">方法体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：至于static 、final、abstract 来修饰的方法，后面在讲</p></blockquote></li><li><p>举例</p><p>方法：描述类应该具有的功能</p><p>比如：Math类：sqrt()    \random()…….</p><p>Scanner类：nextXxx()….</p><p>Arrays类：sort()  \binarySearch()  \ toString() \ equals()…….</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">(<span class="type">int</span> hour)</span>&#123;  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>  String <span class="title function_">getNmae</span><span class="params">()</span>&#123;  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getNation</span><span class="params">(String nation)</span>&#123;  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getNation</span><span class="params">(String nation , <span class="type">int</span>  key)</span>&#123;  &#125;</span><br><span class="line"></span><br><span class="line">.................</span><br></pre></td></tr></table></figure></li><li><p>返回值类型：有返回值 VS  没有返回值（void）</p><p>有返回值：声明方法时，必须写返回值类型。同时，在方法中，有return 数据；返回值，该值类型是对应返回值类型</p><p>没有返回值：声明方法是用void 。方法中，return可用可不用，仅代表结束方法 —–return；不加返回值</p></li><li><p>方法的使用中，可以调用当前类的属性或方法</p><p>特殊的，方法A调用方法A：递归方法</p><p>方法中，不可以定义方法</p></li><li><p>注意：</p><ol><li>有无返回值视题目要求而定</li><li>方法名：命名需要“见名知意”</li><li>形参可有多个</li><li>方法体：方法功能的体现</li></ol></li></ol><h3 id="4-6-“万事万物皆对象”"><a href="#4-6-“万事万物皆对象”" class="headerlink" title="4.6 “万事万物皆对象”"></a>4.6 “万事万物皆对象”</h3><p>在Java语言范畴中，我们都将功能、结构等封装到类中，通过类的实例化(造对象)，来调用具体的功能结构</p><p>&#x3D;&gt; Scanner ,String 等</p><p>&#x3D;&gt;文件：File</p><p>&#x3D;&gt;网络资源：URL</p><h3 id="4-6-匿名对象的使用"><a href="#4-6-匿名对象的使用" class="headerlink" title="4.6 匿名对象的使用"></a>4.6 匿名对象的使用</h3><ol><li><p>理解：我们创建的对象，没有显式的赋给一个变量名。即为匿名对象</p></li><li><p>特征 ：匿名对象只能调用一次</p></li><li><p>使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InstanceTest</span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]  args)</span>&#123;</span><br><span class="line">      <span class="type">Person</span> <span class="variable">pop</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span> ();</span><br><span class="line">       pop.name= <span class="number">10</span>;<span class="comment">//这是正常做法</span></span><br><span class="line">       <span class="keyword">new</span>  <span class="title class_">Person</span>().name = <span class="number">10</span>;<span class="comment">//匿名</span></span><br><span class="line">       <span class="comment">//匿名对象：减少简单操作去创建新的变量及内存</span></span><br><span class="line">       <span class="keyword">new</span> <span class="title class_">Person</span>().eat(<span class="number">5</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">   <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">       <span class="type">int</span> name</span><br><span class="line">       <span class="type">int</span>  age </span><br><span class="line">   </span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">(<span class="type">int</span> n )</span>&#123;</span><br><span class="line">           System.out.print(n+<span class="string">&quot;碗面&quot;</span>)；</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">开发中使用：</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">    <span class="type">PhoneMall</span> <span class="variable">mall</span>  <span class="operator">=</span>  <span class="keyword">new</span>  <span class="title class_">PhoneMall</span>();</span><br><span class="line">    mall.show(<span class="keyword">new</span> <span class="title class_">Phone</span>());</span><br><span class="line"><span class="comment">//其中</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PhoneMall</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(Phone  phone)</span>&#123;</span><br><span class="line">phone.sendEmail();</span><br><span class="line">phone.playGame();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="4-7-数组：基本操作代码演示"><a href="#4-7-数组：基本操作代码演示" class="headerlink" title="4.7  数组：基本操作代码演示"></a>4.7  数组：基本操作代码演示</h3><h3 id="4-8-在谈方法"><a href="#4-8-在谈方法" class="headerlink" title="4.8  在谈方法"></a>4.8  在谈方法</h3><h4 id="1-方法的重载"><a href="#1-方法的重载" class="headerlink" title="1.方法的重载"></a>1.方法的重载</h4><ol><li><p>定义：在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或者参数类型不同即可。</p><p>总结定义：<strong>“两同一不同”</strong></p><p>同一类、相同方法名</p><p>参数列表不同：参数个数不同，参数类型不同</p><p>其原因使计算机能够辨别那些是不同的方法</p></li><li><p>举例：</p><p>Arrays类中重载sort() &#x2F;binarySearch()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">add（<span class="type">int</span> i， intj）</span><br><span class="line"></span><br><span class="line">add(<span class="type">double</span> i ,<span class="type">double</span> j)</span><br><span class="line"></span><br><span class="line">add(<span class="type">int</span> i ,<span class="type">double</span> j)</span><br><span class="line"></span><br><span class="line">add(<span class="type">int</span> i ，String  j)</span><br><span class="line"></span><br><span class="line">add (String j ,<span class="type">int</span>  i)</span><br></pre></td></tr></table></figure><p>以上都是重载，计算机能够识别</p></li><li><p>判断是否重载：</p><p>只需遵从定义，跟方法权限修饰符、返回值类型、形参变量名、方法体都没关系</p></li><li><p>在通过对象调用方法时，如何确定某一个指定的方法</p><p>方法名，不行。则形参列表</p></li></ol><h4 id="2-可变形参的方法"><a href="#2-可变形参的方法" class="headerlink" title="2.可变形参的方法"></a>2.可变形参的方法</h4><ol><li><p>jdk  5.0 新增的内容</p><p>（String…形参名）</p></li><li><p>具体使用：</p><p>2.1 可变个数形参<strong>格式</strong> ：数据类型 . . . 变量名</p><p>2.2 当调用可变个数形参的方法时，传入的<strong>参数个数</strong>可以是：0,1,2,3，…</p><p>2.3 可变个数形参的方法与本类方法名相同，形参不同的方法之间<strong>构成重载</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span> <span class="params">(<span class="type">int</span> ... ints)</span>&#123;  &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span> <span class="params">(<span class="type">double</span>  i  )</span>&#123;  &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span> <span class="params">(String ... strs)</span>&#123;  &#125;</span><br></pre></td></tr></table></figure><p>2.4可变个数形参的方法与本类中方法名相同，形参类型也相同的数组之间<strong>不构成重载</strong>。换句话说，二者不能共存 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span> <span class="params">(String []   strs)</span>&#123;  &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span> <span class="params">(String ... str )</span>&#123;  &#125;<span class="comment">//错误，两者其实是一样的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//都能吸收可变个个数，计算法无法分辨</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span> <span class="params">(<span class="type">int</span> i , String ... str)</span>&#123;  &#125;<span class="comment">//正确的</span></span><br></pre></td></tr></table></figure><p>2.5可变个数形参方法的形参中，<strong>必须声明在末尾</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span> <span class="params">(String []   strs)</span>&#123;  &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span> <span class="params">(<span class="type">int</span> i , String ... str)</span>&#123;  &#125;<span class="comment">//正确</span></span><br></pre></td></tr></table></figure><p>2.6可变个数形参在方法的形参中，<strong>最多只能声明一个可变形参</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(String...strings,<span class="type">int</span>...strs)</span>&#123; &#125;</span><br></pre></td></tr></table></figure><p>2.7优先选择不是可变个数形参</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> val.show(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(<span class="type">int</span>  i)</span>&#123;   <span class="comment">//优先这个</span></span><br><span class="line">System.out.print(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(<span class="type">int</span>...strs)</span>&#123;</span><br><span class="line">System.out.print(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-方法参数的”值传递”机制"><a href="#3-方法参数的”值传递”机制" class="headerlink" title="3.方法参数的”值传递”机制"></a>3.方法参数的”值传递”机制</h4><p>方法的形参的传递机制：值传递</p><ol><li><p>形参：方法定义时，声明的小括号（）内的参数</p></li><li><p>实参：方法调用时，实际传递给形参的数据 val.show(2);&#x2F;&#x2F; 2–实参</p></li><li><p>值传递机制:</p><p>如果参数是基本数据类型，此时实参赋给形参的是实参真实存储的<strong>数据值</strong></p><p>如果参数是引用数据类型，此时实参赋给形参的是实参存储数据的<strong>地址值</strong></p></li><li><p>举例：交换数组中 下标i  和  j  的值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">   <span class="type">int</span>[]  arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">   <span class="comment">//错误做法</span></span><br><span class="line">   Test.swap(arr[<span class="number">1</span>],arr[<span class="number">2</span>]);</span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> i  , <span class="type">int</span>  j)</span>&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> i ; </span><br><span class="line">                   i = j   ; </span><br><span class="line">                j = temp;  </span><br><span class="line">        &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//正确做法</span></span><br><span class="line">   Test.swap(arr, <span class="number">1</span>, <span class="number">2</span>) ;   <span class="comment">//传地址值和下标</span></span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arrss, <span class="type">int</span> i  , <span class="type">int</span>  j)</span>&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arrss[i] ; </span><br><span class="line">                       arrss[i] = arrss[ j]; </span><br><span class="line">                    arrss[ j] = temp;  </span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">#### <span class="number">4.</span>递归方法（了解）</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 递归方法：一个方法体内调用它自身</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 方法递归包含了一种隐式的循环，它的重复执行某段代码，但这种重复执行无须循环控制</span><br><span class="line"></span><br><span class="line">   按已知方向递归，也要有终止条件，否则会导致死循环</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### <span class="number">4.9</span>面向对象特征之一：封装和隐藏</span><br><span class="line"></span><br><span class="line">#### <span class="number">1.</span>概念初理解：</span><br><span class="line"></span><br><span class="line">我们程序设计追求 “ 高内聚 ” ， “ 低耦合 ”</span><br><span class="line"></span><br><span class="line">高内聚：类的内部数据操作细节自己完成，不允许外部干涉</span><br><span class="line"></span><br><span class="line">低耦合：仅对外暴露少量的方法用于使用</span><br><span class="line"></span><br><span class="line">俗话说：把该隐藏的隐藏起来，该暴露的暴露出来。这就是封装性的设计思想。</span><br><span class="line"></span><br><span class="line">#### <span class="number">2.</span>问题引入：</span><br><span class="line"></span><br><span class="line">当我们创建一个类的对象以后，我们通过 “ 对象 . 属性 ”的方式，对对象的属性进行赋值。</span><br><span class="line"></span><br><span class="line">这里，赋值操作要受到属性的数据类型和存储范围的制约。除此之外，没有其他制约条件。</span><br><span class="line"></span><br><span class="line">但是，在实际问题中，我们往往需要给属性赋值加入额外的限制条件。这个就不能在属性声明时体现，我们只能通过方法进行限制条件的添加。（比如 setLegs()）</span><br><span class="line"></span><br><span class="line">同时，我们需要避免用户在使用 “ 对象 . 属性 ” 的方式对属性进行赋值。则需要将属性声明为私有的（<span class="keyword">private</span>）。</span><br><span class="line"></span><br><span class="line">此时，针对--属性 --就体现了封装性。</span><br><span class="line"></span><br><span class="line">#### <span class="number">3.</span>封装性的体现</span><br><span class="line"></span><br><span class="line">我们将类的属性xxx私有化（<span class="keyword">private</span>）, 同时，提供公共的（<span class="keyword">public</span>）方法来获取（getXxx）和设置（setXxx）此属性的值</span><br><span class="line"></span><br><span class="line">拓展：封装性的体现：</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 以上提到的</span><br><span class="line"><span class="number">2.</span> 不对外暴露的私有方法</span><br><span class="line"><span class="number">3.</span> 单例模式(私有化构造器)</span><br><span class="line"><span class="number">4.</span> 如果不希望类在包外被调用，可以将类设置为缺省的</span><br><span class="line"><span class="number">5.</span> ..........</span><br><span class="line"></span><br><span class="line">代码示范：</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">String name ;</span><br><span class="line"><span class="keyword">private</span>  <span class="type">int</span> age ;      <span class="comment">//私有化</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> ages)</span>&#123;</span><br><span class="line">age = ages  ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">return</span> age ; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="4-封装性与权限修饰符"><a href="#4-封装性与权限修饰符" class="headerlink" title="4.封装性与权限修饰符"></a>4.封装性与权限修饰符</h4><ol><li><p>Java规定的4 种权限（从小到大）：private、缺省、protected、public</p></li><li><p>4 种权限可以用来修饰类及类的内部结构：属性、方法、构造器、内部类</p></li><li><p>具体的使用范围</p><p>4 种权限，都可以用来修饰类的内部结构：属性、方法、构造器、内部类</p><p>修饰类，只能用：缺省、public</p><table><thead><tr><th>修饰符</th><th>类内部</th><th>同一个包</th><th>不同包的子类</th><th>同一个工程</th></tr></thead><tbody><tr><td>private</td><td>yes</td><td></td><td></td><td></td></tr><tr><td>缺省</td><td>yes</td><td>yes</td><td></td><td></td></tr><tr><td>protected（暂不考虑）</td><td>yes</td><td>yes</td><td>yes</td><td></td></tr><tr><td>public</td><td>yes</td><td>yes</td><td>yes</td><td>yes</td></tr></tbody></table><p>private：出了这个类用不了</p><p>缺省：出了包用不了</p><p>public：基本都可以用</p></li></ol><p>总结封装性：Java提供了4 种权限修饰符来修饰类及类的内部结构，体现类及类的内部结构在被调用时的可见性的大小</p><h3 id="4-10-类的结构–构造器"><a href="#4-10-类的结构–构造器" class="headerlink" title="4.10 类的结构–构造器"></a>4.10 类的结构–构造器</h3><ol><li><p>构造器的作用（constructor）</p><ol><li>创建对象</li><li>初始化对象的信息</li></ol></li><li><p>说明：</p><ol><li><p>如果没有显式的定义类的构造器的话，则系统就默认提供一个空参的构造器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建对象：new+构造器</span></span><br><span class="line"><span class="type">Person</span>  <span class="variable">p</span>  <span class="operator">=</span>   <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span>  <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="comment">//此时类中并没有构造器，也能够使用，也只能使用空参的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>定义构造器的格式：权限修饰符 类名（形参列表）{  }</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span>  <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">age = n;  <span class="comment">//初始化对象的信息</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>一个类中可以定义多个构造器，彼此构成重载</p></li><li><p>一旦我们显式的定义了类的构造器之后，系统就不在提供默认的空参构造器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span>  <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(); <span class="comment">//报错，除非在造个空参的构造器</span></span><br><span class="line"><span class="type">Person</span>  <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">18</span>);<span class="comment">//正确</span></span><br><span class="line"><span class="keyword">class</span>  <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">age = n;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>一个类中，至少会有一个构造器</p></li><li><p>关于初始化属性总结</p><ol><li><p>默认初始化</p></li><li><p>显式初始化</p></li><li><p>构造器初始化</p></li><li><p>通过 “ 对象 . 方法 ” 或 “ 对象 . 属性 ” 的方式，赋值</p><p>这是按先后顺序覆盖的，也一定是按这个顺序</p></li></ol></li></ol></li></ol><h3 id="4-11-拓展：JavaBean"><a href="#4-11-拓展：JavaBean" class="headerlink" title="4.11 拓展：JavaBean"></a>4.11 拓展：JavaBean</h3><ol><li><p>JavaBean是一种Java语言写成的可重用组件</p></li><li><p>所谓的javaBean，是指符合如下标准的java类：</p><p>类是公共的</p><p>有一个无参的公共的构造器</p><p>有属性，且有对应的get、set方法</p><p>未完待续…..</p></li></ol><h3 id="4-12-关键字：this"><a href="#4-12-关键字：this" class="headerlink" title="4.12 关键字：this"></a>4.12 关键字：this</h3><h4 id="1-this的作用"><a href="#1-this的作用" class="headerlink" title="1.this的作用"></a>1.this的作用</h4><p>可以用来修饰和调用：（属性、方法、构造器）</p><h4 id="2-this-修饰属性和方法"><a href="#2-this-修饰属性和方法" class="headerlink" title="2.this 修饰属性和方法"></a>2.this 修饰属性和方法</h4><p>this理解为：当前对象或者当前正在创建的对象</p><p>1.在<strong>类的方法</strong>中，我们可以使用 “ this . 属性  ” 或 “ this . 方法” 的方式，调用当前对象属性或方法。</p><p>通常情况下，我们都选择省略 “this” </p><p>特殊情况下，如果方法的形参和类的属性同名时，我们必须显式的使用 “ this . 变量 ” 的方式，表明此变量是属性，而非形参</p><p>2.同理，在类的构造器也是这个道理</p><p>在<strong>类的构造器</strong>中，我们可以使用 “ this . 属性  ” 或 “ this . 方法” 的方式，调用当前对象属性或方法。</p><p>通常情况下，我们都选择省略 “this” </p><p>特殊情况下，如果构造器的形参和类的属性同名时，我们必须显式的使用 “ this . 变量 ” 的方式，表明此变量是属性，而非形参</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line">Stirng  name;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span>&#123;<span class="comment">//方法中</span></span><br><span class="line">重名，使用<span class="built_in">this</span></span><br><span class="line"><span class="built_in">this</span> . age = age ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>  <span class="title function_">Person</span><span class="params">(String name)</span>&#123;</span><br><span class="line"><span class="comment">//构造器中</span></span><br><span class="line"><span class="built_in">this</span> . name = name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-this-调用构造器"><a href="#3-this-调用构造器" class="headerlink" title="3.this 调用构造器"></a>3.this 调用构造器</h4><ol><li><p>我们在类的构造器中，可以显式的使用 “ this(形参列表) ” 方式，调用本类中指定的其他构造器</p><p>可能原因：每个构造器或者两个构造器间有相同代码的重复操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"></span><br><span class="line">String name ;</span><br><span class="line"><span class="type">int</span>  age ;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span>&#123;</span><br><span class="line">     一些操作</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>();</span><br><span class="line"><span class="built_in">this</span>.name = name ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>构造器中不能通过 “this (形参列表)” 方式调用自己</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"></span><br><span class="line">   String name ;</span><br><span class="line">   <span class="type">int</span>  age ;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span>&#123;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>(<span class="string">&quot;Tom&quot;</span>);<span class="comment">//不能调用自己</span></span><br><span class="line">  <span class="built_in">this</span>.name = name ;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果一个类中有n个构造器，则最多有n-1构造器中使用了“this (形参列表)” </p><p>构造器间不能出现成环调用–死循环</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"></span><br><span class="line">String name ;</span><br><span class="line"><span class="type">int</span>  age ;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="built_in">this</span>(<span class="string">&quot;Tom&quot;</span>); <span class="comment">//你调它</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">this</span>(); <span class="comment">//它调你</span></span><br><span class="line"><span class="built_in">this</span>.name = name ;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>规定：“this (形参列表)” 必须声明在当前构造器的首行</p><p>防止你调用的构造器和你下面出现的操作相同，覆盖了你的操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>(); <span class="comment">//它调你</span></span><br><span class="line"><span class="built_in">this</span>.name = name ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>构造器内部，最多只能声明一个“this (形参列表)” ,用来调用其他的构造器</p><p>人呐，只能有一个女朋友</p></li></ol><h4 id="4-this-表示当前对象，作为实参被调用"><a href="#4-this-表示当前对象，作为实参被调用" class="headerlink" title="4.this 表示当前对象，作为实参被调用"></a>4.this 表示当前对象，作为实参被调用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span>  <span class="title class_">Boy</span>&#123;</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">marry</span><span class="params">(Girl  girl)</span>&#123;</span><br><span class="line">一些操作</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span>  <span class="title class_">Girl</span>&#123;</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">marry</span><span class="params">(Boy  boy)</span>&#123;</span><br><span class="line">Boy.marry(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>this 是当前对象，类型为Girl</strong></p><p><strong>补充：也可单独表示：</strong></p><p><strong>obj &#x3D;&#x3D; this  ：判断形参obj是否等于当前对象</strong></p></blockquote><h3 id="4-13-关键字-package"><a href="#4-13-关键字-package" class="headerlink" title="4.13 关键字 package"></a>4.13 关键字 package</h3><ol><li><p>为了更好的实现项目中类的管理，提供包的概念</p></li><li><p>使用package声明类或接口所属的包，声明在源文件的首行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.java2</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">xxx</span>&#123;  </span><br><span class="line">   &#125; </span><br></pre></td></tr></table></figure><blockquote><p>包，属于标识符，遵循标识符的命名规则、规范（xxxyyyzzz）、“见名知意”</p></blockquote></li><li><p>每点“ . ”一次，就代表一层文件目录</p><p>com.atguigu.java2</p></li><li><p>补充：</p><p>同一个包下，不能命名同名的接口、类</p><p>不同的包下，可以命名同名的接口、类</p></li><li><p>JDK主要包介绍</p><ol><li>java.lang–包含一些java语言的核心类，比如String、Math、Integer、System和Thread，提供常用的功能</li><li>java.util—包含一些实用工具类，比如系统特性、接口的集合框架类、实用与日期日历相关的函数</li><li>java.net</li><li>java.io</li><li>java.text</li><li>java.sql</li><li>java.awt</li></ol></li></ol><p>4.14  MVC 模式设计</p><p>MVC是常用的设计模式之一，将整个程序分为三个层次：视图模型层，控制器层，与数据模型层。</p><p>这种将程序输入输出、数据处理，以及数据的展示分离开来的设计模式使程序结构变的灵活而且清晰，同时也描述了程序各个对象间的通信方式，降低了程序的耦合性。</p><h3 id="4-15-关键字-import"><a href="#4-15-关键字-import" class="headerlink" title="4.15 关键字 import"></a>4.15 关键字 import</h3><p>​    import：导入</p><ol><li><p>在源文件中显式的使用import结构导入指定包下的类、接口</p></li><li><p>声明在包的声明和类的声明之间</p></li><li><p>如果需要导入多个结构，可以并列写写出即可</p></li><li><p>如果使用的类或接口是java.lang包下定义的，则可以省略import结构</p></li><li><p>如果使用的类或接口是本包下定义的，则可以省略import</p></li><li><p>如果在源文件中，使用了不同包下同名的类，则必须至少有一个需要一全类名的方式显示</p><p>应在前面加上具体的文件路径(每个都可以加上路径，只是为了美观简约的去掉)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.atguigu.java2.Account</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">xxxx</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Account</span> <span class="variable">acc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Account</span> (<span class="number">100</span>);</span><br><span class="line">        com.atguigu.java5.<span class="type">Account</span> <span class="variable">acc1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Accout</span>(<span class="number">100</span>,<span class="number">0</span>,<span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用“xxx .*” 方式表明可以调用xxx包下的所有结构。但是如果使用的是xxx子包下的结构，则仍需要显式</p></li><li><p>import static ：导入指定类或接口中的静态结构;属性和方法</p></li></ol><h1 id="五、面向对象（中）"><a href="#五、面向对象（中）" class="headerlink" title="五、面向对象（中）"></a>五、面向对象（中）</h1><h3 id="5-1面向对象特征之二：继承性"><a href="#5-1面向对象特征之二：继承性" class="headerlink" title="5.1面向对象特征之二：继承性"></a>5.1面向对象特征之二：继承性</h3><h4 id="1-继承性的好处"><a href="#1-继承性的好处" class="headerlink" title="1.继承性的好处"></a>1.继承性的好处</h4><ol><li>减少代码的冗余，提高代码的复用性</li><li>便于功能的扩展</li><li>为了之后多态性的使用，提供了前提</li></ol><h4 id="2-继承性的格式"><a href="#2-继承性的格式" class="headerlink" title="2.继承性的格式"></a>2.继承性的格式</h4><p>class  A  <strong>extends</strong>  B {  }</p><p>A : 子类、派生类、subclass</p><p>B :  父类、超类、基类、superclass</p><h4 id="3-用处体现："><a href="#3-用处体现：" class="headerlink" title="3.用处体现："></a>3.用处体现：</h4><ol><li>一旦子类A继承父类B以后，<strong>子类A中就获取了父类B中声明的所有属性和方法</strong></li></ol><p>特别地，父类中声明为private的属性或方法，子类继承父类以后，仍然认为获取了私有结构。只是因为封装性的影响，使得子类不能直接调用父类此结构</p><ol start="2"><li><strong>子类继承父类</strong>以后，还可以声明自己特有的属性或方法，实现功能的扩展。也就是<strong>子类有的父类没有，反之。父类有的子类都有</strong></li></ol><h4 id="4-Java中关于继承性的规定："><a href="#4-Java中关于继承性的规定：" class="headerlink" title="4.Java中关于继承性的规定："></a>4.Java中关于继承性的规定：</h4><ol><li><p>一个类可以被多个子类继承</p></li><li><p>Java中类的单继承性：一个类只能有一个类</p></li><li><p>子父类是相对的概念</p></li><li><p>子类直接继承的父类，称为：直接父类。间接继承的父类称为：0间接父类。</p><p>也就是子类有父类，父类还有父类，这样，子类继承以上的两个父类</p></li><li><p>子类继承父类以后，就获取了直接父类以及所有间接父类中声明的属性和方法</p></li></ol><p><strong>Object类</strong></p><ol><li>如果我们没有显式的声明一个类的父类的话，则此类继承于java.lang.Object类</li><li>所有的java类（除了java.lang.Object类之外）都直接或间接的继承于java.lang.Object类</li><li>意味着，所有的java类具有java.lang.Object类声明的功能</li></ol><h3 id="5-2-方法的重写"><a href="#5-2-方法的重写" class="headerlink" title="5.2 方法的重写"></a>5.2 方法的重写</h3><p>（overeide 、overwrite）</p><ol><li><p><strong>重写：子类继承父类以后，可以对父类中同名同参数的方法，进行覆盖</strong></p></li><li><p><strong>应用：重写以后，且当创建子类对象以后，通过子类对象调用子父类中的同名同参数的方法时，参数实际执行的是子类重写父类的方法</strong></p></li><li><p>重写的规定：约定俗称：子类中的叫重写的方法，父类中的叫被重写的方法</p><ol><li>子类重写的<strong>方法名和形参列表</strong>和父类被重写的<strong>方法名和形参列表相同</strong></li><li>子类重写的方法的权限修饰符不小于被重写的方法的权限修饰符</li></ol><p>​                    特殊情况：子类不能重写父类中声明为private的<strong>方法</strong></p></li><li><p>返回值类型;</p><ol><li>父类被重写的方法的返回值类型是void，则子类重写的方法的返回值类型只能是void</li><li>父类被重写的方法的返回值类型是A类型，则子类重写的方法的返回值类型只能是A类或A类的子类</li><li>父类被重写的方法的返回值类型是基本数据类型，则子类重写的方法的返回值类型只能是相同的基本数据类型</li><li>子类重写的方法抛出异常类型不大于父类被重写的方法抛出异常类型</li></ol></li><li><p><strong>由于注意事项很多，一般都写和父类的方法一样的即可</strong></p></li><li><p>补充：子类和父类的同名同参数的方法要么都声明为非static的（考虑重写），要么都声明static（不考虑重写）</p></li><li><p>面试题：区分方法的重写和重载？</p><ol><li><p>二者的概念：</p><p>重载：在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或者参数类型不同即可。—构造器也能重写</p><p>重写：子类继承父类以后，可以对父类中同名同参数的方法，进行覆盖—构造器不能重写</p></li><li><p>在谈谈二者具体规则</p></li><li><p>最后;</p><p>重载：不表现为多态性</p><p>​            调用的地址在编译期就绑定了，在方法调用之前，编译器就已经确定了所要调用的方法，称为早绑定或静态绑定</p><p>重写：表现为多态性</p><p>​           在方法调用的那一刻，解释运行器才会确定所要调用的方法，   重写称为  晚绑定 或动态绑定</p></li></ol></li></ol><h3 id="5-3-关键字：super"><a href="#5-3-关键字：super" class="headerlink" title="5.3 关键字：super"></a>5.3 关键字：super</h3><h4 id="1-理解和用处"><a href="#1-理解和用处" class="headerlink" title="1.理解和用处"></a>1.理解和用处</h4><p>理解：父类的（<strong>继承性提到superclass说的就是父类</strong>）</p><p>用处：可以用来调用：属性、方法、构造器</p><p><strong>与this类似，都用来区分相同名字不同内涵的代码</strong></p><p>this（形参列表）：本类重载的其它构造器（不能自己调自己）</p><p>super（形参列表）：调用父类中指定的构造器</p><h4 id="2-super的使用"><a href="#2-super的使用" class="headerlink" title="2.super的使用"></a>2.super的使用</h4><ol><li><p>我们可以在子类的方法或构造器中。通过使用 <strong>“super.属性”或“super .方法 ”</strong>的方式显式调用父类中声明的属性或方法。但是，通常情况下，我们习惯省略super.</p></li><li><p>特殊情况：当子类和父类中定义了<strong>同名的属性</strong>时，我们想要在子类中调用父类中声明的属性，则必须显式的使用 “super.属性” 的方式，表明调用的是父类中声明的属性</p></li><li><p>特殊情况：当子类<strong>重写了父类中的方法</strong>以后，我们想在子类的方法中调用父类中被重写的方法时，则必须显式的使用“super .方法 ”的方式，表明调用的是父类中被重写的方法</p><p>(2)(3) 代码演示</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span>&#123;   <span class="comment">//父类</span></span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">int</span> id；</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//吃饭</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span>&#123;          子类</span><br><span class="line">    String id ;</span><br><span class="line">    id = <span class="string">&quot;23456&quot;</span>;   <span class="comment">//这表示的是子类的id</span></span><br><span class="line">    <span class="built_in">super</span>.id = <span class="number">23</span>;  <span class="comment">//这是父类中声明的id</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//吃席</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">walk</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//走十公里；</span></span><br><span class="line">        eat();<span class="comment">//表明的是子类已经重写过的  </span></span><br><span class="line">        <span class="built_in">super</span>.eat( ); <span class="comment">// 表明是父类中的</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-super-调用构造器"><a href="#3-super-调用构造器" class="headerlink" title="3.super 调用构造器"></a>3.super 调用构造器</h4><ol><li><p>我们可以在子类的构造器中显式的使用 “super(形参列表)”的方式，调用父类中声明的指定的构造器</p></li><li><p>“super(形参列表)”的使用，必须声明在子类<strong>构造器的首行</strong></p></li><li><p>我们在类的构造器中，针对与 “this(形参列表)”或 “super(形参列表)”<strong>只能二选一</strong></p></li><li><p>在构造器的首行，<strong>没有显式的声明</strong> “this(形参列表)”或 “super(形参列表)”则<strong>默认用的是父类中空参的构造器</strong></p></li><li><p>在类的多个构造器中，<strong>至少有一个类的构造器中使用了 “super(形参列表)”</strong>，调用父类中的构造器</p></li><li><p>总结(1)(4)(5):</p><p><strong>子类必须在多个构造器中调用至少调用一次父类的构造器“super(形参列表)”</strong>（5）</p><p>所有类父类都是Object类</p><p><strong>每个构造器中都默认有super（），来调用父类的构造器空参构造器(4)</strong></p><p><strong>如果程序经过修改：父类使用带参构造器，则系统不在提供空参构造器，那么子类就得在构造器中调用与父类构造器匹配的super(形参列表)   (1)</strong></p></li></ol><h4 id="4-子类对象实例化的全过程"><a href="#4-子类对象实例化的全过程" class="headerlink" title="4.子类对象实例化的全过程"></a>4.子类对象实例化的全过程</h4><ol><li><p>从结果上来看（继承性）</p><p>子类继承父类以后，就获取了父类中声明的属性或方法</p><p>创建子类对象，在堆空间中，就会加载所有父类中声明的属性</p></li><li><p>从过程上来看</p><p>​    当我们通过子类的构造器创建子类对象时，我们一定会直接或间接的调用其父类的构造器，进而调用父类的父类的构造器，直到调用了java.lang.Object 类中空参的构造器为止。正因为加载过所有的父类的结构，所以才可以看到内存中有父类中的结构，子类对象才可以考虑进行调用</p></li><li><p>明确：虽然创建子类对象时，调用了父类的构造器，但是自始至终就创建过一个对象，即为new的子类对象</p></li></ol><h3 id="5-4面向对象特征之三：多态性"><a href="#5-4面向对象特征之三：多态性" class="headerlink" title="5.4面向对象特征之三：多态性"></a>5.4面向对象特征之三：多态性</h3><h4 id="1-理解"><a href="#1-理解" class="headerlink" title="1.理解"></a>1.理解</h4><ol><li><p>可以理解为一个事物的多种形态</p></li><li><p>对象的多态性：父类的引用指向子类对象，(或子类的对象赋给父类的引用)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span>  <span class="variable">p1</span> <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">Student</span>();  <span class="comment">//person父类，student子类</span></span><br></pre></td></tr></table></figure></li></ol><p><strong>多态的使用前提</strong></p><ol><li>有，类的继承关系</li><li>有，方法的重写</li></ol><h4 id="2-虚拟方法调用"><a href="#2-虚拟方法调用" class="headerlink" title="2.虚拟方法调用"></a>2.虚拟方法调用</h4><p>有了对象的多态性以后，我们在编译期，只能调用父类中声明的方法，但是在运行期，我们<strong>实际执行的是子类重写父类的方法</strong></p><p>总结：编译看左边，运行看右边</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span>  <span class="variable">p1</span> <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">Student</span>();  <span class="comment">//person父类，student子类</span></span><br></pre></td></tr></table></figure><p>举例一：</p><p>假设Animal动物是所有动物的父类（比如 Dog 、Fish…)</p><p>他们是继承关系，且eat()  和  shuot () 都经过重写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Animal</span>  <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>() ;  <span class="comment">// 虚拟方法调用   编译看左边，运行看右边</span></span><br><span class="line">func(test) ;                         <span class="comment">//编译期，test是Animal类型，满足方法形参</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span>  <span class="title function_">func</span> <span class="params">(Animal  animal)</span>&#123;</span><br><span class="line">       animal.eat();                   <span class="comment">//运行时，实际执行的是已经重写的方法</span></span><br><span class="line">       animal.shout();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>总结：方法形参写父类，利用多态性（虚拟方法调用）任意声明一个子类都可以满足此方法——多态性的好处</p><p>举例二：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="keyword">void</span>  <span class="title function_">method</span><span class="params">(Object  obj)</span>&#123; <span class="comment">//Object类是任意类的父类</span></span><br></pre></td></tr></table></figure><p>利用虚拟调用Object  ob &#x3D; new  任意类（）；都可以调用此方法</p><h4 id="3-使用说明"><a href="#3-使用说明" class="headerlink" title="3.使用说明"></a>3.使用说明</h4><p>对象的多态性，只适用于方法，不适用于属性（编译和运行都看左边）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span>  <span class="variable">p1</span> <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">Student</span>();  <span class="comment">//person父类，student子类</span></span><br></pre></td></tr></table></figure><h4 id="4-多态性的转型"><a href="#4-多态性的转型" class="headerlink" title="4.多态性的转型"></a>4.多态性的转型</h4><p><strong>1.向上转型：即为多态</strong></p><p>将 Person p1 &#x3D; new Student（）;</p><p>声明用父类 ，new用子类  </p><p>编译时认为 p1 是Person类的，所以只能调用Person类中声明的属性和方法</p><p>实际运行时是执行子类重写父类的方法</p><p>（不包括属性）</p><p><strong>2.向下转型：父类–&gt;子类</strong></p><p><strong>需求</strong>：为了在使用多态虚拟方法调用后，<strong>还能使用子类特有的属性和方法</strong></p><p>操作：使用强制类型转换符</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Man</span>();</span><br><span class="line"><span class="type">Man</span>  <span class="variable">m1</span>  <span class="operator">=</span> (Man)p1 ; <span class="comment">//此时 m1 是Man类型</span></span><br></pre></td></tr></table></figure><p>出现问题：使用强转时，可能出现ClassCastException的异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Woman</span>  <span class="variable">w1</span> <span class="operator">=</span> <span class="keyword">new</span>  (Woman) p2 ;</span><br></pre></td></tr></table></figure><p>此时编译不报错，但是运行报错</p><p>虽然他们父类都是Person，但是不能够操作</p><p>解决问题：使用instanceof关键字</p><p><strong>a  instanceof   A</strong> :判断对象a(变量名) 是否是A类(类型)的实例。如果是，返回true。如果不是，返回false。</p><p>使用前提：</p><ol><li><p>要求两个类必须是必须有子父类的关系，否则编译错误。</p></li><li><p>：e  instanceof  a </p><p>a  只能是  e  的父类 或者 是 e</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">if</span>(p2  <span class="keyword">instanceof</span>  Woman) &#123;</span><br><span class="line"><span class="type">Woman</span>  <span class="variable">w1</span> <span class="operator">=</span> (Woman )p2;</span><br><span class="line">w1.goShopping();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(p2  <span class="keyword">instanceof</span>  Man) &#123;</span><br><span class="line"><span class="type">Man</span>  <span class="variable">w1</span> <span class="operator">=</span> (Man)p2;</span><br><span class="line">w1.earnMoney();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>练习：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span>  <span class="variable">p3</span>  <span class="operator">=</span> <span class="keyword">new</span>  <span class="title class_">Woman</span>();</span><br><span class="line"><span class="type">Object</span>  <span class="variable">obj</span> <span class="operator">=</span>  <span class="keyword">new</span>  <span class="title class_">Woman</span>();</span><br><span class="line"><span class="type">Woman</span>  <span class="variable">w1</span> <span class="operator">=</span> (Woman) p3; 编译运行都通过</span><br><span class="line"><span class="type">Man</span>  <span class="variable">m1</span>  <span class="operator">=</span>  (Man) p3 ;  编译通过，运行不通过</span><br><span class="line"><span class="type">Person</span>  <span class="variable">p</span>   <span class="operator">=</span>   (Person)obj ;编译运行都通过</span><br></pre></td></tr></table></figure><h4 id="5-小练习"><a href="#5-小练习" class="headerlink" title="5.小练习"></a>5.小练习</h4><p>Base 是父类 ，其中有属性 count &#x3D;10 和方法 display() —调用会输出count</p><p>Sub 是子类 重写了count &#x3D;20 ，也重写了display，调用会输出count</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Sub</span>  <span class="variable">s</span>  <span class="operator">=</span>  <span class="keyword">new</span>  <span class="title class_">Sub</span> ();</span><br><span class="line">s.display(); <span class="comment">//20</span></span><br><span class="line"></span><br><span class="line"><span class="type">Base</span> <span class="variable">b</span> <span class="operator">=</span> s ;  <span class="comment">// 多态性，这时b是直接得到s的地址</span></span><br><span class="line">System.out.println( b ==s）; <span class="comment">//地址一样返回true</span></span><br><span class="line">b.count <span class="comment">//输出10  ，多态不适用属性</span></span><br><span class="line">b.display(); <span class="comment">//输出20   适用于方法</span></span><br></pre></td></tr></table></figure><h4 id="6-面试题"><a href="#6-面试题" class="headerlink" title="6.面试题"></a>6.面试题</h4><p>谈谈你对多态性的理解？<br>实现代码的通用性。<br>Object类中定义的publicbooleanequals（object obj）{ }<br>JDBC：使用java程序操作（获取数据库连接、CRUD）数据库（MySQL、Oracle、DB2、SQL Server）<br>抽象类、接口的使用肯定体现了多态性。（抽象类、接口不能实例化）<br>多态是编译时行为还是<strong>运行时行为</strong>？</p><h3 id="5-5-Object类使用"><a href="#5-5-Object类使用" class="headerlink" title="5.5 Object类使用"></a>5.5 Object类使用</h3><h4 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h4><p>java.lang.Object 类</p><ol><li><p>Object类是所有Java类的跟父类（想象类构成的树，它为根节点）</p></li><li><p>如果在类的声明中为使用extends 关键字指明其父类，则默认父类为java.lang.Object 类</p></li><li><p>Object 类的功能（属性、方法）就具有通用性</p><p>属性：无</p><p>方法：equals ()  &#x2F;   toString()   &#x2F;    getClass()  &#x2F;  hashCode()  &#x2F;  clone() &#x2F; finalize()  &#x2F;  wait()  、 notify()、notifyAll()</p></li><li><p>Object类只声明了一个空参构造器</p></li><li><p>补充：数组也是可以理解为Object类的子类，其可以调用Object类中声明的方法 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="type">int</span>[ ]  arr  =  <span class="keyword">new</span>  <span class="title class_">int</span>[ ]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">System.out.println(arr.toString()); </span><br><span class="line">System.out.println(arr);</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>两者输出都是该数组的地址</p></blockquote><h4 id="2-equals-和-x3D-x3D"><a href="#2-equals-和-x3D-x3D" class="headerlink" title="2.equals() 和 &#x3D; &#x3D;"></a>2.equals() 和 &#x3D; &#x3D;</h4><p><strong>1.&#x3D;&#x3D;运算符</strong></p><ol><li><p>可以使用在基本数据类型变量和引用数据类型变量中</p></li><li><p>如果比较的是基本数据类型：比较两个变量保存的数据是否相等（不一定类型相同，但会自动类型提升）</p></li><li><p>如果比较的是引用数据类型变量：比较哦两个对象的地址值是否相同。即两个引用是否指向同一个对象实体</p></li><li><p>补充：使用 &#x3D;&#x3D;  符号时，必须保证左右两边的变量类型一致</p></li><li><p>特别关于String 类型</p><p>String类型赋值是放在常量池中，不像以往说的放在堆空间中，它有复用性，发现有相同的字符就只调用相同字符的地址赋给它</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span>  <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;BB&quot;</span> ;<span class="comment">//此类声明可不写new</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span>  <span class="operator">=</span> <span class="string">&quot;BB&quot;</span> ; </span><br><span class="line">System.out.println(s1==s2) ; <span class="comment">//ture</span></span><br></pre></td></tr></table></figure></li></ol><p><strong>2.equals（）</strong></p><ol><li><p>是一个方法，而非运算符</p></li><li><p>只能使用于引用数据类型</p></li><li><p>Object 类中 equals() 的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span>  <span class="title function_">equals</span><span class="params">(Object  obj)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="built_in">this</span> ==obj) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：Object类中定义的equals() 和 &#x3D;&#x3D;</p><p>的作用是相同的 ：</p><p>都是比较两个对象的地址值是否相同。即两个引用是否指向同一个对象实体</p></li><li><p>类似String 、Date、File 、包装类等都重写了Object类中equals()方法。</p><p>重写以后，比较的不是两个引用的地址是否相同，而是根据问题所需比较两个对象的”实体内容“ 是否相同</p><p>比如：首先是不是一个类声明的，其中想要比较的属性是相等</p></li><li><p>通常情况下，我们自定义的类如果使用equals() 的话，也通常是比较两个对象的“实体内容” 是否相同。 那么我们就需要堆Object类中的equals() 进行重写</p><p>重写的原则：比较两个对象的实体内容是否相同</p></li><li><p>补充：自己写容易出错，开发中都是自动生成的</p></li></ol><h4 id="3-toString-使用"><a href="#3-toString-使用" class="headerlink" title="3.toString() 使用"></a>3.toString() 使用</h4><ol><li><p>当我们输出一个对象的引用时，实际上就是调用当前对象的toString()</p></li><li><p>Object类中toString() 的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> 返回的是类的名字及地址</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>类似String 、Date、File 、包装类等都重写了Object类中toString()方法。</p><p>我们想要调用这个方法来输出时，返回的是我们最想看到的结构，所以都会考虑重写</p></li><li><p>手动实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span>&#123;</span><br><span class="line">reutrn  <span class="string">&quot;name=&quot;</span>+name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5.小问题</p><p>（1）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span>  <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">System.out.println(p1);</span><br><span class="line">System.ou.println(p1.toString());</span><br><span class="line"><span class="comment">//二者是一样的结果</span></span><br><span class="line"><span class="comment">//前者，最后还是会去调用toString</span></span><br></pre></td></tr></table></figure><p>（2）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span>  <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot; a b c&quot;</span> ;</span><br><span class="line">System.out.println(s);<span class="comment">//输出结果一样</span></span><br><span class="line">System.ou.println(p1.toString());</span><br></pre></td></tr></table></figure><p>（3）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span>  <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot; a b c&quot;</span> ;</span><br><span class="line">    s   =   <span class="literal">null</span>;</span><br><span class="line">System.out.println(s);</span><br><span class="line">System.ou.println(p1.toString());</span><br><span class="line"><span class="comment">//前者输出null，后者不输出，出现指针异常NullPointerException</span></span><br><span class="line"><span class="comment">//由于前者最后还是会去调用toString()</span></span><br><span class="line"><span class="comment">//但是途中有保护机制</span></span><br><span class="line"><span class="keyword">if</span>(s==<span class="literal">null</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;null&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>补充：自己写容易出错，开发中都是自动生成的</p></li></ol><h3 id="5-6-单元测试"><a href="#5-6-单元测试" class="headerlink" title="5.6 单元测试"></a>5.6 单元测试</h3><p>Java中的JUnit单元测试</p><ol><li><p>创建Java类，进行单元测试</p><p>此时的Java类要求是public的，并且此类提供公共的无参构造器</p></li><li><p>此单元测试方法上需要声明注释：@Test，将鼠标覆盖注释，点击出现的超链接，系统会自动为加入JUnit4和导入该类</p></li><li><p>此类中声明单元测试的方法</p><p>此时要求方法的权限是public，没有返回值，没有形参</p></li><li><p>声明好单元测试方法以后，就可以在方法体内测试相关的代码</p></li><li><p>写完代码以后，双击单元测试方法名，右键 run  as  – –JUnit Test</p></li><li><p>说明：</p><p>如果执行结果没有任何异常：绿条</p><p>执行结果出现异常：红条</p></li></ol><h3 id="5-7-包装类的使用"><a href="#5-7-包装类的使用" class="headerlink" title="5.7 包装类的使用"></a>5.7 包装类的使用</h3><h4 id="1-理解-1"><a href="#1-理解-1" class="headerlink" title="1.理解"></a>1.理解</h4><p>针对八种基本数据类型定义的引用类型—-包装类（封装类）</p><p>有了类的特点，就可以调用类中的方法，Java才是真正的面向对象</p><h4 id="2-今昔对比"><a href="#2-今昔对比" class="headerlink" title="2.今昔对比"></a>2.今昔对比</h4><p>基本数据类型： byte  &#x2F;  short &#x2F;  int  &#x2F;  long &#x2F;  float &#x2F;  double  &#x2F;  boolean  &#x2F;  char</p><p>包装类： <strong>B</strong>yte  &#x2F;  <strong>S</strong>hort &#x2F;  Integer  &#x2F;  <strong>L</strong>ong &#x2F;  <strong>F</strong>loat &#x2F;  <strong>D</strong>ouble  &#x2F;  <strong>B</strong>oolean  &#x2F;  Character</p><p>除了 Boolean  &#x2F;  Character  其他的父类都是Number</p><h4 id="3-一般操作-基到包"><a href="#3-一般操作-基到包" class="headerlink" title="3.一般操作-基到包"></a>3.一般操作-基到包</h4><p>基本数据类型—&gt;包装类调用包装类的构造器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>  <span class="variable">p1</span>  <span class="operator">=</span>  <span class="number">10</span></span><br><span class="line"><span class="type">Itnteger</span>  <span class="variable">in1</span>  <span class="operator">=</span>  <span class="keyword">new</span>  <span class="title class_">Integer</span>(p1);</span><br><span class="line"><span class="comment">//或Itnteger  in1  =  new  Integer(10);</span></span><br><span class="line">System.out.println(in1.toString());<span class="comment">//10</span></span><br><span class="line">System.out.println(in1); <span class="comment">//这样是一样的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//可以从String中抽离数字，的那是也只能是纯数字</span></span><br><span class="line"><span class="type">Itnteger</span>  <span class="variable">in1</span>  <span class="operator">=</span>  <span class="keyword">new</span>  <span class="title class_">Integer</span>(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">System.out.println(in1.toString());<span class="comment">//123</span></span><br><span class="line"><span class="type">Itnteger</span>  <span class="variable">in1</span>  <span class="operator">=</span>  <span class="keyword">new</span>  <span class="title class_">Integer</span>(<span class="string">&quot;123abc&quot;</span>);</span><br><span class="line">System.out.println(in1.toString());<span class="comment">//这样则会报错</span></span><br><span class="line"></span><br><span class="line"><span class="type">Float</span>  <span class="variable">f1</span>  <span class="operator">=</span> <span class="keyword">new</span>  <span class="title class_">Float</span>(<span class="number">12.3f</span>);</span><br><span class="line"><span class="type">Float</span> <span class="variable">f2</span> <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">Float</span>(<span class="string">&quot;12.3&quot;</span>);<span class="comment">//两者一样</span></span><br><span class="line"></span><br><span class="line"><span class="type">Boolean</span>  <span class="variable">b1</span> <span class="operator">=</span> <span class="keyword">new</span>  <span class="title class_">Boolean</span>(<span class="literal">true</span>);</span><br><span class="line"><span class="type">Boolean</span>  <span class="variable">b2</span> <span class="operator">=</span> <span class="keyword">new</span>  <span class="title class_">Boolean</span>(<span class="string">&quot;true&quot;</span>);</span><br><span class="line"><span class="comment">//在双引号内不区分大小写，如有多余的字符，返回的也是false</span></span><br></pre></td></tr></table></figure><h4 id="4-一般操作-包到基"><a href="#4-一般操作-包到基" class="headerlink" title="4.一般操作-包到基"></a>4.一般操作-包到基</h4><p>包装类—&gt;基本数据类型：调用包装类Xxx的xxxValue()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Itnteger</span>  <span class="variable">in1</span>  <span class="operator">=</span>  <span class="keyword">new</span>  <span class="title class_">Integer</span>(<span class="number">10</span>);</span><br><span class="line"><span class="type">int</span>  <span class="variable">i1</span>  <span class="operator">=</span>  in1.intValue();</span><br><span class="line"></span><br><span class="line"><span class="type">Float</span>  <span class="variable">f1</span>  <span class="operator">=</span> <span class="keyword">new</span>  <span class="title class_">Float</span>(<span class="number">12.3f</span>);</span><br><span class="line"><span class="type">float</span>   <span class="variable">f2</span>  <span class="operator">=</span>  f1.floatValue();</span><br><span class="line"></span><br><span class="line"><span class="type">Boolean</span>  <span class="variable">b1</span> <span class="operator">=</span> <span class="keyword">new</span>  <span class="title class_">Boolean</span>(<span class="literal">true</span>);</span><br><span class="line"><span class="type">boolean</span>  <span class="variable">b2</span> <span class="operator">=</span> b1.booleanValue();</span><br></pre></td></tr></table></figure><h4 id="5-便捷操作-基到包"><a href="#5-便捷操作-基到包" class="headerlink" title="5.便捷操作-基到包"></a>5.便捷操作-基到包</h4><p>基本数据类型—&gt;包装类</p><p>自动装箱</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>  <span class="variable">num1</span>  <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">Integer</span>  <span class="variable">in1</span>  <span class="operator">=</span>  num2  ;</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span>  <span class="variable">b1</span>  <span class="operator">=</span>   <span class="literal">true</span>  ;</span><br><span class="line"><span class="type">Boolean</span> <span class="variable">b2</span>  <span class="operator">=</span>   b1  ;</span><br><span class="line"></span><br><span class="line"><span class="type">Float</span>  <span class="variable">f1</span>  <span class="operator">=</span> <span class="number">12.3</span> ;</span><br></pre></td></tr></table></figure><blockquote><p>不用new了，就可以直接使用</p></blockquote><h4 id="6-便捷操作-包到基"><a href="#6-便捷操作-包到基" class="headerlink" title="6.便捷操作-包到基"></a>6.便捷操作-包到基</h4><p>包装类- —&gt;基本数据类型</p><p>自动拆箱：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span>  <span class="variable">in1</span> <span class="operator">=</span> <span class="number">10</span> ; <span class="comment">//自动装箱</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>  <span class="variable">num1</span> <span class="operator">=</span> in1 ; <span class="comment">//自动拆箱</span></span><br></pre></td></tr></table></figure><h4 id="7-包装类和基本数据类型比较问题"><a href="#7-包装类和基本数据类型比较问题" class="headerlink" title="7.包装类和基本数据类型比较问题"></a>7.包装类和基本数据类型比较问题</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span>  <span class="variable">i</span>   <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>);</span><br><span class="line"><span class="type">Integer</span>  <span class="variable">j</span>  <span class="operator">=</span> newInteger(<span class="number">1</span>);</span><br><span class="line">System.out.println(i == j);</span><br><span class="line"><span class="comment">//false 比的是地址</span></span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span>  <span class="variable">m</span> <span class="operator">=</span>  <span class="number">1</span> ;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">n</span> <span class="operator">=</span>  <span class="number">1</span> ;</span><br><span class="line">System.out.println(m == n);</span><br><span class="line"><span class="comment">//ture  地址一样</span></span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span>  <span class="variable">x</span> <span class="operator">=</span>  <span class="number">128</span> ;</span><br><span class="line"><span class="type">Integer</span>  <span class="variable">y</span> <span class="operator">=</span>  <span class="number">128</span> ;</span><br><span class="line">System.out.println(x == y);</span><br><span class="line"><span class="comment">//false 地址不一样</span></span><br></pre></td></tr></table></figure><p>1、<strong>基本型和基本型封装型</strong>进行<strong>“&#x3D;&#x3D;”运算符的比较</strong>，<strong>基本型封装型</strong>将会<strong>自动拆箱</strong>变为<strong>基本型</strong>后再<strong>进行比较</strong>，因此Integer(0)会自动拆箱为int类型再进行比较，显然返回true；<br>2、<strong>两个Integer类型</strong>进行<strong>“&#x3D;&#x3D;”比较</strong>，如果其值在-128至127，那么返回true，否则返回false, 这跟Integer.valueOf()的缓冲对象有关，这里不进行赘述。<br>3、<strong>两个基本型的封装型进行equals()比较</strong>，首先equals()会比较类型，如果类型相同，则继续比较值，如果值也相同，返回true<br>4、基本型封装类型调用equals(),但是参数是基本类型，这时候，先会进行自动装箱，基本型转换为其封装类型，再进行3中的比较。</p><blockquote><p>解释：new 过的空间地址不一样，Integer中存在数组存放使用频率最大的数  -128 ~~ 127 之间，在这区间内的数可以使用的是相同的地址</p><p>超过此范围，才会自动装箱给你new新空间来存放128</p></blockquote><h4 id="8-第三者String-基包到str"><a href="#8-第三者String-基包到str" class="headerlink" title="8.第三者String-基包到str"></a>8.第三者String-基包到str</h4><p>基本数据类型、包装类–&gt;String类型.</p><p>调用String重载的valueOf(Xxx  xxx)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">num1</span>  <span class="operator">=</span> <span class="number">10</span> ;</span><br><span class="line"><span class="type">Integer</span>  <span class="variable">num2</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式一：</span></span><br><span class="line"><span class="type">String</span>  <span class="variable">str1</span> <span class="operator">=</span> num1 +<span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="type">String</span>  <span class="variable">str2</span>  <span class="operator">=</span> num2 +<span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式二：</span></span><br><span class="line"><span class="type">String</span>  <span class="variable">str1</span> <span class="operator">=</span> String . valueOf(num1)；</span><br><span class="line"><span class="type">String</span>  <span class="variable">str2</span> <span class="operator">=</span> String . valueOf(num2)；</span><br></pre></td></tr></table></figure><h4 id="9-第三者String-str到基包"><a href="#9-第三者String-str到基包" class="headerlink" title="9.第三者String -str到基包"></a>9.第三者String -str到基包</h4><p>String类型—&gt;基本数据类型、包装类.</p><p>调用包装类的parseXxx(String   s  )</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span>  <span class="variable">str1</span>  <span class="operator">=</span>  <span class="string">&quot;123&quot;</span>;</span><br><span class="line"><span class="type">int</span>  <span class="variable">num1</span> <span class="operator">=</span> Integer . parseInt(str1)  ;</span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span>  <span class="variable">num2</span> <span class="operator">=</span> Integer . parseInt(str1)  ;</span><br></pre></td></tr></table></figure><h1 id="六、面向对象（下）"><a href="#六、面向对象（下）" class="headerlink" title="六、面向对象（下）"></a>六、面向对象（下）</h1><h3 id="6-1关键字：static"><a href="#6-1关键字：static" class="headerlink" title="6.1关键字：static"></a>6.1关键字：static</h3><h4 id="1-介绍-1"><a href="#1-介绍-1" class="headerlink" title="1.介绍"></a>1.介绍</h4><p>static：静态的</p><p>static可以用来修饰：属性、方法、代码块、内部类</p><h4 id="2-修饰属性"><a href="#2-修饰属性" class="headerlink" title="2.修饰属性"></a>2.修饰属性</h4><p>static  String  nation ;     静态变量  （或类变量）</p><ol><li><p>属性：按是否使用static修饰，分为：修饰属性 vs 非静态属性（实例变量）</p></li><li><p>实例变量</p><p>我们创建了类的多个对象，每个对象都独立的拥有一套类中的非静态属性。当<strong>修改其中一个对象中的非静态属性时，不会导致其中对象中同样的属性值的修改</strong></p></li><li><p>静态变量</p><p>我们创建了类的多个对象，多个对象共享同一个静态变量。当<strong>通过该某一个对象修改静态变量时，会导致其他对象调用此静态变量时，是修改过了的</strong></p></li><li><p>修饰属性的其他说明</p><ol><li><p>静态变量随这类的加载而加载(在方法区的静态域中)。可以通过 “ 类 . 静态变量 ” 的方式进行调用</p></li><li><p>静态变量的加载要早于对象的创建</p></li><li><p>由于类只会加载一次，则静态变量在内存汇总也只会存在一份：存在方法区的静态域中</p></li><li><p>类：可以直接调用类变量（静态变量），不能调用实例变量</p></li></ol><p>   对象：可以直接调用类变量（静态变量），也可以调用实例变量</p><p>   <strong>举例以上：</strong></p>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">      Person.nation  =  <span class="string">&quot;中国华人民共和国&quot;</span> ;  <span class="comment">//可以直接调用也可以改 </span></span><br><span class="line">      <span class="comment">//Person.name  错，不能调用非静态的</span></span><br><span class="line">      </span><br><span class="line">      <span class="type">Person</span>  <span class="variable">p1</span>  <span class="operator">=</span>  <span class="keyword">new</span>  <span class="title class_">Person</span>();</span><br><span class="line">      p1.nation  =  <span class="string">&quot;China&quot;</span> ; <span class="comment">//造完对象后可以直接调也可以改</span></span><br><span class="line">      </span><br><span class="line">      <span class="type">Person</span>  <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">      p2.nation = <span class="string">&quot;CHN&quot;</span> ; <span class="comment">//改完以后p1.nation 也是CHN</span></span><br><span class="line">      </span><br><span class="line">      <span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">          <span class="keyword">static</span> <span class="type">String</span>  <span class="variable">nation</span> <span class="operator">=</span> <span class="string">&quot;中国&quot;</span> ;</span><br><span class="line">          String  name ;</span><br><span class="line">          <span class="type">int</span>   age ;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span> 类变量内存解析</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">![Snipaste_2022-<span class="number">01</span>-<span class="number">16_12</span>-<span class="number">18</span>-<span class="number">48</span>](尚硅谷java基础学习/Snipaste_2022-<span class="number">01</span>-<span class="number">16_12</span>-<span class="number">18</span>-<span class="number">48.</span>png)</span><br><span class="line"></span><br><span class="line">#### <span class="number">3.</span>修饰方法</span><br><span class="line"></span><br><span class="line">静态方法</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 随着类的加载而加载，可以通过 “ 类 . 静态方法” 的方式进行调用</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 补充：如果在本类中调用本类的静态的属性或方法可以  nation 或Person . nation    , walk() 或  Person . walk()</span><br><span class="line"></span><br><span class="line">   通常会省略类名</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> **静态方法中，只能调用静态的方法或属性**</span><br><span class="line"></span><br><span class="line">   **要想调用非静态的，只能在本方法内创建类的对象实例，进行间接调用**</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> 非静态的方法中，既可以调用非静态的方法或属性，也可以调用静态的方法或属性</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span> 实例化子类对象时，涉及到父类、子类中（静态代码块、非静态代码块、构造器--也是此顺序）的加载顺序</span><br><span class="line"></span><br><span class="line">   由父及子，静态先行</span><br><span class="line"></span><br><span class="line">   代码</span><br><span class="line"></span><br><span class="line"><span class="number">6.</span> <span class="keyword">static</span> 注意点</span><br><span class="line"></span><br><span class="line">   <span class="number">1.</span> 在静态方法内，不能使用<span class="built_in">this</span>关键字 、<span class="built_in">super</span>关键字</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line"></span><br><span class="line">   <span class="number">2.</span> 关于静态属性和静态方法的使用，大家都从生命周期的角度去解释</span><br><span class="line"></span><br><span class="line">   <span class="number">3.</span> 所谓“生命周期”</span><br><span class="line"></span><br><span class="line">      首先程序先加载类，而静态就是跟随了类的加载。</span><br><span class="line"></span><br><span class="line">      其次造对象，才有非静态的（属性或方法）</span><br><span class="line"></span><br><span class="line">      其中可能一些对象执行程序结束被回收，而静态的始终还在</span><br><span class="line"></span><br><span class="line">      最后全部程序结束，静态的才被回收</span><br><span class="line"></span><br><span class="line">      就此看来，在一开始类就可以调用静态的属性或方法，当然这也规划了类不能调用非静态的属性或方法。</span><br><span class="line"></span><br><span class="line">      对象是后出现的，所以其可以调用非静态的属性或方法 </span><br><span class="line"></span><br><span class="line"><span class="number">7.</span> 开发中应用</span><br><span class="line"></span><br><span class="line">   <span class="number">1.</span> 开发中，如何确定一个属性是否声明为<span class="keyword">static</span>的？</span><br><span class="line"></span><br><span class="line">      属性是可以被多个所共享的，不会随者对象的不同而不同的</span><br><span class="line"></span><br><span class="line">      类中的常量也常常声明为<span class="keyword">static</span>  比如Math.PI</span><br><span class="line"></span><br><span class="line">   <span class="number">2.</span> 开发中，如何确定一个方法是否要声明为<span class="keyword">static</span>的</span><br><span class="line"></span><br><span class="line">      操作（调用）静态属性的方法，通常也是设置为静态的</span><br><span class="line"></span><br><span class="line">      工具类中的方法，习惯上声明为<span class="keyword">static</span> 的。比如：Math、Arrays 、Collections</span><br><span class="line"></span><br><span class="line">      都是大家通用的操作，不需要在一一造对象的</span><br><span class="line"></span><br><span class="line">   <span class="number">3.</span> 小举例</span><br><span class="line"></span><br><span class="line">      ```java</span><br><span class="line">      <span class="keyword">private</span>  <span class="type">int</span>  id  ；</span><br><span class="line">      <span class="keyword">private</span>  <span class="keyword">static</span>  <span class="type">int</span>  <span class="variable">inti</span> <span class="operator">=</span> <span class="number">1001</span>;<span class="comment">//编号</span></span><br><span class="line">      <span class="keyword">public</span> <span class="title function_">Circle</span><span class="params">()</span>&#123;</span><br><span class="line">      id  =  init ++;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="4-单例设计模式"><a href="#4-单例设计模式" class="headerlink" title="4.单例设计模式"></a>4.单例设计模式</h4><p>1.理解</p><p>设计模式是在大量的实践中总结和理论化之后优选的代码结构、编程风格、以及解决问题的思考方式。——-23种设计模式</p><p>所谓的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例</p><p>两种实现方式：</p><p>饿汉式    VS     懒汉式</p><p><strong>2.饿汉式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span>  <span class="title class_">Bank</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Bank</span><span class="params">()</span>&#123;   <span class="comment">//1.私有化构造器</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//2. 内部创建类的对象</span></span><br><span class="line"><span class="comment">// 4. 要求此对象必须声明为静态的</span></span><br><span class="line"><span class="keyword">private</span>  <span class="keyword">static</span>  <span class="type">Bank</span>  <span class="variable">inst</span>  <span class="operator">=</span>   <span class="keyword">new</span>  <span class="title class_">Bank</span>() ;</span><br><span class="line"><span class="comment">// 3. 提供公共的静态的方法，返回类的对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>  Bank  <span class="title function_">getInst</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> inst ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3.懒汉式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span>  <span class="title class_">Bank</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  <span class="title function_">Bank</span><span class="params">()</span>&#123;   <span class="comment">//1.私有化构造器</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2. 声明当前类的对象，没有初始化</span></span><br><span class="line">    <span class="comment">// 4. 要求此对象必须声明为静态的</span></span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">static</span>  <span class="type">Bank</span>  <span class="variable">inst</span>  <span class="operator">=</span>   <span class="literal">null</span> ;</span><br><span class="line">    <span class="comment">// 3. 提供公共的静态的方法，返回类的当前对象对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>  Bank  <span class="title function_">getInst</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( inst == <span class="literal">null</span> )&#123;  </span><br><span class="line">        inst  =  <span class="keyword">new</span>  <span class="title class_">Bank</span>() ;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">return</span> inst ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4.两种模式利弊</strong></p><p>饿汉式：</p><ul><li>好处：饿汉式是线程安全的</li><li>坏处：对象加载时间过长</li></ul><p>懒汉式;</p><ul><li>好处：延迟对象的创建</li><li>坏处：目前写法坏处：线程不安全–&gt;讲到多线程内容时，再修改</li><li>举例：你有一银行账户2000元：你同时在手机中和在ATM机中取款，这时你可能有机会同时进入并将前同时取出。</li></ul><blockquote><p>这里的懒汉式也是这个道理，两个操作同时进行，就有可能判断他们都为空null，继而创建出了两个对象</p><p>如是这样，将导致你高铁抢到的票，有三四个票是重复的</p></blockquote><p><strong>5.应用场所</strong></p><p><img src="/2022/10/02/%E5%B0%9A%E7%A1%85%E8%B0%B7java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/Snipaste_2022-01-16_15-36-11.png" alt="Snipaste_2022-01-16_15-36-11"></p><h3 id="6-3-main-方法详解"><a href="#6-3-main-方法详解" class="headerlink" title="6.3 main() 方法详解"></a>6.3 main() 方法详解</h3><h4 id="1-使用说明"><a href="#1-使用说明" class="headerlink" title="1.使用说明"></a>1.使用说明</h4><ol><li>main( ) 方法作为程序的入口</li><li>main ( ) 方法也是一个普通的静态方法 </li><li>main ( ) 方法可以作为我们与控制台交互的方式</li></ol><h4 id="2-理解"><a href="#2-理解" class="headerlink" title="2.理解"></a>2.理解</h4><ol><li><p>格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">( String[ ]  args )</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//是一个public 公共的，静态的，返回值为空的，形参为String[]  args 和方法名叫main的一个方法</span></span><br></pre></td></tr></table></figure></li><li><p>小结：一叶知秋</p><p>public static void main( String[ ]  args ){        方法体      }</p><p>权限修饰符：private 、缺省、protected、public—封装性</p><p>修饰符：static、final、abstract、native—-可以用来修饰方法</p><p>返回值类型：无返回值、有返回值–return</p><p>方法名：“见名知意”</p><p>形参列表：重载    VS  重写（参数的值传递机制、体现对象的多态性</p><p>方法体：来体现方法的功能</p></li><li><p>注意：</p><ol><li><p>在每个类中都可以声明名字叫main的方法，在运行时，会手动区分</p></li><li><p><strong>因为是static ,所以方法内只能调用静态的属性或方法</strong></p><p><strong>要想调用非静态的，只能在本方法内创建类的对象，进行间接调用</strong></p></li><li><p>形参中的String类型的数组可以在控制台中传入一些值</p><p>右键—Run Configuration—MainDemo—Arguments</p><p>在Program arguments 中带双引号输入你想要传的数值或字符</p></li><li><p>cmd 控制台中</p><p>java  类名  。。。</p><p>在类名后带双引号输入你想要传的数值或字符</p></li></ol></li></ol><h3 id="6-4-类的结构–代码块"><a href="#6-4-类的结构–代码块" class="headerlink" title="6.4 类的结构–代码块"></a>6.4 类的结构–代码块</h3><p>或初始化块</p><h4 id="1-介绍-2"><a href="#1-介绍-2" class="headerlink" title="1.介绍"></a>1.介绍</h4><ol><li><p><strong>代码块的作用：用来初始化类、对象</strong></p></li><li><p>代码块如果有修饰的话，只能使用static</p></li><li><p>分类：静态代码块 VS  非静态代码块</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//VS</span></span><br><span class="line">  &#123;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="2-静态代码块"><a href="#2-静态代码块" class="headerlink" title="2.静态代码块"></a>2.静态代码块</h4><ol><li>内部可以有输出语句</li><li><strong>随着类的加载而执行，而且只执行一次</strong></li><li><strong>作用：初始化类的信息</strong></li><li>如果一个类中定义了多个静态代码块，则按声明的先后顺序执行</li><li><strong>静态代码块的执行要优先于非静态代码块的执行</strong></li><li><strong>静态代码块内只能调用静态的属性、静态的方法，</strong>不能调用非静态的结构</li></ol><h4 id="3-非静态代码块"><a href="#3-非静态代码块" class="headerlink" title="3.非静态代码块"></a>3.非静态代码块</h4><ol><li><p>内部可以有输出语句</p></li><li><p><strong>随着对象的创建而执行</strong></p></li><li><p><strong>每创建一个对象，就执行一次非静态代码块</strong></p></li><li><p>作用：可以在创建对象时，对对象的属性等进行初始化</p></li><li><p>如果一个类中定义了多个非静态代码块，则按声明的先后顺序执行</p></li><li><p><strong>非静态代码块内可以调用静态的属性、静态的方法，或非静态的属性、非静态的方法</strong></p></li><li><p>顺序说明</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span><span class="number">1</span>; <span class="comment">//---------------A</span></span><br><span class="line">    &#123;<span class="comment">//--------------B</span></span><br><span class="line">    age =<span class="number">2</span>;</span><br><span class="line">    &#125;<span class="comment">//这两个是按先后顺序执行的结果age=2，B 和A</span></span><br><span class="line">    <span class="comment">//反过来，age=1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//static的也一样</span></span><br><span class="line">    <span class="keyword">static</span>  <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">    age  =<span class="number">2</span> ;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="4-属性可以赋值的位置"><a href="#4-属性可以赋值的位置" class="headerlink" title="4.属性可以赋值的位置"></a>4.属性可以赋值的位置</h4><ol><li>默认初始化</li><li>显式初始化、代码块初始化</li><li>构造器初始化</li><li>有了对象以后，通过 “对象 . 属性”或“对象  . 方法” 的方式，进行赋值</li></ol><p>执行先后顺序也是这个顺序，至于2 . 中，因上述顺序代码说明，他们执行是有先后顺序的，</p><h3 id="6-5-关键字：f-inal"><a href="#6-5-关键字：f-inal" class="headerlink" title="6.5 关键字：f inal"></a>6.5 关键字：f inal</h3><h4 id="1-介绍-3"><a href="#1-介绍-3" class="headerlink" title="1.介绍"></a>1.介绍</h4><p>译为：最终的             在这表：最终的形态</p><p>final 可以用来修饰的结构：类、方法、变量</p><h4 id="2-修饰一个类"><a href="#2-修饰一个类" class="headerlink" title="2.修饰一个类"></a>2.修饰一个类</h4><p>此类不能被其他类所继承</p><p>后面没有子类了，没有儿子了</p><p>比如：String类、System类、StringBuffer类</p><h4 id="3-修饰方法"><a href="#3-修饰方法" class="headerlink" title="3.修饰方法"></a>3.修饰方法</h4><p>表明此方法不可以被重写了（也是最终的形态了）</p><p>比如：Object类中getClass() ;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="keyword">static</span>  <span class="keyword">void</span>  <span class="title function_">eat</span> <span class="params">()</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-修饰变量"><a href="#4-修饰变量" class="headerlink" title="4.修饰变量"></a>4.修饰变量</h4><p>此时的“变量” 就称为是一个常量。(最终的形态，数据不能在被修改)</p><ol><li><p>final修饰属性：</p><p>可以考虑赋值的位置有：显式初始化、代码块中的初始化、构造器中的初始化（按优先级排的序，有了显式初始化，代码块就不能在初始化了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式一：</span></span><br><span class="line">    <span class="keyword">final</span>  <span class="type">int</span>  <span class="variable">AGE</span> <span class="operator">=</span> <span class="number">1</span> ;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式二：</span></span><br><span class="line"><span class="keyword">final</span>  <span class="type">int</span>  GG;</span><br><span class="line">&#123;</span><br><span class="line">GG=<span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式三：</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Person</span>&#123;       </span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="variable">AGE</span> <span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> AA;</span><br><span class="line">        </span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span>&#123;</span><br><span class="line">AA =<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>final 修饰局部变量：</p><p>尤其是使用final 修饰形参时，表明此形参是一个常量。当我们调用此方法时，给常量形参赋一个实参，一旦赋值以后，就只能在方法体内使用此形参，但不能进行赋值或修改该值了</p></li></ol><h4 id="5-全局变量"><a href="#5-全局变量" class="headerlink" title="5.全局变量"></a>5.全局变量</h4><p>全局变量（成员变量）：包含类属性和实例属性</p><p>static final  用来修饰属性：全局变量</p><h3 id="6-6关键字：abstract"><a href="#6-6关键字：abstract" class="headerlink" title="6.6关键字：abstract"></a>6.6关键字：abstract</h3><h4 id="1-介绍-4"><a href="#1-介绍-4" class="headerlink" title="1.介绍"></a>1.介绍</h4><p>abstract :  抽象的</p><p>abstract 可以用来修饰的结构：类、方法</p><p>此类不能实例化（不能new对象）</p><h4 id="2-修饰类"><a href="#2-修饰类" class="headerlink" title="2.修饰类"></a>2.修饰类</h4><ol><li>此类不能实例化（不能new对象）</li><li>抽象类中一定有构造器，便于子类实例化时调用（子类还是要调用父类的构造器）</li><li>开发中，会提供抽象类的子类，让子类对象实例化，完成相关的操作。</li><li>abstract  class   类名{  }</li></ol><h4 id="3-修饰方法-1"><a href="#3-修饰方法-1" class="headerlink" title="3.修饰方法"></a>3.修饰方法</h4><ol><li><p>抽象方法只有方法的声明，没有方法体,用分号结尾</p><p>比如： public  abstract  void  eat() ;</p></li><li><p>包含抽象方法的类，一定是一个抽象类。反之，抽象类中不一定有抽象方法</p></li><li><p>子类要想实例化，需要重写父类中的所有的抽象方法</p></li><li><p>若子类没有重写父类中的所有的抽象方法，则此子类也是一个抽象类，需要加上abstract进行修饰</p></li></ol><h4 id="4-使用注意点"><a href="#4-使用注意点" class="headerlink" title="4.使用注意点"></a>4.使用注意点</h4><ol><li>abstract不能用来修饰：属性、构造器等结构</li><li>abstract 不能用来修饰私有方法、静态方法、final 的方法、final 的类</li><li>好处：有继承关系，父类为抽象类，且有抽象方法不提供实现，此抽象方法是由于每个子类公有的但是具体方法体不同，所以必须得重写。<strong>提供抽象类，就是为了提醒所有子类用时必须重写抽象方法</strong></li></ol><h4 id="5-匿名子类的对象"><a href="#5-匿名子类的对象" class="headerlink" title="5.匿名子类的对象"></a>5.匿名子类的对象</h4><ol><li><p>一般有类的匿名和不匿名、对象的匿名和不匿名</p></li><li><p>非匿名类非匿名对象： Person  p &#x3D; new  Student()</p></li><li><p>非匿名类匿名对象： new  Student()</p></li><li><p>匿名类非匿名对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假设Person类是一个抽象类 </span></span><br><span class="line"><span class="type">Person</span>  <span class="variable">p</span>  <span class="operator">=</span>  <span class="keyword">new</span>   <span class="title class_">Person</span> () &#123;</span><br><span class="line">  <span class="comment">//这里面，重写抽象类中的所有抽象方法</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">Person</span>  <span class="variable">p</span>  <span class="operator">=</span>  <span class="keyword">new</span>   <span class="title class_">Person</span> () &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span>  <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;吃饭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//此时完成了创建匿名子类非匿名对象</span></span><br><span class="line"><span class="comment">//对象名是知道的p，父类是Person(抽象类)，但是子类的类名不知道。</span></span><br><span class="line"><span class="comment">//假设有一个方法：</span></span><br><span class="line"><span class="keyword">public</span>  <span class="keyword">void</span>  <span class="title function_">method</span><span class="params">(Person  per)</span>&#123;</span><br><span class="line">per.eat();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//此时调用该方法 method (p) ;</span></span><br><span class="line"><span class="comment">//这里体现了多态，实际执行的是匿名子类中的重写的方法</span></span><br></pre></td></tr></table></figure></li><li><p>匿名类匿名对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">method(<span class="keyword">new</span>   <span class="title class_">Person</span> () &#123;</span><br><span class="line">  <span class="comment">//这里面，重写抽象类中的所有抽象方法</span></span><br><span class="line">&#125; ) ;</span><br></pre></td></tr></table></figure></li></ol><h4 id="6-模板方法的设计模式"><a href="#6-模板方法的设计模式" class="headerlink" title="6.模板方法的设计模式"></a>6.模板方法的设计模式</h4><p>多态以及abstract 的应用</p><p>抽象类体现的就是一种模板模式的设计，抽象类作为多个子类的通用模板，子类在抽象类的基础上进行扩展、改造，但子类总体上会保留抽象类的行为方式。</p><p>解决的问题： </p><p> 当功能内部一部分实现是确定的，一部分实现是不确定的。这时可以把不确定的部分暴露出去，让子类去实现。 </p><p>换句话说，在软件开发中实现一个算法时，整体步骤很固定、通用，这些步骤已经在父类中写好了。但是某些部分易变，易变部分可以抽象出来，供不同子类实现。这就是一种模板模式</p><p>代码举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Template</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">getTime</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">code();</span><br><span class="line"><span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">&quot;执行时间是：&quot;</span> + (end - start));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">code</span><span class="params">()</span>;   <span class="comment">//抽象方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubTemplate</span> <span class="keyword">extends</span> <span class="title class_">Template</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">code</span><span class="params">()</span> &#123;    <span class="comment">//重写抽象方法</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">System.out.println(i);</span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个子类想要想要计算运行时间就只需重写抽象方法即可</p><p>还有一种银行举例：抽象类中写有抽象方法和非抽象方法，抽象方法因为子类的此方法体各不相同，所以需要子类重写。</p><p>取号  干什么事    排队</p><p>取号和排队非抽象方法，干什么事是抽象方法</p><p>将这个流程封装为一个方法，当不同子类调用时，输出–干什么事–也不同</p><h3 id="6-8-interface-接口"><a href="#6-8-interface-接口" class="headerlink" title="6.8 interface 接口"></a>6.8 interface 接口</h3><h4 id="1-介绍-5"><a href="#1-介绍-5" class="headerlink" title="1.介绍"></a>1.介绍</h4><ol><li><p>接口使用interface 来定义</p></li><li><p>Java中，接口和类是并列的两个结构</p></li><li><p>不能实例化</p></li></ol><h4 id="2-定义接口"><a href="#2-定义接口" class="headerlink" title="2.定义接口"></a>2.定义接口</h4><p>定义接口中的成员</p><ol><li><p><strong>JDK 7 及以前，只能定义全局常量和抽象方法</strong><br><strong>全局常量：public  static  final</strong> </p><p>全局常量：包含类属性和实例属性</p><p><strong>抽象方法：public abstract</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">AAA</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">static</span>  <span class="keyword">final</span> <span class="type">int</span> <span class="variable">AGE</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">AGE</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">static</span>  <span class="keyword">final</span> <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">    <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();  <span class="comment">//public  static  final在接口中书写时可以省略不写</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;   &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;    &#125;  <span class="comment">//在接口中书写时可以省略不写</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>JDK 8 除了定义全局常量和抽象方法之外，还可以定义静态方法、默认方法（暂时先不考虑）</strong></p><p>  接口中不能定义构造器，意味者不能实例化</p></li></ol><h4 id="3-使用方式"><a href="#3-使用方式" class="headerlink" title="3.使用方式"></a>3.使用方式</h4><ol><li>Java开发中，接口通过让类去实现（implement）的方式来使用</li><li>如果实现类覆盖（重写）了接口中所有抽象方法，则此实现类就可以实例化</li><li>如果实现类没有覆盖接口中所有的抽象方法，则此实现类仍为一个抽象类（要么重写所有抽象方法，要么加上abstract）</li></ol><p>​              格式：假设CC为接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span>  <span class="title class_">AA</span>  <span class="keyword">implements</span> <span class="title class_">CC</span>,EE,DD&#123;   &#125;</span><br></pre></td></tr></table></figure><ol start="4"><li><p>接口可以作为声明使用，但不能够new对象(声明在类中和方法形参中)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">USB</span>  <span class="variable">usb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Flash</span>();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">(USB  usb)</span>&#123;</span><br><span class="line">    usb.start();</span><br><span class="line">    usb.stop();</span><br><span class="line">&#125;   <span class="comment">// USB是接口， Flash是实现类  ，方法内调用的实际是实现类重写的方法----类似于子父类关系--体现了多态性</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="4-体现继承性"><a href="#4-体现继承性" class="headerlink" title="4.体现继承性"></a>4.体现继承性</h4><ol><li><p>Java类中可以实现多个接口—&gt;弥补了Java单继承性的局限性</p></li><li><p>格式：        </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span>  <span class="title class_">AA</span> <span class="keyword">extends</span>  <span class="title class_">BB</span> <span class="keyword">implements</span>  <span class="title class_">CC</span>,DD,EE&#123;    &#125; </span><br></pre></td></tr></table></figure><p>AA继承了BB ，还实现了很多接口</p></li><li><p>AA得重写所有实现的接口中的抽象方法</p></li><li><p>接口与接口之间可以继承，而且还可以多继承</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">AA</span>&#123;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">BB</span>&#123;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">CC</span>  <span class="keyword">extends</span> <span class="title class_">AA</span>,BB&#123;</span><br><span class="line">    <span class="comment">//接口内东西可写可不写</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果有个EE去实现CC，得重写AA，BB，CC中所有的抽象方法</span></span><br></pre></td></tr></table></figure><h4 id="5-接口是一种规范"><a href="#5-接口是一种规范" class="headerlink" title="5.接口是一种规范"></a>5.接口是一种规范</h4><p>接口，实际上可以看做一种规范</p><p>USB接口全球同一口径、人就要会思考、鸟就会飞、鱼就会游等等</p><p>将口径、思考、飞、游，都可作为接口</p><h4 id="6-体现多态性"><a href="#6-体现多态性" class="headerlink" title="6.体现多态性"></a>6.体现多态性</h4><ol><li><p>接口指定具体使用，体现多态性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">USB</span> &#123;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span>  <span class="title class_">BB</span>  <span class="keyword">implements</span> <span class="title class_">USB</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;开始工作&quot;</span>)； &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;停止工作&quot;</span>)； &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">USBTest</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[ ]  args)</span>&#123;</span><br><span class="line">        <span class="type">USBTest</span> <span class="variable">com</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">USBTest</span>();</span><br><span class="line">        <span class="type">BB</span>  <span class="variable">bb</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BB</span>();</span><br><span class="line">        com.Computer(bb);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span>  <span class="title function_">Computer</span><span class="params">(USB  usb)</span> &#123;</span><br><span class="line">        usb.start();</span><br><span class="line">        <span class="comment">//调用其他方法进行操作</span></span><br><span class="line">        usb.stop();      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//此时体现多态性</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="7-匿名子类的对象"><a href="#7-匿名子类的对象" class="headerlink" title="7.匿名子类的对象"></a>7.匿名子类的对象</h4><ol><li><p>创建了接口的匿名实现类的非匿名对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">USB</span>  <span class="variable">p</span>  <span class="operator">=</span>  <span class="keyword">new</span>   <span class="title class_">USB</span> () &#123;</span><br><span class="line">  <span class="comment">//这里面，重写接口中的抽象方法</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">USB</span>  <span class="variable">p</span>  <span class="operator">=</span>  <span class="keyword">new</span>   <span class="title class_">USB</span> () &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span>  <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;吃饭&quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对象名是知道的p，接口名，但是实现类的类名不知道。</span></span><br><span class="line"><span class="comment">//假设有一个方法：</span></span><br><span class="line"><span class="keyword">public</span>  <span class="keyword">void</span>  <span class="title function_">method</span><span class="params">(USB  per)</span>&#123;</span><br><span class="line">per.eat();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时调用该方法 method (p) ;<br>这里体现了多态，实际执行的是匿名实现类中的重写的方法</p></li><li><p>匿名类匿名对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">method( <span class="keyword">new</span>   <span class="title class_">USB</span> () &#123;  <span class="comment">/*这里面，重写接口中的抽象方法*/</span>  &#125; ) ;</span><br></pre></td></tr></table></figure></li></ol><h4 id="8-接口实例化在说明"><a href="#8-接口实例化在说明" class="headerlink" title="8.接口实例化在说明"></a>8.接口实例化在说明</h4><p>接口到底能不能实例化？</p><p>接口不可以实例化，因为它没有构造器（它需要通过实现类进行实例化，不能new</p><p>除了，在匿名内部类可以new＋接口&#x3D;实现类，其实是接口的子类，只是名字(类名)和接口一样）类似于抽象类</p><h4 id="9-JDK-8新增"><a href="#9-JDK-8新增" class="headerlink" title="9.JDK 8新增"></a>9.JDK 8新增</h4><p>1.介绍</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="keyword">interface</span> <span class="title class_">CompareA</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span>&#123;      方法体    &#125; <span class="comment">//--------静态方法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123; 方法体   &#125;  <span class="comment">//--------默认方法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>  <span class="keyword">void</span>  <span class="title function_">method3</span><span class="params">()</span>&#123;      方法体     &#125;  <span class="comment">//----修饰符都为public可省略</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.使用细节：</p><ol><li><p>接口中定义的静态方法，只能通过接口来调用</p><p>CompareA . method1();</p></li><li><p>通过实现类的对象，可以调用接口中的默认方法。</p></li><li><p>如果实现类重写了接口中的默认方法，调用时，仍然调用的是重写以后的方法</p></li><li><p>如果子类（或实现类）继承的父类和实现的接口中声明了同名同参数的方法，那么子类在没有重写此方法的情况下，默认调用的是父类中同名同参数的默认方法——&gt;类优先原则（只针对于方法，属性不考虑，如果父类和接口属性重名就会报错，别重名。）</p></li><li><p>如果实现类实现的两个接口中存在同名同参数的默认方法，则必须要在实现类中进行重写。</p></li><li><p>如何咋子类（或实现类）的方法中调用父类、接口中被重写的方法</p><ol><li><p>调用自已定义的重写的方法：method3();</p></li><li><p>调用的是父类中声明的：super . method3() ;</p></li><li><p>调用接口中的默认方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CompareA . <span class="built_in">super</span> . method3() ;</span><br><span class="line"></span><br><span class="line">CompareB . <span class="built_in">super</span> . method3() ;</span><br></pre></td></tr></table></figure></li></ol></li></ol><h3 id="6-9-类的结构–内部类"><a href="#6-9-类的结构–内部类" class="headerlink" title="6.9 类的结构–内部类"></a>6.9 类的结构–内部类</h3><h4 id="1-介绍-6"><a href="#1-介绍-6" class="headerlink" title="1.介绍"></a>1.介绍</h4><ol><li>Java中允许将一个类A声明在另一个类B中，则类A结合水内部类，类B称为外部类</li><li>内部类的分类：成员内部类（静态、非静态）  VS  局部内部类（方法内、代码块内、构造器内）</li></ol><h4 id="2-成员内部"><a href="#2-成员内部" class="headerlink" title="2.成员内部"></a>2.成员内部</h4><ol><li><p>首先它是作为外部类的成员</p><ol><li>调用外部类的结构</li><li>可以被static 的修饰</li><li>可以被4种不同的修饰</li></ol></li><li><p>另外：作为一个类</p><ol><li>类内可以定义属性、方法、构造器等</li><li>可以被final 修饰，表示此类不能被继承。言外之意，不使用final，就可以被继承</li><li>可以被abstract 修饰</li></ol></li><li><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">class</span> <span class="title class_">Animal</span>&#123;   </span><br><span class="line">   </span><br><span class="line">        <span class="keyword">class</span>  <span class="title class_">Dog</span>&#123;    </span><br><span class="line">   <span class="keyword">public</span>  <span class="title function_">Dog</span><span class="params">()</span>&#123;   &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title function_">display</span><span class="params">( String  name )</span>&#123;   &#125; </span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">public</span>  <span class="keyword">static</span>  <span class="keyword">class</span>  <span class="title class_">Bird</span>&#123;       &#125;</span><br><span class="line"><span class="keyword">public</span>   <span class="keyword">final</span> <span class="keyword">class</span>  <span class="title class_">Cat</span>&#123;       &#125;</span><br><span class="line">   <span class="keyword">public</span>   <span class="keyword">abstract</span> <span class="keyword">class</span>  <span class="title class_">Cat</span>&#123;       &#125;</span><br><span class="line">   </span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### <span class="number">3.</span>关注如下的<span class="number">3</span>个问题</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 如何实例化成员内部类的对象</span><br><span class="line"></span><br><span class="line">   ```java</span><br><span class="line">   <span class="comment">//创建Dog实例（静态的成员内部类）</span></span><br><span class="line">   Person . <span class="type">Dog</span>  <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span> . Dog() ;</span><br><span class="line">   dog . show() ;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//创建Bird实例（非静态的实例成员内部类）</span></span><br><span class="line">   <span class="type">Person</span>  <span class="variable">p</span>  <span class="operator">=</span>   <span class="keyword">new</span>   <span class="title class_">Person</span>() ;</span><br><span class="line">   Person . <span class="type">Bird</span>  <span class="variable">bird</span> <span class="operator">=</span>  p . <span class="keyword">new</span> . Bird() ;</span><br><span class="line">   bird . sing();</span><br></pre></td></tr></table></figure></li><li><p>如何在成员内部类中区分调用外部类的结构</p><p>调用属性</p><p>调用内部类和外部类方法也是如此，不重名时，可省略</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">class</span> <span class="title class_">Animal</span>&#123;    </span><br><span class="line">       <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;动物&quot;</span> ;</span><br><span class="line">   </span><br><span class="line">       <span class="keyword">class</span>  <span class="title class_">Dog</span>&#123;    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;狗&quot;</span> ;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span>  <span class="title function_">display</span><span class="params">( String  name )</span>&#123;</span><br><span class="line">   </span><br><span class="line">   System.out.println(name);  <span class="comment">//形参</span></span><br><span class="line">   System.out.println(<span class="built_in">this</span> . name);  <span class="comment">//内部类的</span></span><br><span class="line">   System.out.println(Person . <span class="built_in">this</span> . name);  <span class="comment">//外部类的</span></span><br><span class="line">                   &#125;</span><br><span class="line">   </span><br><span class="line"><span class="number">3.</span> 开发中局部内部类的使用---匿名</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line"><span class="comment">//返回一个实现了Comparable 接口的类的对象</span></span><br><span class="line"><span class="keyword">public</span> Comparable  <span class="title function_">getComparable</span><span class="params">( )</span> &#123;</span><br><span class="line"><span class="comment">//方式一：创建一个实现了Comparable接口的类：局部内部类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyComparable</span> implement Comparable &#123;</span><br><span class="line"><span class="comment">//重写接口抽象方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Object  o )</span>&#123;   方法体  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>  <span class="keyword">new</span> <span class="title class_">MyComparable</span> ;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//方式二：</span></span><br><span class="line">    <span class="keyword">return</span>  <span class="keyword">new</span> <span class="title class_">Comparable</span>( ) &#123;</span><br><span class="line"><span class="keyword">public</span>  <span class="type">int</span>  <span class="title function_">compareTo</span><span class="params">(Object  o )</span>&#123;   方法体  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>方式一：有类名，没有对象名</p><p>方式二：没有类名，没有对象名</p></blockquote><h1 id="七、异常处理"><a href="#七、异常处理" class="headerlink" title="七、异常处理"></a>七、异常处理</h1><h3 id="7-1异常"><a href="#7-1异常" class="headerlink" title="7.1异常"></a>7.1异常</h3><h4 id="1-异常的体系结构"><a href="#1-异常的体系结构" class="headerlink" title="1.异常的体系结构"></a>1.异常的体系结构</h4><ul><li><p>java.lang.Throwable</p><ul><li>java.lang.Error:一般不编写针对性的代码进行处理。<br>* java.lang.Exception:可以进行异常的处理</li></ul><pre><code>* **编译时异常**(checked)   * IOException      * FileNotFoundException         * ClassNotFoundException          * **运行时异常**(unchecked,RuntimeException)          * NullPointerException          * ArrayIndexOutOfBoundsException           * ClassCastException           * NumberFormatException           * InputMismatchException           * ArithmeticException</code></pre></li></ul><h4 id="2-从程序执行过程"><a href="#2-从程序执行过程" class="headerlink" title="2.从程序执行过程"></a>2.从程序执行过程</h4><p>看编译时异常和运行时异常</p><p>编译时异常：执行javac.exe命名时，可能出现的异常<br>运行时异常：执行java.exe命名时，出现的异常</p><h4 id="3-常见的异常类型"><a href="#3-常见的异常类型" class="headerlink" title="3.常见的异常类型"></a>3.常见的异常类型</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">                 <span class="comment">//******************以下是运行时异常***************************</span></span><br><span class="line"><span class="comment">//ArithmeticException</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test6</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">System.out.println(a / b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//InputMismatchException</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test5</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="type">int</span> <span class="variable">score</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">System.out.println(score);</span><br><span class="line"></span><br><span class="line">scanner.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//NumberFormatException</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;123&quot;</span>;</span><br><span class="line">str = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> Integer.parseInt(str);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ClassCastException</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> (String)obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//IndexOutOfBoundsException</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">//ArrayIndexOutOfBoundsException</span></span><br><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">System.out.println(arr[<span class="number">10</span>]);</span><br><span class="line"><span class="comment">//StringIndexOutOfBoundsException</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">System.out.println(str.charAt(<span class="number">3</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//NullPointerException</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>[] arr = <span class="literal">null</span>;</span><br><span class="line">System.out.println(arr[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">str = <span class="literal">null</span>;</span><br><span class="line">System.out.println(str.charAt(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">//******************以下是编译时异常***************************</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test7</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line"><span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> fis.read();</span><br><span class="line"><span class="keyword">while</span>(data != -<span class="number">1</span>)&#123;</span><br><span class="line">System.out.print((<span class="type">char</span>)data);</span><br><span class="line">data = fis.read();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fis.close();</span><br><span class="line"></span><br><span class="line">&#125;                       </span><br></pre></td></tr></table></figure><h3 id="7-2异常处理"><a href="#7-2异常处理" class="headerlink" title="7.2异常处理"></a>7.2异常处理</h3><h4 id="1-java异常处理的抓抛模型"><a href="#1-java异常处理的抓抛模型" class="headerlink" title="1.java异常处理的抓抛模型"></a>1.java异常处理的抓抛模型</h4><p>过程一：”抛”：程序在正常执行的过程中，一旦出现异常，就会在异常代码处生成一个对应异常类的对象。</p><ol><li>并将此对象抛出。</li><li>一旦抛出对象以后，其后的代码就不再执行。</li></ol><p>关于异常对象的产生：</p><p>① 系统自动生成的异常对象</p><p>② 手动的生成一个异常对象，并抛出（<strong>throw</strong>）</p><p>过程二：”抓”：可以理解为异常的处理方式：</p><p>① try-catch-finally  </p><p>② throws</p><h4 id="2-异常处理方式一"><a href="#2-异常处理方式一" class="headerlink" title="2.异常处理方式一"></a>2.异常处理方式一</h4><p><strong>try-catch-finally</strong></p><ol><li>使用说明：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//可能出现异常的代码</span></span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">1</span> 变量名<span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理异常的方式1</span></span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">2</span> 变量名<span class="number">2</span>)&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理异常的方式2</span></span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">3</span> 变量名<span class="number">3</span>)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理异常的方式3</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">....</span><br><span class="line"></span><br><span class="line"><span class="keyword">finally</span>&#123;</span><br><span class="line"><span class="comment">//一定会执行的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <strong>代码演示：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line"><span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> fis.read();</span><br><span class="line"><span class="keyword">while</span>(data != -<span class="number">1</span>)&#123;</span><br><span class="line">System.out.print((<span class="type">char</span>)data);</span><br><span class="line">data = fis.read();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fis.close();</span><br><span class="line">&#125;<span class="keyword">catch</span>(FileNotFoundException e)&#123;</span><br><span class="line">e.printStackTrace(); <span class="comment">//输出异常</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(IOException e)&#123;   <span class="comment">//子类在它上面</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.说明及解释</p><p><strong>finally是可选的</strong>，可有，可没有。</p><ol><li>使用try将可能出现异常代码包装起来，在执行过程中，一旦出现异常，就会生成一个对应异常类的对象，根据此对象的类型，去catch中进行匹配</li><li><strong>一旦try中的异常对象匹配到某一个catch时，就进入catch中进行异常的处理。一旦处理完成，就跳出当前的try-catch结构（在没写finally的情况。继续执行其后的代码）</strong></li><li>catch中的异常类型如果没子父类关系，则谁声明在上，谁声明在下无所谓。</li><li>catch中的异常类型如果满足子父类关系，则要求子类一定声明在父类的上面。否则，报错</li><li><strong>常用的异常对象处理的方式： ① String  getMessage()    ② printStackTrace()</strong></li><li>在try结构中声明的变量，再出了try结构以后，就不能再被调用</li><li><strong>try-catch-finally结构可以嵌套</strong></li></ol><p>​    <strong>代码演示</strong>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testMethod</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> method();</span><br><span class="line">System.out.println(num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">System.out.println(arr[<span class="number">10</span>]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>; <span class="comment">//如果没异常，在执行这之前会执行finally</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(ArrayIndexOutOfBoundsException e)&#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span>;  <span class="comment">//在执行这之前会执行finally</span></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;我一定会被执行&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">3</span>;  <span class="comment">//到这直接退出了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-小结"><a href="#3-小结" class="headerlink" title="3.小结"></a>3.小结</h4><p><strong>1.如何看待代码中的编译时异常和运行时异常？</strong></p><p>体会1：使用try-catch-finally处理编译时异常，是得程序在编译时就不再报错，但是运行时仍可能报错。相当于我们使用try-catch-finally将一个编译时可能出现的异常，延迟到运行时出现。</p><p>体会2：开发中，由于运行时异常比较常见，所以我们通常就不针对运行时异常编写try-catch-finally了。针对于编译时异常，我们说一定要考虑异常的处理。</p><p><strong>2.finally的再说明：</strong></p><p>1.finally是可选的</p><p>2.<strong>finally中声明的是一定会被执行的代码。即使catch中又出现异常了，try中return语句，catch中return语句等情况。</strong></p><p>3.像数据库连接、输入输出流、网络编程Socket等资源，JVM是不能自动的回收的，我们需要自己手动的进行资源的释放。此时的资源释放，就需要声明在finally中。</p><h4 id="4-面试题"><a href="#4-面试题" class="headerlink" title="4.面试题"></a>4.面试题</h4><p>final、finally、finalize三者的区别？</p><p>类似：<br>throw 和 throws<br>Collection 和 Collections<br>String 、StringBuffer、StringBuilder<br>ArrayList 、 LinkedList<br>HashMap 、LinkedHashMap<br>重写、重载</p><p>结构不相似的：<br>抽象类、接口<br>&#x3D;&#x3D; 、 equals()<br>sleep()、wait()</p><h4 id="5-异常处理方式二"><a href="#5-异常处理方式二" class="headerlink" title="5.异常处理方式二"></a>5.异常处理方式二</h4><ol><li>“throws + 异常类型”写在方法的声明处。指明此方法执行时，可能会抛出的异常类型。</li><li>一旦当方法体执行时，出现异常，仍会在异常代码处生成一个异常类的对象，此对象满足throws后异常类型时，就会被抛出。异常代码后续的代码，就不再执行！</li></ol><p><strong>代码演示：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionTest2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            method2();  <span class="comment">//抛出异常,用try-catch-finally解决</span></span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//method3();//解决后在调用也不报错</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method3</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            method2(); <span class="comment">//抛出异常,用try-catch-finally解决</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> <span class="keyword">throws</span> IOException&#123;<span class="comment">//抛出异常</span></span><br><span class="line">        method1(); <span class="comment">//method1抛出异常,如果在method2不解决可以在向上抛出</span></span><br><span class="line">                    <span class="comment">//，直到被解决才不报错</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException,IOException&#123;  <span class="comment">//可能会抛出的异常类型，抛出                                      //异常</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;hello1.txt&quot;</span>);</span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> fis.read();</span><br><span class="line">        <span class="keyword">while</span>(data != -<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.print((<span class="type">char</span>)data);</span><br><span class="line">            data = fis.read();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fis.close();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;hahaha!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-对比两种处理方式"><a href="#6-对比两种处理方式" class="headerlink" title="6.对比两种处理方式"></a><strong>6</strong>.对比两种处理方式</h4><ol><li>try-catch-finally:真正的将异常给处理掉了。</li><li>throws的方式只是将异常抛给了方法的调用者。并没真正将异常处理掉。</li></ol><h4 id="7-开发中如何选择两种处理方式？"><a href="#7-开发中如何选择两种处理方式？" class="headerlink" title="7.开发中如何选择两种处理方式？"></a>7.开发中如何选择两种处理方式？</h4><ol><li>如果父类中被重写的方法没throws方式处理异常，则子类重写的方法也不能使用throws，意味着如果子类重写的方法中异常，必须使用try-catch-finally方式处理。</li><li>执行的方法a中，先后又调用了另外的几个方法，这几个方法是递进关系执行的。我们建议这几个方法使用throws的方式进行处理。而执行的方法a可以考虑使用try-catch-finally方式进行处理。（也就是都向上抛调用上抛，最后都在一个方法内统一处理）</li></ol><h4 id="8-补充"><a href="#8-补充" class="headerlink" title="8.补充"></a>8.补充</h4><p>方法重写的规则之一：<br>子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型</p><h3 id="7-3手动抛出异常对象"><a href="#7-3手动抛出异常对象" class="headerlink" title="7.3手动抛出异常对象"></a>7.3手动抛出异常对象</h3><h4 id="1-使用说明-1"><a href="#1-使用说明-1" class="headerlink" title="1.使用说明"></a>1.使用说明</h4><p>在程序执行中，除了自动抛出异常对象的情况之外，我们还可以手动的throw一个异常类的对象。</p><h4 id="2-面试题"><a href="#2-面试题" class="headerlink" title="2.面试题"></a>2.面试题</h4><p>throw 和  throws区别：</p><ol><li>throw 表示抛出一个异常类的对象，生成异常对象的过程。声明在方法体内。</li><li>throws 属于异常处理的一种方式，声明在方法的声明处。</li></ol><h4 id="3-典型例题"><a href="#3-典型例题" class="headerlink" title="3.典型例题"></a>3.典型例题</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentTest</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">s.regist(-<span class="number">1001</span>);</span><br><span class="line">System.out.println(s);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="comment">//e.printStackTrace();</span></span><br><span class="line">System.out.println(e.getMessage());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">regist</span><span class="params">(<span class="type">int</span> id)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="keyword">if</span>(id &gt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">this</span>.id = id;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//手动抛出异常对象</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;您输入的数据非法！&quot;</span>);</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;您输入的数据非法！&quot;</span>);</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MyException</span>(<span class="string">&quot;不能输入负数&quot;</span>);</span><br><span class="line"><span class="comment">//这些提示文字最后可以通过getMassage()获取并输出</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;Student [id=&quot;</span> + id + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-4自定义异常类"><a href="#7-4自定义异常类" class="headerlink" title="7.4自定义异常类"></a>7.4自定义异常类</h3><h4 id="1-如何自定义异常类？"><a href="#1-如何自定义异常类？" class="headerlink" title="1.如何自定义异常类？"></a>1.如何自定义异常类？</h4><ol><li>继承于现的异常结构：RuntimeException 、Exception</li><li>提供全局常量：serialVersionUID（相当于一个编号，可以自己写）</li><li>提供重载的构造器</li></ol><h4 id="2-代码演示"><a href="#2-代码演示" class="headerlink" title="2.代码演示"></a>2.代码演示</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">7034897193246939L</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyException</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyException</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、Java概述&quot;&gt;&lt;a href=&quot;#一、Java概述&quot; class=&quot;headerlink&quot; title=&quot;一、Java概述&quot;&gt;&lt;/a&gt;一、Java概述&lt;/h1&gt;&lt;h3 id=&quot;1-1Java通识介绍&quot;&gt;&lt;a href=&quot;#1-1Java通识介绍&quot; class</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>JavaWeb笔记</title>
    <link href="http://example.com/2022/09/30/JavaWeb/"/>
    <id>http://example.com/2022/09/30/JavaWeb/</id>
    <published>2022-09-29T16:00:00.000Z</published>
    <updated>2022-10-05T10:59:13.056Z</updated>
    
    <content type="html"><![CDATA[<h1 id="课程体系设计"><a href="#课程体系设计" class="headerlink" title="课程体系设计"></a>课程体系设计</h1><p><img src="/2022/09/30/JavaWeb/image-20220608183738984.png" alt="image-20220608183738984"></p><h1 id="课件"><a href="#课件" class="headerlink" title="课件"></a>课件</h1><h1 id="前端知识"><a href="#前端知识" class="headerlink" title="前端知识"></a>前端知识</h1><h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><h3 id="HTML中的基础标签"><a href="#HTML中的基础标签" class="headerlink" title="HTML中的基础标签"></a>HTML中的基础标签</h3><ol><li><p>html语言是解释型语言，不是编译型<br>浏览器是容错的</p></li><li><p>html页面中由一对标签组成：<html></html></p><html> 称之为 开始标签</html>称之为 结束标签</li><li><p>title 表示网页的标题</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;title&gt;这是我的第一个网页&lt;/title&gt;</span><br></pre></td></tr></table></figure><p>可以在meta标签中设置编码方式</p><meta charset="UTF-8"><ol start="5"><li><br>表示换行 。br标签是一个单标签。单标签：开始标签和结束标签是同一个，斜杠放在单词后面</li><li>p 表示段落标签</li><li>img 标签图片标签<br>  src属性表示图片文件的路径<br>  width和height表示图片的大小<br>  alt表示图片的提示</li><li>路径的问题：<ol><li>相对路径</li><li>绝对路径</li></ol></li><li>h1~h6 : 标题标签</li><li>列表标签:</li></ol><ul><li><p>ol 有序列表<br>  start 表示从*开始，type 显示的类型：A a I i 1(deafult)</p>  <ol type="a" start="3">              <li>扫地僧</li>              <li>萧远山</li>              <li>慕容博</li>              <li>虚竹</li>              <li>阿紫</li>          </ol>  </li><li><p>ul 无序列表<br>  type disc(default) , circle , square</p>  <ul type="circle">              <li>乔峰</li>              <li>阿朱</li>              <li>马夫人</li>              <li>白世镜</li>          </ul></li></ul><ol start="11"><li><p>u 下划线 b 粗体  i 斜体</p><p>你是<b><i><u>喜欢</u></i></b>是<b>甜</b>月饼还是<i>咸</i><u>月饼</u>？</p></li><li><p>上标 sup   下标 sub</p><p>水分子的化学式： H<sub>2</sub>O<br>    氧气的化学式： O<sup>2</sup></p></li><li><p>HTML中的实体： 小于号 &amp;lt ; 大于等于号 &amp;ge ;  版权 &amp;copy ;</p></li><li><p>span 不换行的块标记</p></li></ol><ol start="15"><li>a 表示超链接</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">href 链接的地址</span><br><span class="line">target:</span><br><span class="line">_self 在本窗口打开</span><br><span class="line">_blank 在一个新窗口打开</span><br><span class="line">_parent 在父窗口打开</span><br><span class="line">_top  在顶层窗口打开</span><br></pre></td></tr></table></figure><ol start="16"><li><p>div  块级标签，会独占一行</p></li><li><p>表格table<br>行tr<br>列td<br>表头列th</p><p>table中有如下属性（虽然已经淘汰，但是最好了解一下）</p><ul><li>border：表格边框的粗细</li><li>width:表格的宽度</li><li>cellspacing：单元格间距</li><li>cellpadding：单元格填充</li></ul><p>tr中有一个属性： align -&gt; center , left , right </p><p>rowspan : 行合并<br>colspan : 列合并</p></li></ol><table border="1" width="600" cellspacing="0" cellpadding="4">            <tr align="center">                <th>姓名</th>                <th>门派</th>                <th>成名绝技</th>                <th>内功值</th>            </tr>            <tr align="center">                <td>乔峰</td>                <td>丐帮</td>                <td>少林长拳</td>                <td>5000</td>            </tr>            <tr align="center">                <td>虚竹</td>                <td>灵鹫宫</td>                <td>北冥神功</td>                <td>15000</td>            </tr>            <tr align="center">                <td>扫地僧</td>                <td>少林寺</td>                <td>七十二绝技</td>                <td>未知</td>            </tr>        </table><table border="1" cellspacing="0" cellpadding="4" width="600">            <tr>                <th>名称</th>                <th>单价</th>                <th>数量</th>                <th>小计</th>                <th>操作</th>            </tr>            <tr align="center">                <td>苹果</td>                <td rowspan="2">5</td>                <td>20</td>                <td>100</td>                <td><img src="/2022/09/30/JavaWeb/Learn_data\javaweb\代码素材资料\Day1-HTML\代码\02.HTML\imgs/del.jpg" width="24" height="24"></td>            </tr>            <tr align="center">                <td>菠萝</td>                <td>15</td>                <td>45</td>                <td><img src="/2022/09/30/JavaWeb/Learn_data\javaweb\代码素材资料\Day1-HTML\代码\02.HTML\imgs/del.jpg" width="24" height="24"></td>            </tr>            <tr align="center">                <td>西瓜</td>                <td>6</td>                <td>6</td>                <td>36</td>                <td><img src="/2022/09/30/JavaWeb/Learn_data\javaweb\代码素材资料\Day1-HTML\代码\02.HTML\imgs/del.jpg" width="24" height="24"></td>            </tr>            <tr align="center">                <td>总计</td>                <td colspan="4">181</td>            </tr>        </table><ol start="18"><li><p>表单form</p><p>action：提交表单的目的地址</p><p>method：发送http使用的方法</p></li></ol><ol start="19"><li><p>input type&#x3D;”text” 表示文本框 ， 其中 name属性必须要指定，否则这个文本框的数据将来是不会发送给服务器的<br>input type&#x3D;”password” 表示密码框<br>input type&#x3D;”radio” 表示单选按钮。需要注意的是，name属性值保持一致，这样才会有互斥的效果;可<strong>以通过checked属性设置默认选中的项</strong></p><blockquote><p>注意：属性名和属性值相同可以只写属性名</p></blockquote><p>input type&#x3D;”checkbox” 表示复选框。name属性值建议保持一致，这样将来我们服务器端获取值的时候获取的是一个数组<br>select 表示下拉列表。每一个选项是option，其中value属性是发送给服务器的值 , <strong>selected表示默认选中的项</strong><br>textarea 表示多行文本框（或者称之为文本域）,它的value值就是开始结束标签之间的内容<br>input type&#x3D;”submit” 表示提交按钮<br>input type&#x3D;”reset” 表示重置按钮<br>input type&#x3D;”button” 表示普通按钮</p></li></ol><form action="demo04.html" method="post">             昵称：<input type="text" value="请输入你的昵称"><br>            密码：<input type="password" name="pwd"><br>            性别：<input type="radio" name="gender" value="male">男        <input type="radio" name="gender" value="female" checked>女<br>            爱好：<input type="checkbox" name="hobby" value="basketball">篮球                  <input type="checkbox" name="hobby" value="football" checked>足球                  <input type="checkbox" name="hobby" value="earth" checked>地球<br>            星座：<select name="star">                    <option value="1">白羊座</option>                    <option value="2" selected>金牛座</option>                    <option value="3">双子座</option>                    <option value="4">天蝎座</option>                    <option value="5">天秤座</option>                  </select><br>            备注：<textarea name="remark" rows="4" cols="50"></textarea><br>            <input type="submit" value=" 注 册 ">            <input type="reset" value="重置">            <input type="button" value="这是一个普通按钮">        </form><ol start="20"><li><p>frameset 表示页面框架 ， 这个标签已经淘汰，了解，不需要掌握<br>frame表示框架中的具体页面引用</p><p>iframe 在一个页面嵌入一个子页面</p></li></ol><h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><h3 id="CSS的语法"><a href="#CSS的语法" class="headerlink" title="CSS的语法"></a>CSS的语法</h3><ol><li><p>为什么需要CSS</p><p>标签样式的太多，一个个写在标签上过于麻烦，冗余。</p></li><li><p>CSS的最基本的分类: 标签样式表、类样式表、ID样式表</p><p>标签样式表–以标签名作为名字</p><p>p{<br>            color:red;<br>        }<br>类样式表—“.”开头，匹配标签中属性class名为f20的</p><p>.f20{<br>            font-size:20px;<br>        }<br>ID样式表—-“#”号开头，匹配标签属性id名为p4的</p><p>#p4{<br>background-color:pink;<br>font-size:24px;<br>font-weight:bolder;<br>font-style:italic;<br>​}</p><blockquote><p>id属性在整个HTML文档中，尽量保持唯一（虽然重复也不会报错）</p></blockquote><p>组合样式—某标签下的子标签</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> <span class="selector-tag">p</span>&#123;</span><br><span class="line"><span class="attribute">color</span>:blue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span> <span class="selector-class">.f32</span>&#123;</span><br><span class="line"><span class="attribute">font-size</span>:<span class="number">32px</span>;</span><br><span class="line"><span class="attribute">font-family</span>:<span class="string">&quot;黑体&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>CSS从位置上的分类：嵌入式样式表、内部样式表、外部样式表</p></li></ol><p>嵌入式样式表—-嵌套在在标签内的样式</p><p><span style="font-size:60px;font-weight:bolder;color:yellow;">HELLO</span></p><p>内部样式表—即写在当前html文件中的</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line"><span class="comment">/* 被style标签包围的范围是CSS环境，可以写CSS代码 */</span></span><br><span class="line"><span class="comment">/* 标签样式表 */</span></span><br><span class="line"><span class="selector-tag">p</span>&#123;</span><br><span class="line"><span class="attribute">color</span>:red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 类样式 */</span></span><br><span class="line"><span class="selector-class">.f20</span>&#123;</span><br><span class="line"><span class="attribute">font-size</span>:<span class="number">20px</span>;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>外部样式表—-引入外部的样式表文件，文件以.css结尾</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 引用外部的CSS样式表文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;css/demo01.css&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h3><p>IE浏览器：实际尺寸 &#x3D; width<br>chrome浏览器：实际尺寸&#x3D; width+左右borderwidth+padding</p><p>CSS盒子模型：<br>1.border 边框</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 1. border 边框样式 */</span></span><br><span class="line"><span class="attribute">border-width</span>:<span class="number">1px</span>;<span class="comment">/*边框粗细*/</span></span><br><span class="line"><span class="attribute">border-style</span>:solid;<span class="comment">/*边框样式：solid(实线) , dotted(点状线) ... */</span></span><br><span class="line"><span class="attribute">border-color</span>:blue;<span class="comment">/*边框颜色*/</span></span><br><span class="line"><span class="comment">/* border:4px double blue;*/</span>  可合并</span><br><span class="line"></span><br><span class="line"><span class="comment">/* border-top : 4px dotted blue;*/</span></span><br></pre></td></tr></table></figure><p>2.margin 间距，是外边距，即盒子与盒子之间的距离</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">margin-top</span>:<span class="number">100px</span>;<span class="comment">/*盒子与盒子之间的距离*/</span></span><br><span class="line"><span class="attribute">margin-left</span>:<span class="number">100px</span>;</span><br><span class="line"><span class="comment">/*margin:100px 100px 50px 150px;*/</span> </span><br></pre></td></tr></table></figure><blockquote><p> 一个值，四个方向统一；两个值：上下、左右；三个值：上、左右、下；四个值：上右下左 </p></blockquote><p>3.padding 填充，是内边距，是盒子的边与盒子内部元素的距离</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* padding : 填充 */</span></span><br><span class="line"><span class="attribute">padding-top</span>:<span class="number">50px</span>;  <span class="comment">/*本标签从顶部边框向内填充*/</span></span><br><span class="line"><span class="attribute">padding-left</span>:<span class="number">50px</span>;</span><br></pre></td></tr></table></figure><blockquote><p>margin是用来隔开元素与元素的间距；padding是用来隔开元素与内容的间隔。margin使元素与元素互不相干；padding让内容（文字）与（包裹）元素之间有一段“呼吸距离”。</p></blockquote><p>补充：浏览器与盒子之间初始时会有微小间隔，可以通过body进行修改</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span>&#123;</span><br><span class="line"><span class="attribute">margin</span>:<span class="number">0</span>;</span><br><span class="line"><span class="attribute">padding</span>:<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CSS布局"><a href="#CSS布局" class="headerlink" title="CSS布局"></a>CSS布局</h3><p>position: absolute – 绝对定位 , 需要配合使用 left , top<br>relative – 相对定位 , 一般会和 float , margin , padding …. 一起使用</p><p>浮动可以理解为让某个div元素脱离标准流，漂浮在标准流之上，和标准流不是⼀个层次。</p><p>float 有left左浮动和right右浮动，默认是none不浮动</p><p><a href="https://wenku.baidu.com/view/f7786fa780d049649b6648d7c1c708a1284a0ada.html">（图文详细）最通俗易懂的CSS浮动float属性详解 - 百度文库 (baidu.com)</a></p><h2 id="javascript"><a href="#javascript" class="headerlink" title="javascript"></a>javascript</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>Javascript : 客户端的一个脚本语言<br>js是一门弱类型的语言 , 变量的数据类型由后面赋的值的类型决定</p><p>有独立标签，javascript代码写入其中</p><script language="javascript"> </script><h3 id="JavaScript数据类型"><a href="#JavaScript数据类型" class="headerlink" title="JavaScript数据类型"></a>JavaScript数据类型</h3><ul><li><p>基本数据类型</p><ul><li><p>数值型：JavaScript不区分整数、小数</p></li><li><p>字符串：JavaScript不区分字符、字符串；单引号、双引号意思一样。</p></li><li><p>布尔型：true、false</p><p>在JavaScript中，其他类型和布尔类型的自动转换。</p><p>true：非零的数值，非空字符串，非空对象</p><p>false：零，空字符串，null，undefined</p><p>例如：”false”放在if判断中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &quot;false&quot;是一个非空字符串，直接放在if判断中会被当作『真』处理</span></span><br><span class="line"><span class="keyword">if</span>(<span class="string">&quot;false&quot;</span>)&#123;</span><br><span class="line"><span class="title function_">alert</span>(<span class="string">&quot;true&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="title function_">alert</span>(<span class="string">&quot;false&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>引用类型</p><ul><li><p>所有new出来的对象</p></li><li><p>用[]声明的数组</p></li><li><p>用{}声明的对象</p><pre><code>var str = &quot;hello world&quot;;  类型名称var匹配任意类型    alert(typeof str);    str= 9999 ;    alert(typeof str);   //typeof str返回类型名称 //alter()警告框var person = new Object();  //    person.pid = &quot;p001&quot;;    person.pname=&quot;鸠摩智&quot;;    alert(person.pid+&quot;_&quot;+person.pname);</code></pre></li></ul></li></ul><h3 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h3><p>相较于java灵活，约束少</p><p>一个函数可以有或没有返回值，取决于写不写，形参和实参没有具体类型和个数限制。从左往右一次赋值</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//java 方法</span><br><span class="line">public String hello(String name)&#123;</span><br><span class="line">return &quot;hello to &quot; + name ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//js 方法</span><br><span class="line">function hello(num1 , num2 , name)&#123;</span><br><span class="line">if(num1&gt;num2)&#123;</span><br><span class="line">return &quot;hello to&quot; + name ;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">alert(&quot;HELLO&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="鼠标悬浮和离开"><a href="#鼠标悬浮和离开" class="headerlink" title="鼠标悬浮和离开"></a>鼠标悬浮和离开</h3><h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><p>在此方法中调用JavaScript方法需要在html标签中显式的调用</p><p>html代码</p><div id="div_container">            <div id="div_fruit_list">                <table id="tbl_fruit">                    <tr>                        <th class="w20">名称</th>                        <th class="w20">单价</th>                        <th class="w20">数量</th>                        <th class="w20">小计</th>                        <th>操作</th>                    </tr>                    <tr onmouseover="showBGColor()" onmouseout="clearBGColor()">                        <td>苹果</td>                        <td onmouseover="showHand()">5</td>                        <td>20</td>                        <td>100</td>                        <td><img src="/2022/09/30/JavaWeb/del.jpg" class="delImg"></td>                    </tr>                    <tr onmouseover="showBGColor()" onmouseout="clearBGColor()">                        <td>西瓜</td>                        <td onmouseover="showHand()">3</td>                        <td>20</td>                        <td>60</td>                        <td><img src="/2022/09/30/JavaWeb/del.jpg" class="delImg"></td>                    </tr>                    <tr onmouseover="showBGColor()" onmouseout="clearBGColor()">                        <td>菠萝</td>                        <td onmouseover="showHand()">4</td>                        <td>25</td>                        <td>100</td>                        <td><img src="/2022/09/30/JavaWeb/del.jpg" class="delImg"></td>                    </tr>                    <tr onmouseover="showBGColor()" onmouseout="clearBGColor()">                        <td>榴莲</td>                        <td onmouseover="showHand()">3</td>                        <td>30</td>                        <td>90</td>                        <td><img src="/2022/09/30/JavaWeb/del.jpg" class="delImg"></td>                    </tr>                    <tr>                        <td>总计</td>                        <td colspan="4">999</td>                    </tr>                </table>            </div>        </div><p>对应javascript代码，在此方法中调用JavaScript方法需要在html标签中显式的调用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当鼠标悬浮时，显示背景颜色</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">showBGColor</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="comment">//event : 当前发生的事件</span></span><br><span class="line"><span class="comment">//event.srcElement : 事件源</span></span><br><span class="line"><span class="comment">//alert(event.srcElement);</span></span><br><span class="line"><span class="comment">//alert(event.srcElement.tagName);--&gt; TD</span></span><br><span class="line"><span class="keyword">if</span>(event &amp;&amp; event.<span class="property">srcElement</span> &amp;&amp; event.<span class="property">srcElement</span>.<span class="property">tagName</span>==<span class="string">&quot;TD&quot;</span>)&#123;</span><br><span class="line"><span class="keyword">var</span> td = event.<span class="property">srcElement</span> ;</span><br><span class="line"><span class="comment">//td.parentElement 表示获取td的父元素 -&gt; TR</span></span><br><span class="line"><span class="keyword">var</span> tr = td.<span class="property">parentElement</span> ;</span><br><span class="line"><span class="comment">//如果想要通过js代码设置某节点的样式，则需要加上 .style</span></span><br><span class="line">tr.<span class="property">style</span>.<span class="property">backgroundColor</span> = <span class="string">&quot;navy&quot;</span> ;</span><br><span class="line"></span><br><span class="line"><span class="comment">//tr.cells表示获取这个tr中的所有的单元格</span></span><br><span class="line"><span class="keyword">var</span> tds = tr.<span class="property">cells</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span> ; i&lt;tds.<span class="property">length</span> ; i++)&#123;</span><br><span class="line">tds[i].<span class="property">style</span>.<span class="property">color</span>=<span class="string">&quot;white&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当鼠标离开时，恢复原始样式</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">clearBGColor</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(event &amp;&amp; event.<span class="property">srcElement</span> &amp;&amp; event.<span class="property">srcElement</span>.<span class="property">tagName</span>==<span class="string">&quot;TD&quot;</span>)&#123;</span><br><span class="line"><span class="keyword">var</span> td = event.<span class="property">srcElement</span> ;</span><br><span class="line"><span class="keyword">var</span> tr = td.<span class="property">parentElement</span> ;</span><br><span class="line">tr.<span class="property">style</span>.<span class="property">backgroundColor</span>=<span class="string">&quot;transparent&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> tds = tr.<span class="property">cells</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span> ; i&lt;tds.<span class="property">length</span> ; i++)&#123;</span><br><span class="line">tds[i].<span class="property">style</span>.<span class="property">color</span>=<span class="string">&quot;threeddarkshadow&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当鼠标悬浮在单价单元格时，显示手势</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">showHand</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(event &amp;&amp; event.<span class="property">srcElement</span> &amp;&amp; event.<span class="property">srcElement</span>.<span class="property">tagName</span>==<span class="string">&quot;TD&quot;</span>)&#123;</span><br><span class="line"><span class="keyword">var</span> td = event.<span class="property">srcElement</span> ;</span><br><span class="line"><span class="comment">//cursor : 光标</span></span><br><span class="line">td.<span class="property">style</span>.<span class="property">cursor</span>=<span class="string">&quot;hand&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><p>此方法无需在html代码标签中显式调用，使代码变得简洁</p><p>html<strong>代码</strong></p><div id="div_container">            <div id="div_fruit_list">                <table id="tbl_fruit">                    <tr>                        <th class="w20">名称</th>                        <th class="w20">单价</th>                        <th class="w20">数量</th>                        <th class="w20">小计</th>                        <th>操作</th>                    </tr>                    <tr>                        <td>苹果</td>                        <td>5</td>                        <td>20</td>                        <td>100</td>                        <td><img src="/2022/09/30/JavaWeb/del.jpg" class="delImg"></td>                    </tr>                    <tr>                        <td>西瓜</td>                        <td>3</td>                        <td>20</td>                        <td>60</td>                        <td><img src="/2022/09/30/JavaWeb/del.jpg" class="delImg"></td>                    </tr>                    <tr>                        <td>菠萝</td>                        <td>4</td>                        <td>25</td>                        <td>100</td>                        <td><img src="/2022/09/30/JavaWeb/del.jpg" class="delImg"></td>                    </tr>                    <tr>                        <td>榴莲</td>                        <td>3</td>                        <td>30</td>                        <td>90</td>                        <td><img src="/2022/09/30/JavaWeb/del.jpg" class="delImg"></td>                    </tr>                    <tr>                        <td>总计</td>                        <td colspan="4">999</td>                    </tr>                </table>            </div>        </div><p>JavaScript<strong>代码</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">onload</span>=<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="comment">//当页面加载完成，我们需要绑定各种事件</span></span><br><span class="line"><span class="comment">//根据id获取到表格</span></span><br><span class="line"><span class="keyword">var</span> fruitTbl =  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;tbl_fruit&quot;</span>);</span><br><span class="line"><span class="comment">//获取表格中的所有的行</span></span><br><span class="line"><span class="keyword">var</span> rows = fruitTbl.<span class="property">rows</span> ;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span> ; i&lt;rows.<span class="property">length</span>-<span class="number">1</span> ; i++)&#123;</span><br><span class="line"><span class="keyword">var</span> tr = rows[i];</span><br><span class="line"><span class="comment">//1.绑定鼠标悬浮以及离开时设置背景颜色事件</span></span><br><span class="line">tr.<span class="property">onmouseover</span>=showBGColor; <span class="comment">//这里调用不用加()</span></span><br><span class="line">tr.<span class="property">onmouseout</span>=clearBGColor;</span><br><span class="line"><span class="comment">//获取tr这一行的所有单元格</span></span><br><span class="line"><span class="keyword">var</span> cells = tr.<span class="property">cells</span>;</span><br><span class="line"><span class="keyword">var</span> priceTD = cells[<span class="number">1</span>]; </span><br><span class="line"><span class="comment">//2.绑定鼠标悬浮在单价单元格变手势的事件</span></span><br><span class="line">priceTD.<span class="property">onmouseover</span> = showHand ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当鼠标悬浮时，显示背景颜色</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">showBGColor</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="comment">//event : 当前发生的事件</span></span><br><span class="line"><span class="comment">//event.srcElement : 事件源</span></span><br><span class="line"><span class="comment">//alert(event.srcElement);</span></span><br><span class="line"><span class="comment">//alert(event.srcElement.tagName);--&gt; TD</span></span><br><span class="line"><span class="keyword">if</span>(event &amp;&amp; event.<span class="property">srcElement</span> &amp;&amp; event.<span class="property">srcElement</span>.<span class="property">tagName</span>==<span class="string">&quot;TD&quot;</span>)&#123;</span><br><span class="line"><span class="keyword">var</span> td = event.<span class="property">srcElement</span> ;</span><br><span class="line"><span class="comment">//td.parentElement 表示获取td的父元素 -&gt; TR</span></span><br><span class="line"><span class="keyword">var</span> tr = td.<span class="property">parentElement</span> ;</span><br><span class="line"><span class="comment">//如果想要通过js代码设置某节点的样式，则需要加上 .style</span></span><br><span class="line">tr.<span class="property">style</span>.<span class="property">backgroundColor</span> = <span class="string">&quot;navy&quot;</span> ;</span><br><span class="line"></span><br><span class="line"><span class="comment">//tr.cells表示获取这个tr中的所有的单元格</span></span><br><span class="line"><span class="keyword">var</span> tds = tr.<span class="property">cells</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span> ; i&lt;tds.<span class="property">length</span> ; i++)&#123;</span><br><span class="line">tds[i].<span class="property">style</span>.<span class="property">color</span>=<span class="string">&quot;white&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当鼠标离开时，恢复原始样式</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">clearBGColor</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(event &amp;&amp; event.<span class="property">srcElement</span> &amp;&amp; event.<span class="property">srcElement</span>.<span class="property">tagName</span>==<span class="string">&quot;TD&quot;</span>)&#123;</span><br><span class="line"><span class="keyword">var</span> td = event.<span class="property">srcElement</span> ;</span><br><span class="line"><span class="keyword">var</span> tr = td.<span class="property">parentElement</span> ;</span><br><span class="line">tr.<span class="property">style</span>.<span class="property">backgroundColor</span>=<span class="string">&quot;transparent&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> tds = tr.<span class="property">cells</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span> ; i&lt;tds.<span class="property">length</span> ; i++)&#123;</span><br><span class="line">tds[i].<span class="property">style</span>.<span class="property">color</span>=<span class="string">&quot;threeddarkshadow&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当鼠标悬浮在单价单元格时，显示手势</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">showHand</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(event &amp;&amp; event.<span class="property">srcElement</span> &amp;&amp; event.<span class="property">srcElement</span>.<span class="property">tagName</span>==<span class="string">&quot;TD&quot;</span>)&#123;</span><br><span class="line"><span class="keyword">var</span> td = event.<span class="property">srcElement</span> ;</span><br><span class="line"><span class="comment">//cursor : 光标</span></span><br><span class="line">td.<span class="property">style</span>.<span class="property">cursor</span>=<span class="string">&quot;hand&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="更新单价-小计-总计"><a href="#更新单价-小计-总计" class="headerlink" title="更新单价-小计-总计"></a>更新单价-小计-总计</h4><p>html代码同上</p><p>JavaScript代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">onload</span>=<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="title function_">updateZJ</span>();</span><br><span class="line"><span class="comment">//当页面加载完成，我们需要绑定各种事件</span></span><br><span class="line"><span class="comment">//根据id获取到表格</span></span><br><span class="line"><span class="keyword">var</span> fruitTbl =  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;tbl_fruit&quot;</span>);</span><br><span class="line"><span class="comment">//获取表格中的所有的行</span></span><br><span class="line"><span class="keyword">var</span> rows = fruitTbl.<span class="property">rows</span> ;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span> ; i&lt;rows.<span class="property">length</span>-<span class="number">1</span> ; i++)&#123;</span><br><span class="line"><span class="keyword">var</span> tr = rows[i];</span><br><span class="line"><span class="comment">//1.绑定鼠标悬浮以及离开时设置背景颜色事件</span></span><br><span class="line">tr.<span class="property">onmouseover</span>=showBGColor;</span><br><span class="line">tr.<span class="property">onmouseout</span>=clearBGColor;</span><br><span class="line"><span class="comment">//获取tr这一行的所有单元格</span></span><br><span class="line"><span class="keyword">var</span> cells = tr.<span class="property">cells</span>;</span><br><span class="line"><span class="keyword">var</span> priceTD = cells[<span class="number">1</span>];</span><br><span class="line"><span class="comment">//2.绑定鼠标悬浮在单价单元格变手势的事件</span></span><br><span class="line">priceTD.<span class="property">onmouseover</span> = showHand ;</span><br><span class="line"><span class="comment">//3.绑定鼠标点击单价单元格的事件</span></span><br><span class="line">priceTD.<span class="property">onclick</span>=editPrice;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当鼠标点击单价单元格时进行价格编辑</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">editPrice</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(event &amp;&amp; event.<span class="property">srcElement</span> &amp;&amp; event.<span class="property">srcElement</span>.<span class="property">tagName</span>==<span class="string">&quot;TD&quot;</span>)&#123;</span><br><span class="line"><span class="keyword">var</span> priceTD = event.<span class="property">srcElement</span> ;</span><br><span class="line"><span class="comment">//目的是判断当前priceTD有子节点，而且第一个子节点是文本节点 ， TextNode对应的是3  ElementNode对应的是1</span></span><br><span class="line"><span class="keyword">if</span>(priceTD.<span class="property">firstChild</span> &amp;&amp; priceTD.<span class="property">firstChild</span>.<span class="property">nodeType</span>==<span class="number">3</span>)&#123;</span><br><span class="line"><span class="comment">//innerText 表示设置或者获取当前节点的内部文本</span></span><br><span class="line"><span class="keyword">var</span> oldPrice = priceTD.<span class="property">innerText</span> ;</span><br><span class="line"><span class="comment">//innerHTML 表示设置当前节点的内部HTML</span></span><br><span class="line">priceTD.<span class="property">innerHTML</span>=<span class="string">&quot;&lt;input type=&#x27;text&#x27; size=&#x27;4&#x27;/&gt;&quot;</span>;</span><br><span class="line"><span class="comment">// &lt;td&gt;&lt;input type=&#x27;text&#x27; size=&#x27;4&#x27;/&gt;&lt;/td&gt;</span></span><br><span class="line"><span class="keyword">var</span> input = priceTD.<span class="property">firstChild</span>;</span><br><span class="line"><span class="keyword">if</span>(input.<span class="property">tagName</span>==<span class="string">&quot;INPUT&quot;</span>)&#123;</span><br><span class="line">input.<span class="property">value</span> = oldPrice ;</span><br><span class="line"><span class="comment">//选中输入框内部的文本</span></span><br><span class="line">input.<span class="title function_">select</span>();</span><br><span class="line"><span class="comment">//4.绑定输入框失去焦点事件 , 失去焦点，更新单价</span></span><br><span class="line">input.<span class="property">onblur</span>=updatePrice ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">updatePrice</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(event &amp;&amp; event.<span class="property">srcElement</span> &amp;&amp; event.<span class="property">srcElement</span>.<span class="property">tagName</span>==<span class="string">&quot;INPUT&quot;</span>)&#123;</span><br><span class="line"><span class="keyword">var</span> input = event.<span class="property">srcElement</span> ;</span><br><span class="line"><span class="keyword">var</span> newPrice = input.<span class="property">value</span> ;</span><br><span class="line"><span class="comment">//input节点的父节点是td</span></span><br><span class="line"><span class="keyword">var</span> priceTD = input.<span class="property">parentElement</span> ;</span><br><span class="line">priceTD.<span class="property">innerText</span> = newPrice ;</span><br><span class="line"></span><br><span class="line"><span class="comment">//更新当前行的小计这一个格子的值</span></span><br><span class="line"><span class="comment">//priceTD.parentElement td的父元素是tr</span></span><br><span class="line"><span class="title function_">updateXJ</span>(priceTD.<span class="property">parentElement</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//更新指定行的小计</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">updateXJ</span>(<span class="params">tr</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(tr &amp;&amp; tr.<span class="property">tagName</span>==<span class="string">&quot;TR&quot;</span>)&#123;</span><br><span class="line"><span class="keyword">var</span> tds = tr.<span class="property">cells</span>;</span><br><span class="line"><span class="keyword">var</span> price = tds[<span class="number">1</span>].<span class="property">innerText</span> ;</span><br><span class="line"><span class="keyword">var</span> count = tds[<span class="number">2</span>].<span class="property">innerText</span> ;</span><br><span class="line"><span class="comment">//innerText获取到的值的类型是字符串类型，因此需要类型转换，才能进行数学运算</span></span><br><span class="line"><span class="keyword">var</span> xj = <span class="built_in">parseInt</span>(price) * <span class="built_in">parseInt</span>(count);</span><br><span class="line">tds[<span class="number">3</span>].<span class="property">innerText</span> = xj ;</span><br><span class="line"></span><br><span class="line"><span class="comment">//更新总计</span></span><br><span class="line"><span class="title function_">updateZJ</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//更新总计</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">updateZJ</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="keyword">var</span> fruitTbl = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;tbl_fruit&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> rows = fruitTbl.<span class="property">rows</span> ;</span><br><span class="line"><span class="keyword">var</span> sum = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>; i&lt;rows.<span class="property">length</span>-<span class="number">1</span> ; i++)&#123;</span><br><span class="line"><span class="keyword">var</span> tr = rows[i];</span><br><span class="line"><span class="keyword">var</span> xj = <span class="built_in">parseInt</span>(tr.<span class="property">cells</span>[<span class="number">3</span>].<span class="property">innerText</span>);<span class="comment">//NaN    not a number 不是一个数字</span></span><br><span class="line">sum = sum + xj ;</span><br><span class="line">&#125;</span><br><span class="line">rows[rows.<span class="property">length</span>-<span class="number">1</span>].<span class="property">cells</span>[<span class="number">1</span>].<span class="property">innerText</span> = sum ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//当鼠标悬浮时，显示背景颜色</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">showBGColor</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="comment">//event : 当前发生的事件</span></span><br><span class="line"><span class="comment">//event.srcElement : 事件源</span></span><br><span class="line"><span class="comment">//alert(event.srcElement);</span></span><br><span class="line"><span class="comment">//alert(event.srcElement.tagName);--&gt; TD</span></span><br><span class="line"><span class="keyword">if</span>(event &amp;&amp; event.<span class="property">srcElement</span> &amp;&amp; event.<span class="property">srcElement</span>.<span class="property">tagName</span>==<span class="string">&quot;TD&quot;</span>)&#123;</span><br><span class="line"><span class="keyword">var</span> td = event.<span class="property">srcElement</span> ;</span><br><span class="line"><span class="comment">//td.parentElement 表示获取td的父元素 -&gt; TR</span></span><br><span class="line"><span class="keyword">var</span> tr = td.<span class="property">parentElement</span> ;</span><br><span class="line"><span class="comment">//如果想要通过js代码设置某节点的样式，则需要加上 .style</span></span><br><span class="line">tr.<span class="property">style</span>.<span class="property">backgroundColor</span> = <span class="string">&quot;navy&quot;</span> ;</span><br><span class="line"></span><br><span class="line"><span class="comment">//tr.cells表示获取这个tr中的所有的单元格</span></span><br><span class="line"><span class="keyword">var</span> tds = tr.<span class="property">cells</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span> ; i&lt;tds.<span class="property">length</span> ; i++)&#123;</span><br><span class="line">tds[i].<span class="property">style</span>.<span class="property">color</span>=<span class="string">&quot;white&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当鼠标离开时，恢复原始样式</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">clearBGColor</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(event &amp;&amp; event.<span class="property">srcElement</span> &amp;&amp; event.<span class="property">srcElement</span>.<span class="property">tagName</span>==<span class="string">&quot;TD&quot;</span>)&#123;</span><br><span class="line"><span class="keyword">var</span> td = event.<span class="property">srcElement</span> ;</span><br><span class="line"><span class="keyword">var</span> tr = td.<span class="property">parentElement</span> ;</span><br><span class="line">tr.<span class="property">style</span>.<span class="property">backgroundColor</span>=<span class="string">&quot;transparent&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> tds = tr.<span class="property">cells</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span> ; i&lt;tds.<span class="property">length</span> ; i++)&#123;</span><br><span class="line">tds[i].<span class="property">style</span>.<span class="property">color</span>=<span class="string">&quot;threeddarkshadow&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当鼠标悬浮在单价单元格时，显示手势</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">showHand</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(event &amp;&amp; event.<span class="property">srcElement</span> &amp;&amp; event.<span class="property">srcElement</span>.<span class="property">tagName</span>==<span class="string">&quot;TD&quot;</span>)&#123;</span><br><span class="line"><span class="keyword">var</span> td = event.<span class="property">srcElement</span> ;</span><br><span class="line"><span class="comment">//cursor : 光标</span></span><br><span class="line">td.<span class="property">style</span>.<span class="property">cursor</span>=<span class="string">&quot;hand&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="删除指定行和控制键盘的输入"><a href="#删除指定行和控制键盘的输入" class="headerlink" title="删除指定行和控制键盘的输入"></a>删除指定行和控制键盘的输入</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">onload</span>=<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="title function_">updateZJ</span>();</span><br><span class="line"><span class="comment">//当页面加载完成，我们需要绑定各种事件</span></span><br><span class="line"><span class="comment">//根据id获取到表格</span></span><br><span class="line"><span class="keyword">var</span> fruitTbl =  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;tbl_fruit&quot;</span>);</span><br><span class="line"><span class="comment">//获取表格中的所有的行</span></span><br><span class="line"><span class="keyword">var</span> rows = fruitTbl.<span class="property">rows</span> ;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span> ; i&lt;rows.<span class="property">length</span>-<span class="number">1</span> ; i++)&#123;</span><br><span class="line"><span class="keyword">var</span> tr = rows[i];</span><br><span class="line"><span class="comment">//1.绑定鼠标悬浮以及离开时设置背景颜色事件</span></span><br><span class="line">tr.<span class="property">onmouseover</span>=showBGColor;</span><br><span class="line">tr.<span class="property">onmouseout</span>=clearBGColor;</span><br><span class="line"><span class="comment">//获取tr这一行的所有单元格</span></span><br><span class="line"><span class="keyword">var</span> cells = tr.<span class="property">cells</span>;</span><br><span class="line"><span class="keyword">var</span> priceTD = cells[<span class="number">1</span>];</span><br><span class="line"><span class="comment">//2.绑定鼠标悬浮在单价单元格变手势的事件</span></span><br><span class="line">priceTD.<span class="property">onmouseover</span> = showHand ;</span><br><span class="line"><span class="comment">//3.绑定鼠标点击单价单元格的事件</span></span><br><span class="line">priceTD.<span class="property">onclick</span>=editPrice;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//7.绑定删除小图标的点击事件</span></span><br><span class="line"><span class="keyword">var</span> img = cells[<span class="number">4</span>].<span class="property">firstChild</span>;</span><br><span class="line"><span class="keyword">if</span>(img &amp;&amp; img.<span class="property">tagName</span>==<span class="string">&quot;IMG&quot;</span>)&#123;</span><br><span class="line"><span class="comment">//绑定单击事件</span></span><br><span class="line">img.<span class="property">onclick</span> = delFruit ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">delFruit</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(event &amp;&amp; event.<span class="property">srcElement</span> &amp;&amp; event.<span class="property">srcElement</span>.<span class="property">tagName</span>==<span class="string">&quot;IMG&quot;</span>)&#123;</span><br><span class="line"><span class="comment">//alert表示弹出一个对话框，只有确定按钮</span></span><br><span class="line"><span class="comment">//confirm表示弹出一个对话框，有确定和取消按钮。当点击确定，返回true，否则返回false</span></span><br><span class="line"><span class="keyword">if</span>(<span class="variable language_">window</span>.<span class="title function_">confirm</span>(<span class="string">&quot;是否确认删除当前库存记录&quot;</span>))&#123;</span><br><span class="line"><span class="keyword">var</span> img = event.<span class="property">srcElement</span> ;</span><br><span class="line"><span class="keyword">var</span> tr = img.<span class="property">parentElement</span>.<span class="property">parentElement</span> ;</span><br><span class="line"><span class="keyword">var</span> fruitTbl = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;tbl_fruit&quot;</span>);</span><br><span class="line">fruitTbl.<span class="title function_">deleteRow</span>(tr.<span class="property">rowIndex</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">updateZJ</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当鼠标点击单价单元格时进行价格编辑</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">editPrice</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(event &amp;&amp; event.<span class="property">srcElement</span> &amp;&amp; event.<span class="property">srcElement</span>.<span class="property">tagName</span>==<span class="string">&quot;TD&quot;</span>)&#123;</span><br><span class="line"><span class="keyword">var</span> priceTD = event.<span class="property">srcElement</span> ;</span><br><span class="line"><span class="comment">//目的是判断当前priceTD有子节点，而且第一个子节点是文本节点 ， TextNode对应的是3  ElementNode对应的是1</span></span><br><span class="line"><span class="keyword">if</span>(priceTD.<span class="property">firstChild</span> &amp;&amp; priceTD.<span class="property">firstChild</span>.<span class="property">nodeType</span>==<span class="number">3</span>)&#123;</span><br><span class="line"><span class="comment">//innerText 表示设置或者获取当前节点的内部文本</span></span><br><span class="line"><span class="keyword">var</span> oldPrice = priceTD.<span class="property">innerText</span> ;</span><br><span class="line"><span class="comment">//innerHTML 表示设置当前节点的内部HTML</span></span><br><span class="line">priceTD.<span class="property">innerHTML</span>=<span class="string">&quot;&lt;input type=&#x27;text&#x27; size=&#x27;4&#x27;/&gt;&quot;</span>;</span><br><span class="line"><span class="comment">// &lt;td&gt;&lt;input type=&#x27;text&#x27; size=&#x27;4&#x27;/&gt;&lt;/td&gt;</span></span><br><span class="line"><span class="keyword">var</span> input = priceTD.<span class="property">firstChild</span>;</span><br><span class="line"><span class="keyword">if</span>(input.<span class="property">tagName</span>==<span class="string">&quot;INPUT&quot;</span>)&#123;</span><br><span class="line">input.<span class="property">value</span> = oldPrice ;</span><br><span class="line"><span class="comment">//选中输入框内部的文本</span></span><br><span class="line">input.<span class="title function_">select</span>();</span><br><span class="line"><span class="comment">//4.绑定输入框失去焦点事件 , 失去焦点，更新单价</span></span><br><span class="line">input.<span class="property">onblur</span>=updatePrice ;</span><br><span class="line"></span><br><span class="line"><span class="comment">//8.在输入框上绑定键盘摁下的事件，此处我需要保证用户输入的是数字</span></span><br><span class="line">input.<span class="property">onkeydown</span>=ckInput;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//检验键盘摁下的值的方法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ckInput</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="keyword">var</span> kc = event.<span class="property">keyCode</span> ;</span><br><span class="line"><span class="comment">// 0 ~ 9 : 48~57</span></span><br><span class="line"><span class="comment">//backspace : 8</span></span><br><span class="line"><span class="comment">//enter : 13</span></span><br><span class="line"><span class="comment">//console.log(kc);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!( ( kc&gt;=<span class="number">48</span> &amp;&amp; kc&lt;=<span class="number">57</span> ) || kc==<span class="number">8</span> || kc==<span class="number">13</span> ))&#123;</span><br><span class="line">event.<span class="property">returnValue</span>=<span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(kc==<span class="number">13</span>)&#123;</span><br><span class="line">event.<span class="property">srcElement</span>.<span class="title function_">blur</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//更新单价的方法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">updatePrice</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(event &amp;&amp; event.<span class="property">srcElement</span> &amp;&amp; event.<span class="property">srcElement</span>.<span class="property">tagName</span>==<span class="string">&quot;INPUT&quot;</span>)&#123;</span><br><span class="line"><span class="keyword">var</span> input = event.<span class="property">srcElement</span> ;</span><br><span class="line"><span class="keyword">var</span> newPrice = input.<span class="property">value</span> ;</span><br><span class="line"><span class="comment">//input节点的父节点是td</span></span><br><span class="line"><span class="keyword">var</span> priceTD = input.<span class="property">parentElement</span> ;</span><br><span class="line">priceTD.<span class="property">innerText</span> = newPrice ;</span><br><span class="line"></span><br><span class="line"><span class="comment">//5. 更新当前行的小计这一个格子的值</span></span><br><span class="line"><span class="comment">//priceTD.parentElement td的父元素是tr</span></span><br><span class="line"><span class="title function_">updateXJ</span>(priceTD.<span class="property">parentElement</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//更新指定行的小计</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">updateXJ</span>(<span class="params">tr</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(tr &amp;&amp; tr.<span class="property">tagName</span>==<span class="string">&quot;TR&quot;</span>)&#123;</span><br><span class="line"><span class="keyword">var</span> tds = tr.<span class="property">cells</span>;</span><br><span class="line"><span class="keyword">var</span> price = tds[<span class="number">1</span>].<span class="property">innerText</span> ;</span><br><span class="line"><span class="keyword">var</span> count = tds[<span class="number">2</span>].<span class="property">innerText</span> ;</span><br><span class="line"><span class="comment">//innerText获取到的值的类型是字符串类型，因此需要类型转换，才能进行数学运算</span></span><br><span class="line"><span class="keyword">var</span> xj = <span class="built_in">parseInt</span>(price) * <span class="built_in">parseInt</span>(count);</span><br><span class="line">tds[<span class="number">3</span>].<span class="property">innerText</span> = xj ;</span><br><span class="line"></span><br><span class="line"><span class="comment">//6. 更新总计</span></span><br><span class="line"><span class="title function_">updateZJ</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//更新总计</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">updateZJ</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="keyword">var</span> fruitTbl = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;tbl_fruit&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> rows = fruitTbl.<span class="property">rows</span> ;</span><br><span class="line"><span class="keyword">var</span> sum = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>; i&lt;rows.<span class="property">length</span>-<span class="number">1</span> ; i++)&#123;</span><br><span class="line"><span class="keyword">var</span> tr = rows[i];</span><br><span class="line"><span class="keyword">var</span> xj = <span class="built_in">parseInt</span>(tr.<span class="property">cells</span>[<span class="number">3</span>].<span class="property">innerText</span>);<span class="comment">//NaN    not a number 不是一个数字</span></span><br><span class="line">sum = sum + xj ;</span><br><span class="line">&#125;</span><br><span class="line">rows[rows.<span class="property">length</span>-<span class="number">1</span>].<span class="property">cells</span>[<span class="number">1</span>].<span class="property">innerText</span> = sum ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//当鼠标悬浮时，显示背景颜色</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">showBGColor</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="comment">//event : 当前发生的事件</span></span><br><span class="line"><span class="comment">//event.srcElement : 事件源</span></span><br><span class="line"><span class="comment">//alert(event.srcElement);</span></span><br><span class="line"><span class="comment">//alert(event.srcElement.tagName);--&gt; TD</span></span><br><span class="line"><span class="keyword">if</span>(event &amp;&amp; event.<span class="property">srcElement</span> &amp;&amp; event.<span class="property">srcElement</span>.<span class="property">tagName</span>==<span class="string">&quot;TD&quot;</span>)&#123;</span><br><span class="line"><span class="keyword">var</span> td = event.<span class="property">srcElement</span> ;</span><br><span class="line"><span class="comment">//td.parentElement 表示获取td的父元素 -&gt; TR</span></span><br><span class="line"><span class="keyword">var</span> tr = td.<span class="property">parentElement</span> ;</span><br><span class="line"><span class="comment">//如果想要通过js代码设置某节点的样式，则需要加上 .style</span></span><br><span class="line">tr.<span class="property">style</span>.<span class="property">backgroundColor</span> = <span class="string">&quot;navy&quot;</span> ;</span><br><span class="line"></span><br><span class="line"><span class="comment">//tr.cells表示获取这个tr中的所有的单元格</span></span><br><span class="line"><span class="keyword">var</span> tds = tr.<span class="property">cells</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span> ; i&lt;tds.<span class="property">length</span> ; i++)&#123;</span><br><span class="line">tds[i].<span class="property">style</span>.<span class="property">color</span>=<span class="string">&quot;white&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当鼠标离开时，恢复原始样式</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">clearBGColor</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(event &amp;&amp; event.<span class="property">srcElement</span> &amp;&amp; event.<span class="property">srcElement</span>.<span class="property">tagName</span>==<span class="string">&quot;TD&quot;</span>)&#123;</span><br><span class="line"><span class="keyword">var</span> td = event.<span class="property">srcElement</span> ;</span><br><span class="line"><span class="keyword">var</span> tr = td.<span class="property">parentElement</span> ;</span><br><span class="line">tr.<span class="property">style</span>.<span class="property">backgroundColor</span>=<span class="string">&quot;transparent&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> tds = tr.<span class="property">cells</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span> ; i&lt;tds.<span class="property">length</span> ; i++)&#123;</span><br><span class="line">tds[i].<span class="property">style</span>.<span class="property">color</span>=<span class="string">&quot;threeddarkshadow&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当鼠标悬浮在单价单元格时，显示手势</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">showHand</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(event &amp;&amp; event.<span class="property">srcElement</span> &amp;&amp; event.<span class="property">srcElement</span>.<span class="property">tagName</span>==<span class="string">&quot;TD&quot;</span>)&#123;</span><br><span class="line"><span class="keyword">var</span> td = event.<span class="property">srcElement</span> ;</span><br><span class="line"><span class="comment">//cursor : 光标</span></span><br><span class="line">td.<span class="property">style</span>.<span class="property">cursor</span>=<span class="string">&quot;hand&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CS和BS的异同点"><a href="#CS和BS的异同点" class="headerlink" title="CS和BS的异同点"></a>CS和BS的异同点</h2><p>CS：客户端服务器架构模式</p><ul><li>优点：充分利用客户端机器的资源，减轻服务器的负荷（一部分安全要求不高的计算任务存储任务放在客户端执行，不需要把所有的计算和存储都在服务端执行，从而能够减轻服务器的压力，也能够减轻网络负荷）</li><li>缺点：需要安装；升级维护成本较高</li></ul><p>BS：浏览器服务器架构模式</p><ul><li>优点：客户端不许需要安装；维护成本较低</li><li>缺点：所有的计算和存储任务都是放在服务器端的，服务器的负荷较重；在服务器计算完成之后把结果在传输给客户端，因此客户端和服务器端会进行非常频繁的数据通信，从而网络负荷较重</li></ul><h2 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h2><h3 id="Tomcat的部署运行"><a href="#Tomcat的部署运行" class="headerlink" title="Tomcat的部署运行"></a>Tomcat的部署运行</h3><p><img src="/2022/09/30/JavaWeb/image-20220619142600475.png" alt="image-20220619142600475"></p><blockquote><p>baidu文件夹作为项目的存放位置</p></blockquote><h3 id="Tomcat部署运行在idea"><a href="#Tomcat部署运行在idea" class="headerlink" title="Tomcat部署运行在idea"></a>Tomcat部署运行在idea</h3><p>先创建一个java工程，在工程下创建一个java模块，再次java模块下添加web应用框架，就此web项目就创建成功</p><p><img src="/2022/09/30/JavaWeb/image-20220619142935124.png" alt="image-20220619142935124"></p><p>创建Tomcat模板</p><p><img src="/2022/09/30/JavaWeb/image-20220619143035494.png" alt="image-20220619143035494"></p><p><img src="/2022/09/30/JavaWeb/image-20220619143223910.png" alt="image-20220619143223910"></p><p>添加Tomcat</p><p><img src="/2022/09/30/JavaWeb/image-20220619143316111.png" alt="image-20220619143316111"></p><blockquote><p>URL是tomcat默认访问地址</p></blockquote><p>注意：</p><p><img src="/2022/09/30/JavaWeb/image-20220702143544183.png" alt="image-20220702143544183"></p><blockquote><p>Application context 地址要与URL中的context地址一致，这表示当前上下文的入口</p></blockquote><h1 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h1><h2 id="1、Servlet概述"><a href="#1、Servlet概述" class="headerlink" title="1、Servlet概述"></a>1、Servlet概述</h2><h3 id="1-Servlet名字"><a href="#1-Servlet名字" class="headerlink" title="1.Servlet名字"></a>1.Servlet名字</h3><p>Servlet&#x3D;Server+applet</p><p>Server：服务器</p><p>applet：小程序</p><p>Servlet含义是服务器端的小程序</p><h3 id="2-Servlet在整个Web应用中起到的作用"><a href="#2-Servlet在整个Web应用中起到的作用" class="headerlink" title="2.Servlet在整个Web应用中起到的作用"></a>2.Servlet在整个Web应用中起到的作用</h3><p><img src="/2022/09/30/JavaWeb/image-20220630195102715.png" alt="image-20220630195102715"></p><p>在整个Web应用中，Servlet主要负责处理请求、协调调度功能。我们可以把Servlet称为Web应用中的<strong>『控制器』</strong></p><h2 id="2、Servlet入门实例"><a href="#2、Servlet入门实例" class="headerlink" title="2、Servlet入门实例"></a>2、Servlet入门实例</h2><p>创建一个javaweb模块</p><p><img src="/2022/09/30/JavaWeb/image-20220630200546258.png" alt="image-20220630200546258"></p><blockquote><p>这里如果不能直接创建Javaweb模块这可以先创建Java模块，后右键模块文件—&gt;点击Add Framework Support 将Web加入到本模块中</p></blockquote><p>创建lib文件在工程下，导入jar包，即导入mysql驱动</p><p><img src="/2022/09/30/JavaWeb/image-20220630200721149.png" alt="image-20220630200721149"></p><blockquote><p>这里是tomcat9.0的，适配MySQL5.1.7，不知道为啥，MySQL8.0驱动不适配</p></blockquote><p>右键lib文件夹–&gt;as a library ，使之加入library</p><p>最上方File —&gt; Project Structure </p><ul><li>在页面框右边Modules，选择对应模块，选择Dependencies依赖，添加刚刚加入mysql驱动到依赖中</li><li>在页面框右边problem，解决出现的问题（将lib加入artifacts）</li></ul><p>编写网页html，表单用来提交发送数据到服务器</p><p><img src="/2022/09/30/JavaWeb/image-20220630202454142.png" alt="image-20220630202454142"></p><p>编写addServlet，获取请求中的数据，编写JDBC将数据保存到数据库</p><p><img src="/2022/09/30/JavaWeb/image-20220630203516754.png" alt="image-20220630203516754"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AddServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">fname</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;fname&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">priceStr</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;price&quot;</span>);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">price</span> <span class="operator">=</span> Integer.parseInt(priceStr);</span><br><span class="line">        <span class="type">String</span> <span class="variable">fcountStr</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;fcount&quot;</span>);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">fcount</span> <span class="operator">=</span> Integer.parseInt(fcountStr);</span><br><span class="line">        <span class="type">String</span> <span class="variable">remark</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;remark&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">FruitDAO</span> <span class="variable">fruitDAO</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FruitDAOImpl</span>();</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> fruitDAO.addFruit(<span class="keyword">new</span> <span class="title class_">Fruit</span>(<span class="number">0</span> , fname , price , fcount , remark));</span><br><span class="line"></span><br><span class="line">        System.out.println(flag ? <span class="string">&quot;添加成功！&quot;</span> : <span class="string">&quot;添加失败！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置xml文件，因为用户将数据发送给add，那我们就得配置，使得服务器能够找到add对应的addServlet类</p><p><img src="/2022/09/30/JavaWeb/image-20220630202751833.png" alt="image-20220630202751833"></p><ol><li>用户发请求，action&#x3D;add</li><li>项目中，web.xml中找到url-pattern &#x3D; &#x2F;add   -&gt; 第12行</li><li>找第11行的servlet-name &#x3D; AddServlet</li><li>找和servlet-mapping中servlet-name一致的servlet ， 找到第7行</li><li>找第8行的servlet-class -&gt; com.atguigu.servlets.AddServlet</li><li>用户发送的是post请求（method&#x3D;post） ， 因此 tomcat会执行AddServlet中的doPost方法</li></ol><p>之后就可以运行tomcat，在出现的表单中填写数据，提交，发送到服务器，servlet进行数据处理之后加入数据库</p><h3 id="设置编码问题"><a href="#设置编码问题" class="headerlink" title="设置编码问题"></a>设置编码问题</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">设置编码</span><br><span class="line">tomcat8之前，设置编码：</span><br><span class="line">  1)get请求方式：</span><br><span class="line">    //get方式目前不需要设置编码（基于tomcat8）</span><br><span class="line">    //如果是get请求发送的中文数据，转码稍微有点麻烦（tomcat8之前）</span><br><span class="line">    String fname = request.getParameter(&quot;fname&quot;);</span><br><span class="line">    //1.将字符串打散成字节数组</span><br><span class="line">    byte[] bytes = fname.getBytes(&quot;ISO-8859-1&quot;);</span><br><span class="line">    //2.将字节数组按照设定的编码重新组装成字符串</span><br><span class="line">    fname = new String(bytes,&quot;UTF-8&quot;);</span><br><span class="line">  2)post请求方式：</span><br><span class="line">    request.setCharacterEncoding(&quot;UTF-8&quot;);</span><br><span class="line">tomcat8开始，设置编码，只需要针对post方式</span><br><span class="line">    request.setCharacterEncoding(&quot;UTF-8&quot;);</span><br><span class="line">注意：</span><br><span class="line">    需要注意的是，设置编码(post)这一句代码必须在所有的获取参数动作之前</span><br></pre></td></tr></table></figure><h2 id="3、Servlet的继承关系及核心方法"><a href="#3、Servlet的继承关系及核心方法" class="headerlink" title="3、Servlet的继承关系及核心方法"></a>3、Servlet的继承关系及核心方法</h2><h3 id="1-Servlet的继承关系"><a href="#1-Servlet的继承关系" class="headerlink" title="1.Servlet的继承关系"></a>1.Servlet的继承关系</h3><p>重点查看的是服务方法（service()）</p><ol><li><p>继承关系<br> javax.servlet.Servlet接口<br>   javax.servlet.GenericServlet抽象类<br>   javax.servlet.http.HttpServlet抽象子类</p></li><li><p>相关方法<br> javax.servlet.Servlet接口:<br> void init(config) - 初始化方法<br> void service(request,response) - 服务方法<br> void destory() - 销毁方法</p></li></ol><p>  javax.servlet.GenericServlet抽象类：<br>    void service(request,response) - 仍然是抽象的</p><p>  javax.servlet.http.HttpServlet 抽象子类：<br>    void service(request,response) - 不是抽象的</p><h3 id="2-service-方法"><a href="#2-service-方法" class="headerlink" title="2.service( )方法"></a>2.service( )方法</h3><ol><li><p>String method &#x3D; req.getMethod(); 获取请求的方式</p><ol><li>各种if判断，根据请求方式不同，决定去调用不同的do方法    <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (method.equals(<span class="string">&quot;GET&quot;</span>)) &#123;</span><br><span class="line">         <span class="built_in">this</span>.doGet(req,resp);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(<span class="string">&quot;HEAD&quot;</span>)) &#123;</span><br><span class="line">         <span class="built_in">this</span>.doHead(req, resp);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(<span class="string">&quot;POST&quot;</span>)) &#123;</span><br><span class="line">         <span class="built_in">this</span>.doPost(req, resp);</span><br><span class="line">         &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(<span class="string">&quot;PUT&quot;</span>)) &#123;</span><br><span class="line">         <span class="built_in">this</span>.doPut(req, resp); </span><br><span class="line">        &#125;  </span><br><span class="line"></span><br><span class="line">​    在HttpServlet这个抽象类中，<span class="keyword">do</span>方法都差不多:</span><br><span class="line">​    ```java</span><br><span class="line">​    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">protocol</span> <span class="operator">=</span> req.getProtocol();</span><br><span class="line">​    <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> lStrings.getString(<span class="string">&quot;http.method_get_not_supported&quot;</span>);</span><br><span class="line">​    <span class="keyword">if</span> (protocol.endsWith(<span class="string">&quot;1.1&quot;</span>)) &#123;</span><br><span class="line">​     resp.sendError(<span class="number">405</span>, msg);</span><br><span class="line">​    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">​     resp.sendError(<span class="number">400</span>, msg);</span><br><span class="line">​    &#125;</span><br><span class="line">​     &#125;</span><br><span class="line">​    ```</span><br><span class="line"></span><br><span class="line">&gt;  HttpServlet中这些<span class="keyword">do</span>方法默认都是<span class="number">405</span>的实现风格-要我们子类去实现对应的方法，否则默认会报<span class="number">405</span>错误</span><br><span class="line"></span><br><span class="line">### <span class="number">3.</span>小结</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>) 继承关系： HttpServlet -&gt; GenericServlet -&gt; Servlet</span><br><span class="line"><span class="number">2</span>) Servlet中的核心方法： init() , service() , destroy()</span><br><span class="line"><span class="number">3</span>) 服务方法： 当有请求过来时，service方法会自动响应（其实是tomcat容器调用的）</span><br><span class="line">        在HttpServlet中我们会去分析请求的方式：到底是get、post、head还是delete等等</span><br><span class="line">        然后再决定调用的是哪个<span class="keyword">do</span>开头的方法</span><br><span class="line">        那么在HttpServlet中这些<span class="keyword">do</span>方法默认都是<span class="number">405</span>的实现风格-要我们子类去实现对应的方法，否则默认会报<span class="number">405</span>错误</span><br><span class="line"><span class="number">4</span>) 因此，我们在新建Servlet时，我们才会去考虑请求方法，从而决定重写哪个<span class="keyword">do</span>方法</span><br><span class="line"></span><br><span class="line">## <span class="number">4</span>、Servlet的生命周期</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>） 生命周期：从出生到死亡的过程就是生命周期。对应Servlet中的三个方法：init(),service(),destroy()</span><br><span class="line"><span class="number">2</span>） 默认情况下：</span><br><span class="line">    第一次接收请求时，这个Servlet会进行实例化(调用构造方法)、初始化(调用init())、然后服务(调用service())</span><br><span class="line">    从第二次请求开始，每一次都是服务</span><br><span class="line">    当容器关闭时，其中的所有的servlet实例会被销毁，调用销毁方法</span><br><span class="line"><span class="number">3</span>） 通过案例我们发现：</span><br><span class="line"></span><br><span class="line">- **Servlet实例tomcat只会创建一个，所有的请求都是这个实例去响应。**</span><br><span class="line">    - 默认情况下，第一次请求时，tomcat才会去实例化，初始化，然后再服务</span><br><span class="line">      * 这样的好处是什么？ 提高系统的启动速度  </span><br><span class="line">      * 这样的缺点是什么？ 第一次请求时，耗时较长。</span><br><span class="line">    - 因此得出结论：如果需要提高响应速度，我们应该设置Servlet的初始化时机。</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>） Servlet的初始化时机：</span><br><span class="line"></span><br><span class="line">- 默认是第一次接收请求时，实例化，初始化</span><br><span class="line">- 我们可以通过&lt;load-on-startup&gt;来设置servlet启动的先后顺序,数字越小，启动越靠前，最小值<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="number">5</span>） Servlet在容器中是：单例的、线程不安全的</span><br><span class="line"></span><br><span class="line">- 单例：所有的请求都是同一个实例去响应</span><br><span class="line"></span><br><span class="line">- 线程不安全：一个线程需要根据这个实例中的某个成员变量值去做逻辑判断。但是在中间某个时机，另一个线程改变了这个成员变量的值，从而导致第一个线程的执行路径发生了变化</span><br><span class="line"></span><br><span class="line">- 我们已经知道了servlet是线程不安全的</span><br><span class="line"></span><br><span class="line">  * 给我们的启发是： 尽量的不要在servlet中定义成员变量。</span><br><span class="line"></span><br><span class="line">  * 如果不得不定义成员变量，那么不要去：</span><br><span class="line"></span><br><span class="line">    ①不要去修改成员变量的值</span><br><span class="line"></span><br><span class="line">    ②不要去根据成员变量的值做一些逻辑判断</span><br><span class="line"></span><br><span class="line">线程不安全图示：</span><br><span class="line"></span><br><span class="line">![image-<span class="number">20220701202330023</span>](JavaWeb/image-<span class="number">20220701202330023.</span>png)</span><br><span class="line"></span><br><span class="line">## <span class="number">5</span>、Http协议</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>） Http 称之为 超文本传输协议</span><br><span class="line"><span class="number">2</span>） Http是无状态的</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>） Http请求响应包含两个部分：请求和响应</span><br><span class="line"></span><br><span class="line">  - 请求：</span><br><span class="line">    请求包含三个部分：</span><br><span class="line">    * <span class="number">1.</span>请求行 ； </span><br><span class="line">    * <span class="number">2.</span>请求消息头 </span><br><span class="line">    * <span class="number">3.</span>请求主体</span><br><span class="line"></span><br><span class="line">  - <span class="number">1</span>)请求行包含是三个信息：</span><br><span class="line">    * <span class="number">1.</span>请求的方式 ； </span><br><span class="line">    * <span class="number">2.</span>请求的URL ； </span><br><span class="line">    * <span class="number">3.</span>请求的协议（一般都是HTTP1<span class="number">.1</span>）</span><br><span class="line">  - <span class="number">2</span>)请求消息头中包含了很多客户端需要告诉服务器的信息，比如：我的浏览器型号、版本、我能接收的内容的类型、我给你发的内容的类型、内容的长度等等</span><br><span class="line">  - <span class="number">3</span>)请求体，三种情况</span><br><span class="line">    * get方式，没有请求体，但是有一个queryString</span><br><span class="line">    * post方式，有请求体，form data</span><br><span class="line">    * json格式，有请求体，request payload</span><br><span class="line">  - 响应：</span><br><span class="line">    响应也包含三种： <span class="number">1.</span> 响应行 ； <span class="number">2.</span>响应头 ； <span class="number">3.</span>响应体</span><br><span class="line">    * <span class="number">1</span>)响应行包含三个信息：</span><br><span class="line">      * <span class="number">1.</span>协议 </span><br><span class="line">      * <span class="number">2.</span>响应状态码(<span class="number">200</span>) </span><br><span class="line">      * <span class="number">3.</span>响应状态(ok)</span><br><span class="line">    * <span class="number">2</span>)响应头：包含了服务器的信息；服务器发送给浏览器的信息（内容的媒体类型、编码、内容长度等）</span><br><span class="line">    * <span class="number">3</span>)响应体：响应的实际内容（比如请求add.html页面时，响应的内容就是&lt;html&gt;&lt;head&gt;&lt;body&gt;&lt;form....）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## <span class="number">6</span>、会话</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>） Http是无状态的</span><br><span class="line">    - HTTP 无状态 ：服务器无法判断这两次请求是同一个客户端发过来的，还是不同的客户端发过来的</span><br><span class="line">        - 无状态带来的现实问题：第一次请求是添加商品到购物车，第二次请求是结账；如果这两次请求服务器无法区分是同一个用户的，那么就会导致混乱</span><br><span class="line">        - 通过会话跟踪技术来解决无状态的问题。</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>） 会话跟踪技术</span><br><span class="line"></span><br><span class="line">    - 客户端第一次发请求给服务器，服务器获取session，获取不到，则创建新的，然后响应给客户端</span><br><span class="line">        - 下次客户端给服务器发请求时，会把sessionID带给服务器，那么服务器就能获取到了，那么服务器就判断这一次请求和上次某次请求是同一个客户端，从而能够区分开客户端</span><br><span class="line">        - 常用的API：</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">request.getSession() -&gt; 获取当前的会话，没有则创建一个新的会话</span><br><span class="line">request.getSession(<span class="literal">true</span>) -&gt; 效果和不带参数相同</span><br><span class="line">request.getSession(<span class="literal">false</span>) -&gt; 获取当前会话，没有则返回<span class="literal">null</span>，不会创建新的</span><br><span class="line">session.getId() -&gt; 获取sessionID</span><br><span class="line">session.isNew() -&gt; 判断当前session是否是新的</span><br><span class="line">session.getMaxInactiveInterval() -&gt; session的非激活间隔时长，默认<span class="number">1800</span>秒</span><br><span class="line">session.setMaxInactiveInterval()</span><br><span class="line">session.invalidate() -&gt; 强制性让会话立即失效</span><br><span class="line">  ....</span><br></pre></td></tr></table></figure></li></ol></li></ol><p>会话图示：</p><p><img src="/2022/09/30/JavaWeb/image-20220701202434538.png" alt="image-20220701202434538"></p><p>3） session保存作用域</p><ul><li>session保存作用域是和具体的某一个session对应的，设置他的专属属性</li><li>常用的API：<br>void session.setAttribute(k,v)<br>Object session.getAttribute(k)<br>void removeAttribute(k)</li></ul><h2 id="7、服务器内部转发以及客户端重定向"><a href="#7、服务器内部转发以及客户端重定向" class="headerlink" title="7、服务器内部转发以及客户端重定向"></a>7、服务器内部转发以及客户端重定向</h2><p>1） 服务器内部转发 : request.getRequestDispatcher(“…”).forward(request,response);</p><ul><li>一次请求响应的过程，对于客户端而言，内部经过了多少次转发，客户端是不知道的</li><li>地址栏访问地址没有变化</li></ul><p>图示：</p><p><img src="/2022/09/30/JavaWeb/image-20220701204547620.png" alt="image-20220701204547620"></p><p>2）客户端重定向： response.sendRedirect(“….”);</p><ul><li>两次请求响应的过程。客户端肯定知道请求URL有变化</li><li>地址栏访问地址有变化</li></ul><p>图示：</p><p><img src="/2022/09/30/JavaWeb/image-20220701204618860.png" alt="image-20220701204618860"></p><h2 id="8、Thymeleaf-视图模板技术"><a href="#8、Thymeleaf-视图模板技术" class="headerlink" title="8、Thymeleaf - 视图模板技术"></a>8、Thymeleaf - 视图模板技术</h2><p>过程图示：</p><p><img src="/2022/09/30/JavaWeb/image-20220702132830048.png" alt="image-20220702132830048"></p><p>Thymeleaf中提供processTemplate( )方法将数据渲染到html页面</p><ol><li>添加thymeleaf的jar包</li></ol><p><img src="/2022/09/30/JavaWeb/image-20220702130459879.png" alt="image-20220702130459879"></p><ol start="2"><li><p>在web.xml文件中添加配置</p><ul><li>配置前缀 view-prefix</li><li>配置后缀 view-suffix</li></ul></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置上下文参数 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>view-prefix<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>/<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>view-suffix<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>.html<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li><p>新建一个Servlet类ViewBaseServlet，本质上是搭建Thymeleaf所需的环境</p><p>ViewBaseServlet继承是HttpServlet</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ViewBaseServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> TemplateEngine templateEngine;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">        <span class="comment">// 1.获取ServletContext对象</span></span><br><span class="line">        <span class="type">ServletContext</span> <span class="variable">servletContext</span> <span class="operator">=</span> <span class="built_in">this</span>.getServletContext();</span><br><span class="line">        <span class="comment">// 2.创建Thymeleaf解析器对象</span></span><br><span class="line">        <span class="type">ServletContextTemplateResolver</span> <span class="variable">templateResolver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServletContextTemplateResolver</span>(servletContext);</span><br><span class="line">        <span class="comment">// 3.给解析器对象设置参数</span></span><br><span class="line">        <span class="comment">// ①HTML是默认模式，明确设置是为了代码更容易理解</span></span><br><span class="line">        templateResolver.setTemplateMode(TemplateMode.HTML);</span><br><span class="line">        <span class="comment">// ②设置前缀</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">viewPrefix</span> <span class="operator">=</span> servletContext.getInitParameter(<span class="string">&quot;view-prefix&quot;</span>);</span><br><span class="line">        templateResolver.setPrefix(viewPrefix);</span><br><span class="line">        <span class="comment">// ③设置后缀</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">viewSuffix</span> <span class="operator">=</span> servletContext.getInitParameter(<span class="string">&quot;view-suffix&quot;</span>);</span><br><span class="line">        templateResolver.setSuffix(viewSuffix);</span><br><span class="line">        <span class="comment">// ④设置缓存过期时间（毫秒）</span></span><br><span class="line">        templateResolver.setCacheTTLMs(<span class="number">60000L</span>);</span><br><span class="line">        <span class="comment">// ⑤设置是否缓存</span></span><br><span class="line">        templateResolver.setCacheable(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">// ⑥设置服务器端编码方式</span></span><br><span class="line">        templateResolver.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        <span class="comment">// 4.创建模板引擎对象</span></span><br><span class="line">        templateEngine = <span class="keyword">new</span> <span class="title class_">TemplateEngine</span>();</span><br><span class="line">        <span class="comment">// 5.给模板引擎对象设置模板解析器</span></span><br><span class="line">        templateEngine.setTemplateResolver(templateResolver);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">processTemplate</span><span class="params">(String templateName, HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 1.设置响应体内容类型和字符集</span></span><br><span class="line">        resp.setContentType(<span class="string">&quot;text/html;charset=UTF-8&quot;</span>);</span><br><span class="line">        <span class="comment">// 2.创建WebContext对象</span></span><br><span class="line">        <span class="type">WebContext</span> <span class="variable">webContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WebContext</span>(req, resp, getServletContext());</span><br><span class="line">        <span class="comment">// 3.处理模板数据</span></span><br><span class="line">        templateEngine.process(templateName, webContext, resp.getWriter());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使得我们的Servlet继承ViewBaseServlet</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Servlet从3.0版本开始支持注解方式的注册，无需在xml文件中配置index与IndexServlet对应信息</span></span><br><span class="line"><span class="meta">@WebServlet(&quot;/index&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IndexServlet</span> <span class="keyword">extends</span> <span class="title class_">ViewBaseServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request , HttpServletResponse response)</span><span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        <span class="type">FruitDAO</span> <span class="variable">fruitDAO</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FruitDAOImpl</span>();</span><br><span class="line">        List&lt;Fruit&gt; fruitList = fruitDAO.getFruitList();</span><br><span class="line">        <span class="comment">//保存到session作用域</span></span><br><span class="line">        <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession() ;</span><br><span class="line">        session.setAttribute(<span class="string">&quot;fruitList&quot;</span>,fruitList);</span><br><span class="line">        <span class="comment">//此处的视图名称是 index</span></span><br><span class="line">        <span class="comment">//那么thymeleaf会将这个 逻辑视图名称 对应到 物理视图 名称上去</span></span><br><span class="line">        <span class="comment">//逻辑视图名称 ：   index</span></span><br><span class="line">        <span class="comment">//物理视图名称 ：   view-prefix + 逻辑视图名称 + view-suffix</span></span><br><span class="line">        <span class="comment">//所以真实的视图名称是：      /       index       .html</span></span><br><span class="line">        <span class="built_in">super</span>.processTemplate(<span class="string">&quot;index&quot;</span>,request,response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><blockquote><p>根据逻辑视图名称 得到 物理视图名称<br>此处的视图名称是 index<br>那么thymeleaf会将这个 逻辑视图名称 对应到 物理视图 名称上去<br>逻辑视图名称 ：   index<br>物理视图名称 ：   view-prefix + 逻辑视图名称 + view-suffix<br>所以真实的视图名称是：      &#x2F;       index       .html<br>super.processTemplate(“index”,request,response);</p></blockquote></li><li><p>使用thymeleaf的标签<br>  th:if   ,  th:unless   , th:each   ,   th:text</p></li><li><p>index.html水果库存页面</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;css/index.css&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;div_container&quot;</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;div_fruit_list&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;center f30&quot;</span>&gt;</span>欢迎使用水果库存后台管理系统<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">table</span> <span class="attr">id</span>=<span class="string">&quot;tbl_fruit&quot;</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">th</span> <span class="attr">class</span>=<span class="string">&quot;w20&quot;</span>&gt;</span>名称<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">th</span> <span class="attr">class</span>=<span class="string">&quot;w20&quot;</span>&gt;</span>单价<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">th</span> <span class="attr">class</span>=<span class="string">&quot;w20&quot;</span>&gt;</span>库存<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">th</span>&gt;</span>操作<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">tr</span> <span class="attr">th:if</span>=<span class="string">&quot;$&#123;#lists.isEmpty(session.fruitList)&#125;&quot;</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">td</span> <span class="attr">colspan</span>=<span class="string">&quot;4&quot;</span>&gt;</span>对不起，库存为空！<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">tr</span> <span class="attr">th:unless</span>=<span class="string">&quot;$&#123;#lists.isEmpty(session.fruitList)&#125;&quot;</span> <span class="attr">th:each</span>=<span class="string">&quot;fruit : $&#123;session.fruitList&#125;&quot;</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;fruit.fname&#125;&quot;</span>&gt;</span>苹果<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;fruit.price&#125;&quot;</span>&gt;</span>5<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;fruit.fcount&#125;&quot;</span>&gt;</span>20<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;imgs/del.jpg&quot;</span> <span class="attr">class</span>=<span class="string">&quot;delImg&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>操作注意：</p></li></ol><img src="/2022/09/30/JavaWeb/image-20220702132012777.png" alt="image-20220702132012777" style="zoom:67%;"><blockquote><p>URL：默认地址index后不加 .html</p></blockquote><p>&#x2F;&#x2F; 200 : 正常响应<br>&#x2F;&#x2F; 404 : 找不到资源<br>&#x2F;&#x2F; 405 : 请求方式不支持<br>&#x2F;&#x2F; 500 : 服务器内部错误</p><h2 id="9、保存作用域"><a href="#9、保存作用域" class="headerlink" title="9、保存作用域"></a>9、保存作用域</h2><p>原始情况下，保存作用域我们可以认为有四个： </p><ul><li>page（页面级别，现在几乎不用） </li><li>request（一次请求响应范围） </li><li>session（一次会话范围） </li><li>application（整个应用程序范围）</li></ul><p> 1） request：一次请求响应范围</p><p><img src="/2022/09/30/JavaWeb/image-20220702140400146.png" alt="image-20220702140400146"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//演示request保存作用域（demo01和demo02）</span></span><br><span class="line"><span class="meta">@WebServlet(&quot;/demo01&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01Servlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//1.向request保存作用域保存数据</span></span><br><span class="line">        request.setAttribute(<span class="string">&quot;uname&quot;</span>,<span class="string">&quot;lili&quot;</span>);</span><br><span class="line">        <span class="comment">//2.客户端重定向</span></span><br><span class="line">        <span class="comment">//response.sendRedirect(&quot;demo02&quot;); 不可以</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.服务器端转发</span></span><br><span class="line">        request.getRequestDispatcher(<span class="string">&quot;demo02&quot;</span>).forward(request,response);  <span class="comment">//相当于一次请求</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet(&quot;/demo02&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo02Servlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//1.获取request保存作用域保存的数据，key为uname</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">unameObj</span> <span class="operator">=</span> request.getAttribute(<span class="string">&quot;uname&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;unameObj = &quot;</span> + unameObj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 2） session：一次会话范围有效</p><p><img src="/2022/09/30/JavaWeb/image-20220702140443309.png" alt="image-20220702140443309"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//演示session保存作用域（demo03和demo04）</span></span><br><span class="line"><span class="meta">@WebServlet(&quot;/demo03&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo03Servlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//1.向session保存作用域保存数据</span></span><br><span class="line">        request.getSession().setAttribute(<span class="string">&quot;uname&quot;</span>,<span class="string">&quot;lili&quot;</span>);</span><br><span class="line">        <span class="comment">//2.客户端重定向</span></span><br><span class="line">        response.sendRedirect(<span class="string">&quot;demo04&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.服务器端转发</span></span><br><span class="line">        <span class="comment">//request.getRequestDispatcher(&quot;demo04&quot;).forward(request,response);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet(&quot;/demo04&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo04Servlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//1.获取session保存作用域保存的数据，key为uname</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">unameObj</span> <span class="operator">=</span> request.getSession().getAttribute(<span class="string">&quot;uname&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;unameObj = &quot;</span> + unameObj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 3） application： 一次应用程序范围有效</p><p><img src="/2022/09/30/JavaWeb/image-20220702140505247.png" alt="image-20220702140505247"></p><h2 id="10、路径问题"><a href="#10、路径问题" class="headerlink" title="10、路径问题"></a>10、路径问题</h2><p><img src="/2022/09/30/JavaWeb/image-20220702184941299.png" alt="image-20220702184941299"></p><p>. .  表示返回上一级</p><h1 id="水果系统项目"><a href="#水果系统项目" class="headerlink" title="水果系统项目"></a>水果系统项目</h1><h2 id="水果系统"><a href="#水果系统" class="headerlink" title="水果系统"></a>水果系统</h2><h3 id="1-建立数据库和表"><a href="#1-建立数据库和表" class="headerlink" title="1.建立数据库和表"></a>1.建立数据库和表</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t_fruit(</span><br><span class="line">fid <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT <span class="keyword">PRIMARY</span> KEY,  #自增fid语句</span><br><span class="line">fname <span class="type">VARCHAR</span>(<span class="number">15</span>) <span class="keyword">NULL</span>,</span><br><span class="line">price <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">fcount <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">remark <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NULL</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> t_fruit;  #删除表语句</span><br></pre></td></tr></table></figure><h3 id="2-创建JavaWbe项目模块"><a href="#2-创建JavaWbe项目模块" class="headerlink" title="2.创建JavaWbe项目模块"></a>2.创建JavaWbe项目模块</h3><ul><li>创建JavaWeb模块</li><li>将MySQL驱动lib依赖添加新模块中</li><li>将thyemleaf jar包依赖添加到新模块中</li><li>将新模块加入Tomcat中，并加入Tomcat依赖添加新模块中</li><li>在web.xml中，配置前缀和后缀，用于thyemleaf的逻辑地址转换为物理地址</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>view-prefix<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>/<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>view-suffix<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>.html<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3、主索引index页面"><a href="#3、主索引index页面" class="headerlink" title="3、主索引index页面"></a>3、主索引index页面</h3><h4 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h4><ul><li>按5条库存记录展示在页面中</li><li>添加库存记录功能，跳转至add.html</li><li>首页、上一页、下一页、尾页功能，每页5条库存记录</li></ul><h4 id="1）编写index-html页面"><a href="#1）编写index-html页面" class="headerlink" title="1）编写index.html页面"></a>1）编写index.html页面</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;css/index.css&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">script</span> <span class="attr">language</span>=<span class="string">&quot;JavaScript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;js/index.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;div_container&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;div_fruit_list&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;center f30&quot;</span>&gt;</span>欢迎使用水果库存后台管理系统<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;border:0px solid red;width:60%;margin-left:20%;text-align:right;&quot;</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/add.html&#125;&quot;</span> <span class="attr">style</span>=<span class="string">&quot;border:0px solid blue;margin-bottom:4px;&quot;</span>&gt;</span>添加新库存记录<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">table</span> <span class="attr">id</span>=<span class="string">&quot;tbl_fruit&quot;</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span> <span class="attr">class</span>=<span class="string">&quot;w20&quot;</span>&gt;</span>名称1<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span> <span class="attr">class</span>=<span class="string">&quot;w20&quot;</span>&gt;</span>单价<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span> <span class="attr">class</span>=<span class="string">&quot;w20&quot;</span>&gt;</span>库存<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>操作<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">tr</span> <span class="attr">th:if</span>=<span class="string">&quot;$&#123;#lists.isEmpty(session.fruitList)&#125;&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">colspan</span>=<span class="string">&quot;4&quot;</span>&gt;</span>对不起，库存为空！<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">tr</span> <span class="attr">th:unless</span>=<span class="string">&quot;$&#123;#lists.isEmpty(session.fruitList)&#125;&quot;</span> <span class="attr">th:each</span>=<span class="string">&quot;fruit : $&#123;session.fruitList&#125;&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- &lt;td&gt;&lt;a th:text=&quot;$&#123;fruit.fname&#125;&quot; th:href=&quot;@&#123;&#x27;/edit.do?fid=&#x27;+$&#123;fruit.fid&#125;&#125;&quot;&gt;苹果&lt;/a&gt;&lt;/td&gt; --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;fruit.fname&#125;&quot;</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/edit.do(fid=$&#123;fruit.fid&#125;)&#125;&quot;</span>&gt;</span>苹果<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;fruit.price&#125;&quot;</span>&gt;</span>5<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;fruit.fcount&#125;&quot;</span>&gt;</span>20<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- &lt;td&gt;&lt;img src=&quot;imgs/del.jpg&quot; class=&quot;delImg&quot; th:onclick=&quot;&#x27;delFruit(&#x27;+$&#123;fruit.fid&#125;+&#x27;)&#x27;&quot;/&gt;&lt;/td&gt; --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;imgs/del.jpg&quot;</span> <span class="attr">class</span>=<span class="string">&quot;delImg&quot;</span> <span class="attr">th:onclick</span>=<span class="string">&quot;|delFruit($&#123;fruit.fid&#125;)|&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;width:60%;margin-left:20%;border:0px solid red;padding-top:4px;&quot;</span> <span class="attr">class</span>=<span class="string">&quot;center&quot;</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;首  页1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn&quot;</span> <span class="attr">th:onclick</span>=<span class="string">&quot;|page(1)|&quot;</span> <span class="attr">th:disabled</span>=<span class="string">&quot;$&#123;session.pageNo==1&#125;&quot;</span>/&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;上一页&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn&quot;</span> <span class="attr">th:onclick</span>=<span class="string">&quot;|page($&#123;session.pageNo-1&#125;)|&quot;</span> <span class="attr">th:disabled</span>=<span class="string">&quot;$&#123;session.pageNo==1&#125;&quot;</span>/&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;下一页&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn&quot;</span> <span class="attr">th:onclick</span>=<span class="string">&quot;|page($&#123;session.pageNo+1&#125;)|&quot;</span> <span class="attr">th:disabled</span>=<span class="string">&quot;$&#123;session.pageNo==session.pageCount&#125;&quot;</span>/&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;尾  页&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn&quot;</span> <span class="attr">th:onclick</span>=<span class="string">&quot;|page($&#123;session.pageCount&#125;)|&quot;</span> <span class="attr">th:disabled</span>=<span class="string">&quot;$&#123;session.pageNo==session.pageCount&#125;&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2）编写index-css"><a href="#2）编写index-css" class="headerlink" title="2）编写index.css"></a>2）编写index.css</h4><p>略</p><h4 id="3）编写index-js"><a href="#3）编写index-js" class="headerlink" title="3）编写index.js"></a>3）编写index.js</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">delFruit</span>(<span class="params">fid</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="title function_">confirm</span>(<span class="string">&#x27;是否确认删除？&#x27;</span>))&#123;</span><br><span class="line">        <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">href</span>=<span class="string">&#x27;del.do?fid=&#x27;</span>+fid; </span><br><span class="line">        <span class="comment">//当前窗口地址+加上del.do?fid=fid ,即传输一个参数给del.do</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">page</span>(<span class="params">pageNo</span>)&#123;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">href</span>=<span class="string">&quot;index?pageNo=&quot;</span>+pageNo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4）编写indexServlet"><a href="#4）编写indexServlet" class="headerlink" title="4）编写indexServlet"></a>4）编写indexServlet</h4><p>在FruitDAO接口中添加方法，在FruitDAOImpl实现类中重写此方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Fruit&gt; <span class="title function_">getFruitList</span><span class="params">(Integer pageNo)</span> &#123; <span class="comment">//按一页5条数据的返回</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.executeQuery(<span class="string">&quot;select * from t_fruit limit ?, 5&quot;</span> ,(pageNo-<span class="number">1</span>)*<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getFruitCount</span><span class="params">()</span> &#123;  <span class="comment">//查询总记录条数</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select count(*) from t_fruit&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> ((Long)<span class="built_in">super</span>.executeComplexQuery(sql)[<span class="number">0</span>]).intValue();</span><br><span class="line">        <span class="comment">//executeComplexQuery返回的是一个Object[] ,数值为long类型，不能直接转成int类型，所以先转成Long引用类型之后在用intValue()转为int类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后在编写indexServlet</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Servlet从3.0版本开始支持注解方式的注册</span></span><br><span class="line"><span class="meta">@WebServlet(&quot;/index&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IndexServlet</span> <span class="keyword">extends</span> <span class="title class_">ViewBaseServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request , HttpServletResponse response)</span><span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">pageNo</span> <span class="operator">=</span> <span class="number">1</span> ;</span><br><span class="line">        <span class="type">String</span> <span class="variable">pageNoStr</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;pageNo&quot;</span>);  <span class="comment">//js返回的页</span></span><br><span class="line">        <span class="keyword">if</span>(StringUtil.isNotEmpty(pageNoStr))&#123;</span><br><span class="line">            pageNo = Integer.parseInt(pageNoStr);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession() ;</span><br><span class="line">        session.setAttribute(<span class="string">&quot;pageNo&quot;</span>,pageNo);</span><br><span class="line"></span><br><span class="line">        <span class="type">FruitDAO</span> <span class="variable">fruitDAO</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FruitDAOImpl</span>();</span><br><span class="line">        List&lt;Fruit&gt; fruitList = fruitDAO.getFruitList(pageNo);</span><br><span class="line"></span><br><span class="line">        session.setAttribute(<span class="string">&quot;fruitList&quot;</span>,fruitList);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//总记录条数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">fruitCount</span> <span class="operator">=</span> fruitDAO.getFruitCount();</span><br><span class="line">        <span class="comment">//总页数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">pageCount</span> <span class="operator">=</span> (fruitCount+<span class="number">5</span>-<span class="number">1</span>)/<span class="number">5</span> ;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        总记录条数       总页数</span></span><br><span class="line"><span class="comment">        1               1</span></span><br><span class="line"><span class="comment">        5               1</span></span><br><span class="line"><span class="comment">        6               2</span></span><br><span class="line"><span class="comment">        10              2</span></span><br><span class="line"><span class="comment">        11              3</span></span><br><span class="line"><span class="comment">        fruitCount      (fruitCount+5-1)/5</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        session.setAttribute(<span class="string">&quot;pageCount&quot;</span>,pageCount);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//此处的视图名称是 index</span></span><br><span class="line">        <span class="comment">//那么thymeleaf会将这个 逻辑视图名称 对应到 物理视图 名称上去</span></span><br><span class="line">        <span class="comment">//逻辑视图名称 ：   index</span></span><br><span class="line">        <span class="comment">//物理视图名称 ：   view-prefix + 逻辑视图名称 + view-suffix</span></span><br><span class="line">        <span class="comment">//所以真实的视图名称是：      /       index       .html</span></span><br><span class="line">        <span class="built_in">super</span>.processTemplate(<span class="string">&quot;index&quot;</span>,request,response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="问题一：Tomcat热部署"><a href="#问题一：Tomcat热部署" class="headerlink" title="问题一：Tomcat热部署"></a>问题一：Tomcat热部署</h4><p>Tomcat热部署原因导刚修改的数据加载不上来，因此需要删除Artifact的项目模块，重启Tomcat造次加载</p><h3 id="4、添加add操作"><a href="#4、添加add操作" class="headerlink" title="4、添加add操作"></a>4、添加add操作</h3><h4 id="1）编写add-html页面"><a href="#1）编写add-html页面" class="headerlink" title="1）编写add.html页面"></a>1）编写add.html页面</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span>    <span class="comment">&lt;!--thymeleaf的声明--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;css/add.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;div_container&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;div_fruit_list&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;center f30&quot;</span>&gt;</span>新增库存信息<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;add.do&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">table</span> <span class="attr">id</span>=<span class="string">&quot;tbl_fruit&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">th</span> <span class="attr">class</span>=<span class="string">&quot;w20&quot;</span>&gt;</span>名称：<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">               <span class="comment">&lt;!-- &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;fname&quot; th:value=&quot;$&#123;fruit.fname&#125;&quot;/&gt;&lt;/td&gt; --&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;fname&quot;</span> /&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">th</span> <span class="attr">class</span>=<span class="string">&quot;w20&quot;</span>&gt;</span>单价：<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;price&quot;</span> /&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">th</span> <span class="attr">class</span>=<span class="string">&quot;w20&quot;</span>&gt;</span>库存：<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;fcount&quot;</span> /&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">th</span> <span class="attr">class</span>=<span class="string">&quot;w20&quot;</span>&gt;</span>备注：<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;remark&quot;</span> /&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">th</span> <span class="attr">colspan</span>=<span class="string">&quot;2&quot;</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;添加&quot;</span> /&gt;</span></span><br><span class="line">               <span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2）编写add-css样式"><a href="#2）编写add-css样式" class="headerlink" title="2）编写add.css样式"></a>2）编写add.css样式</h4><p>略</p><h4 id="3）编写addServlet"><a href="#3）编写addServlet" class="headerlink" title="3）编写addServlet"></a>3）编写addServlet</h4><p>在FruitDAO接口中添加addFruit方法，在FruitDAOImpl实现类中重写此方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FruitDAOImpl</span> <span class="keyword">extends</span> <span class="title class_">BaseDAO</span>&lt;Fruit&gt; <span class="keyword">implements</span> <span class="title class_">FruitDAO</span> &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFruit</span><span class="params">(Fruit fruit)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into t_fruit values(0,?,?,?,?)&quot;</span>;</span><br><span class="line">    <span class="built_in">super</span>.executeUpdate(sql,fruit.getFname(),fruit.getPrice(),fruit.getFcount(),fruit.getRemark());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后进行编写addServlet类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/add.do&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AddServlet</span> <span class="keyword">extends</span> <span class="title class_">ViewBaseServlet</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">FruitDAO</span> <span class="variable">fruitDAO</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FruitDAOImpl</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        req.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="type">String</span> <span class="variable">fname</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;fname&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">priceStr</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;price&quot;</span>);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">price</span> <span class="operator">=</span> Integer.parseInt(priceStr);</span><br><span class="line">        <span class="type">String</span> <span class="variable">fcountStr</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;fcount&quot;</span>);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">fcount</span> <span class="operator">=</span> Integer.parseInt(fcountStr);</span><br><span class="line">        <span class="type">String</span> <span class="variable">remark</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;remark&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Fruit</span> <span class="variable">fruit</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Fruit</span>(<span class="number">0</span>,fname,price,fcount,remark);</span><br><span class="line">        fruitDAO.addFruit(fruit);</span><br><span class="line">        </span><br><span class="line">        resp.sendRedirect(<span class="string">&quot;index&quot;</span>); <span class="comment">//跳转回主页面的操作，使客户端向index.html请求</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="问题一：反射类型转换失败"><a href="#问题一：反射类型转换失败" class="headerlink" title="问题一：反射类型转换失败"></a>问题一：反射类型转换失败</h3><p>java.lang.Class cannot be cast to java.lang.reflect.ParameterizedType</p><p>解决方法：</p><ul><li>instanceof是Java中的二元<a href="https://so.csdn.net/so/search?q=%E8%BF%90%E7%AE%97%E7%AC%A6&spm=1001.2101.3001.7020">运算符</a>，左边是对象，右边是类；当对象是右边类或子类所创建对象时，返回true；否则，返回false。</li><li>在强制转化<code>参数化类型</code> 当参数类型可能有多个泛型参数的时候<br>需要多一层判断是否包含 （此一个对象是否为一个类的实例）， 然后再执行逻辑代码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">BaseDAO</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//getClass() 获取Class对象，当前我们执行的是new FruitDAOImpl() , 创建的是FruitDAOImpl的实例</span></span><br><span class="line">    <span class="comment">//那么子类构造方法内部首先会调用父类（BaseDAO）的无参构造方法</span></span><br><span class="line">    <span class="comment">//因此此处的getClass()会被执行，但是getClass获取的是FruitDAOImpl的Class</span></span><br><span class="line">    <span class="comment">//所以getGenericSuperclass()获取到的是BaseDAO的Class</span></span><br><span class="line">    <span class="type">Type</span> <span class="variable">genericType</span> <span class="operator">=</span> getClass().getGenericSuperclass();</span><br><span class="line">    <span class="comment">//ParameterizedType 参数化类型</span></span><br><span class="line">    <span class="keyword">if</span>(genericType <span class="keyword">instanceof</span> ParameterizedType)&#123;  <span class="comment">//添加类型判断</span></span><br><span class="line">        Type[] actualTypeArguments = ((ParameterizedType) genericType).getActualTypeArguments();</span><br><span class="line">        <span class="comment">//获取到的&lt;T&gt;中的T的真实的类型</span></span><br><span class="line">        <span class="type">Type</span> <span class="variable">actualType</span> <span class="operator">=</span> actualTypeArguments[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            entityClass = Class.forName(actualType.getTypeName());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5、编辑edit操作"><a href="#5、编辑edit操作" class="headerlink" title="5、编辑edit操作"></a>5、编辑edit操作</h3><h4 id="1）编写edit-html页面"><a href="#1）编写edit-html页面" class="headerlink" title="1）编写edit.html页面"></a>1）编写edit.html页面</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;css/edit.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;div_container&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;div_fruit_list&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;center f30&quot;</span>&gt;</span>编辑库存信息3<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">form</span> <span class="attr">th:action</span>=<span class="string">&quot;@&#123;/update.do&#125;&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">th:object</span>=<span class="string">&quot;$&#123;fruit&#125;&quot;</span>&gt;</span></span><br><span class="line">         <span class="comment">&lt;!-- 隐藏域 ： 功能类似于文本框 ， 它的值会随着表单的发送也会发送给服务器，但是界面上用户看不到 --&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;fid&quot;</span> <span class="attr">th:value</span>=<span class="string">&quot;*&#123;fid&#125;&quot;</span>/&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">table</span> <span class="attr">id</span>=<span class="string">&quot;tbl_fruit&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">th</span> <span class="attr">class</span>=<span class="string">&quot;w20&quot;</span>&gt;</span>名称：<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">               <span class="comment">&lt;!-- &lt;td=&quot;w20&quot;&gt;单价：&lt;/th&gt;</span></span><br><span class="line"><span class="comment">               &lt;td&gt;&lt;inpu&gt;&lt;input type=&quot;text&quot; name=&quot;fname&quot; th:value=&quot;$&#123;fruit.fname&#125;&quot;/&gt;&lt;/td&gt; --&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;fname&quot;</span> <span class="attr">th:value</span>=<span class="string">&quot;*&#123;fname&#125;&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">th</span> <span class="attr">classt</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;price&quot;</span> <span class="attr">th:value</span>=<span class="string">&quot;*&#123;price&#125;&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">th</span> <span class="attr">class</span>=<span class="string">&quot;w20&quot;</span>&gt;</span>库存：<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;fcount&quot;</span> <span class="attr">th:value</span>=<span class="string">&quot;*&#123;fcount&#125;&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">th</span> <span class="attr">class</span>=<span class="string">&quot;w20&quot;</span>&gt;</span>备注：<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;remark&quot;</span> <span class="attr">th:value</span>=<span class="string">&quot;*&#123;remark&#125;&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">th</span> <span class="attr">colspan</span>=<span class="string">&quot;2&quot;</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;修改&quot;</span> /&gt;</span></span><br><span class="line">               <span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>问题一：</p><p>th:object&#x3D;”${fruit}   表示以下的调用，都是调用这个对象</p><p>th:value&#x3D;”*{fid}</p><p>问题二：</p><p>value表示文本框中的值</p><p>问题三：</p><p>此form表单在edit页面，点击修改则将数据发送至update.do</p></blockquote><h4 id="2）编写edit-css"><a href="#2）编写edit-css" class="headerlink" title="2）编写edit.css"></a>2）编写edit.css</h4><p>略</p><h4 id="3）编写editServlet"><a href="#3）编写editServlet" class="headerlink" title="3）编写editServlet"></a>3）编写editServlet</h4><p>在FruitDAO接口中添加getFruitByFid方法，在FruitDAOImpl实现类中重写此方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Fruit <span class="title function_">getFruitByFid</span><span class="params">(Integer fid)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.load(<span class="string">&quot;select * from t_fruit where fid= ?&quot;</span>,fid); <span class="comment">//返回查询的个体对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写editServlet</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/edit.do&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EditServlet</span> <span class="keyword">extends</span> <span class="title class_">ViewBaseServlet</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">FruitDAO</span> <span class="variable">fruitDAO</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FruitDAOImpl</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request , HttpServletResponse response)</span><span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">fidStr</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;fid&quot;</span>); <span class="comment">//客户端在index页面请求edit页面发送过来的</span></span><br><span class="line">        <span class="keyword">if</span>(StringUtil.isNotEmpty(fidStr))&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">fid</span> <span class="operator">=</span> Integer.parseInt(fidStr);</span><br><span class="line">            <span class="type">Fruit</span> <span class="variable">fruit</span> <span class="operator">=</span> fruitDAO.getFruitByFid(fid);</span><br><span class="line">            </span><br><span class="line">            request.setAttribute(<span class="string">&quot;fruit&quot;</span>,fruit); <span class="comment">//在一次请求中有效，设置在请求中</span></span><br><span class="line">            <span class="built_in">super</span>.processTemplate(<span class="string">&quot;edit&quot;</span>,request,response); <span class="comment">//在服务器端内部请求转发request给edit</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6、更新update操作"><a href="#6、更新update操作" class="headerlink" title="6、更新update操作"></a>6、更新update操作</h3><p>在FruitDAO接口中添加updateFruit方法，在FruitDAOImpl实现类中重写此方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateFruit</span><span class="params">(Fruit fruit)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;update t_fruit set fname = ? , price = ? , fcount = ? , remark = ? where fid = ? &quot;</span> ;</span><br><span class="line">    <span class="built_in">super</span>.executeUpdate(sql,fruit.getFname(),fruit.getPrice(),fruit.getFcount(),fruit.getRemark(),fruit.getFid());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写updateServlet</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/update.do&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UpdateServlet</span> <span class="keyword">extends</span> <span class="title class_">ViewBaseServlet</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">FruitDAO</span> <span class="variable">fruitDAO</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FruitDAOImpl</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//1.设置编码</span></span><br><span class="line">        request.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.获取参数</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">fidStr</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;fid&quot;</span>);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">fid</span> <span class="operator">=</span> Integer.parseInt(fidStr);</span><br><span class="line">        <span class="type">String</span> <span class="variable">fname</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;fname&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">priceStr</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;price&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">price</span> <span class="operator">=</span> Integer.parseInt(priceStr);</span><br><span class="line">        <span class="type">String</span> <span class="variable">fcountStr</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;fcount&quot;</span>);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">fcount</span> <span class="operator">=</span> Integer.parseInt(fcountStr);</span><br><span class="line">        <span class="type">String</span> <span class="variable">remark</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;remark&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.执行更新</span></span><br><span class="line">        fruitDAO.updateFruit(<span class="keyword">new</span> <span class="title class_">Fruit</span>(fid,fname, price ,fcount ,remark ));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.资源跳转</span></span><br><span class="line">        <span class="comment">//super.processTemplate(&quot;index&quot;,request,response);</span></span><br><span class="line">        <span class="comment">//相当于下面这句话，即服务器内资源重定向</span></span><br><span class="line">        <span class="comment">//request.getRequestDispatcher(&quot;index.html&quot;).forward(request,response);</span></span><br><span class="line">        <span class="comment">//因为index是用session保存数据的，所以刚刚更新的数据此时index的session还没有，所以不能用这个句话</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//此处需要重定向，目的是重新给IndexServlet发请求，重新获取furitList，然后覆盖到session中，这样index.html页面上显示的session中的数据才是最新的</span></span><br><span class="line">        response.sendRedirect(<span class="string">&quot;index&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7、删除delete操作"><a href="#7、删除delete操作" class="headerlink" title="7、删除delete操作"></a>7、删除delete操作</h3><p>在FruitDAO接口中添加delFruit方法，在FruitDAOImpl实现类中重写此方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delFruit</span><span class="params">(Integer fid)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.executeUpdate(<span class="string">&quot;delete from t_fruit where fid = ? &quot;</span> , fid) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写delServlet</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/del.do&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DelServlet</span> <span class="keyword">extends</span> <span class="title class_">ViewBaseServlet</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">FruitDAO</span> <span class="variable">fruitDAO</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FruitDAOImpl</span>();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request , HttpServletResponse response)</span><span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">fidStr</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;fid&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(StringUtil.isNotEmpty(fidStr))&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">fid</span> <span class="operator">=</span> Integer.parseInt(fidStr);</span><br><span class="line">            fruitDAO.delFruit(fid);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//super.processTemplate(&quot;index&quot;,request,response);</span></span><br><span class="line">            response.sendRedirect(<span class="string">&quot;index&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8、整体的目录和工具类"><a href="#8、整体的目录和工具类" class="headerlink" title="8、整体的目录和工具类"></a>8、整体的目录和工具类</h3><img src="/2022/09/30/JavaWeb/image-20220704151614586.png" alt="image-20220704151614586" style="zoom:50%;"><h4 id="BaseDAO"><a href="#BaseDAO" class="headerlink" title="BaseDAO"></a>BaseDAO</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">BaseDAO</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DRIVER</span> <span class="operator">=</span> <span class="string">&quot;com.mysql.jdbc.Driver&quot;</span> ;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">URL</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">USER</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PWD</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Connection conn ;</span><br><span class="line">    <span class="keyword">protected</span> PreparedStatement psmt ;</span><br><span class="line">    <span class="keyword">protected</span> ResultSet rs ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//T的Class对象</span></span><br><span class="line">    <span class="keyword">private</span> Class entityClass ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BaseDAO</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//getClass() 获取Class对象，当前我们执行的是new FruitDAOImpl() , 创建的是FruitDAOImpl的实例</span></span><br><span class="line">        <span class="comment">//那么子类构造方法内部首先会调用父类（BaseDAO）的无参构造方法</span></span><br><span class="line">        <span class="comment">//因此此处的getClass()会被执行，但是getClass获取的是FruitDAOImpl的Class</span></span><br><span class="line">        <span class="comment">//所以getGenericSuperclass()获取到的是BaseDAO的Class</span></span><br><span class="line">        <span class="type">Type</span> <span class="variable">genericType</span> <span class="operator">=</span> getClass().getGenericSuperclass();</span><br><span class="line">        <span class="comment">//ParameterizedType 参数化类型</span></span><br><span class="line">        Type[] actualTypeArguments = ((ParameterizedType) genericType).getActualTypeArguments();</span><br><span class="line">        <span class="comment">//获取到的&lt;T&gt;中的T的真实的类型</span></span><br><span class="line">        <span class="type">Type</span> <span class="variable">actualType</span> <span class="operator">=</span> actualTypeArguments[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            entityClass = Class.forName(actualType.getTypeName());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Connection <span class="title function_">getConn</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.加载驱动</span></span><br><span class="line">            Class.forName(DRIVER);</span><br><span class="line">            <span class="comment">//2.通过驱动管理器获取连接对象</span></span><br><span class="line">            <span class="keyword">return</span> DriverManager.getConnection(URL, USER, PWD);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException | SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">(ResultSet rs , PreparedStatement psmt , Connection conn)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (rs != <span class="literal">null</span>) &#123;</span><br><span class="line">                rs.close();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(psmt!=<span class="literal">null</span>)&#123;</span><br><span class="line">                psmt.close();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(conn!=<span class="literal">null</span> &amp;&amp; !conn.isClosed())&#123;</span><br><span class="line">                conn.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//给预处理命令对象设置参数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setParams</span><span class="params">(PreparedStatement psmt , Object... params)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="keyword">if</span>(params!=<span class="literal">null</span> &amp;&amp; params.length&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; params.length; i++) &#123;</span><br><span class="line">                psmt.setObject(i+<span class="number">1</span>,params[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行更新，返回影响行数</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">executeUpdate</span><span class="params">(String sql , Object... params)</span>&#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">insertFlag</span> <span class="operator">=</span> <span class="literal">false</span> ;</span><br><span class="line">        insertFlag = sql.trim().toUpperCase().startsWith(<span class="string">&quot;INSERT&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            conn = getConn();</span><br><span class="line">            <span class="keyword">if</span>(insertFlag)&#123;</span><br><span class="line">                psmt = conn.prepareStatement(sql,Statement.RETURN_GENERATED_KEYS);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                psmt = conn.prepareStatement(sql);</span><br><span class="line">            &#125;</span><br><span class="line">            setParams(psmt,params);</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> psmt.executeUpdate() ;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(insertFlag)&#123;</span><br><span class="line">                rs = psmt.getGeneratedKeys();</span><br><span class="line">                <span class="keyword">if</span>(rs.next())&#123;</span><br><span class="line">                    <span class="keyword">return</span> ((Long)rs.getLong(<span class="number">1</span>)).intValue();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> count ;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            close(rs,psmt,conn);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过反射技术给obj对象的property属性赋propertyValue值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(Object obj ,  String property , Object propertyValue)</span>&#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> obj.getClass();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//获取property这个字符串对应的属性名 ， 比如 &quot;fid&quot;  去找 obj对象中的 fid 属性</span></span><br><span class="line">            <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> clazz.getDeclaredField(property);</span><br><span class="line">            <span class="keyword">if</span>(field!=<span class="literal">null</span>)&#123;</span><br><span class="line">                field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                field.set(obj,propertyValue);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException | IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行复杂查询，返回例如统计结果</span></span><br><span class="line">    <span class="keyword">protected</span> Object[] executeComplexQuery(String sql , Object... params)&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            conn = getConn() ;</span><br><span class="line">            psmt = conn.prepareStatement(sql);</span><br><span class="line">            setParams(psmt,params);</span><br><span class="line">            rs = psmt.executeQuery();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//通过rs可以获取结果集的元数据</span></span><br><span class="line">            <span class="comment">//元数据：描述结果集数据的数据 , 简单讲，就是这个结果集有哪些列，什么类型等等</span></span><br><span class="line"></span><br><span class="line">            <span class="type">ResultSetMetaData</span> <span class="variable">rsmd</span> <span class="operator">=</span> rs.getMetaData();</span><br><span class="line">            <span class="comment">//获取结果集的列数</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">columnCount</span> <span class="operator">=</span> rsmd.getColumnCount();</span><br><span class="line">            Object[] columnValueArr = <span class="keyword">new</span> <span class="title class_">Object</span>[columnCount];</span><br><span class="line">            <span class="comment">//6.解析rs</span></span><br><span class="line">            <span class="keyword">if</span>(rs.next())&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i&lt;columnCount;i++)&#123;</span><br><span class="line">                    <span class="type">Object</span> <span class="variable">columnValue</span> <span class="operator">=</span> rs.getObject(i+<span class="number">1</span>);     <span class="comment">//33    苹果      5</span></span><br><span class="line">                    columnValueArr[i]=columnValue;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> columnValueArr ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            close(rs,psmt,conn);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行查询，返回单个实体对象</span></span><br><span class="line">    <span class="keyword">protected</span> T <span class="title function_">load</span><span class="params">(String sql , Object... params)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            conn = getConn() ;</span><br><span class="line">            psmt = conn.prepareStatement(sql);</span><br><span class="line">            setParams(psmt,params);</span><br><span class="line">            rs = psmt.executeQuery();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//通过rs可以获取结果集的元数据</span></span><br><span class="line">            <span class="comment">//元数据：描述结果集数据的数据 , 简单讲，就是这个结果集有哪些列，什么类型等等</span></span><br><span class="line"></span><br><span class="line">            <span class="type">ResultSetMetaData</span> <span class="variable">rsmd</span> <span class="operator">=</span> rs.getMetaData();</span><br><span class="line">            <span class="comment">//获取结果集的列数</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">columnCount</span> <span class="operator">=</span> rsmd.getColumnCount();</span><br><span class="line">            <span class="comment">//6.解析rs</span></span><br><span class="line">            <span class="keyword">if</span>(rs.next())&#123;</span><br><span class="line">                <span class="type">T</span> <span class="variable">entity</span> <span class="operator">=</span> (T)entityClass.newInstance();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i&lt;columnCount;i++)&#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">columnName</span> <span class="operator">=</span> rsmd.getColumnName(i+<span class="number">1</span>);            <span class="comment">//fid   fname   price</span></span><br><span class="line">                    <span class="type">Object</span> <span class="variable">columnValue</span> <span class="operator">=</span> rs.getObject(i+<span class="number">1</span>);     <span class="comment">//33    苹果      5</span></span><br><span class="line">                    setValue(entity,columnName,columnValue);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> entity ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            close(rs,psmt,conn);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行查询，返回List</span></span><br><span class="line">    <span class="keyword">protected</span> List&lt;T&gt; <span class="title function_">executeQuery</span><span class="params">(String sql , Object... params)</span>&#123;</span><br><span class="line">        List&lt;T&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            conn = getConn() ;</span><br><span class="line">            psmt = conn.prepareStatement(sql);</span><br><span class="line">            setParams(psmt,params);</span><br><span class="line">            rs = psmt.executeQuery();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//通过rs可以获取结果集的元数据</span></span><br><span class="line">            <span class="comment">//元数据：描述结果集数据的数据 , 简单讲，就是这个结果集有哪些列，什么类型等等</span></span><br><span class="line"></span><br><span class="line">            <span class="type">ResultSetMetaData</span> <span class="variable">rsmd</span> <span class="operator">=</span> rs.getMetaData();</span><br><span class="line">            <span class="comment">//获取结果集的列数</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">columnCount</span> <span class="operator">=</span> rsmd.getColumnCount();</span><br><span class="line">            <span class="comment">//6.解析rs</span></span><br><span class="line">            <span class="keyword">while</span>(rs.next())&#123;</span><br><span class="line">                <span class="type">T</span> <span class="variable">entity</span> <span class="operator">=</span> (T)entityClass.newInstance();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i&lt;columnCount;i++)&#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">columnName</span> <span class="operator">=</span> rsmd.getColumnName(i+<span class="number">1</span>);            <span class="comment">//fid   fname   price</span></span><br><span class="line">                    <span class="type">Object</span> <span class="variable">columnValue</span> <span class="operator">=</span> rs.getObject(i+<span class="number">1</span>);     <span class="comment">//33    苹果      5</span></span><br><span class="line">                    setValue(entity,columnName,columnValue);</span><br><span class="line">                &#125;</span><br><span class="line">                list.add(entity);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            close(rs,psmt,conn);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ViewBaseServlet"><a href="#ViewBaseServlet" class="headerlink" title="ViewBaseServlet"></a>ViewBaseServlet</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ViewBaseServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TemplateEngine templateEngine;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.获取ServletContext对象</span></span><br><span class="line">        <span class="type">ServletContext</span> <span class="variable">servletContext</span> <span class="operator">=</span> <span class="built_in">this</span>.getServletContext();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.创建Thymeleaf解析器对象</span></span><br><span class="line">        <span class="type">ServletContextTemplateResolver</span> <span class="variable">templateResolver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServletContextTemplateResolver</span>(servletContext);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.给解析器对象设置参数</span></span><br><span class="line">        <span class="comment">// ①HTML是默认模式，明确设置是为了代码更容易理解</span></span><br><span class="line">        templateResolver.setTemplateMode(TemplateMode.HTML);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ②设置前缀</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">viewPrefix</span> <span class="operator">=</span> servletContext.getInitParameter(<span class="string">&quot;view-prefix&quot;</span>);</span><br><span class="line"></span><br><span class="line">        templateResolver.setPrefix(viewPrefix);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ③设置后缀</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">viewSuffix</span> <span class="operator">=</span> servletContext.getInitParameter(<span class="string">&quot;view-suffix&quot;</span>);</span><br><span class="line"></span><br><span class="line">        templateResolver.setSuffix(viewSuffix);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ④设置缓存过期时间（毫秒）</span></span><br><span class="line">        templateResolver.setCacheTTLMs(<span class="number">60000L</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ⑤设置是否缓存</span></span><br><span class="line">        templateResolver.setCacheable(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ⑥设置服务器端编码方式</span></span><br><span class="line">        templateResolver.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.创建模板引擎对象</span></span><br><span class="line">        templateEngine = <span class="keyword">new</span> <span class="title class_">TemplateEngine</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.给模板引擎对象设置模板解析器</span></span><br><span class="line">        templateEngine.setTemplateResolver(templateResolver);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">processTemplate</span><span class="params">(String templateName, HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 1.设置响应体内容类型和字符集</span></span><br><span class="line">        resp.setContentType(<span class="string">&quot;text/html;charset=UTF-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.创建WebContext对象</span></span><br><span class="line">        <span class="type">WebContext</span> <span class="variable">webContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WebContext</span>(req, resp, getServletContext());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.处理模板数据</span></span><br><span class="line">        templateEngine.process(templateName, webContext, resp.getWriter());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="StringUtil"><a href="#StringUtil" class="headerlink" title="StringUtil"></a>StringUtil</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringUtil</span> &#123;</span><br><span class="line">    <span class="comment">//判断字符串是否为null或者&quot;&quot;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">(String str)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> str==<span class="literal">null</span> || <span class="string">&quot;&quot;</span>.equals(str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isNotEmpty</span><span class="params">(String str)</span>&#123; <span class="keyword">return</span> !isEmpty(str); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9、增添查询功能"><a href="#9、增添查询功能" class="headerlink" title="9、增添查询功能"></a>9、增添查询功能</h3><p>查询功能：根据在form表单中输入关键字，发送至服务端，返回fname或remark中存在关键字的库存记录，还是按显示出来。</p><p>由于此功能除了与index基本相似，区别在于index查询显示全部数据，而这是通过查询匹配的关键的数据因此在index.html中增加form表单文本框，发送indexServlet</p><p><img src="/2022/09/30/JavaWeb/image-20220705111704829.png" alt="image-20220705111704829"></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;border:0px solid red;width:60%;margin-left:20%;text-align:right;&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">form</span> <span class="attr">th:action</span>=<span class="string">&quot;@&#123;/index&#125;&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">style</span>=<span class="string">&quot;float:left;width:60%;margin-left:20%;&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;oper&quot;</span> <span class="attr">value</span>=<span class="string">&quot;search&quot;</span>/&gt;</span></span><br><span class="line">      请输入关键字：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;keyword&quot;</span> <span class="attr">th:value</span>=<span class="string">&quot;$&#123;session.keyword&#125;&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;查询&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/add.html&#125;&quot;</span> <span class="attr">style</span>=<span class="string">&quot;border:0px solid blue;margin-bottom:4px;&quot;</span>&gt;</span>添加新库存记录<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对应的sql修改</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Fruit&gt; <span class="title function_">getFruitList</span><span class="params">(String keyword , Integer pageNo)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.executeQuery(<span class="string">&quot;select * from t_fruit where fname like ? or remark like ? limit ? , 5&quot;</span> ,<span class="string">&quot;%&quot;</span>+keyword+<span class="string">&quot;%&quot;</span>,<span class="string">&quot;%&quot;</span>+keyword+<span class="string">&quot;%&quot;</span>, (pageNo-<span class="number">1</span>)*<span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>index修改</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/index&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IndexServlet</span> <span class="keyword">extends</span> <span class="title class_">ViewBaseServlet</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        doGet(req,resp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request , HttpServletResponse response)</span><span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        request.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">       <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession() ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置当前页，默认值1</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">pageNo</span> <span class="operator">=</span> <span class="number">1</span> ;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">oper</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;oper&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果oper!=null 说明 通过表单的查询按钮点击过来的</span></span><br><span class="line">        <span class="comment">//如果oper是空的，说明 不是通过表单的查询按钮点击过来的</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">keyword</span> <span class="operator">=</span> <span class="literal">null</span> ;</span><br><span class="line">        <span class="keyword">if</span>(StringUtil.isNotEmpty(oper) &amp;&amp; <span class="string">&quot;search&quot;</span>.equals(oper))&#123;</span><br><span class="line">            <span class="comment">//说明是点击表单查询发送过来的请求</span></span><br><span class="line">            <span class="comment">//此时，pageNo应该还原为1 ， keyword应该从请求参数中获取</span></span><br><span class="line">            pageNo = <span class="number">1</span> ;</span><br><span class="line">            keyword = request.getParameter(<span class="string">&quot;keyword&quot;</span>);</span><br><span class="line">            <span class="comment">//如果keyword为null，需要设置为空字符串&quot;&quot;，否则查询时会拼接成 %null% , 我们期望的是 %%</span></span><br><span class="line">            <span class="keyword">if</span>(StringUtil.isEmpty(keyword))&#123;</span><br><span class="line">                keyword = <span class="string">&quot;&quot;</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将keyword保存（覆盖）到session中，便于查找上一页或下一页时使用</span></span><br><span class="line">            session.setAttribute(<span class="string">&quot;keyword&quot;</span>,keyword);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//说明此处不是点击表单查询发送过来的请求（比如点击下面的上一页下一页或者直接在地址栏输入网址）</span></span><br><span class="line">            <span class="comment">//此时keyword应该从session作用域获取</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">pageNoStr</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;pageNo&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span>(StringUtil.isNotEmpty(pageNoStr))&#123;</span><br><span class="line">                pageNo = Integer.parseInt(pageNoStr);   <span class="comment">//如果从请求中读取到pageNo，则类型转换。否则，pageNo默认就是1</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果不是点击的查询按钮，那么查询是基于session中保存的现有keyword进行查询</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">keywordObj</span> <span class="operator">=</span> session.getAttribute(<span class="string">&quot;keyword&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span>(keywordObj!=<span class="literal">null</span>)&#123;</span><br><span class="line">                keyword = (String)keywordObj ;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                keyword = <span class="string">&quot;&quot;</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重新更新当前页的值</span></span><br><span class="line">        session.setAttribute(<span class="string">&quot;pageNo&quot;</span>,pageNo);</span><br><span class="line"></span><br><span class="line">        <span class="type">FruitDAO</span> <span class="variable">fruitDAO</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FruitDAOImpl</span>();</span><br><span class="line">        List&lt;Fruit&gt; fruitList = fruitDAO.getFruitList(keyword , pageNo);</span><br><span class="line">        session.setAttribute(<span class="string">&quot;fruitList&quot;</span>,fruitList);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//总记录条数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">fruitCount</span> <span class="operator">=</span> fruitDAO.getFruitCount(keyword);</span><br><span class="line">        <span class="comment">//总页数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">pageCount</span> <span class="operator">=</span> (fruitCount+<span class="number">5</span>-<span class="number">1</span>)/<span class="number">5</span> ;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        总记录条数       总页数</span></span><br><span class="line"><span class="comment">        1               1</span></span><br><span class="line"><span class="comment">        5               1</span></span><br><span class="line"><span class="comment">        6               2</span></span><br><span class="line"><span class="comment">        10              2</span></span><br><span class="line"><span class="comment">        11              3</span></span><br><span class="line"><span class="comment">        fruitCount      (fruitCount+5-1)/5</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        session.setAttribute(<span class="string">&quot;pageCount&quot;</span>,pageCount);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//此处的视图名称是 index</span></span><br><span class="line">        <span class="comment">//那么thymeleaf会将这个 逻辑视图名称 对应到 物理视图 名称上去</span></span><br><span class="line">        <span class="comment">//逻辑视图名称 ：   index</span></span><br><span class="line">        <span class="comment">//物理视图名称 ：   view-prefix + 逻辑视图名称 + view-suffix</span></span><br><span class="line">        <span class="comment">//所以真实的视图名称是：      /       index       .html</span></span><br><span class="line">        <span class="built_in">super</span>.processTemplate(<span class="string">&quot;index&quot;</span>,request,response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="水果系统-优化1"><a href="#水果系统-优化1" class="headerlink" title="水果系统-优化1"></a>水果系统-优化1</h2><h3 id="原始项目简图"><a href="#原始项目简图" class="headerlink" title="原始项目简图"></a>原始项目简图</h3><p><img src="/2022/09/30/JavaWeb/image-20220705114314955.png" alt="image-20220705114314955"></p><blockquote><p>缺点是客户端需要向多个Servlet发送请求，结构混乱</p></blockquote><h3 id="优化1简图"><a href="#优化1简图" class="headerlink" title="优化1简图"></a>优化1简图</h3><p><img src="/2022/09/30/JavaWeb/image-20220705114518645.png" alt="image-20220705114518645"></p><blockquote><p>建立一个总Serlvet，根据请求中的operate调用相应Servlet</p></blockquote><h3 id="修改html"><a href="#修改html" class="headerlink" title="修改html"></a>修改html</h3><p><img src="/2022/09/30/JavaWeb/image-20220705115816559.png" alt="image-20220705115816559"></p><blockquote><p>提供operate信息，全部请求发送至fruit.do ，FruitServlet根据operate调用相关Servlet</p></blockquote><h3 id="优化1-编写FruitServlet-switch"><a href="#优化1-编写FruitServlet-switch" class="headerlink" title="优化1.编写FruitServlet-switch"></a>优化1.编写FruitServlet-switch</h3><p>这里使用switch进行区分不同操作而调用相应方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/fruit.do&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FruitServlet</span> <span class="keyword">extends</span> <span class="title class_">ViewBaseServlet</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">FruitDAO</span> <span class="variable">fruitDAO</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FruitDAOImpl</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//设置编码</span></span><br><span class="line">        request.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">operate</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;operate&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(StringUtil.isEmpty(operate))&#123; <span class="comment">//没有其余操作，默认跳转index</span></span><br><span class="line">            operate = <span class="string">&quot;index&quot;</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span>(operate)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;index&quot;</span>:</span><br><span class="line">                index(request,response);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;add&quot;</span>:</span><br><span class="line">                add(request,response);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;del&quot;</span>:</span><br><span class="line">                del(request,response);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;edit&quot;</span>:</span><br><span class="line">                edit(request,response);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;update&quot;</span>:</span><br><span class="line">                update(request,response);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;operate值非法!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//1.设置编码</span></span><br><span class="line">        request.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.获取参数</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">fidStr</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;fid&quot;</span>);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">fid</span> <span class="operator">=</span> Integer.parseInt(fidStr);</span><br><span class="line">        <span class="type">String</span> <span class="variable">fname</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;fname&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">priceStr</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;price&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">price</span> <span class="operator">=</span> Integer.parseInt(priceStr);</span><br><span class="line">        <span class="type">String</span> <span class="variable">fcountStr</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;fcount&quot;</span>);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">fcount</span> <span class="operator">=</span> Integer.parseInt(fcountStr);</span><br><span class="line">        <span class="type">String</span> <span class="variable">remark</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;remark&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.执行更新</span></span><br><span class="line">        fruitDAO.updateFruit(<span class="keyword">new</span> <span class="title class_">Fruit</span>(fid,fname, price ,fcount ,remark ));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.资源跳转</span></span><br><span class="line">        <span class="comment">//super.processTemplate(&quot;index&quot;,request,response);</span></span><br><span class="line">        <span class="comment">//request.getRequestDispatcher(&quot;index.html&quot;).forward(request,response);</span></span><br><span class="line">        <span class="comment">//此处需要重定向，目的是重新给IndexServlet发请求，重新获取furitList，然后覆盖到session中，这样index.html页面上显示的session中的数据才是最新的</span></span><br><span class="line">        response.sendRedirect(<span class="string">&quot;fruit.do&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">edit</span><span class="params">(HttpServletRequest request , HttpServletResponse response)</span><span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">fidStr</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;fid&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(StringUtil.isNotEmpty(fidStr))&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">fid</span> <span class="operator">=</span> Integer.parseInt(fidStr);</span><br><span class="line">            <span class="type">Fruit</span> <span class="variable">fruit</span> <span class="operator">=</span> fruitDAO.getFruitByFid(fid);</span><br><span class="line">            request.setAttribute(<span class="string">&quot;fruit&quot;</span>,fruit);</span><br><span class="line">            <span class="built_in">super</span>.processTemplate(<span class="string">&quot;edit&quot;</span>,request,response);  <span class="comment">//找到edit.html，将数据渲染上去</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">del</span><span class="params">(HttpServletRequest request , HttpServletResponse response)</span><span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">fidStr</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;fid&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(StringUtil.isNotEmpty(fidStr))&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">fid</span> <span class="operator">=</span> Integer.parseInt(fidStr);</span><br><span class="line">            fruitDAO.delFruit(fid);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//super.processTemplate(&quot;index&quot;,request,response);</span></span><br><span class="line">            response.sendRedirect(<span class="string">&quot;fruit.do&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        request.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">fname</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;fname&quot;</span>);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">price</span> <span class="operator">=</span> Integer.parseInt(request.getParameter(<span class="string">&quot;price&quot;</span>)) ;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">fcount</span> <span class="operator">=</span> Integer.parseInt(request.getParameter(<span class="string">&quot;fcount&quot;</span>));</span><br><span class="line">        <span class="type">String</span> <span class="variable">remark</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;remark&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Fruit</span> <span class="variable">fruit</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Fruit</span>(<span class="number">0</span>,fname , price , fcount , remark ) ;</span><br><span class="line"></span><br><span class="line">        fruitDAO.addFruit(fruit);</span><br><span class="line"></span><br><span class="line">        response.sendRedirect(<span class="string">&quot;fruit.do&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">index</span><span class="params">(HttpServletRequest request , HttpServletResponse response)</span><span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession() ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置当前页，默认值1</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">pageNo</span> <span class="operator">=</span> <span class="number">1</span> ;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">oper</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;oper&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果oper!=null 说明 通过表单的查询按钮点击过来的</span></span><br><span class="line">        <span class="comment">//如果oper是空的，说明 不是通过表单的查询按钮点击过来的</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">keyword</span> <span class="operator">=</span> <span class="literal">null</span> ;</span><br><span class="line">        <span class="keyword">if</span>(StringUtil.isNotEmpty(oper) &amp;&amp; <span class="string">&quot;search&quot;</span>.equals(oper))&#123;</span><br><span class="line">            <span class="comment">//说明是点击表单查询发送过来的请求</span></span><br><span class="line">            <span class="comment">//此时，pageNo应该还原为1 ， keyword应该从请求参数中获取</span></span><br><span class="line">            pageNo = <span class="number">1</span> ;</span><br><span class="line">            keyword = request.getParameter(<span class="string">&quot;keyword&quot;</span>);</span><br><span class="line">            <span class="comment">//如果keyword为null，需要设置为空字符串&quot;&quot;，否则查询时会拼接成 %null% , 我们期望的是 %%</span></span><br><span class="line">            <span class="keyword">if</span>(StringUtil.isEmpty(keyword))&#123;</span><br><span class="line">                keyword = <span class="string">&quot;&quot;</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将keyword保存（覆盖）到session中</span></span><br><span class="line">            session.setAttribute(<span class="string">&quot;keyword&quot;</span>,keyword);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//说明此处不是点击表单查询发送过来的请求（比如点击下面的上一页下一页或者直接在地址栏输入网址）</span></span><br><span class="line">            <span class="comment">//此时keyword应该从session作用域获取</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">pageNoStr</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;pageNo&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span>(StringUtil.isNotEmpty(pageNoStr))&#123;</span><br><span class="line">                pageNo = Integer.parseInt(pageNoStr);   <span class="comment">//如果从请求中读取到pageNo，则类型转换。否则，pageNo默认就是1</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果不是点击的查询按钮，那么查询是基于session中保存的现有keyword进行查询</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">keywordObj</span> <span class="operator">=</span> session.getAttribute(<span class="string">&quot;keyword&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span>(keywordObj!=<span class="literal">null</span>)&#123;</span><br><span class="line">                keyword = (String)keywordObj ;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                keyword = <span class="string">&quot;&quot;</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重新更新当前页的值</span></span><br><span class="line">        session.setAttribute(<span class="string">&quot;pageNo&quot;</span>,pageNo);</span><br><span class="line"></span><br><span class="line">        <span class="type">FruitDAO</span> <span class="variable">fruitDAO</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FruitDAOImpl</span>();</span><br><span class="line">        List&lt;Fruit&gt; fruitList = fruitDAO.getFruitList(keyword , pageNo);</span><br><span class="line">        session.setAttribute(<span class="string">&quot;fruitList&quot;</span>,fruitList);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//总记录条数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">fruitCount</span> <span class="operator">=</span> fruitDAO.getFruitCount(keyword);</span><br><span class="line">        <span class="comment">//总页数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">pageCount</span> <span class="operator">=</span> (fruitCount+<span class="number">5</span>-<span class="number">1</span>)/<span class="number">5</span> ;</span><br><span class="line">       </span><br><span class="line">        session.setAttribute(<span class="string">&quot;pageCount&quot;</span>,pageCount);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//那么thymeleaf会将这个 逻辑视图名称 对应到 物理视图 名称上去</span></span><br><span class="line">        <span class="built_in">super</span>.processTemplate(<span class="string">&quot;index&quot;</span>,request,response); <span class="comment">//找到index.html，将数据渲染上去</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优化1-5编写FruitServlet-反射"><a href="#优化1-5编写FruitServlet-反射" class="headerlink" title="优化1.5编写FruitServlet-反射"></a>优化1.5编写FruitServlet-反射</h2><p>由于优化1使用switch进行区分调用operate相应方法，如果方法很多，switch显得笨拙，这里将使用反射机制，将本类同名方法找出</p><p>只需要重写修改service方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//设置编码</span></span><br><span class="line">        request.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="type">String</span> <span class="variable">operate</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;operate&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(StringUtil.isEmpty(operate))&#123;</span><br><span class="line">            operate = <span class="string">&quot;index&quot;</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> <span class="built_in">this</span>.getClass().getDeclaredMethod(operate,HttpServletRequest.class,HttpServletResponse.class);</span><br><span class="line">            <span class="keyword">if</span>(method!=<span class="literal">null</span>)&#123;</span><br><span class="line">                method.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                method.invoke(<span class="built_in">this</span>,request,response);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;operate值非法!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h2 id="水果系统-优化2"><a href="#水果系统-优化2" class="headerlink" title="水果系统-优化2"></a>水果系统-优化2</h2><h3 id="DispatcherServlet的引入"><a href="#DispatcherServlet的引入" class="headerlink" title="DispatcherServlet的引入"></a>DispatcherServlet的引入</h3><p><img src="/2022/09/30/JavaWeb/image-20220705171834121.png" alt="image-20220705171834121"></p><p>随着组件的增多，每个组件又有很多功能，因此将各个组件有中央控制器来控制调用</p><h3 id="DispatcherServlet"><a href="#DispatcherServlet" class="headerlink" title="DispatcherServlet"></a>DispatcherServlet</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;*.do&quot;)</span>  <span class="comment">//&quot;*&quot; 表任意字符，后带.do的可以匹配此Servlet</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DispatcherServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,Object&gt; beanMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DispatcherServlet</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//初始化方法：从xml中读取控制器（类名和位置），创建控制器实例，将所有实例保存至beanMap中</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> getClass().getClassLoader().getResourceAsStream(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">            <span class="comment">//1.创建DocumentBuilderFactory</span></span><br><span class="line">            <span class="type">DocumentBuilderFactory</span> <span class="variable">documentBuilderFactory</span> <span class="operator">=</span> DocumentBuilderFactory.newInstance();</span><br><span class="line">            <span class="comment">//2.创建DocumentBuilder对象</span></span><br><span class="line">            <span class="type">DocumentBuilder</span> <span class="variable">documentBuilder</span> <span class="operator">=</span> documentBuilderFactory.newDocumentBuilder() ;</span><br><span class="line">            <span class="comment">//3.创建Document对象</span></span><br><span class="line">            <span class="type">Document</span> <span class="variable">document</span> <span class="operator">=</span> documentBuilder.parse(inputStream);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//4.获取所有的bean节点</span></span><br><span class="line">            <span class="type">NodeList</span> <span class="variable">beanNodeList</span> <span class="operator">=</span> document.getElementsByTagName(<span class="string">&quot;bean&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i&lt;beanNodeList.getLength() ; i++)&#123;</span><br><span class="line">                <span class="type">Node</span> <span class="variable">beanNode</span> <span class="operator">=</span> beanNodeList.item(i);</span><br><span class="line">                <span class="keyword">if</span>(beanNode.getNodeType() == Node.ELEMENT_NODE)&#123;  <span class="comment">//是不是元素节点</span></span><br><span class="line">                    <span class="type">Element</span> <span class="variable">beanElement</span> <span class="operator">=</span> (Element)beanNode ;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">beanId</span> <span class="operator">=</span>  beanElement.getAttribute(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">                    <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> beanElement.getAttribute(<span class="string">&quot;class&quot;</span>);</span><br><span class="line">                    <span class="type">Class</span> <span class="variable">controllerBeanClass</span> <span class="operator">=</span> Class.forName(className);</span><br><span class="line">                    <span class="type">Object</span> <span class="variable">beanObj</span> <span class="operator">=</span> controllerBeanClass.newInstance() ;</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">//由于控制器没有setServletContext</span></span><br><span class="line">                    <span class="comment">//所以在这里顺便将setServletContext传给它</span></span><br><span class="line">                    <span class="type">Method</span> <span class="variable">setServletContextMethod</span> <span class="operator">=</span> controllerBeanClass.getDeclaredMethod(<span class="string">&quot;setServletContext&quot;</span>,ServletContext.class);</span><br><span class="line">                    setServletContextMethod.invoke(beanObj , <span class="built_in">this</span>.getServletContext());</span><br><span class="line"></span><br><span class="line">                    beanMap.put(beanId , beanObj) ;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//设置编码</span></span><br><span class="line">        request.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        <span class="comment">//假设url是：  http://localhost:8080/pro15/hello.do</span></span><br><span class="line">        <span class="comment">//那么servletPath是：    /hello.do</span></span><br><span class="line">        <span class="comment">// 我的思路是：</span></span><br><span class="line">        <span class="comment">// 第1步： /hello.do -&gt;   hello   或者  /fruit.do  -&gt; fruit</span></span><br><span class="line">        <span class="comment">// 第2步： hello -&gt; HelloController 或者 fruit -&gt; FruitController</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">servletPath</span> <span class="operator">=</span> request.getServletPath(); <span class="comment">//具体控制器名称</span></span><br><span class="line">        servletPath = servletPath.substring(<span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">lastDotIndex</span> <span class="operator">=</span> servletPath.lastIndexOf(<span class="string">&quot;.do&quot;</span>) ;</span><br><span class="line">        servletPath = servletPath.substring(<span class="number">0</span>,lastDotIndex); <span class="comment">// 去掉/ 和.do 的字符</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//用servletPath就可获取对应的对象</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">controllerBeanObj</span> <span class="operator">=</span> beanMap.get(servletPath);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">operate</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;operate&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(StringUtil.isEmpty(operate))&#123;</span><br><span class="line">            operate = <span class="string">&quot;index&quot;</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> controllerBeanObj.getClass().getDeclaredMethod(operate,HttpServletRequest.class,HttpServletResponse.class);</span><br><span class="line">            <span class="keyword">if</span>(method!=<span class="literal">null</span>)&#123;</span><br><span class="line">                method.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                method.invoke(controllerBeanObj,request,response);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;operate值非法!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ViewBaseServlet-1"><a href="#ViewBaseServlet-1" class="headerlink" title="ViewBaseServlet"></a>ViewBaseServlet</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ViewBaseServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TemplateEngine templateEngine;</span><br><span class="line">    <span class="keyword">private</span> ServletContext servletContext ;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ServletContext servletContext)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">        <span class="built_in">this</span>.servletContext = servletContext ;</span><br><span class="line">        <span class="comment">// 1.获取ServletContext对象</span></span><br><span class="line">        <span class="comment">//ServletContext servletContext = this.getServletContext();</span></span><br><span class="line">        <span class="comment">// 2.创建Thymeleaf解析器对象</span></span><br><span class="line">        <span class="type">ServletContextTemplateResolver</span> <span class="variable">templateResolver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServletContextTemplateResolver</span>(servletContext);</span><br><span class="line">        <span class="comment">// 3.给解析器对象设置参数</span></span><br><span class="line">        <span class="comment">// ①HTML是默认模式，明确设置是为了代码更容易理解</span></span><br><span class="line">        templateResolver.setTemplateMode(TemplateMode.HTML);</span><br><span class="line">        <span class="comment">// ②设置前缀</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">viewPrefix</span> <span class="operator">=</span> servletContext.getInitParameter(<span class="string">&quot;view-prefix&quot;</span>);</span><br><span class="line">        templateResolver.setPrefix(viewPrefix);</span><br><span class="line">        <span class="comment">// ③设置后缀</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">viewSuffix</span> <span class="operator">=</span> servletContext.getInitParameter(<span class="string">&quot;view-suffix&quot;</span>);</span><br><span class="line">        templateResolver.setSuffix(viewSuffix);</span><br><span class="line">        <span class="comment">// ④设置缓存过期时间（毫秒）</span></span><br><span class="line">        templateResolver.setCacheTTLMs(<span class="number">60000L</span>);</span><br><span class="line">        <span class="comment">// ⑤设置是否缓存</span></span><br><span class="line">        templateResolver.setCacheable(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">// ⑥设置服务器端编码方式</span></span><br><span class="line">        templateResolver.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        <span class="comment">// 4.创建模板引擎对象</span></span><br><span class="line">        templateEngine = <span class="keyword">new</span> <span class="title class_">TemplateEngine</span>();</span><br><span class="line">        <span class="comment">// 5.给模板引擎对象设置模板解析器</span></span><br><span class="line">        templateEngine.setTemplateResolver(templateResolver);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">processTemplate</span><span class="params">(String templateName, HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 1.设置响应体内容类型和字符集</span></span><br><span class="line">        resp.setContentType(<span class="string">&quot;text/html;charset=UTF-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.创建WebContext对象</span></span><br><span class="line">        <span class="type">WebContext</span> <span class="variable">webContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WebContext</span>(req, resp, <span class="built_in">this</span>.servletContext);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.处理模板数据</span></span><br><span class="line">        templateEngine.process(templateName, webContext, resp.getWriter());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="FruitController"><a href="#FruitController" class="headerlink" title="FruitController"></a>FruitController</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FruitController</span> <span class="keyword">extends</span> <span class="title class_">ViewBaseServlet</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//之前FruitServlet是一个Sevlet组件，那么其中的init方法一定会被调用 </span></span><br><span class="line">    <span class="comment">//之前的init方法内部会出现一句话：super.init();</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ServletContext servletContext ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setServletContext</span><span class="params">(ServletContext servletContext)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">        <span class="built_in">this</span>.servletContext = servletContext;</span><br><span class="line">        <span class="built_in">super</span>.init(servletContext);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">FruitDAO</span> <span class="variable">fruitDAO</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FruitDAOImpl</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//1.设置编码</span></span><br><span class="line">        request.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.获取参数</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">fidStr</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;fid&quot;</span>);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">fid</span> <span class="operator">=</span> Integer.parseInt(fidStr);</span><br><span class="line">        <span class="type">String</span> <span class="variable">fname</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;fname&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">priceStr</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;price&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">price</span> <span class="operator">=</span> Integer.parseInt(priceStr);</span><br><span class="line">        <span class="type">String</span> <span class="variable">fcountStr</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;fcount&quot;</span>);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">fcount</span> <span class="operator">=</span> Integer.parseInt(fcountStr);</span><br><span class="line">        <span class="type">String</span> <span class="variable">remark</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;remark&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.执行更新</span></span><br><span class="line">        fruitDAO.updateFruit(<span class="keyword">new</span> <span class="title class_">Fruit</span>(fid,fname, price ,fcount ,remark ));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.资源跳转</span></span><br><span class="line">        <span class="comment">//super.processTemplate(&quot;index&quot;,request,response);</span></span><br><span class="line">        <span class="comment">//request.getRequestDispatcher(&quot;index.html&quot;).forward(request,response);</span></span><br><span class="line">        <span class="comment">//此处需要重定向，目的是重新给IndexServlet发请求，重新获取furitList，然后覆盖到session中，这样index.html页面上显示的session中的数据才是最新的</span></span><br><span class="line">        response.sendRedirect(<span class="string">&quot;fruit.do&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">edit</span><span class="params">(HttpServletRequest request , HttpServletResponse response)</span><span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">fidStr</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;fid&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(StringUtil.isNotEmpty(fidStr))&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">fid</span> <span class="operator">=</span> Integer.parseInt(fidStr);</span><br><span class="line">            <span class="type">Fruit</span> <span class="variable">fruit</span> <span class="operator">=</span> fruitDAO.getFruitByFid(fid);</span><br><span class="line">            request.setAttribute(<span class="string">&quot;fruit&quot;</span>,fruit);</span><br><span class="line">            <span class="built_in">super</span>.processTemplate(<span class="string">&quot;edit&quot;</span>,request,response);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">del</span><span class="params">(HttpServletRequest request , HttpServletResponse response)</span><span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">fidStr</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;fid&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(StringUtil.isNotEmpty(fidStr))&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">fid</span> <span class="operator">=</span> Integer.parseInt(fidStr);</span><br><span class="line">            fruitDAO.delFruit(fid);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//super.processTemplate(&quot;index&quot;,request,response);</span></span><br><span class="line">            response.sendRedirect(<span class="string">&quot;fruit.do&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        request.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">fname</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;fname&quot;</span>);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">price</span> <span class="operator">=</span> Integer.parseInt(request.getParameter(<span class="string">&quot;price&quot;</span>)) ;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">fcount</span> <span class="operator">=</span> Integer.parseInt(request.getParameter(<span class="string">&quot;fcount&quot;</span>));</span><br><span class="line">        <span class="type">String</span> <span class="variable">remark</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;remark&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Fruit</span> <span class="variable">fruit</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Fruit</span>(<span class="number">0</span>,fname , price , fcount , remark ) ;</span><br><span class="line"></span><br><span class="line">        fruitDAO.addFruit(fruit);</span><br><span class="line"></span><br><span class="line">        response.sendRedirect(<span class="string">&quot;fruit.do&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">index</span><span class="params">(HttpServletRequest request , HttpServletResponse response)</span><span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession() ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置当前页，默认值1</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">pageNo</span> <span class="operator">=</span> <span class="number">1</span> ;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">oper</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;oper&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果oper!=null 说明 通过表单的查询按钮点击过来的</span></span><br><span class="line">        <span class="comment">//如果oper是空的，说明 不是通过表单的查询按钮点击过来的</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">keyword</span> <span class="operator">=</span> <span class="literal">null</span> ;</span><br><span class="line">        <span class="keyword">if</span>(StringUtil.isNotEmpty(oper) &amp;&amp; <span class="string">&quot;search&quot;</span>.equals(oper))&#123;</span><br><span class="line">            <span class="comment">//说明是点击表单查询发送过来的请求</span></span><br><span class="line">            <span class="comment">//此时，pageNo应该还原为1 ， keyword应该从请求参数中获取</span></span><br><span class="line">            pageNo = <span class="number">1</span> ;</span><br><span class="line">            keyword = request.getParameter(<span class="string">&quot;keyword&quot;</span>);</span><br><span class="line">            <span class="comment">//如果keyword为null，需要设置为空字符串&quot;&quot;，否则查询时会拼接成 %null% , 我们期望的是 %%</span></span><br><span class="line">            <span class="keyword">if</span>(StringUtil.isEmpty(keyword))&#123;</span><br><span class="line">                keyword = <span class="string">&quot;&quot;</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将keyword保存（覆盖）到session中</span></span><br><span class="line">            session.setAttribute(<span class="string">&quot;keyword&quot;</span>,keyword);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//说明此处不是点击表单查询发送过来的请求（比如点击下面的上一页下一页或者直接在地址栏输入网址）</span></span><br><span class="line">            <span class="comment">//此时keyword应该从session作用域获取</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">pageNoStr</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;pageNo&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span>(StringUtil.isNotEmpty(pageNoStr))&#123;</span><br><span class="line">                pageNo = Integer.parseInt(pageNoStr);   <span class="comment">//如果从请求中读取到pageNo，则类型转换。否则，pageNo默认就是1</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果不是点击的查询按钮，那么查询是基于session中保存的现有keyword进行查询</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">keywordObj</span> <span class="operator">=</span> session.getAttribute(<span class="string">&quot;keyword&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span>(keywordObj!=<span class="literal">null</span>)&#123;</span><br><span class="line">                keyword = (String)keywordObj ;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                keyword = <span class="string">&quot;&quot;</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 重新更新当前页的值</span></span><br><span class="line">        session.setAttribute(<span class="string">&quot;pageNo&quot;</span>,pageNo);</span><br><span class="line"></span><br><span class="line">        <span class="type">FruitDAO</span> <span class="variable">fruitDAO</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FruitDAOImpl</span>();</span><br><span class="line">        List&lt;Fruit&gt; fruitList = fruitDAO.getFruitList(keyword , pageNo);</span><br><span class="line">        session.setAttribute(<span class="string">&quot;fruitList&quot;</span>,fruitList);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//总记录条数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">fruitCount</span> <span class="operator">=</span> fruitDAO.getFruitCount(keyword);</span><br><span class="line">        <span class="comment">//总页数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">pageCount</span> <span class="operator">=</span> (fruitCount+<span class="number">5</span>-<span class="number">1</span>)/<span class="number">5</span> ;</span><br><span class="line">      </span><br><span class="line">        session.setAttribute(<span class="string">&quot;pageCount&quot;</span>,pageCount);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">super</span>.processTemplate(<span class="string">&quot;index&quot;</span>,request,response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="applicationContext-xml"><a href="#applicationContext-xml" class="headerlink" title="applicationContext.xml"></a>applicationContext.xml</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 这个bean标签的作用是 将来servletpath中涉及的名字对应的是fruit，那么就要FruitController这个类来处理 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;fruit&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.fruit.controllers.FruitController&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">1.概念</span></span><br><span class="line"><span class="comment">HTML : 超文本标记语言</span></span><br><span class="line"><span class="comment">XML : 可扩展的标记语言 （标签名字可自定义）</span></span><br><span class="line"><span class="comment">HTML是XML的一个子集</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2.XML包含三个部分：</span></span><br><span class="line"><span class="comment">1) XML声明 ， 而且声明这一行代码必须在XML文件的第一行</span></span><br><span class="line"><span class="comment">2) DTD 文档类型定义</span></span><br><span class="line"><span class="comment">3) XML正文</span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br></pre></td></tr></table></figure><h3 id="思路即问题的总结"><a href="#思路即问题的总结" class="headerlink" title="思路即问题的总结"></a>思路即问题的总结</h3><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>DispatcherServlet继承HttpServlet</p><ul><li>中央控制器接受所有客户端发来的操作请求</li><li>其中的init方法初始化方法：从xml中读取控制器（类名和位置），创建控制器实例，将所有实例保存至beanMap中</li><li>service方法将请求中的具体的“xxx.do”,“xxx”字符是具体的控制器名称，可在beanMap中得到相应实例，之后在获取请求中operate具体的操作进行调用实例中的方法</li></ul><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><ul><li>ServletContext在启动时自动调用init方法创建</li><li>FruitServlet是被DispatcherServlet调用的，不在是一个Sevlet组件，ServletContext没有被创建</li><li>在控制器自定义setServletContext方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//之前FruitServlet是一个Sevlet组件，那么其中的init方法一定会被调用 ，创建ServletContext</span></span><br><span class="line"><span class="comment">//之前的init方法内部会出现一句话：super.init();</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FruitController</span> <span class="keyword">extends</span> <span class="title class_">ViewBaseServlet</span> &#123;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span> ServletContext servletContext ;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setServletContext</span><span class="params">(ServletContext servletContext)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">    <span class="built_in">this</span>.servletContext = servletContext;</span><br><span class="line">    <span class="built_in">super</span>.init(servletContext);  <span class="comment">//将servletContext传ViewBaseServlet，thyemleaf为了渲染数据到网页</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>DispatcherServlet是一个Sevlet组件，在这里可以得到ServletContext，通过调用setServletContextMethod传给控制器</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">                    <span class="type">Class</span> <span class="variable">controllerBeanClass</span> <span class="operator">=</span> Class.forName(className);</span><br><span class="line">                    <span class="type">Object</span> <span class="variable">beanObj</span> <span class="operator">=</span> controllerBeanClass.newInstance() ; </span><br><span class="line"><span class="type">Method</span> <span class="variable">setServletContextMethod</span> <span class="operator">=</span> controllerBeanClass.getDeclaredMethod(<span class="string">&quot;setServletContext&quot;</span>,ServletContext.class);<span class="comment">//方法名 ，参数</span></span><br><span class="line">                    setServletContextMethod.invoke(beanObj , <span class="built_in">this</span>.getServletContext());</span><br></pre></td></tr></table></figure><h2 id="水果系统-优化2-5"><a href="#水果系统-优化2-5" class="headerlink" title="水果系统-优化2.5"></a>水果系统-优化2.5</h2><h3 id="DispatcherServlet-1"><a href="#DispatcherServlet-1" class="headerlink" title="DispatcherServlet"></a>DispatcherServlet</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;*.do&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DispatcherServlet</span> <span class="keyword">extends</span> <span class="title class_">ViewBaseServlet</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,Object&gt; beanMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DispatcherServlet</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">        <span class="built_in">super</span>.init();  <span class="comment">//调用ViewBaseServlet方法进行初始化，为了渲染数据和重定向</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> getClass().getClassLoader().getResourceAsStream(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">            <span class="comment">//1.创建DocumentBuilderFactory</span></span><br><span class="line">            <span class="type">DocumentBuilderFactory</span> <span class="variable">documentBuilderFactory</span> <span class="operator">=</span> DocumentBuilderFactory.newInstance();</span><br><span class="line">            <span class="comment">//2.创建DocumentBuilder对象</span></span><br><span class="line">            <span class="type">DocumentBuilder</span> <span class="variable">documentBuilder</span> <span class="operator">=</span> documentBuilderFactory.newDocumentBuilder() ;</span><br><span class="line">            <span class="comment">//3.创建Document对象</span></span><br><span class="line">            <span class="type">Document</span> <span class="variable">document</span> <span class="operator">=</span> documentBuilder.parse(inputStream);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//4.获取所有的bean节点</span></span><br><span class="line">            <span class="type">NodeList</span> <span class="variable">beanNodeList</span> <span class="operator">=</span> document.getElementsByTagName(<span class="string">&quot;bean&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i&lt;beanNodeList.getLength() ; i++)&#123;</span><br><span class="line">                <span class="type">Node</span> <span class="variable">beanNode</span> <span class="operator">=</span> beanNodeList.item(i);</span><br><span class="line">                <span class="keyword">if</span>(beanNode.getNodeType() == Node.ELEMENT_NODE)&#123;</span><br><span class="line">                    <span class="type">Element</span> <span class="variable">beanElement</span> <span class="operator">=</span> (Element)beanNode ;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">beanId</span> <span class="operator">=</span>  beanElement.getAttribute(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">                    <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> beanElement.getAttribute(<span class="string">&quot;class&quot;</span>);</span><br><span class="line">                    <span class="type">Class</span> <span class="variable">controllerBeanClass</span> <span class="operator">=</span> Class.forName(className);</span><br><span class="line">                    <span class="type">Object</span> <span class="variable">beanObj</span> <span class="operator">=</span> controllerBeanClass.newInstance();</span><br><span class="line"></span><br><span class="line">                    beanMap.put(beanId , beanObj) ;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//设置编码--统一设置编码</span></span><br><span class="line">        request.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="type">String</span> <span class="variable">servletPath</span> <span class="operator">=</span> request.getServletPath();</span><br><span class="line">        servletPath = servletPath.substring(<span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">lastDotIndex</span> <span class="operator">=</span> servletPath.lastIndexOf(<span class="string">&quot;.do&quot;</span>) ;</span><br><span class="line">        servletPath = servletPath.substring(<span class="number">0</span>,lastDotIndex);</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">controllerBeanObj</span> <span class="operator">=</span> beanMap.get(servletPath);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">operate</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;operate&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(StringUtil.isEmpty(operate))&#123;</span><br><span class="line">            operate = <span class="string">&quot;index&quot;</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//operate和方法名一样，所以通过反射获取</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> controllerBeanObj.getClass().getDeclaredMethod(operate,HttpServletRequest.class);</span><br><span class="line">            <span class="keyword">if</span>(method!=<span class="literal">null</span>)&#123;</span><br><span class="line">                method.setAccessible(<span class="literal">true</span>); <span class="comment">//使其可访问</span></span><br><span class="line">                <span class="comment">//调用后得到返回值，进行解析，可知是服务器还是客户端转发</span></span><br><span class="line">                <span class="type">Object</span> <span class="variable">returnObj</span> <span class="operator">=</span> method.invoke(controllerBeanObj, request);</span><br><span class="line"><span class="type">String</span> <span class="variable">methodReturnStr</span> <span class="operator">=</span> (String)returnObj;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(methodReturnStr.startsWith(<span class="string">&quot;Redirect:&quot;</span>))&#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">redirectStr</span> <span class="operator">=</span> methodReturnStr.substring(<span class="string">&quot;Redirect:&quot;</span>.length());</span><br><span class="line">                    response.sendRedirect(redirectStr);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="built_in">super</span>.processTemplate(methodReturnStr,request,response);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;operate值非法!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="FruitController-1"><a href="#FruitController-1" class="headerlink" title="FruitController"></a>FruitController</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FruitController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">FruitDAO</span> <span class="variable">fruitDAO</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FruitDAOImpl</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">update</span><span class="params">(HttpServletRequest request)</span>&#123;</span><br><span class="line">        <span class="comment">//1.设置编码 --中央控制器统一设置</span></span><br><span class="line">        <span class="comment">//request.setCharacterEncoding(&quot;utf-8&quot;);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.获取参数</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">fidStr</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;fid&quot;</span>);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">fid</span> <span class="operator">=</span> Integer.parseInt(fidStr);</span><br><span class="line">        <span class="type">String</span> <span class="variable">fname</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;fname&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">priceStr</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;price&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">price</span> <span class="operator">=</span> Integer.parseInt(priceStr);</span><br><span class="line">        <span class="type">String</span> <span class="variable">fcountStr</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;fcount&quot;</span>);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">fcount</span> <span class="operator">=</span> Integer.parseInt(fcountStr);</span><br><span class="line">        <span class="type">String</span> <span class="variable">remark</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;remark&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.执行更新</span></span><br><span class="line">        fruitDAO.updateFruit(<span class="keyword">new</span> <span class="title class_">Fruit</span>(fid,fname, price ,fcount ,remark ));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.资源跳转</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Redirect:fruit.do&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">edit</span><span class="params">(HttpServletRequest request )</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">fidStr</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;fid&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(StringUtil.isNotEmpty(fidStr))&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">fid</span> <span class="operator">=</span> Integer.parseInt(fidStr);</span><br><span class="line">            <span class="type">Fruit</span> <span class="variable">fruit</span> <span class="operator">=</span> fruitDAO.getFruitByFid(fid);</span><br><span class="line">            request.setAttribute(<span class="string">&quot;fruit&quot;</span>,fruit);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;edit&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">del</span><span class="params">(HttpServletRequest request )</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">fidStr</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;fid&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(StringUtil.isNotEmpty(fidStr))&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">fid</span> <span class="operator">=</span> Integer.parseInt(fidStr);</span><br><span class="line">            fruitDAO.delFruit(fid);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//super.processTemplate(&quot;index&quot;,request,response);</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Redirect:fruit.do&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">add</span><span class="params">(HttpServletRequest request)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">fname</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;fname&quot;</span>);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">price</span> <span class="operator">=</span> Integer.parseInt(request.getParameter(<span class="string">&quot;price&quot;</span>)) ;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">fcount</span> <span class="operator">=</span> Integer.parseInt(request.getParameter(<span class="string">&quot;fcount&quot;</span>));</span><br><span class="line">        <span class="type">String</span> <span class="variable">remark</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;remark&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Fruit</span> <span class="variable">fruit</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Fruit</span>(<span class="number">0</span>,fname , price , fcount , remark ) ;</span><br><span class="line"></span><br><span class="line">        fruitDAO.addFruit(fruit);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Redirect:fruit.do&quot;</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">index</span><span class="params">(HttpServletRequest request )</span>&#123;</span><br><span class="line">        <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession() ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置当前页，默认值1</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">pageNo</span> <span class="operator">=</span> <span class="number">1</span> ;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">oper</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;oper&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果oper!=null 说明 通过表单的查询按钮点击过来的</span></span><br><span class="line">        <span class="comment">//如果oper是空的，说明 不是通过表单的查询按钮点击过来的</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">keyword</span> <span class="operator">=</span> <span class="literal">null</span> ;</span><br><span class="line">        <span class="keyword">if</span>(StringUtil.isNotEmpty(oper) &amp;&amp; <span class="string">&quot;search&quot;</span>.equals(oper))&#123;</span><br><span class="line">            <span class="comment">//说明是点击表单查询发送过来的请求</span></span><br><span class="line">            <span class="comment">//此时，pageNo应该还原为1 ， keyword应该从请求参数中获取</span></span><br><span class="line">            pageNo = <span class="number">1</span> ;</span><br><span class="line">            keyword = request.getParameter(<span class="string">&quot;keyword&quot;</span>);</span><br><span class="line">            <span class="comment">//如果keyword为null，需要设置为空字符串&quot;&quot;，否则查询时会拼接成 %null% , 我们期望的是 %%</span></span><br><span class="line">            <span class="keyword">if</span>(StringUtil.isEmpty(keyword))&#123;</span><br><span class="line">                keyword = <span class="string">&quot;&quot;</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将keyword保存（覆盖）到session中</span></span><br><span class="line">            session.setAttribute(<span class="string">&quot;keyword&quot;</span>,keyword);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//说明此处不是点击表单查询发送过来的请求（比如点击下面的上一页下一页或者直接在地址栏输入网址）</span></span><br><span class="line">            <span class="comment">//此时keyword应该从session作用域获取</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">pageNoStr</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;pageNo&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span>(StringUtil.isNotEmpty(pageNoStr))&#123;</span><br><span class="line">                pageNo = Integer.parseInt(pageNoStr);   <span class="comment">//如果从请求中读取到pageNo，则类型转换。否则，pageNo默认就是1</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果不是点击的查询按钮，那么查询是基于session中保存的现有keyword进行查询</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">keywordObj</span> <span class="operator">=</span> session.getAttribute(<span class="string">&quot;keyword&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span>(keywordObj!=<span class="literal">null</span>)&#123;</span><br><span class="line">                keyword = (String)keywordObj ;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                keyword = <span class="string">&quot;&quot;</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 重新更新当前页的值</span></span><br><span class="line">        session.setAttribute(<span class="string">&quot;pageNo&quot;</span>,pageNo);</span><br><span class="line"></span><br><span class="line">        <span class="type">FruitDAO</span> <span class="variable">fruitDAO</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FruitDAOImpl</span>();</span><br><span class="line">        List&lt;Fruit&gt; fruitList = fruitDAO.getFruitList(keyword , pageNo);</span><br><span class="line">        session.setAttribute(<span class="string">&quot;fruitList&quot;</span>,fruitList);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//总记录条数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">fruitCount</span> <span class="operator">=</span> fruitDAO.getFruitCount(keyword);</span><br><span class="line">        <span class="comment">//总页数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">pageCount</span> <span class="operator">=</span> (fruitCount+<span class="number">5</span>-<span class="number">1</span>)/<span class="number">5</span> ;</span><br><span class="line"></span><br><span class="line">        session.setAttribute(<span class="string">&quot;pageCount&quot;</span>,pageCount);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ViewBaseServlet-2"><a href="#ViewBaseServlet-2" class="headerlink" title="ViewBaseServlet"></a>ViewBaseServlet</h3><p>还原回原最初代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.myssm.myspringmvc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.thymeleaf.TemplateEngine;</span><br><span class="line"><span class="keyword">import</span> org.thymeleaf.context.WebContext;</span><br><span class="line"><span class="keyword">import</span> org.thymeleaf.templatemode.TemplateMode;</span><br><span class="line"><span class="keyword">import</span> org.thymeleaf.templateresolver.ServletContextTemplateResolver;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletContext;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ViewBaseServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TemplateEngine templateEngine;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.获取ServletContext对象</span></span><br><span class="line">        <span class="type">ServletContext</span> <span class="variable">servletContext</span> <span class="operator">=</span> <span class="built_in">this</span>.getServletContext();</span><br><span class="line">        <span class="comment">// 2.创建Thymeleaf解析器对象</span></span><br><span class="line">        <span class="type">ServletContextTemplateResolver</span> <span class="variable">templateResolver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServletContextTemplateResolver</span>(servletContext);</span><br><span class="line">        <span class="comment">// 3.给解析器对象设置参数</span></span><br><span class="line">        <span class="comment">// ①HTML是默认模式，明确设置是为了代码更容易理解</span></span><br><span class="line">        templateResolver.setTemplateMode(TemplateMode.HTML);</span><br><span class="line">        <span class="comment">// ②设置前缀</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">viewPrefix</span> <span class="operator">=</span> servletContext.getInitParameter(<span class="string">&quot;view-prefix&quot;</span>);</span><br><span class="line">        templateResolver.setPrefix(viewPrefix);</span><br><span class="line">        <span class="comment">// ③设置后缀</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">viewSuffix</span> <span class="operator">=</span> servletContext.getInitParameter(<span class="string">&quot;view-suffix&quot;</span>);</span><br><span class="line">        templateResolver.setSuffix(viewSuffix);</span><br><span class="line">        <span class="comment">// ④设置缓存过期时间（毫秒）</span></span><br><span class="line">        templateResolver.setCacheTTLMs(<span class="number">60000L</span>);</span><br><span class="line">        <span class="comment">// ⑤设置是否缓存</span></span><br><span class="line">        templateResolver.setCacheable(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">// ⑥设置服务器端编码方式</span></span><br><span class="line">        templateResolver.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        <span class="comment">// 4.创建模板引擎对象</span></span><br><span class="line">        templateEngine = <span class="keyword">new</span> <span class="title class_">TemplateEngine</span>();</span><br><span class="line">        <span class="comment">// 5.给模板引擎对象设置模板解析器</span></span><br><span class="line">        templateEngine.setTemplateResolver(templateResolver);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">processTemplate</span><span class="params">(String templateName, HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 1.设置响应体内容类型和字符集 --中央控制器设置也可以</span></span><br><span class="line">        resp.setContentType(<span class="string">&quot;text/html;charset=UTF-8&quot;</span>);</span><br><span class="line">        <span class="comment">// 2.创建WebContext对象</span></span><br><span class="line">        <span class="type">WebContext</span> <span class="variable">webContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WebContext</span>(req, resp, <span class="built_in">this</span>.getServletContext());</span><br><span class="line">        <span class="comment">// 3.处理模板数据</span></span><br><span class="line">        templateEngine.process(templateName, webContext, resp.getWriter());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>优化2.5在优化2上做出的改进，目的是将FruitController和DispatcherServlet低耦合，使FruitController尽量变成普通的类，使代码更加简洁</p><p>思路：</p><ul><li>DispatcherServlet继承ViewBaseServlet，它来调用init（），继续对数据的服务端数据的渲染和转发重定向</li><li>DispatcherServlet来进行重定向的调用，即要求控制器相关功能方法返回字符串（代表服务端或客户端转发）</li></ul><h2 id="水果系统-优化3"><a href="#水果系统-优化3" class="headerlink" title="水果系统-优化3"></a>水果系统-优化3</h2><h3 id="DispatcherServlet-2"><a href="#DispatcherServlet-2" class="headerlink" title="DispatcherServlet"></a>DispatcherServlet</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;*.do&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DispatcherServlet</span> <span class="keyword">extends</span> <span class="title class_">ViewBaseServlet</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,Object&gt; beanMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DispatcherServlet</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">        <span class="built_in">super</span>.init();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> getClass().getClassLoader().getResourceAsStream(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">            <span class="comment">//1.创建DocumentBuilderFactory</span></span><br><span class="line">            <span class="type">DocumentBuilderFactory</span> <span class="variable">documentBuilderFactory</span> <span class="operator">=</span> DocumentBuilderFactory.newInstance();</span><br><span class="line">            <span class="comment">//2.创建DocumentBuilder对象</span></span><br><span class="line">            <span class="type">DocumentBuilder</span> <span class="variable">documentBuilder</span> <span class="operator">=</span> documentBuilderFactory.newDocumentBuilder() ;</span><br><span class="line">            <span class="comment">//3.创建Document对象</span></span><br><span class="line">            <span class="type">Document</span> <span class="variable">document</span> <span class="operator">=</span> documentBuilder.parse(inputStream);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//4.获取所有的bean节点</span></span><br><span class="line">            <span class="type">NodeList</span> <span class="variable">beanNodeList</span> <span class="operator">=</span> document.getElementsByTagName(<span class="string">&quot;bean&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i&lt;beanNodeList.getLength() ; i++)&#123;</span><br><span class="line">                <span class="type">Node</span> <span class="variable">beanNode</span> <span class="operator">=</span> beanNodeList.item(i);</span><br><span class="line">                <span class="keyword">if</span>(beanNode.getNodeType() == Node.ELEMENT_NODE)&#123;</span><br><span class="line">                    <span class="type">Element</span> <span class="variable">beanElement</span> <span class="operator">=</span> (Element)beanNode ;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">beanId</span> <span class="operator">=</span>  beanElement.getAttribute(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">                    <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> beanElement.getAttribute(<span class="string">&quot;class&quot;</span>);</span><br><span class="line">                    <span class="type">Class</span> <span class="variable">controllerBeanClass</span> <span class="operator">=</span> Class.forName(className);</span><br><span class="line">                    <span class="type">Object</span> <span class="variable">beanObj</span> <span class="operator">=</span> controllerBeanClass.newInstance() ;</span><br><span class="line">                    beanMap.put(beanId , beanObj) ;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//设置编码</span></span><br><span class="line">        request.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="type">String</span> <span class="variable">servletPath</span> <span class="operator">=</span> request.getServletPath();</span><br><span class="line">        servletPath = servletPath.substring(<span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">lastDotIndex</span> <span class="operator">=</span> servletPath.lastIndexOf(<span class="string">&quot;.do&quot;</span>) ;</span><br><span class="line">        servletPath = servletPath.substring(<span class="number">0</span>,lastDotIndex);</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">controllerBeanObj</span> <span class="operator">=</span> beanMap.get(servletPath);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">operate</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;operate&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(StringUtil.isEmpty(operate))&#123;</span><br><span class="line">            operate = <span class="string">&quot;index&quot;</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Method[] methods = controllerBeanObj.getClass().getDeclaredMethods();</span><br><span class="line">            <span class="keyword">for</span>(Method method : methods)&#123;</span><br><span class="line">                <span class="keyword">if</span>(operate.equals(method.getName()))&#123;</span><br><span class="line">                    <span class="comment">//1.统一获取请求参数</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">//1-1.获取当前方法的参数，返回参数数组</span></span><br><span class="line">                    Parameter[] parameters = method.getParameters();</span><br><span class="line">                    <span class="comment">//1-2.parameterValues 用来承载参数的值</span></span><br><span class="line">                    Object[] parameterValues = <span class="keyword">new</span> <span class="title class_">Object</span>[parameters.length];</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; parameters.length; i++) &#123;</span><br><span class="line">                        <span class="type">Parameter</span> <span class="variable">parameter</span> <span class="operator">=</span> parameters[i];</span><br><span class="line">                        <span class="type">String</span> <span class="variable">parameterName</span> <span class="operator">=</span> parameter.getName() ;</span><br><span class="line">                        <span class="comment">//如果参数名是request,response,session 那么就不是通过请求中获取参数的方式了</span></span><br><span class="line">                        <span class="keyword">if</span>(<span class="string">&quot;request&quot;</span>.equals(parameterName))&#123;</span><br><span class="line">                            parameterValues[i] = request ;</span><br><span class="line">                        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;response&quot;</span>.equals(parameterName))&#123;</span><br><span class="line">                            parameterValues[i] = response ;</span><br><span class="line">                        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;session&quot;</span>.equals(parameterName))&#123;</span><br><span class="line">                            parameterValues[i] = request.getSession() ;</span><br><span class="line">                        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                            <span class="comment">//从请求中获取参数值</span></span><br><span class="line">                            <span class="type">String</span> <span class="variable">parameterValue</span> <span class="operator">=</span> request.getParameter(parameterName);</span><br><span class="line">                            <span class="type">String</span> <span class="variable">typeName</span> <span class="operator">=</span> parameter.getType().getName();</span><br><span class="line"></span><br><span class="line">                            <span class="type">Object</span> <span class="variable">parameterObj</span> <span class="operator">=</span> parameterValue ;</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">if</span>(parameterObj!=<span class="literal">null</span>) &#123; <span class="comment">//该项目只涉及Integer和String类型</span></span><br><span class="line">                                <span class="keyword">if</span> (<span class="string">&quot;java.lang.Integer&quot;</span>.equals(typeName)) &#123;</span><br><span class="line">                                    parameterObj = Integer.parseInt(parameterValue);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                            parameterValues[i] = parameterObj ;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//2.controller组件中的方法调用</span></span><br><span class="line">                    method.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                    <span class="type">Object</span> <span class="variable">returnObj</span> <span class="operator">=</span> method.invoke(controllerBeanObj,parameterValues);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//3.视图处理</span></span><br><span class="line">                    <span class="type">String</span> <span class="variable">methodReturnStr</span> <span class="operator">=</span> (String)returnObj ;</span><br><span class="line">                    <span class="keyword">if</span>(methodReturnStr.startsWith(<span class="string">&quot;redirect:&quot;</span>))&#123;        <span class="comment">//比如：  redirect:fruit.do</span></span><br><span class="line">                        <span class="type">String</span> <span class="variable">redirectStr</span> <span class="operator">=</span> methodReturnStr.substring(<span class="string">&quot;redirect:&quot;</span>.length());</span><br><span class="line">                        response.sendRedirect(redirectStr);</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="built_in">super</span>.processTemplate(methodReturnStr,request,response);    <span class="comment">// 比如：  &quot;edit&quot;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            &#125;else&#123;</span></span><br><span class="line"><span class="comment">                throw new RuntimeException(&quot;operate值非法!&quot;);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 常见错误： IllegalArgumentException: argument type mismatch</span></span><br></pre></td></tr></table></figure><h3 id="FruitController-2"><a href="#FruitController-2" class="headerlink" title="FruitController"></a>FruitController</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FruitController</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">FruitDAO</span> <span class="variable">fruitDAO</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FruitDAOImpl</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">update</span><span class="params">(Integer fid , String fname , Integer price , Integer fcount , String remark )</span>&#123;</span><br><span class="line">        <span class="comment">//3.执行更新</span></span><br><span class="line">        fruitDAO.updateFruit(<span class="keyword">new</span> <span class="title class_">Fruit</span>(fid,fname, price ,fcount ,remark ));</span><br><span class="line">        <span class="comment">//4.资源跳转</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;redirect:fruit.do&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">edit</span><span class="params">(Integer fid , HttpServletRequest request)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(fid!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">Fruit</span> <span class="variable">fruit</span> <span class="operator">=</span> fruitDAO.getFruitByFid(fid);</span><br><span class="line">            request.setAttribute(<span class="string">&quot;fruit&quot;</span>,fruit);</span><br><span class="line">            <span class="comment">//super.processTemplate(&quot;edit&quot;,request,response);</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;edit&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;error&quot;</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">del</span><span class="params">(Integer fid  )</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(fid!=<span class="literal">null</span>)&#123;</span><br><span class="line">            fruitDAO.delFruit(fid);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;redirect:fruit.do&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;error&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">add</span><span class="params">(String fname , Integer price , Integer fcount , String remark )</span> &#123;</span><br><span class="line">        <span class="type">Fruit</span> <span class="variable">fruit</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Fruit</span>(<span class="number">0</span>,fname , price , fcount , remark ) ;</span><br><span class="line">        fruitDAO.addFruit(fruit);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;redirect:fruit.do&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">index</span><span class="params">(String oper , String keyword , Integer pageNo , HttpServletRequest request )</span> &#123;</span><br><span class="line">        <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession() ;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(pageNo==<span class="literal">null</span>)&#123;</span><br><span class="line">            pageNo = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(StringUtil.isNotEmpty(oper) &amp;&amp; <span class="string">&quot;search&quot;</span>.equals(oper))&#123;</span><br><span class="line">            pageNo = <span class="number">1</span> ;</span><br><span class="line">            <span class="keyword">if</span>(StringUtil.isEmpty(keyword))&#123;</span><br><span class="line">                keyword = <span class="string">&quot;&quot;</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            session.setAttribute(<span class="string">&quot;keyword&quot;</span>,keyword);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">keywordObj</span> <span class="operator">=</span> session.getAttribute(<span class="string">&quot;keyword&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span>(keywordObj!=<span class="literal">null</span>)&#123;</span><br><span class="line">                keyword = (String)keywordObj ;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                keyword = <span class="string">&quot;&quot;</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重新更新当前页的值</span></span><br><span class="line">        session.setAttribute(<span class="string">&quot;pageNo&quot;</span>,pageNo);</span><br><span class="line"></span><br><span class="line">        <span class="type">FruitDAO</span> <span class="variable">fruitDAO</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FruitDAOImpl</span>();</span><br><span class="line">        List&lt;Fruit&gt; fruitList = fruitDAO.getFruitList(keyword , pageNo);</span><br><span class="line">        session.setAttribute(<span class="string">&quot;fruitList&quot;</span>,fruitList);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//总记录条数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">fruitCount</span> <span class="operator">=</span> fruitDAO.getFruitCount(keyword);</span><br><span class="line">        <span class="comment">//总页数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">pageCount</span> <span class="operator">=</span> (fruitCount+<span class="number">5</span>-<span class="number">1</span>)/<span class="number">5</span> ;</span><br><span class="line">        session.setAttribute(<span class="string">&quot;pageCount&quot;</span>,pageCount);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;index&quot;</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>在优化2.5之上做出改进，将FruitController和DispatcherServlet实现低耦合，使FruitController变成普通的类，代码变得简洁，将冗余的操作放在中央控制器DispatcherServlet去执行</p><ul><li>获取参数名是request,response,session</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="string">&quot;request&quot;</span>.equals(parameterName))&#123;</span><br><span class="line">                      parameterValues[i] = request ;</span><br><span class="line">                  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;response&quot;</span>.equals(parameterName))&#123;</span><br><span class="line">                      parameterValues[i] = response ;</span><br><span class="line">                  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;session&quot;</span>.equals(parameterName))&#123;</span><br><span class="line">                      parameterValues[i] = request.getSession() ;</span><br><span class="line">                  &#125;</span><br></pre></td></tr></table></figure><ul><li>获取请求request中参数</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">parameterValue</span> <span class="operator">=</span> request.getParameter(parameterName); <span class="comment">//根据参数名获取参数值</span></span><br><span class="line">         <span class="type">String</span> <span class="variable">typeName</span> <span class="operator">=</span> parameter.getType().getName(); <span class="comment">//获取参数类型名</span></span><br><span class="line">         <span class="type">Object</span> <span class="variable">parameterObj</span> <span class="operator">=</span> parameterValue ;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span>(parameterObj!=<span class="literal">null</span>) &#123; <span class="comment">//该项目只涉及Integer和String类型</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="string">&quot;java.lang.Integer&quot;</span>.equals(typeName)) &#123;<span class="comment">//将String类型的转为Integer类型</span></span><br><span class="line">                       parameterObj = Integer.parseInt(parameterValue);</span><br><span class="line">                  &#125;</span><br><span class="line">             &#125;</span><br><span class="line">                     parameterValues[i] = parameterObj ; <span class="comment">//放入参数数组</span></span><br><span class="line"> </span><br><span class="line">             <span class="comment">//2.controller组件中的方法调用</span></span><br><span class="line">             method.setAccessible(<span class="literal">true</span>);</span><br><span class="line">             <span class="type">Object</span> <span class="variable">returnObj</span> <span class="operator">=</span> method.invoke(controllerBeanObj,parameterValues);</span><br></pre></td></tr></table></figure><ul><li>问题：idea编译器默认是不编译参数的名称的，默认将参数名称变为arg0，arg1，arg2……..</li></ul><p>可在setting设置中进行修改编译器的编译信息，将参数名称添加到编译中</p><p><img src="/2022/09/30/JavaWeb/image-20220705231754207.png" alt="image-20220705231754207"></p><h2 id="复习总结"><a href="#复习总结" class="headerlink" title="复习总结"></a>复习总结</h2><p>review:</p><ol><li>最初的做法是： 一个请求对应一个Servlet，这样存在的问题是servlet太多了</li><li>把一些列的请求都对应一个Servlet，<br>IndexServlet&#x2F;AddServlet&#x2F;EditServlet&#x2F;DelServlet&#x2F;UpdateServlet -&gt; 合并成FruitServlet<br>通过一个operate的值来决定调用FruitServlet中的哪一个方法<br>使用的是switch-case</li><li>在上一个版本中，Servlet中充斥着大量的switch-case，试想一下，随着我们的项目的业务规模扩大，那么会有很多的Servlet，也就意味着会有很多的switch-case，这是一种代码冗余<br>因此，我们在servlet中使用了反射技术，我们规定operate的值和方法名一致，那么接收到operate的值是什么就表明我们需要调用对应的方法进行响应，如果找不到对应的方法，则抛异常</li><li>在上一个版本中我们使用了反射技术，但是其实还是存在一定的问题：每一个servlet中都有类似的反射技术的代码。因此继续抽取，设计了中央控制器类：DispatcherServlet<br>DispatcherServlet这个类的工作分为两大部分：<br>1.根据url定位到能够处理这个请求的controller组件：<br> 1)从url中提取servletPath : &#x2F;fruit.do -&gt; fruit<br> 2)根据fruit找到对应的组件:FruitController ， 这个对应的依据我们存储在applicationContext.xml中<br>   &lt;bean id&#x3D;”fruit” class&#x3D;”com.atguigu.fruit.controllers.FruitController&#x2F;&gt;<br>   通过DOM技术我们去解析XML文件，在中央控制器中形成一个beanMap容器，用来存放所有的Controller组件<br> 3)根据获取到的operate的值定位到我们FruitController中需要调用的方法<br>2.调用Controller组件中的方法：<ol><li>获取参数<br>获取即将要调用的方法的参数签名信息: Parameter[] parameters &#x3D; method.getParameters();<br>通过parameter.getName()获取参数的名称；<br>准备了Object[] parameterValues 这个数组用来存放对应参数的参数值<br>另外，我们需要考虑参数的类型问题，需要做类型转化的工作。通过parameter.getType()获取参数的类型</li><li>执行方法<br>Object returnObj &#x3D; method.invoke(controllerBean , parameterValues);</li><li>视图处理<br>String returnStr &#x3D; (String)returnObj;<br>if(returnStr.startWith(“redirect:”)){<br> ….<br>}else if…..</li></ol></li></ol><h1 id="再次学习Servlet的初始化方法"><a href="#再次学习Servlet的初始化方法" class="headerlink" title="再次学习Servlet的初始化方法"></a>再次学习Servlet的初始化方法</h1><ol><li>Servlet生命周期：实例化、初始化、服务、销毁</li></ol><ol start="2"><li>Servlet中的初始化方法有两个：init() , init(config)<br>  其中带参数的方法代码如下： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ServletConfig config)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line"><span class="built_in">this</span>.config = config ;</span><br><span class="line">init();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>  另外一个无参的init方法如下： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  如果我们想要在Servlet初始化时做一些准备工作，那么我们可以重写init方法<br>  我们可以通过如下步骤去获取初始化设置的数据</li></ol><ul><li>获取config对象：ServletConfig config &#x3D; getServletConfig();</li><li>获取初始化参数值： config.getInitParameter(key);</li></ul><ol start="3"><li><p>在web.xml文件中配置Servlet</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>Demo01Servlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.atguigu.servlet.Demo01Servlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>world<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>uname<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>jim<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>Demo01Servlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/demo01<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>也可以通过注解的方式进行配置：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(urlPatterns = &#123;&quot;/demo01&quot;&#125; ,</span></span><br><span class="line"><span class="meta">initParams = &#123;</span></span><br><span class="line"><span class="meta">    @WebInitParam(name=&quot;hello&quot;,value=&quot;world&quot;),</span></span><br><span class="line"><span class="meta">    @WebInitParam(name=&quot;uname&quot;,value=&quot;jim&quot;)</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br></pre></td></tr></table></figure></li></ol><ol start="5"><li>学习Servlet中的ServletContext和<context-param></context-param></li></ol><ul><li><p>获取ServletContext，有很多方法<br>在初始化方法中： ServletContxt servletContext &#x3D; getServletContext();<br>在服务方法中也可以通过request对象获取，也可以通过session获取：<br>request.getServletContext(); session.getServletContext()</p></li><li><p>获取初始化值：<br>servletContext.getInitParameter();</p></li></ul><h1 id="业务层"><a href="#业务层" class="headerlink" title="业务层"></a>业务层</h1><h2 id="MVC概念解释"><a href="#MVC概念解释" class="headerlink" title="MVC概念解释"></a>MVC概念解释</h2><p>MVC : Model（模型）、View（视图）、Controller（控制器）</p><ul><li>视图层：用于做数据展示以及和用户交互的一个界面</li><li>控制层：能够接受客户端的请求，具体的业务功能还是需要借助于模型组件来完成</li><li>模型层：模型分为很多种：<ul><li>数据访问模型（DAO）</li><li>业务逻辑模型（BO）</li><li>值对象模型（POJO&#x2F;vo(value object)）</li><li>数据传输对象（DTO）</li></ul></li></ul><h2 id="区分业务对象和数据访问对象"><a href="#区分业务对象和数据访问对象" class="headerlink" title="区分业务对象和数据访问对象"></a>区分业务对象和数据访问对象</h2><p>1） DAO中的方法都是单精度方法或者称之为细粒度方法。什么叫单精度？一个方法只考虑一个操作，比如添加，那就是insert操作、查询那就是select操作….<br>2） BO中的方法属于业务方法，也实际的业务是比较复杂的，因此业务方法的粒度是比较粗的</p><p>举例：</p><ul><li><p>注册这个功能属于业务功能，也就是说注册这个方法属于业务方法。那么这个业务方法中包含了多个DAO方法。也就是说注册这个业务功能需要通过多个DAO方法的组合调用，从而完成注册功能的开发。</p><p>注册DAO举例：</p><ul><li>检查用户名是否已经被注册 - DAO中的select操作</li><li>用户表新增一条新用户记录 - DAO中的insert操作</li><li>向用户积分表新增一条记录（新用户默认初始化积分100分） - DAO中的insert操作</li><li>向系统消息表新增一条记录（某某某新用户注册了，需要根据通讯录信息向他的联系人推送消息） - DAO中的insert操作</li><li>向系统日志表新增一条记录（某用户在某IP在某年某月某日某时某分某秒某毫秒注册） - DAO中的insert操作</li><li>….</li></ul></li></ul><h1 id="水果库存系统中添加业务层组件-优化4"><a href="#水果库存系统中添加业务层组件-优化4" class="headerlink" title="水果库存系统中添加业务层组件-优化4"></a>水果库存系统中添加业务层组件-优化4</h1><h2 id="简图1"><a href="#简图1" class="headerlink" title="简图1"></a>简图1</h2><p><img src="/2022/09/30/JavaWeb/image-20220706151602119.png" alt="image-20220706151602119"></p><h2 id="简图2"><a href="#简图2" class="headerlink" title="简图2"></a>简图2</h2><p><img src="/2022/09/30/JavaWeb/image-20220706160218945.png" alt="image-20220706160218945"></p><blockquote><p>尽然减少耦合和依赖，三者之间有依赖关系，这里将三者Fruit加入到applicationContext配置文件中，依赖关系也在这里呈现，最后由ClassPathXmlApplictionContext进行创建实例和建立他们的之间的依赖关系（即对属性赋值）</p></blockquote><h2 id="applicationContext"><a href="#applicationContext" class="headerlink" title="applicationContext"></a>applicationContext</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;fruitDAO&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.fruit.dao.impl.FruitDAOImpl&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;fruitService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.fruit.service.impl.FruitServiceImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- property标签用来表示属性；name表示属性名；ref表示引用其他bean的id值--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;fruitDAO&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;fruitDAO&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;fruit&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.fruit.controllers.FruitController&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;fruitService&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;fruitService&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">Node 节点</span></span><br><span class="line"><span class="comment">    Element 元素节点</span></span><br><span class="line"><span class="comment">    Text 文本节点</span></span><br><span class="line"><span class="comment">&lt;sname&gt;jim&lt;/sname&gt;</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></table></figure><h2 id="ClassPathXmlApplicationContext"><a href="#ClassPathXmlApplicationContext" class="headerlink" title="ClassPathXmlApplicationContext"></a>ClassPathXmlApplicationContext</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassPathXmlApplicationContext</span> <span class="keyword">implements</span> <span class="title class_">BeanFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,Object&gt; beanMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ClassPathXmlApplicationContext</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> getClass().getClassLoader().getResourceAsStream(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">            <span class="comment">//1.创建DocumentBuilderFactory</span></span><br><span class="line">            <span class="type">DocumentBuilderFactory</span> <span class="variable">documentBuilderFactory</span> <span class="operator">=</span> DocumentBuilderFactory.newInstance();</span><br><span class="line">            <span class="comment">//2.创建DocumentBuilder对象</span></span><br><span class="line">            <span class="type">DocumentBuilder</span> <span class="variable">documentBuilder</span> <span class="operator">=</span> documentBuilderFactory.newDocumentBuilder() ;</span><br><span class="line">            <span class="comment">//3.创建Document对象</span></span><br><span class="line">            <span class="type">Document</span> <span class="variable">document</span> <span class="operator">=</span> documentBuilder.parse(inputStream);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//4.获取所有的bean节点</span></span><br><span class="line">            <span class="type">NodeList</span> <span class="variable">beanNodeList</span> <span class="operator">=</span> document.getElementsByTagName(<span class="string">&quot;bean&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i&lt;beanNodeList.getLength() ; i++)&#123;</span><br><span class="line">                <span class="type">Node</span> <span class="variable">beanNode</span> <span class="operator">=</span> beanNodeList.item(i);</span><br><span class="line">                <span class="keyword">if</span>(beanNode.getNodeType() == Node.ELEMENT_NODE)&#123;</span><br><span class="line">                    <span class="type">Element</span> <span class="variable">beanElement</span> <span class="operator">=</span> (Element)beanNode ;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">beanId</span> <span class="operator">=</span>  beanElement.getAttribute(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">                    <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> beanElement.getAttribute(<span class="string">&quot;class&quot;</span>);</span><br><span class="line">                    <span class="type">Class</span> <span class="variable">beanClass</span> <span class="operator">=</span> Class.forName(className);</span><br><span class="line">                    <span class="comment">//创建bean实例</span></span><br><span class="line">                    <span class="type">Object</span> <span class="variable">beanObj</span> <span class="operator">=</span> beanClass.newInstance() ;</span><br><span class="line">                    <span class="comment">//将bean实例对象保存到map容器中</span></span><br><span class="line">                    beanMap.put(beanId , beanObj) ;</span><br><span class="line">                    <span class="comment">//到目前为止，此处需要注意的是，bean和bean之间的依赖关系还没有设置</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//5.组装bean之间的依赖关系</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i&lt;beanNodeList.getLength() ; i++)&#123;</span><br><span class="line">                <span class="type">Node</span> <span class="variable">beanNode</span> <span class="operator">=</span> beanNodeList.item(i);</span><br><span class="line">                <span class="keyword">if</span>(beanNode.getNodeType() == Node.ELEMENT_NODE) &#123;</span><br><span class="line">                    <span class="type">Element</span> <span class="variable">beanElement</span> <span class="operator">=</span> (Element) beanNode;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">beanId</span> <span class="operator">=</span> beanElement.getAttribute(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">                    <span class="type">NodeList</span> <span class="variable">beanChildNodeList</span> <span class="operator">=</span> beanElement.getChildNodes();</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; beanChildNodeList.getLength() ; j++) &#123;</span><br><span class="line">                        <span class="type">Node</span> <span class="variable">beanChildNode</span> <span class="operator">=</span> beanChildNodeList.item(j);</span><br><span class="line">                        <span class="keyword">if</span>(beanChildNode.getNodeType()==Node.ELEMENT_NODE &amp;&amp; <span class="string">&quot;property&quot;</span>.equals(beanChildNode.getNodeName()))&#123;</span><br><span class="line">                            <span class="type">Element</span> <span class="variable">propertyElement</span> <span class="operator">=</span> (Element) beanChildNode;</span><br><span class="line">                            <span class="type">String</span> <span class="variable">propertyName</span> <span class="operator">=</span> propertyElement.getAttribute(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">                            <span class="type">String</span> <span class="variable">propertyRef</span> <span class="operator">=</span> propertyElement.getAttribute(<span class="string">&quot;ref&quot;</span>);</span><br><span class="line">                            <span class="comment">//1) 找到propertyRef对应的实例</span></span><br><span class="line">                            <span class="type">Object</span> <span class="variable">refObj</span> <span class="operator">=</span> beanMap.get(propertyRef);</span><br><span class="line">                            <span class="comment">//2) 将refObj设置到当前bean对应的实例的property属性上去</span></span><br><span class="line">                            <span class="type">Object</span> <span class="variable">beanObj</span> <span class="operator">=</span> beanMap.get(beanId);</span><br><span class="line">                            <span class="type">Class</span> <span class="variable">beanClazz</span> <span class="operator">=</span> beanObj.getClass();</span><br><span class="line">                            <span class="type">Field</span> <span class="variable">propertyField</span> <span class="operator">=</span> beanClazz.getDeclaredField(propertyName);</span><br><span class="line">                            propertyField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                            propertyField.set(beanObj,refObj); <span class="comment">//设置其属性值，完成他们的依赖关系</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getBean</span><span class="params">(String id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> beanMap.get(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h1><h2 id="耦合-x2F-依赖"><a href="#耦合-x2F-依赖" class="headerlink" title="耦合&#x2F;依赖"></a>耦合&#x2F;依赖</h2><p>依赖指的是某某某离不开某某某<br>在软件系统中，层与层之间是存在依赖的。我们也称之为耦合。<br>我们系统架构或者是设计的一个原则是： 高内聚低耦合。<br>层内部的组成应该是高度聚合的，而层与层之间的关系应该是低耦合的，最理想的情况0耦合（就是没有耦合）</p><h2 id="IOC-控制反转："><a href="#IOC-控制反转：" class="headerlink" title="IOC - 控制反转："></a>IOC - 控制反转：</h2><ol><li>之前在Servlet中，我们创建service对象 ， FruitService fruitService &#x3D; new FruitServiceImpl();<ul><li>这句话如果出现在servlet中的某个方法内部，那么这个fruitService的作用域（生命周期）应该就是这个方法级别；</li><li>如果这句话出现在servlet的类中，也就是说fruitService是一个成员变量，那么这个fruitService的作用域（生命周期）应该就是这个servlet实例级别</li></ul></li><li>之后我们在applicationContext.xml中定义了这个fruitService。然后通过解析XML，产生fruitService实例，存放在beanMap中，这个beanMap在一个BeanFactory中<br>因此，我们转移（改变）了之前的service实例、dao实例等等他们的生命周期。控制权从程序员转移到BeanFactory。这个现象我们称之为控制反转</li></ol><blockquote><p>之前对象在出现频繁创建和销毁，生命周期短暂，现在生命周期长，利用率高</p></blockquote><h2 id="DI-依赖注入："><a href="#DI-依赖注入：" class="headerlink" title="DI - 依赖注入："></a>DI - 依赖注入：</h2><ol><li><p>之前我们在控制层出现代码：FruitService fruitService &#x3D; new FruitServiceImpl()；<br>那么，控制层和service层存在耦合。</p></li><li><p>之后，我们将代码修改成FruitService fruitService &#x3D; null ;<br>然后，在applicationContext.xml配置文件中配置:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;fruit&quot;</span> <span class="attr">class</span>=<span class="string">&quot;FruitController&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;fruitService&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;fruitService&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h1 id="过滤器Filter"><a href="#过滤器Filter" class="headerlink" title="过滤器Filter"></a>过滤器Filter</h1><h2 id="过滤器Filter概述"><a href="#过滤器Filter概述" class="headerlink" title="过滤器Filter概述"></a>过滤器Filter概述</h2><ol><li>Filter也属于Servlet规范</li><li>Filter开发步骤：新建类实现Filter接口，然后实现其中的三个方法：init、doFilter、destroy<br>配置Filter，可以用注解@WebFilter，也可以使用xml文件 <filter> <filter-mapping></filter-mapping></filter></li><li>Filter在配置时，和servlet一样，也可以配置通配符，例如 @WebFilter(“*.do”)表示拦截所有以.do结尾的请求</li><li>过滤器链<br>1）执行的顺序依次是： A B C demo03 C2 B2 A2<br>2）如果采取的是注解的方式进行配置，那么过滤器链的拦截顺序是<strong>按照全类名的先后顺序排序</strong>的<br>3）如果采取的是xml的方式进行配置，那么按照<strong>配置的先后顺序进行排序</strong></li></ol><h2 id="过滤器项目简图"><a href="#过滤器项目简图" class="headerlink" title="过滤器项目简图"></a>过滤器项目简图</h2><p><img src="/2022/09/30/JavaWeb/image-20220707122421570.png" alt="image-20220707122421570"></p><blockquote><p>客户端向servlet发送请求，需要先经过对应的Filter过滤器</p><p>Servlet向另外客户端相应还是原路经过Filter返回，类似递归</p></blockquote><h2 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h2><h3 id="Filter01"><a href="#Filter01" class="headerlink" title="Filter01"></a>Filter01</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebFilter(&quot;*.do&quot;)</span>  <span class="comment">//任何向.do结尾的Serlvet发送请求都会经过这</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Filter01</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;A&quot;</span>); <span class="comment">//客户端向Servelet发请求，执行完相应代码后放行</span></span><br><span class="line">        <span class="comment">//放行 --- 跳转至下一个过滤器或直接到达Servlet</span></span><br><span class="line">        filterChain.doFilter(servletRequest,servletResponse);</span><br><span class="line">        System.out.println(<span class="string">&quot;A2&quot;</span>); <span class="comment">//Servlet向客户端响应，执行的代码</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Demo01Servlet"><a href="#Demo01Servlet" class="headerlink" title="Demo01Servlet"></a>Demo01Servlet</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/demo01.do&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01Servlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;demo01 service.....&quot;</span>);</span><br><span class="line">        request.getRequestDispatcher(<span class="string">&quot;succ.html&quot;</span>).forward(request,response); <span class="comment">//重定向还是要经过过滤器</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="过滤器的简单应用–设置编码"><a href="#过滤器的简单应用–设置编码" class="headerlink" title="过滤器的简单应用–设置编码"></a>过滤器的简单应用–设置编码</h2><h3 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h3><p><img src="/2022/09/30/JavaWeb/image-20220707123727361.png" alt="image-20220707123727361"></p><h3 id="CharacterEncodingFilter"><a href="#CharacterEncodingFilter" class="headerlink" title="CharacterEncodingFilter"></a>CharacterEncodingFilter</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebFilter(urlPatterns = &#123;&quot;*.do&quot;&#125;,</span></span><br><span class="line"><span class="meta">initParams = &#123;@WebInitParam(name = &quot;encoding&quot;,value = &quot;UTF-8&quot;)&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CharacterEncodingFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">encoding</span> <span class="operator">=</span> <span class="string">&quot;UTF-8&quot;</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">encodingStr</span> <span class="operator">=</span> filterConfig.getInitParameter(<span class="string">&quot;encoding&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(StringUtil.isNotEmpty(encodingStr))&#123;</span><br><span class="line">            encoding = encodingStr ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        </span><br><span class="line">        ((HttpServletRequest)servletRequest).setCharacterEncoding(encoding);</span><br><span class="line">        </span><br><span class="line">        filterChain.doFilter(servletRequest,servletResponse);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>利用配置文件或注解可以为Request自定义编码集</p></blockquote><h1 id="事务管理"><a href="#事务管理" class="headerlink" title="事务管理"></a>事务管理</h1><h2 id="编程式管理事务"><a href="#编程式管理事务" class="headerlink" title="编程式管理事务"></a>编程式管理事务</h2><p><strong>事务管理之前</strong></p><p><img src="/2022/09/30/JavaWeb/image-20220707160516225.png" alt="image-20220707160516225"></p><blockquote><p>当前Service中包含了三个DAO操作</p><p>之前的DAO的事务管理的基本API是右边写的方式</p><p>这样的方式的带来的问题是DAO01执行成功-提交，DAO02执行失败-回滚，DAO03执行成功-提交</p><p>此时service操作是成功还是失败？？ service的操作应该是一个整体，不能部分成功部分失败。</p><p>因此，service是一个整体，要么都成功，要么都失败 –  得出结论：事务管理不能以DAO层的单精度方法为单位，而应该以业务层的方法为单位</p></blockquote><p><strong>事务管理前置之后</strong></p><p><img src="/2022/09/30/JavaWeb/image-20220707161136914.png" alt="image-20220707161136914"></p><h2 id="水果系统在优化-5"><a href="#水果系统在优化-5" class="headerlink" title="水果系统在优化-5"></a>水果系统在优化-5</h2><h3 id="事务管理前置到过滤器"><a href="#事务管理前置到过滤器" class="headerlink" title="事务管理前置到过滤器"></a>事务管理前置到过滤器</h3><p><img src="/2022/09/30/JavaWeb/image-20220707161647857.png" alt="image-20220707161647857"></p><p>解决难点：需要这三个组件中的操作都是用同一个Connection，就是使用ThreadLocal，能够将连接保存在Map&lt;&gt;中，使用时获取，关闭连接时在关闭就ok，此时新建一个ConnUtil工具类进行实现创建连接和关闭连接的方法</p><h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><p>get() , set(obj)</p><p>ThreadLocal称之为本地线程 。 我们可以通过set方法在当前线程上存储数据、通过get方法在当前线程上获取数据</p><h4 id="set方法源码分析："><a href="#set方法源码分析：" class="headerlink" title="set方法源码分析："></a>set方法源码分析：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123;</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread(); <span class="comment">//获取当前的线程</span></span><br><span class="line"><span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);    <span class="comment">//每一个线程都维护各自的一个容器（ThreadLocalMap）</span></span><br><span class="line"><span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">    map.set(<span class="built_in">this</span>, value);          <span class="comment">//这里的key对应的是ThreadLocal，因为我们的组件中需要传输（共享）的对象可能会有多个（不止Connection）</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    createMap(t, value);           <span class="comment">//默认情况下map是没有初始化的，那么第一次往其中添加数据时，会去初始化</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="get方法源码分析："><a href="#get方法源码分析：" class="headerlink" title="get方法源码分析："></a>get方法源码分析：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread(); <span class="comment">//获取当前的线程</span></span><br><span class="line"><span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);    <span class="comment">//获取和这个线程（企业）相关的ThreadLocalMap（也就是工作纽带的集合）</span></span><br><span class="line"><span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</span><br><span class="line">    ThreadLocalMap.<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> map.getEntry(<span class="built_in">this</span>);   <span class="comment">//this指的是ThreadLocal对象，通过它才能知道是哪一个工作纽带</span></span><br><span class="line">    <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> (T)e.value;     <span class="comment">//entry.value就可以获取到工具箱了</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> setInitialValue();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><blockquote><p>当前线程可比作一个企业，本地线程则可比作企业的一个工作，一个工作只有一个工具箱（如连接Connection）一个企业中可有多个工作</p></blockquote><h3 id="ConnUtil–统一连接"><a href="#ConnUtil–统一连接" class="headerlink" title="ConnUtil–统一连接"></a>ConnUtil–统一连接</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConnUtil</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Connection&gt; threadLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//private static ThreadLocal&lt;Object&gt; threadLocal2 = new ThreadLocal&lt;&gt;();</span></span><br><span class="line">    <span class="comment">//private static ThreadLocal&lt;Object&gt; threadLocal3 = new ThreadLocal&lt;&gt;();</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DRIVER</span> <span class="operator">=</span> <span class="string">&quot;com.mysql.jdbc.Driver&quot;</span> ;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">URL</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/fruitdb?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">USER</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PWD</span> <span class="operator">=</span> <span class="string">&quot;123456&quot;</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Connection <span class="title function_">createConn</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.加载驱动</span></span><br><span class="line">            Class.forName(DRIVER);</span><br><span class="line">            <span class="comment">//2.通过驱动管理器获取连接对象</span></span><br><span class="line">            <span class="keyword">return</span> DriverManager.getConnection(URL, USER, PWD);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException | SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title function_">getConn</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> threadLocal.get();</span><br><span class="line">        <span class="keyword">if</span>(conn==<span class="literal">null</span>)&#123;</span><br><span class="line">            conn =createConn();</span><br><span class="line">            threadLocal.set(conn);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> threadLocal.get() ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">closeConn</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> threadLocal.get();</span><br><span class="line">        <span class="keyword">if</span>(conn==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!conn.isClosed())&#123;</span><br><span class="line">            conn.close();</span><br><span class="line">            threadLocal.set(<span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="过滤器无法捕获异常"><a href="#过滤器无法捕获异常" class="headerlink" title="过滤器无法捕获异常"></a>过滤器无法捕获异常</h3><p>问题：如果所有异常都向上抛出，之后统一在过滤器中被发现并处理，但是出现异常的位置就难以定位，所以得在异常处进行处理（try-catch），然后在向上抛出自定义异常</p><p>例如在BaseDAO中进行捕获异常在抛出自定义异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DAOException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DAOException</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2022/09/30/JavaWeb/image-20220707164807611.png" alt="image-20220707164807611"></p><h3 id="TransactionManager"><a href="#TransactionManager" class="headerlink" title="TransactionManager"></a>TransactionManager</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransactionManager</span> &#123;</span><br><span class="line"><span class="comment">//三个操作获取的都是统一连接，进行开启、提交、回归操作</span></span><br><span class="line">    <span class="comment">//开启事务</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">beginTrans</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        ConnUtil.getConn().setAutoCommit(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//提交事务</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">commit</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> ConnUtil.getConn();</span><br><span class="line">        conn.commit();</span><br><span class="line">        ConnUtil.closeConn();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//回滚事务</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">rollback</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> ConnUtil.getConn();</span><br><span class="line">        conn.rollback();</span><br><span class="line">        ConnUtil.closeConn();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="OpenSessionInViewFilter"><a href="#OpenSessionInViewFilter" class="headerlink" title="OpenSessionInViewFilter"></a>OpenSessionInViewFilter</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebFilter(&quot;*.do&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OpenSessionInViewFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            TransactionManager.beginTrans(); <span class="comment">//将连接的自动提交改为false</span></span><br><span class="line">            System.out.println(<span class="string">&quot;开启事务....&quot;</span>);</span><br><span class="line">                filterChain.doFilter(servletRequest, servletResponse);</span><br><span class="line">                TransactionManager.commit();</span><br><span class="line">                System.out.println(<span class="string">&quot;提交事务...&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TransactionManager.rollback();</span><br><span class="line">                    System.out.println(<span class="string">&quot;回滚事务....&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SQLException ex) &#123;</span><br><span class="line">                    ex.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>此次水果系统优化，统一了多个DAO方法的事务管理，统一在过滤器中处理，如有异常则回滚，否则可以提交。此方式的改进中需要统一DAO使用的数据库连接，因此编写ConnUtil，利用ThreadLocal，能够将连接保存在Map&lt;&gt;中，使用时获取</p><h1 id="监听器"><a href="#监听器" class="headerlink" title="监听器"></a>监听器</h1><h2 id="监听器类型"><a href="#监听器类型" class="headerlink" title="监听器类型"></a>监听器类型</h2><ol><li>ServletContextListener - 监听ServletContext对象的创建和销毁的过程</li><li>HttpSessionListener - 监听HttpSession对象的创建和销毁的过程</li><li>ServletRequestListener - 监听ServletRequest对象的创建和销毁的过程</li><li>ServletContextAttributeListener - 监听ServletContext的保存作用域的改动(add,remove,replace)</li><li>HttpSessionAttributeListener - 监听HttpSession的保存作用域的改动(add,remove,replace)</li><li>ServletRequestAttributeListener - 监听ServletRequest的保存作用域的改动(add,remove,replace)</li><li>HttpSessionBindingListener - 监听某个对象在Session域中的创建与移除</li><li>HttpSessionActivationListener - 监听某个对象在Session域中的序列化和反序列化</li></ol><h2 id="监听器的使用"><a href="#监听器的使用" class="headerlink" title="监听器的使用"></a>监听器的使用</h2><p>1、监听器需要实现对应的监听器接口，并重写初始和销毁方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebListener</span> <span class="comment">//使用注解配置监听器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ContextLoaderListener</span> <span class="keyword">implements</span> <span class="title class_">ServletContextListener</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextInitialized</span><span class="params">(ServletContextEvent servletContextEvent)</span> &#123;</span><br><span class="line">        <span class="comment">//该方法在上下文被创建时调用</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextDestroyed</span><span class="params">(ServletContextEvent servletContextEvent)</span> &#123;</span><br><span class="line"><span class="comment">//该方法在上下文被销毁时调用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、识别监听器存在可在web.xml配置文件中添加，也可使用注解添加</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>com.atguigu.listener.MyServletContextListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="水果系统在优化-6"><a href="#水果系统在优化-6" class="headerlink" title="水果系统在优化-6"></a>水果系统在优化-6</h2><h3 id="获取配置文件名的封装"><a href="#获取配置文件名的封装" class="headerlink" title="获取配置文件名的封装"></a>获取配置文件名的封装</h3><h3 id="applicationContext-xml-1"><a href="#applicationContext-xml-1" class="headerlink" title="applicationContext.xml"></a>applicationContext.xml</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>在配置文件中添加上下文参数，在初始时可以通过上下文获取，其目的是避免在java代码中写死配置文件名，可在配置文件中指定配置文件名</p></blockquote><h3 id="监听器的加入：ContextLoaderListener"><a href="#监听器的加入：ContextLoaderListener" class="headerlink" title="监听器的加入：ContextLoaderListener"></a>监听器的加入：ContextLoaderListener</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//监听上下文启动，在上下文启动的时候去创建IOC容器,然后将其保存到application作用域</span></span><br><span class="line"><span class="comment">//后面中央控制器再从application作用域中去获取IOC容器</span></span><br><span class="line"><span class="meta">@WebListener</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ContextLoaderListener</span> <span class="keyword">implements</span> <span class="title class_">ServletContextListener</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextInitialized</span><span class="params">(ServletContextEvent servletContextEvent)</span> &#123;</span><br><span class="line">        <span class="comment">//1.获取ServletContext对象</span></span><br><span class="line">        <span class="type">ServletContext</span> <span class="variable">application</span> <span class="operator">=</span> servletContextEvent.getServletContext();</span><br><span class="line">        <span class="comment">//2.获取上下文的初始化参数</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> application.getInitParameter(<span class="string">&quot;contextConfigLocation&quot;</span>);</span><br><span class="line">        <span class="comment">//3.创建IOC容器</span></span><br><span class="line">        <span class="type">BeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(path);</span><br><span class="line">        <span class="comment">//4.将IOC容器保存到application作用域                     path是配置文件名</span></span><br><span class="line">        application.setAttribute(<span class="string">&quot;beanFactory&quot;</span>,beanFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextDestroyed</span><span class="params">(ServletContextEvent servletContextEvent)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>之前IOC容器是在中央控制器DispatcherServlet中创建的，由于IOC容器承装着所有组件需要使用的实例，因此需要将IOC容器创建时间提前，即在初始Servlet上下文时创建，又因ServletContextListener监听器在Servlet上下文初始时会调用其内部的方法，因此可以重写此方法进行上下文的创建</p></blockquote><h3 id="DispatcherServlet中构造器"><a href="#DispatcherServlet中构造器" class="headerlink" title="DispatcherServlet中构造器"></a>DispatcherServlet中构造器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;*.do&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DispatcherServlet</span> <span class="keyword">extends</span> <span class="title class_">ViewBaseServlet</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">    <span class="built_in">super</span>.init();</span><br><span class="line">    <span class="comment">//之前是在此处主动创建IOC容器的</span></span><br><span class="line">    <span class="comment">//现在优化为从application作用域去获取</span></span><br><span class="line">    <span class="comment">//beanFactory = new ClassPathXmlApplicationContext();</span></span><br><span class="line">    <span class="type">ServletContext</span> <span class="variable">application</span> <span class="operator">=</span> getServletContext();</span><br><span class="line">    <span class="type">Object</span> <span class="variable">beanFactoryObj</span> <span class="operator">=</span> application.getAttribute(<span class="string">&quot;beanFactory&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(beanFactoryObj!=<span class="literal">null</span>)&#123;</span><br><span class="line">        beanFactory = (BeanFactory)beanFactoryObj ;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;IOC容器获取失败！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>ServletContext即Servlet上下文</p></blockquote><h1 id="水果系统总结"><a href="#水果系统总结" class="headerlink" title="水果系统总结"></a>水果系统总结</h1><h2 id="MVC各层的设计"><a href="#MVC各层的设计" class="headerlink" title="MVC各层的设计"></a>MVC各层的设计</h2><p><img src="/2022/09/30/JavaWeb/image-20220707235431197.png" alt="image-20220707235431197"></p><h1 id="qqZone项目"><a href="#qqZone项目" class="headerlink" title="qqZone项目"></a>qqZone项目</h1><h2 id="1-熟悉QQZone业务需求"><a href="#1-熟悉QQZone业务需求" class="headerlink" title="1.熟悉QQZone业务需求"></a>1.熟悉QQZone业务需求</h2><ol><li><p>用户登录</p></li><li><p>登录成功，显示主界面。左侧显示好友列表；上端显示欢迎词。如果不是自己的空间，显示超链接：返回自己的空间；下端显示日志列表</p>   <img src="/2022/09/30/JavaWeb/image-20220711100050088.png" alt="image-20220711100050088" style="zoom:50%;"></li></ol><ol start="3"><li><p>查看日志详情：</p><ul><li>日志本身的信息（作者头像、昵称、日志标题、日志内容、日志的日期）</li><li>回复列表（回复者的头像、昵称、回复内容、回复日期）</li><li>主人回复信息</li></ul>   <img src="/2022/09/30/JavaWeb/image-20220711100334588.png" alt="image-20220711100334588" style="zoom:50%;"></li></ol><ol start="4"><li><p>删除日志（主页面标签）</p></li><li><p>删除特定回复（删除时应该是检查是否有被主人回复过，有则先删除主人回复在删除此回复）</p></li><li><p>删除特定主人回复</p></li><li><p>添加日志、添加回复、添加主人回复</p></li><li><p>点击左侧好友链接，进入好友的空间</p></li></ol><h2 id="2-数据库设计"><a href="#2-数据库设计" class="headerlink" title="2.数据库设计"></a>2.数据库设计</h2><h3 id="1-抽取实体"><a href="#1-抽取实体" class="headerlink" title="1.抽取实体"></a>1.抽取实体</h3><ul><li>用户登录信息</li><li>用户详情信息</li><li>日志 </li><li>回贴  </li><li>主人回复</li></ul><h3 id="2-分析其中的属性"><a href="#2-分析其中的属性" class="headerlink" title="2.分析其中的属性"></a>2.分析其中的属性</h3><ul><li><p>用户登录信息：账号、密码、头像、昵称</p></li><li><p>用户详情信息：真实姓名、星座、血型、邮箱、手机号…..</p></li><li><p>日志：标题、内容、日期、作者</p></li></ul><ul><li>回复：内容、日期、作者、日志</li><li>主人回复：内容、日期、作者、回复</li></ul><h3 id="3-分析实体之间的关系"><a href="#3-分析实体之间的关系" class="headerlink" title="3.分析实体之间的关系"></a>3.分析实体之间的关系</h3><ul><li>用户登录信息 ： 用户详情信息      1：1 PK</li><li>用户 ： 日志                   1：N</li><li>日志 ： 回复                   1：N</li><li>回复 ： 主人回复                1：1 UK</li><li>用户 ： 好友                   M ： N</li></ul><h3 id="4-QQZone-ER图"><a href="#4-QQZone-ER图" class="headerlink" title="4.QQZone-ER图"></a>4.QQZone-ER图</h3><p><img src="/2022/09/30/JavaWeb/image-20220711112329855.png" alt="image-20220711112329855"></p><h3 id="5-数据库的范式"><a href="#5-数据库的范式" class="headerlink" title="5.数据库的范式"></a>5.数据库的范式</h3><p>1） 第一范式：列不可再分<br>2） 第二范式：一张表只表达一层含义（只描述一件事情）<br>3） 第三范式：表中的每一列和主键都是直接依赖关系，而不是间接依赖<br>4.数据库设计的范式和数据库的查询性能很多时候是相悖的，我们需要根据实际的业务情况做一个选择：</p><ul><li>查询频次不高的情况下，我们更倾向于提高数据库的设计范式，从而提高存储效率</li><li>查询频次较高的情形，我们更倾向于牺牲数据库的规范度，降低数据库设计的范式，允许特定的冗余，从而提高查询的性能</li></ul><h3 id="6-查询好友列表"><a href="#6-查询好友列表" class="headerlink" title="6.查询好友列表"></a>6.查询好友列表</h3><p><img src="/2022/09/30/JavaWeb/image-20220711112727972.png" alt="image-20220711112727972"></p><h2 id="3-项目初始化工作"><a href="#3-项目初始化工作" class="headerlink" title="3.项目初始化工作"></a>3.项目初始化工作</h2><p>1.创建JavaWeb工程配置tomcat，导入MySQL的jar包驱动和thyenleaf的jar包，将其设置为library，将在library添加到该工程依赖</p><p>2.将myssm加入进来</p><img src="/2022/09/30/JavaWeb/image-20220711114002663.png" alt="image-20220711114002663" style="zoom: 67%;"><p><strong>监听器listeners</strong>：在上下文创建时即Tomcat开启时，调用其中的contextInitialized初始方法</p><ul><li><p>创建IOC容器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(path);</span><br></pre></td></tr></table></figure></li><li><p>将IOC容器保存到application作用域</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">application.setAttribute(<span class="string">&quot;beanFactory&quot;</span>,beanFactory);</span><br></pre></td></tr></table></figure></li></ul><p><strong>ioc</strong>：通过读取配置文件applicationContext，为其中的类和即类的属性创建实例，并保存在beanMap中（容器）</p><p><strong>filters过滤器</strong>：设置编码、开启事务、提交事务、回滚事务</p><p><strong>basedao</strong>：ConnUtil创建数据库连接，BaseDAO提供操作数据的基本接口实现</p><p><strong>myspringmvc</strong>：</p><ul><li><p>DispatcherServlet中央控制器：获取客户端发来的请求，首先提取请求中xxx.do，从application作用域中保存的IOC容器里取出xxx对应的实例，在提取请求中operate和方法参数，实现xxx实例中operate对应的方法</p></li><li><p>ViewBaseServlet：通过加入前后缀找到指定页面，配合thyemleaf将数据渲染在指定页面上，响应给客户端</p></li><li><p>pageController：由于有些页面直接访问xxx.html，没有经过服务器ViewBaseServlet，没有创建thyemleaf实例，无法使用thyemleaf语法，因此改进，将这些直接访问的页面都先发送至这个页面（page.do）</p><p>请求：<a href="http://localhost:8080/pro22/page.do?operate=page&amp;page=login">http://localhost:8080/pro22/page.do?operate=page&amp;page=login</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PageController</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">page</span><span class="params">(String page)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> page ;       <span class="comment">// frames/left</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="4-功能一实现"><a href="#4-功能一实现" class="headerlink" title="4.功能一实现"></a>4.功能一实现</h2><h3 id="功能一"><a href="#功能一" class="headerlink" title="功能一"></a>功能一</h3><ul><li>登录页面</li><li>登录成功后的页面，显示好友列表，日志列表，顶端的欢迎信息</li><li>点击好友名称超链接可进入其空间</li><li>显示好友空间中的日志列表，顶端欢迎信息和返回自己空间的超链接</li></ul><h3 id="login-html"><a href="#login-html" class="headerlink" title="login.html"></a>login.html</h3><img src="/2022/09/30/JavaWeb/image-20220711100006670.png" alt="image-20220711100006670" style="zoom:50%;"><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;center&quot;</span>&gt;</span>用户登录1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">form</span> <span class="attr">th:action</span>=<span class="string">&quot;@&#123;/user.do&#125;&quot;</span> <span class="attr">method</span>=<span class="string">&quot;get&quot;</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;operate&quot;</span> <span class="attr">value</span>=<span class="string">&quot;login&quot;</span>/&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">th</span>&gt;</span>用户名：<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;loginId&quot;</span> <span class="attr">value</span>=<span class="string">&quot;u001&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">th</span>&gt;</span>密码：<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;pwd&quot;</span> <span class="attr">value</span>=<span class="string">&quot;ok&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">th</span> <span class="attr">colspan</span>=<span class="string">&quot;2&quot;</span>&gt;</span></span><br><span class="line">                          <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;登录&quot;</span>/&gt;</span></span><br><span class="line">                          <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;还没有账号？&quot;</span>/&gt;</span></span><br><span class="line">                      <span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>发送至user.do，operate为login，loginId&#x3D;u001，pwd&#x3D;ok</p></blockquote><h3 id="UserController"><a href="#UserController" class="headerlink" title="UserController"></a>UserController</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> UserBasicService userBasicService ;</span><br><span class="line">    <span class="keyword">private</span> TopicService topicService ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">login</span><span class="params">(String loginId , String pwd , HttpSession session)</span>&#123;</span><br><span class="line">        <span class="comment">//1.登录验证</span></span><br><span class="line">        <span class="type">UserBasic</span> <span class="variable">userBasic</span> <span class="operator">=</span> userBasicService.login(loginId, pwd); <span class="comment">//查找数据库是否有</span></span><br><span class="line">        <span class="keyword">if</span>(userBasic!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//1-1 获取相关的好友信息</span></span><br><span class="line">            List&lt;UserBasic&gt; friendList = userBasicService.getFriendList(userBasic);</span><br><span class="line">            <span class="comment">//1-2 获取相关的日志列表信息(但是，日志只有id，没有其他信息）</span></span><br><span class="line">            List&lt;Topic&gt; topicList = topicService.getTopicList(userBasic);</span><br><span class="line"></span><br><span class="line">            userBasic.setFriendList(friendList);</span><br><span class="line">            userBasic.setTopicList(topicList);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//userBasic这个key保存的是登陆者的信息</span></span><br><span class="line">            <span class="comment">//friend这个key保存的是当前进入的是谁的空间</span></span><br><span class="line">            session.setAttribute(<span class="string">&quot;userBasic&quot;</span>,userBasic);</span><br><span class="line">            session.setAttribute(<span class="string">&quot;friend&quot;</span>,userBasic);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>; <span class="comment">//成功后返回到中央控制器，将响应index.html给客户端</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;login&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">friend</span><span class="params">(Integer id, HttpSession session)</span>&#123;</span><br><span class="line">        <span class="comment">//1.根据id获取指定的用户信息</span></span><br><span class="line">        <span class="type">UserBasic</span> <span class="variable">currFriend</span> <span class="operator">=</span> userBasicService.getUserBasicById(id);</span><br><span class="line"><span class="comment">//2.查询对应日志列表</span></span><br><span class="line">        List&lt;Topic&gt; topicList = topicService.getTopicList(currFriend);</span><br><span class="line"><span class="comment">//3.添加赋值</span></span><br><span class="line">        currFriend.setTopicList(topicList);</span><br><span class="line"><span class="comment">//4.覆盖session中friend</span></span><br><span class="line">        session.setAttribute(<span class="string">&quot;friend&quot;</span>,currFriend);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>UserController中有两个业务属性，为控制器服务</p><h3 id="index-html"><a href="#index-html" class="headerlink" title="index.html"></a>index.html</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;div_top&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">iframe</span>  <span class="attr">th:src</span>=<span class="string">&quot;@&#123;/page.do?operate=page&amp;page=frames/top&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;div_left&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">th:src</span>=<span class="string">&quot;@&#123;/page.do?operate=page&amp;page=frames/left&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;div_main&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">th:src</span>=<span class="string">&quot;@&#123;/page.do?operate=page&amp;page=frames/main&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;div_bottom&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;center&quot;</span> &gt;</span>版权所有<span class="symbol">&amp;reg;</span>，欢迎盗版<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>index页面中有四个板块div_top、div_left、div_main、div_bottom</p><p>其中三个div_top、div_left、div_main页面会再去请求响应的页面</p><h3 id="main-html"><a href="#main-html" class="headerlink" title="main.html"></a>main.html</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;div_topic_list&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;div_to_add&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;right8&quot;</span>&gt;</span>发表新日志<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">table</span> <span class="attr">id</span>=<span class="string">&quot;tbl_topic_list&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">th</span>&gt;</span>ID<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">th</span>&gt;</span>标题<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">th</span>&gt;</span>日期<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">th</span>&gt;</span>操作<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tr</span> <span class="attr">th:if</span>=<span class="string">&quot;$&#123;#lists.isEmpty(session.friend.topicList)&#125;&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">th</span> <span class="attr">colspan</span>=<span class="string">&quot;4&quot;</span>&gt;</span>暂无日志列表<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tr</span> <span class="attr">th:unless</span>=<span class="string">&quot;$&#123;#lists.isEmpty(session.friend.topicList)&#125;&quot;</span> <span class="attr">th:each</span>=<span class="string">&quot;topic : $&#123;session.friend.topicList&#125;&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;topic.id&#125;&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;topic.title&#125;&quot;</span>&gt;</span>我乔峰要走，你们谁可阻拦<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;topic.topicDate&#125;&quot;</span>&gt;</span>2021-09-01 12:30:55<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;删除&quot;</span> &lt;/<span class="attr">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>topicList从session中friend获取，无论自己和别人的空间，topicList都是对应的，而friendList只显示自己的好友列表</p><p>这里删除日志功能还未实现，下面实现</p></blockquote><h3 id="left-html"><a href="#left-html" class="headerlink" title="left.html"></a>left.html</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;div_friendList&quot;</span> &gt;</span></span><br><span class="line">       我的好友<span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">li</span> <span class="attr">th:if</span>=<span class="string">&quot;$&#123;#lists.isEmpty(session.userBasic.friendList)&#125;&quot;</span>&gt;</span>一个好友也没有<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">li</span> <span class="attr">th:unless</span>=<span class="string">&quot;$&#123;#lists.isEmpty(session.userBasic.friendList)&#125;&quot;</span> <span class="attr">th:each</span>=<span class="string">&quot;friend : $&#123;session.userBasic.friendList&#125;&quot;</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;|/user.do?operate=friend&amp;id=$&#123;friend.id&#125;|&#125;&quot;</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;friend.nickName&#125;&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_top&quot;</span>&gt;</span>张三<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>friendList从session中userBasic获取</p><p>名字设置超链接，可进入别人的空间。</p><p>发送请求：&#x2F;user.do?operate&#x3D;friend&amp;id&#x3D;${friend.id} ，重新覆盖friend，更新其id和日志列表</p></blockquote><h3 id="top-html"><a href="#top-html" class="headerlink" title="top.html"></a>top.html</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;top_title&quot;</span> &gt;</span>欢迎来到QQZone1！<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;top_link_div&quot;</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">&quot;|欢迎进入$&#123;session.friend.nickName&#125;的空间！|&quot;</span>&gt;</span>欢迎进入Jim的空间！<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        判断进入的是否是自己的空间的依据是：</span></span><br><span class="line"><span class="comment">        userBasic和friend这两个key中保存的UserBasic是否一致</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        userBasic:&lt;span th:text=&quot;$&#123;session.userBasic.id&#125;&quot;&gt;&lt;/span&gt;&lt;br/&gt;</span></span><br><span class="line"><span class="comment">        friend:&lt;span th:text=&quot;$&#123;session.friend.id&#125;&quot;&gt;&lt;/span&gt;&lt;br/&gt;</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:if</span>=<span class="string">&quot;$&#123;session.userBasic.id!=session.friend.id&#125;&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;|/user.do?operate=friend&amp;id=$&#123;session.userBasic.id&#125;|&#125;&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_top&quot;</span>&gt;</span>返回自己的空间!<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>top.html页面显示登录者昵称、判断是否是自己的空间<br>1)显示登录者昵称： ${session.userBasic.nickName}<br>2)判断是否是自己的空间 : ${session.userBasic.id!&#x3D;session.friend.id}</p><p>如果这里不是自己空间，则session.userBasic.id不等于session.friend.id，，显示“返回自己空间！”的文字超链接 </p><p>点击后发送&#x2F;user.do?operate&#x3D;friend&amp;id&#x3D;${session.userBasic.id} ,重写覆盖friend，更新其id和日志列表</p></blockquote><h3 id="实现功能一的问题"><a href="#实现功能一的问题" class="headerlink" title="实现功能一的问题"></a>实现功能一的问题</h3><p>1）URL没修改，用的还是fruitdb<br>2）忘记别名，userBasic属性中没有fid，只有id属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> List&lt;UserBasic&gt; <span class="title function_">getUserBasicList</span><span class="params">(UserBasic userBasic)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT fid as &#x27;id&#x27; FROM t_friend WHERE uid = ?&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.executeQuery(sql,userBasic.getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 3）rsmd.getColumnName：只能显示列名、rsmd.getColumnLabel()：有别名显示别名，没有别名显示列名<br> 4）Can not set com.atguigu.qqzone.pojo.UserBasic field com.atguigu.qqzone.pojo.Topic.author to java.lang.Integer</p><p>5）left.html页面没有样式，同时数据也不展示，原因是：我们是直接去请求的静态页面资源，那么并没有执行super.processTemplate()，也就是thymeleaf没有起作用<br>(之前的表单也是这个原因)<br>解决方法：</p><ul><li><p>新增PageController，添加page方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">page</span><span class="params">(String page)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> page ;       <span class="comment">// frames/left</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>目的是执行super.processTemplate()方法，让thymeleaf生效</p></li></ul><p>6）点击左侧的好友链接，进入好友空间</p><ol><li>根据id获取指定userBasic信息，查询这个userBasic的topicList，然后覆盖friend对应的value</li><li>main页面应该展示friend中的topicList，而不是userBasic中的topicList</li><li>跳转后，在左侧（left）中显示整个index页面<ul><li>问题：在left页面显示整个index布局</li><li>解决：给超链接添加target属性：   target&#x3D;”_top” 保证在顶层窗口显示整个index页面</li></ul></li><li>top.html页面需要修改： “欢迎进入${session.friend}”<br>top.html页面的返回自己空间的超链接需要修改：<a th:href="@{|/user.do?operate=friend&id=${session.userBasic.id}|}" target="_top"></a></li></ol><p>7）补充target用法</p><p><img src="/2022/09/30/JavaWeb/image-20220710105146793.png" alt="image-20220710105146793"></p><h2 id="5-功能二实现"><a href="#5-功能二实现" class="headerlink" title="5.功能二实现"></a>5.功能二实现</h2><h3 id="功能二"><a href="#功能二" class="headerlink" title="功能二"></a>功能二</h3><p>显示日志详情页面（detail.html）****</p><ul><li>日志作者和作者头像、日志标题、日志内容、日志发布时间</li><li>回复作者和作者头像、回复标题、回复内容、回复时间</li></ul><p><strong>日志详情页面实现和解决问题</strong></p><ol><li>已知topic的id，需要根据topic的id获取特定topic</li><li>获取这个topic关联的所有的回复</li><li>如果某个回复有主人回复，需要查询出来</li></ol><ul><li>在TopicController中获取指定的topic</li><li>具体这个topic中关联多少个Reply，由ReplyService内部实现</li></ul><ol start="4"><li>获取到的topic中的author只有id，那么需要在topicService的getTopic方法中封装，在查询topic本身信息时，同时调用userBasicService中的获取getuserBasic方法，给author属性赋值</li><li>同理，在reply类中也有author，而且这个author也是只有id，那么我们也需要根据id查询得到author，最后设置关联</li></ol><h3 id="main-html-1"><a href="#main-html-1" class="headerlink" title="main.html"></a>main.html</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tr</span> <span class="attr">th:unless</span>=<span class="string">&quot;$&#123;#lists.isEmpty(session.friend.topicList)&#125;&quot;</span> <span class="attr">th:each</span>=<span class="string">&quot;topic : $&#123;session.friend.topicList&#125;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;topic.id&#125;&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;|/topic.do?operate=topicDetail&amp;id=$&#123;topic.id&#125;|&#125;&quot;</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;topic.title&#125;&quot;</span>&gt;</span>我乔峰要走，你们谁可阻拦<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;topic.topicDate&#125;&quot;</span>&gt;</span>2021-09-01 12:30:55<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;删除&quot;</span> <span class="attr">th:if</span>=<span class="string">&quot;$&#123;session.userBasic.id==session.friend.id&#125;&quot;</span> <span class="attr">th:onclick</span>=<span class="string">&quot;|delTopic($&#123;topic.id&#125;)|&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在日志标题加入超链接，连接至topic.do?operate&#x3D;topicDetail&amp;id&#x3D;${topic.id}</p><h3 id="TopicController"><a href="#TopicController" class="headerlink" title="TopicController"></a>TopicController</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TopicController</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> TopicService topicService ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">topicDetail</span><span class="params">(Integer id , HttpSession session)</span>&#123;</span><br><span class="line">        <span class="type">Topic</span> <span class="variable">topic</span> <span class="operator">=</span> topicService.getTopicById(id);<span class="comment">//</span></span><br><span class="line"></span><br><span class="line">        session.setAttribute(<span class="string">&quot;topic&quot;</span>,topic); <span class="comment">//detail.html中通过topic获取数据</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;frames/detail&quot;</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="关键方法：获取回复列表"><a href="#关键方法：获取回复列表" class="headerlink" title="关键方法：获取回复列表"></a>关键方法：获取回复列表</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReplyServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">ReplyService</span> &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Reply&gt; <span class="title function_">getReplyListByTopicId</span><span class="params">(Integer topicId)</span> &#123;</span><br><span class="line">    List&lt;Reply&gt; replyList = replyDAO.getReplyList(<span class="keyword">new</span> <span class="title class_">Topic</span>(topicId));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; replyList.size(); i++) &#123;</span><br><span class="line">        <span class="type">Reply</span> <span class="variable">reply</span> <span class="operator">=</span> replyList.get(i);</span><br><span class="line">        <span class="comment">//1.将关联的作者设置进去</span></span><br><span class="line">        <span class="type">UserBasic</span> <span class="variable">author</span> <span class="operator">=</span> userBasicService.getUserBasicById(reply.getAuthor().getId());</span><br><span class="line">        reply.setAuthor(author);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.将关联的HostReply设置进去</span></span><br><span class="line">        <span class="type">HostReply</span> <span class="variable">hostReply</span> <span class="operator">=</span> hostReplyService.getHostReplyByReplyId(reply.getId());</span><br><span class="line">        reply.setHostReply(hostReply);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> replyList ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="detail-html"><a href="#detail-html" class="headerlink" title="detail.html"></a>detail.html</h3><img src="/2022/09/30/JavaWeb/image-20220711100334588.png" alt="image-20220711100334588" style="zoom:50%;"><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;div_topic_info&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">th:src</span>=<span class="string">&quot;@&#123;|/imgs/$&#123;session.topic.author.headImg&#125;|&#125;&quot;</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;session.topic.author.nickName&#125;&quot;</span>&gt;</span>乔峰<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;session.topic.title&#125;&quot;</span>&gt;</span>《萧某今天就和天下群雄决一死战，你们一起上吧！》<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;session.topic.topicDate&#125;&quot;</span>&gt;</span>2021-09-01 12:30:55<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;session.topic.content&#125;&quot;</span>&gt;</span>杀母大仇, 岂可当作买卖交易？此仇能报便报, 如不能报, 则我父子毕命于此便了。这等肮脏之事, 岂是我萧氏父子所屑为？<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;div_reply_list&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">class</span>=<span class="string">&quot;tbl_reply_info&quot;</span> <span class="attr">th:each</span>=<span class="string">&quot;reply : $&#123;session.topic.replyList&#125;&quot;</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">&quot;img48&quot;</span> <span class="attr">th:src</span>=<span class="string">&quot;@&#123;|/imgs/$&#123;reply.author.headImg&#125;|&#125;&quot;</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;h32 center&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width:100%;&quot;</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;reply.author.nickName&#125;&quot;</span>&gt;</span>段誉<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"> <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">&quot;|回复：$&#123;session.topic.title&#125;|&quot;</span>&gt;</span>萧某今天就和天下群雄决一死战，你们一起上吧！<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;title_date_right&quot;</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;reply.replyDate&#125;&quot;</span>&gt;</span>2021-09-01 14:35:15<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;reply.content&#125;&quot;</span>&gt;</span>你可曾见过边关之上、宋辽相互仇杀的惨状？可曾见过宋人辽人妻离子散、家破人亡的情景？宋辽之间好容易罢兵数十年, 倘若刀兵再起, 契丹铁骑侵入南朝, 你可知将有多少宋人惨遭横死？多少辽人死于非命？!<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">  </span><br><span class="line"> <span class="tag">&lt;<span class="name">ul</span> <span class="attr">th:if</span>=<span class="string">&quot;$&#123;reply.hostReply!=null&#125;&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">li</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;reply.hostReply.content&#125;&quot;</span>&gt;</span>你以为我是慕容复的人，所以和我比试？段兄弟年纪轻轻，就有如此武学修为，实属罕见！武林早已盛传大理段氏有一门绝学，叫六脉神剑，能以无形剑气杀人，果然真有此门神功！<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">li</span>  <span class="attr">th:text</span>=<span class="string">&quot;|主人回复于$&#123;reply.hostReply.hostReplyDate&#125;|&quot;</span>&gt;</span>主人回复于2021/10/01 11:50:30<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:id</span>=<span class="string">&quot;|a$&#123;reply.id&#125;|&quot;</span> <span class="attr">th:unless</span>=<span class="string">&quot;$&#123;reply.hostReply!=null&#125;&quot;</span>  <span class="attr">href</span>=<span class="string">&quot;#&quot;</span> <span class="attr">style</span>=<span class="string">&quot;float: right;display: none;&quot;</span>&gt;</span>主人回复<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>主人回复操作本项目没有实现，留给同学们实现</p></blockquote><h2 id="6-功能三实现"><a href="#6-功能三实现" class="headerlink" title="6.功能三实现"></a>6.功能三实现</h2><h3 id="功能三"><a href="#功能三" class="headerlink" title="功能三"></a>功能三</h3><ol><li>添加回复</li><li>删除回复<ol><li>如果回复有关联的主人回复，需要先删除主人回复</li><li>删除回复<br>Cannot delete or update a parent row: a foreign key constraint fails<br>(<code>qqzonedb</code>.<code>t_host_reply</code>, CONSTRAINT <code>FK_host_reply</code> FOREIGN KEY (<code>reply</code>) REFERENCES <code>t_reply</code> (<code>id</code>))<br> 我们在删除回复表记录时，发现删除失败，原因是：在主人回复表中仍然有记录引用待删除的回复这条记录<br> 如果需要删除主表数据，需要首先删除子表数据</li></ol></li></ol><h3 id="detail-html–添加回复"><a href="#detail-html–添加回复" class="headerlink" title="detail.html–添加回复"></a>detail.html–添加回复</h3><img src="/2022/09/30/JavaWeb/image-20220711100334588.png" alt="image-20220711100334588" style="zoom:50%;"><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;div_add_reply&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;add_reply_title&quot;</span>&gt;</span>添加回复<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;reply.do&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;operate&quot;</span> <span class="attr">value</span>=<span class="string">&quot;addReply&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;topicId&quot;</span> <span class="attr">th:value</span>=<span class="string">&quot;$&#123;session.topic.id&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">th</span> <span class="attr">style</span>=<span class="string">&quot;width: 25%&quot;</span>&gt;</span>回复日志：<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">th:value</span>=<span class="string">&quot;|《$&#123;session.topic.title&#125;》|&quot;</span> <span class="attr">value</span>=<span class="string">&quot;《萧某今天就和天下群雄决一死战，你们一起上吧！》&quot;</span> <span class="attr">readonly</span> /&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">th</span>&gt;</span>回复内容1：<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">name</span>=<span class="string">&quot;content&quot;</span> <span class="attr">rows</span>=<span class="string">&quot;3&quot;</span>&gt;</span>这里是另一个回复！<span class="tag">&lt;/<span class="name">textarea</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">th</span> <span class="attr">colspan</span>=<span class="string">&quot;2&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot; 回 复 &quot;</span>/&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;reset&quot;</span> <span class="attr">value</span>=<span class="string">&quot; 重 置 &quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>将发送这些数据值服务器ReplyController：</p><p>reply.do ,operate&#x3D;addReply，两个属性：name&#x3D;”topicId” th:value&#x3D;”${session.topic.id}”  name&#x3D;”content”</p></blockquote><h3 id="ReplyController"><a href="#ReplyController" class="headerlink" title="ReplyController"></a>ReplyController</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReplyController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ReplyService replyService ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">addReply</span><span class="params">(String content ,Integer topicId , HttpSession session)</span>&#123;</span><br><span class="line">        <span class="type">UserBasic</span> <span class="variable">author</span> <span class="operator">=</span> (UserBasic)session.getAttribute(<span class="string">&quot;userBasic&quot;</span>);</span><br><span class="line">        <span class="type">Reply</span> <span class="variable">reply</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Reply</span>(content , <span class="keyword">new</span> <span class="title class_">Date</span>() , author , <span class="keyword">new</span> <span class="title class_">Topic</span>(topicId));</span><br><span class="line">        replyService.addReply(reply);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;redirect:topic.do?operate=topicDetail&amp;id=&quot;</span>+topicId;</span><br><span class="line">        <span class="comment">// 不能直接跳转detail.html，因为刚加入的回复session中的topic还没更新，所以得重新查一遍</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">delReply</span><span class="params">(Integer replyId , Integer topicId)</span>&#123;</span><br><span class="line">        replyService.delReply(replyId);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;redirect:topic.do?operate=topicDetail&amp;id=&quot;</span>+topicId;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="detail-html–删除回复"><a href="#detail-html–删除回复" class="headerlink" title="detail.html–删除回复"></a>detail.html–删除回复</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">language</span>=<span class="string">&quot;JavaScript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">function</span> <span class="title function_">showDelImg</span>(<span class="params">imgId</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">var</span> obj = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(imgId) ;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">if</span>(obj)&#123;</span></span><br><span class="line"><span class="language-javascript">                obj.<span class="property">style</span>.<span class="property">display</span>=<span class="string">&#x27;inline&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">function</span> <span class="title function_">hiddenDelImg</span>(<span class="params">imgId</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">var</span> obj = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(imgId) ;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">if</span>(obj)&#123;</span></span><br><span class="line"><span class="language-javascript">                obj.<span class="property">style</span>.<span class="property">display</span>=<span class="string">&#x27;none&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">function</span> <span class="title function_">delReply</span>(<span class="params">replyId , topicId</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">if</span>(<span class="variable language_">window</span>.<span class="title function_">confirm</span>(<span class="string">&quot;是否确认删除？&quot;</span>))&#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">href</span>=<span class="string">&#x27;reply.do?operate=delReply&amp;replyId=&#x27;</span>+replyId+<span class="string">&#x27;&amp;topicId=&#x27;</span>+topicId;</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;div_reply_list&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span> <span class="attr">class</span>=<span class="string">&quot;reply_title&quot;</span> <span class="attr">th:onmouseover</span>=<span class="string">&quot;|showDelImg(&#x27;img$&#123;reply.id&#125;&#x27;)|&quot;</span> <span class="attr">th:onmouseout</span>=<span class="string">&quot;|hiddenDelImg(&#x27;img$&#123;reply.id&#125;&#x27;)|&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">&quot;|回复：$&#123;session.topic.title&#125;|&quot;</span>&gt;</span>萧某今天就和天下群雄决一死战，你们一起上吧！<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">                            出现删除这个小图标的条件：</span></span><br><span class="line"><span class="comment">                            1. 在我自己的空间（那当然我对自己的空间拥有所有的操作权限）</span></span><br><span class="line"><span class="comment">                            2. 当前回复的作者就是我（那我可以删除自己的回复）</span></span><br><span class="line"><span class="comment">                         --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">img</span> <span class="attr">th:if</span>=<span class="string">&quot;$&#123;session.userBasic.id==session.friend.id || session.userBasic.id==reply.author.id&#125;&quot;</span> <span class="attr">th:id</span>=<span class="string">&quot;|img$&#123;reply.id&#125;|&quot;</span> <span class="attr">class</span>=<span class="string">&quot;delReplyImg&quot;</span> <span class="attr">th:src</span>=<span class="string">&quot;@&#123;/imgs/del.jpg&#125;&quot;</span> <span class="attr">th:onclick</span>=<span class="string">&quot;|delReply($&#123;reply.id&#125; , $&#123;session.topic.id&#125;)|&quot;</span>/&gt;</span></span><br><span class="line">       </span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;title_date_right&quot;</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;reply.replyDate&#125;&quot;</span>&gt;</span>2021-09-01 14:35:15<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>每个日志的删除图标的id都不同，因为JavaScript会创建对象之后寻找对于id的标签进行操作</p><p>JavaScript方法：delReply(replyId , topicId)  </p><ul><li>发送请求：’reply.do?operate&#x3D;delReply&amp;replyId&#x3D;’+replyId+’&amp;topicId&#x3D;’+topicId;</li></ul></blockquote><h3 id="ReplyController-1"><a href="#ReplyController-1" class="headerlink" title="ReplyController"></a>ReplyController</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReplyController</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> ReplyService replyService ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">delReply</span><span class="params">(Integer replyId , Integer topicId)</span>&#123;</span><br><span class="line">        replyService.delReply(replyId);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;redirect:topic.do?operate=topicDetail&amp;id=&quot;</span>+topicId;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ReplyServiceImpl"><a href="#ReplyServiceImpl" class="headerlink" title="ReplyServiceImpl"></a>ReplyServiceImpl</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReplyServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">ReplyService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ReplyDAO replyDAO ;</span><br><span class="line">    <span class="comment">//此处引入的是其他POJO对应的Service接口，而不是DAO接口</span></span><br><span class="line">    <span class="comment">//其他POJO对应的业务逻辑是封装在service层的，我需要调用别人的业务逻辑方法，而不要去深入考虑人家内部的细节</span></span><br><span class="line">    <span class="keyword">private</span> HostReplyService hostReplyService ;</span><br><span class="line">    <span class="keyword">private</span> UserBasicService userBasicService ;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delReply</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        <span class="comment">//1.根据id获取到reply</span></span><br><span class="line">        <span class="type">Reply</span> <span class="variable">reply</span> <span class="operator">=</span> replyDAO.getReply(id);</span><br><span class="line">        <span class="keyword">if</span>(reply!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//2.如果reply有关联的hostReply，则先删除hostReply</span></span><br><span class="line">            <span class="type">HostReply</span> <span class="variable">hostReply</span> <span class="operator">=</span> hostReplyService.getHostReplyByReplyId(reply.getId());</span><br><span class="line">            <span class="keyword">if</span>(hostReply!=<span class="literal">null</span>)&#123;</span><br><span class="line">                hostReplyService.delHostReply(hostReply.getId());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//3.删除reply</span></span><br><span class="line">            replyDAO.delReply(id);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>delReply方法：如果回复有关联的主人回复，需要先删除主人回复</p></blockquote><h2 id="功能四实现"><a href="#功能四实现" class="headerlink" title="功能四实现"></a>功能四实现</h2><h3 id="功能四"><a href="#功能四" class="headerlink" title="功能四"></a>功能四</h3><p>删除日志</p><ol><li>删除日志，首先需要考虑是否有关联的回复</li><li>删除回复，首先需要考虑是否有关联的主人回复</li><li>另外，如果不是自己的空间，则不能删除日志</li></ol><h3 id="main-html-2"><a href="#main-html-2" class="headerlink" title="main.html"></a>main.html</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">language</span>=<span class="string">&quot;JavaScript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">function</span> <span class="title function_">delTopic</span>(<span class="params">topicId</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">if</span>(<span class="variable language_">window</span>.<span class="title function_">confirm</span>(<span class="string">&quot;是否确认删除日志？&quot;</span>))&#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">href</span>=<span class="string">&quot;topic.do?operate=delTopic&amp;topicId=&quot;</span>+topicId;</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span> <span class="attr">th:if</span>=<span class="string">&quot;$&#123;#lists.isEmpty(session.friend.topicList)&#125;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">th</span> <span class="attr">colspan</span>=<span class="string">&quot;4&quot;</span>&gt;</span>暂无日志列表<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span> <span class="attr">th:unless</span>=<span class="string">&quot;$&#123;#lists.isEmpty(session.friend.topicList)&#125;&quot;</span> <span class="attr">th:each</span>=<span class="string">&quot;topic : $&#123;session.friend.topicList&#125;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;删除&quot;</span> <span class="attr">th:if</span>=<span class="string">&quot;$&#123;session.userBasic.id==session.friend.id&#125;&quot;</span> <span class="attr">th:onclick</span>=<span class="string">&quot;|delTopic($&#123;topic.id&#125;)|&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="TopicController-1"><a href="#TopicController-1" class="headerlink" title="TopicController"></a>TopicController</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TopicController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TopicService topicService ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">delTopic</span><span class="params">(Integer topicId)</span>&#123;</span><br><span class="line">        topicService.delTopic(topicId);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;redirect:topic.do?operate=getTopicList&quot;</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getTopicList</span><span class="params">(HttpSession session)</span>&#123;</span><br><span class="line">        <span class="comment">//从session中获取当前用户信息</span></span><br><span class="line">        <span class="type">UserBasic</span> <span class="variable">userBasic</span> <span class="operator">=</span> (UserBasic)session.getAttribute(<span class="string">&quot;userBasic&quot;</span>);</span><br><span class="line">        <span class="comment">//再次查询当前用户关联的所有的日志</span></span><br><span class="line">        List&lt;Topic&gt; topicList = topicService.getTopicList(userBasic);</span><br><span class="line">        <span class="comment">//设置一下关联的日志列表(因为之前session中关联的friend的topicList和此刻数据库中不一致）</span></span><br><span class="line">        userBasic.setTopicList(topicList);</span><br><span class="line">        <span class="comment">//重新覆盖一下friend中的信息(为什么不覆盖userbasic中？因为main.html页面迭代的是friend这个key中的数据)</span></span><br><span class="line">        session.setAttribute(<span class="string">&quot;friend&quot;</span>,userBasic);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;frames/main&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里是删除完日志后不能直接访问main.html，因为其中session中friend的topicList还没更新，所以再次请求，完成getTopicList方法，更新topicList</p></blockquote><h3 id="TopicServiceImpl"><a href="#TopicServiceImpl" class="headerlink" title="TopicServiceImpl"></a>TopicServiceImpl</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TopicServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">TopicService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">TopicDAO</span> <span class="variable">topicDAO</span> <span class="operator">=</span> <span class="literal">null</span> ;</span><br><span class="line">    <span class="comment">//此处引用的是replyService，而不是replyDAO</span></span><br><span class="line">    <span class="keyword">private</span> ReplyService replyService ;</span><br><span class="line">    <span class="keyword">private</span> UserBasicService userBasicService ;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delTopic</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">    <span class="type">Topic</span> <span class="variable">topic</span> <span class="operator">=</span> topicDAO.getTopic(id);</span><br><span class="line">    <span class="keyword">if</span>(topic!=<span class="literal">null</span>)&#123;</span><br><span class="line">        replyService.delReplyList(topic); <span class="comment">//删除日志先删除回复列表</span></span><br><span class="line">        topicDAO.delTopic(topic);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ReplyServiceImpl-1"><a href="#ReplyServiceImpl-1" class="headerlink" title="ReplyServiceImpl"></a>ReplyServiceImpl</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReplyServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">ReplyService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ReplyDAO replyDAO ;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delReplyList</span><span class="params">(Topic topic)</span> &#123;</span><br><span class="line">    List&lt;Reply&gt; replyList = replyDAO.getReplyList(topic);</span><br><span class="line">    <span class="keyword">if</span>(replyList!=<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(Reply reply : replyList)&#123; <span class="comment">//逐个删除回复</span></span><br><span class="line">            delReply(reply.getId()); <span class="comment">//删除该条回复，包括回复关联有主人回复的回复</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复习总结-1"><a href="#复习总结-1" class="headerlink" title="复习总结"></a>复习总结</h2><h3 id="1-日期和字符串之间的格式化"><a href="#1-日期和字符串之间的格式化" class="headerlink" title="1.日期和字符串之间的格式化"></a>1.日期和字符串之间的格式化</h3><p> String -&gt; java.util.Date</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">dateStr1</span> <span class="operator">=</span> <span class="string">&quot;2021-12-30 12:59:59&quot;</span>;</span><br><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">Date</span> <span class="variable">date1</span> <span class="operator">=</span> sdf.parse(dateStr1);</span><br><span class="line">&#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Date -&gt; String</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Date</span> <span class="variable">date2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="type">String</span> <span class="variable">dateStr2</span> <span class="operator">=</span> sdf.format(date2);</span><br></pre></td></tr></table></figure><blockquote><p>thymeleaf中使用#dates这个公共的内置对象，进行修改网页显示的时间格式<br>$</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;课程体系设计&quot;&gt;&lt;a href=&quot;#课程体系设计&quot; class=&quot;headerlink&quot; title=&quot;课程体系设计&quot;&gt;&lt;/a&gt;课程体系设计&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/2022/09/30/JavaWeb/image-20220608183738984.</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>计算机网络</title>
    <link href="http://example.com/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <id>http://example.com/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</id>
    <published>2022-09-29T16:00:00.000Z</published>
    <updated>2022-10-05T10:56:58.701Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-计算机网络概述"><a href="#1-计算机网络概述" class="headerlink" title="1.计算机网络概述"></a>1.计算机网络概述</h1><h2 id="1-计算机网络在信息时代的作用"><a href="#1-计算机网络在信息时代的作用" class="headerlink" title="1. 计算机网络在信息时代的作用"></a>1. 计算机网络在信息时代的作用</h2><ul><li>计算机网络已由一种通信基础设施发展成为一种重要的信息服务基础设施。</li><li>计算机网络已经像水、电、煤气这些基础设施一样，成为我们生活中不可或缺的一部分。</li></ul><h2 id="2-因特网概述"><a href="#2-因特网概述" class="headerlink" title="2. 因特网概述"></a>2. 因特网概述</h2><h3 id="1-网络、互连网-互联网-和因特网￥"><a href="#1-网络、互连网-互联网-和因特网￥" class="headerlink" title="1. 网络、互连网(互联网)和因特网￥"></a>1. 网络、互连网(互联网)和因特网￥</h3><ol><li>网络(Network)由若干结点(Node)和连接这些结点的链路(Link)组成。</li><li>多个网络还可以通过路由器互连起来，这样就构成了一个覆盖范围更大的网络，即互联网（或互连网)因此，互联网是“网络的网络(Netwrok of Networks) “。</li><li>因特网(Internet)是世界上最大的互连网络（用户数以亿计，互连的网络数以百万计)。</li><li>internet与lnternet的区别<br><strong>internet(互联网或互连网)</strong> 是一个通用名词，它泛指由多个计算机网络互连而成的网络。在这些网络之间的通信协议可以是任意的。<br><strong>Internet(因特网)</strong> 则是一个专用名词，它指当前全球最大的、开放的、由众多网络相互连接而成的特定计算机网络，它采用TCP&#x2F;IP协议族作为通信的规则，其前身是美国的 <strong>ARPANET</strong>。</li></ol><h3 id="2-因特网发展的三个阶段"><a href="#2-因特网发展的三个阶段" class="headerlink" title="2. 因特网发展的三个阶段"></a>2. 因特网发展的三个阶段</h3><p>单个网络ARPANET—向互联网发展–&gt;三级结构的因特网—逐步形成–&gt;多层次ISP结构的因特网</p><h4 id="1-从单个网络ARPANET向互联网发展"><a href="#1-从单个网络ARPANET向互联网发展" class="headerlink" title="1. 从单个网络ARPANET向互联网发展"></a>1. 从单个网络ARPANET向互联网发展</h4><ul><li>1969年，第一个分组交换网 <strong>ARPANET</strong>;</li><li>70年代中期，研究多种网络之间的互连;</li><li>1983年,TCP&#x2F;IP协议成为ARPANET的标准协议(因特网诞生时间)</li></ul><h4 id="2-逐步建成三级结构的因特网"><a href="#2-逐步建成三级结构的因特网" class="headerlink" title="2. 逐步建成三级结构的因特网"></a>2. 逐步建成三级结构的因特网</h4><ul><li>1985年，NSF围绕六个大型计算机中心建设NSFNET（主干网、地区网和校园网）;</li><li>1990年，ARPANET任务完成，正式关闭;</li><li>1991年，美国政府将因特网主干网交给私人公司经营，并开始对接入因特网的单位收费;</li></ul><h4 id="3-多层次ISP结构的因特网"><a href="#3-多层次ISP结构的因特网" class="headerlink" title="3. 多层次ISP结构的因特网"></a>3. 多层次ISP结构的因特网</h4><ul><li>1993年，NSFNET逐渐被若干个商用因特网主干网替代;政府机构不再负责因特网运营，让各种<strong>因特网服务提供者ISP</strong>来运营。</li><li>1994年，万维网wwW技术促使因特网迅猛发展;</li><li>1995年，NSFNET停止运作，因特网彻底商业化。</li></ul><blockquote><p>ISP: 因特网服务提供者ISP（Internet Service Provider）</p></blockquote><h5 id="因特网服务提供者ISP"><a href="#因特网服务提供者ISP" class="headerlink" title="因特网服务提供者ISP"></a>因特网服务提供者ISP</h5><p>图示ISP使用：<img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-02-14_17-54-01.png" alt="Snipaste_2022-02-14_17-54-01"></p><p>1.普通用户通过ISP接入到因特网</p><p>2.因为ISP可从因特网管理机构获取成块的IP地址，同时拥有通信设备及路由器等连网设备。任何机构和个人，只要向ISP缴纳规定的费用，就可以从ISP得到所需的IP地址。</p><p>3.因特网上的主机只能有IP地址才能通信</p><p>4.我国主要的ISP是我们比较熟悉的中国电信、中国联通、中国移动这三大电信运营商。</p><p>5.一旦某个用户能够接入到因特网，那么他也可以成为一个ISP，所需要做的就是购买一些如调制解调器或路由器这样的设备，让其他用户可以和他相连。</p><h3 id="3-因特网的标准化工作"><a href="#3-因特网的标准化工作" class="headerlink" title="3.因特网的标准化工作"></a>3.因特网的标准化工作</h3><ol><li>因特网的标准化工作对因特网的发展起到了非常重要的作用。</li><li>因特网在制定其标准上的一个很大的特点是<strong>面向公众</strong>。<ul><li>因特网所有的RFC(Request For Comments)技术文档都可从因特网上免费下载;(<a href="http://www.ietf.org/rfc.html">http://www.ietf.org/rfc.html</a>)</li><li>任何人都可以随时用电子邮件发表对某个文档的意见或建议。</li></ul></li><li><strong>因特网协会ISOC</strong>是一个国际性组织，它负责对因特网进行全面管理，以及在世界范围内促进其发展和使用。<ul><li>因特网体系结构委员会IAB，负责管理因特网有关协议的开发;</li><li>因特网工程部IETF，负责研究中短期工程问题，主要针对协议的开发和标准化;</li><li>因特网研究部IRTF，从事理论方面的研究和开发一些需要长期考虑的问题。</li></ul></li><li>制订因特网的正式标准要经过以下<strong>4个阶段</strong>:<ol><li>因特网草案(在这个阶段还不是RFC文档)</li><li>建议标准 (从这个阶段开始就成为RFC文档)</li><li>草案标准 (目前已取消)</li><li>因特网标准</li></ol></li></ol><h3 id="4-因特网组成￥"><a href="#4-因特网组成￥" class="headerlink" title="4.因特网组成￥"></a>4.因特网组成￥</h3><p>因特网由边缘部分和核心部分组成。</p><h4 id="1-边缘部分"><a href="#1-边缘部分" class="headerlink" title="1. 边缘部分"></a>1. 边缘部分</h4><p>由所有连接在因特网上的 <strong>主机</strong> 组成。这部分是 <strong>用户直接</strong> 使用的，用来进行 <strong>通信</strong> （传送数据、音频或视频）和 <strong>资源共享</strong></p><h4 id="2-核心部分"><a href="#2-核心部分" class="headerlink" title="2. 核心部分"></a>2. 核心部分</h4><p>由 <strong>大量网络</strong> 和连接这些网络的 <strong>路由器</strong> 组成。这部分是 <strong>为边缘部分提供服务</strong> 的(提供连通性和交换)</p><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-02-14_18-22-39.png" alt="Snipaste_2022-02-14_18-22-39"></p><blockquote><p>路由器是一种专用计算机，但我们不称它为主机，路由器是实现分组交换的关键构建，其任务是转发收到的分组，这是网络核心最重要的部分。</p><p>处在互联网边缘的部分就是连接在互联网上的所有的主机。这些主机又称为**端系统 (end system)**。</p><p><strong>端系统在功能上可能有很大的差别：</strong></p><ol><li>小的端系统可以是一台普通个人电脑，具有上网功能的智能手机，甚至是一个很小的网络摄像头。</li><li>大的端系统则可以是一台非常昂贵的大型计算机。</li><li>端系统的拥有者可以是个人，也可以是单位（如学校、企业、政府机关等），当然也可以是某个ISP。</li></ol></blockquote><h3 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h3><p><strong>端系统之间通信的含义</strong></p><p>“主机 A 和主机 B 进行通信”实际上是指：“运行在主机 A 上的某个程序和运行在主机 B 上的另一个程序进行通信”。<strong>即“主机</strong>  <strong>A</strong>  <strong>的某个进程和主机</strong>  <strong>B</strong>  <strong>上的另一个进程进行通信”。简称为“计算机之间通信”。</strong></p><p>端系统之间的通信方式通常可划分为两大类：</p><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-02-14_18-44-50.png" alt="Snipaste_2022-02-14_18-44-50"></p><p><strong>客户-服务器方式：</strong></p><ul><li>客户 (client) 和服务器 (server) 都是指通信中所涉及的两个应用进程。</li><li>客户 - 服务器方式所描述的是进程之间服务和被服务的关系。</li><li>客户是服务的请求方，服务器是服务的提供方。</li></ul><blockquote><p><strong>服务请求方和服务提供方都要使用网络核心部分所提供的服务。</strong></p></blockquote><p><strong>对等连接方式：</strong></p><ul><li><strong>对等连接</strong> (peer-to-peer，简写为 <strong>P2P</strong> ) 是指两个主机在通信时并不区分哪一个是服务请求方还是服务提供方。</li><li>只要两个主机都运行了对等连接软件 ( P2P 软件) ，它们就可以进行<strong>平等的、对等连接通信</strong>。</li><li>双方都可以下载对方已经存储在硬盘中的共享文档。</li></ul><h2 id="3-三种交换方式"><a href="#3-三种交换方式" class="headerlink" title="3.三种交换方式"></a>3.三种交换方式</h2><p>网络核心部分是互联网中最复杂的部分。</p><p>网络中的核心部分要向网络边缘中的大量主机提供连通性，使边缘部分中的任何一个主机都能够向其他主机通信（即传送或接收各种形式的数据）。</p><p>在网络核心部分起特殊作用的是<strong>路由器</strong>(router)。</p><p><strong>路由器</strong>是实现<strong>分组交换</strong> (packet switching) 的关键构件，其任务是<strong>转发</strong>收到的分组，这是网络核心部分最重要的功能。</p><h3 id="1、电路交换（Circuit-Switching）"><a href="#1、电路交换（Circuit-Switching）" class="headerlink" title="1、电路交换（Circuit Switching）"></a>1、电路交换（Circuit Switching）</h3><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-02-14_18-45-29.png" alt="Snipaste_2022-02-14_18-45-29"></p><blockquote><p>传统两两相连的方式，当电话数量很多时，电话线也很多，就很不方便</p><p>所以要使得每一部电话能够很方便地和另一部电话进行通信，就应该使用一个<strong>中间设备</strong>将这些电话连接起来，这个中间设备就是<strong>电话交换机</strong></p></blockquote><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-02-14_18-45-57.png" alt="Snipaste_2022-02-14_18-45-57"></p><ul><li><p>电话交换机接通电话线的方式称为电路交换；</p></li><li><p>从通信资源的分配角度来看，交换（Switching）就是按照某种方式动态地分配传输线路的资源；</p></li><li><p>电路交换的三个步骤：</p><p>1、建立连接（分配通信资源）</p><p>2、通话（一直占用通信资源）</p><p>3、释放连接（归还通信资源）</p></li></ul><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-02-14_18-46-28.png" alt="Snipaste_2022-02-14_18-46-28"></p><blockquote><p>当使用电路交换来传送计算机数据时，其线路的传输效率往往很低。</p><p>这是因为计算机数据是突发式地出现在传输线路上的。</p><p>所以计算机通常采用的是<strong>分组交换</strong>，而不是线路交换</p></blockquote><h3 id="2、分组交换（Packet-Switching）￥"><a href="#2、分组交换（Packet-Switching）￥" class="headerlink" title="2、分组交换（Packet Switching）￥"></a>2、分组交换（Packet Switching）￥</h3><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-02-14_18-46-58.png" alt="Snipaste_2022-02-14_18-46-58"></p><blockquote><p>通常我们把表示<strong>该消息的整块数据</strong>成为一个<strong>报文</strong>。</p><p>在发送报文之前，先把较长的报文划分成一个个更小的<strong>等长数据段</strong>，在每一个数据段前面。加上一些由必<strong>要的控制信息组成的首部</strong>后，就构成一个分组，也可简称为“包”，相应地，首部也可称为“包头”。</p><p>首部包含了<strong>分组的目的地址</strong></p><p>分组从源主机到目的主机，可走不同的路径。</p></blockquote><p>发送方</p><ul><li>构造分组</li><li>发送分组</li></ul><p>路由器</p><ul><li>缓存分组</li><li>转发分组</li><li>简称为“分组转发”</li></ul><blockquote><p>在路由器中的输入和输出端口之间没有直接连线。</p><p>路由器处理分组的过程是：</p><ol><li>把收到的分组先<strong>放入缓存（暂时存储）；</strong></li><li><em>查找转发表*<em>，找出到某个目的地址应从哪个端口转发；</em></em></li><li><strong>把分组送到适当的端口转发</strong>出去。</li></ol></blockquote><p>接收方</p><ul><li>接收分组</li><li>还原报文</li></ul><h3 id="3、报文交换（Message-Switching）"><a href="#3、报文交换（Message-Switching）" class="headerlink" title="3、报文交换（Message Switching）"></a>3、报文交换（Message Switching）</h3><p>报文交换中的交换结点也采用存储转发方式，但报文交换对报文的大小没有限制，这就要求交换结点需要较大的缓存空间。报文交换主要用于早期的电报通信网，现在较少使用，<strong>通常被较先进的分组交换方式所取代</strong>。</p><h3 id="三种交换方式的对比"><a href="#三种交换方式的对比" class="headerlink" title="三种交换方式的对比"></a>三种交换方式的对比</h3><blockquote><p>假设A，B，C，D是分组传输路径所要经过的4个结点交换机，纵坐标为时间</p></blockquote><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-02-14_18-47-38.png" alt="Snipaste_2022-02-14_18-47-38"></p><p>分析：</p><p>电路交换：</p><ul><li>通信之前首先要建立连接；连接建立好之后，就可以使用已建立好的连接进行数据传送；数据传送后，需释放连接，以归还之前建立连接所占用的通信线路资源。</li><li>一旦建立连接，中间的各结点交换机就是直通形式的，比特流可以直达终点；</li></ul><p>报文交换：</p><ul><li>可以随时发送报文，而不需要事先建立连接；整个报文先传送到相邻结点交换机，全部存储下来后进行查表转发，转发到下一个结点交换机。</li><li>整个报文需要在各结点交换机上进行存储转发，由于不限制报文大小，因此需要各结点交换机都具有较大的缓存空间。</li></ul><p>分组交换：</p><ul><li>可以随时发送分组，而不需要事先建立连接。构成原始报文的一个个分组，依次在各结点交换机上存储转发。各结点交换机在发送分组的同时，还缓存接收到的分组。</li><li>构成原始报文的一个个分组，在各结点交换机上进行存储转发，相比报文交换，减少了转发时延，还可以避免过长的报文长时间占用链路，同时也有利于进行差错控制。</li></ul><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-02-14_18-49-04.png" alt="Snipaste_2022-02-14_18-49-04"></p><h2 id="4-计算机网络的定义和分类"><a href="#4-计算机网络的定义和分类" class="headerlink" title="4.计算机网络的定义和分类"></a>4.计算机网络的定义和分类</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul><li>计算机网络的精确定义并未统一</li><li>计算机网络的最简单的定义是：一些<strong>互</strong>相<strong>连</strong>接的、<strong>自治</strong>的计算机的<strong>集合</strong>。<ul><li>互连：是指计算机之间可以通过有线或无线的方式进行数据通信；</li><li>自治：是指独立的计算机，他有自己的硬件和软件，可以单独运行使用；</li><li>集合：是指至少需要两台计算机；</li></ul></li><li>计算机网络的较好的定义是：计算机网络主要是由一些<strong>通用的，可编程的硬件（一定包含有中央处理机CPU）互连</strong>而成的，而这些硬件并非专门用来实现某一特定目的（例如，传送数据或视频信号）。这些可编程的硬件能够用来<strong>传送多种不同类型的数据</strong>，并能<strong>支持广泛的和日益增长的应用</strong>。<ul><li>计算机网络所连接的硬件，并不限于一般的计算机，而是包括了智能手机等智能硬件。</li><li>计算机网络并非专门用来传送数据，而是能够支持很多种的应用（包括今后可能出现的各种应用）。</li></ul></li></ul><h3 id="分类￥"><a href="#分类￥" class="headerlink" title="分类￥"></a>分类￥</h3><p><strong>按交换技术分类：</strong></p><ul><li>电路交换网络</li><li>报文交换网络</li><li>分组交换网络</li></ul><p><strong>按使用者分类：</strong></p><ul><li>公用网</li><li>专用网</li></ul><p><strong>按传输介质分类：</strong></p><ul><li>有线网络</li><li>无线网络</li></ul><p><strong>按覆盖范围分类：</strong></p><ul><li>广域网WAN（Wide Area Network）</li></ul><p>作用范围通常为几十到几千公里，因而有时也称为远程网（long haul network）。广域网是互联网的核心部分，其任务是通过长距离（例如，跨越不同的国家）运送主机所发送的数据。</p><ul><li>城域网MAN</li></ul><p>作用范围一般是一个城市，可跨越几个街区甚至整个城市</p><ul><li>局域网LAN</li></ul><p>一般用微型计算机或工作站通过高速通信线路相连（速率通常在 10 Mbit&#x2F;s 以上），但地理上范围较小（1 km 左右）</p><ul><li>个域网PAN</li></ul><p>就是在个人工作的地方把个人使用的电子设备用无线技术连接起来的网络。</p><p><strong>按拓扑结构分类：</strong></p><ul><li>总线型网络</li></ul><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-02-14_21-20-10.png" alt="Snipaste_2022-02-14_21-20-10"></p><ul><li>星型网络</li></ul><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-02-14_21-20-16.png" alt="Snipaste_2022-02-14_21-20-16"></p><ul><li>环形网络</li></ul><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-02-14_21-20-20.png" alt="Snipaste_2022-02-14_21-20-20"></p><ul><li>网状型网络</li></ul><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-02-14_21-20-31.png" alt="Snipaste_2022-02-14_21-20-31"></p><h2 id="5-计算机网络的性能指标"><a href="#5-计算机网络的性能指标" class="headerlink" title="5.计算机网络的性能指标"></a>5.计算机网络的性能指标</h2><h3 id="速率"><a href="#速率" class="headerlink" title="速率"></a>速率</h3><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-02-15_11-36-56.png" alt="Snipaste_2022-02-15_11-36-56"></p><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-02-15_11-38-08.png" alt="Snipaste_2022-02-15_11-38-08"></p><h3 id="带宽￥"><a href="#带宽￥" class="headerlink" title="带宽￥"></a>带宽￥</h3><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-02-15_11-38-48.png" alt="Snipaste_2022-02-15_11-38-48"></p><h3 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h3><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-02-15_11-40-38.png" alt="Snipaste_2022-02-15_11-40-38"></p><blockquote><p>带宽1 Gb&#x2F;s的以太网，代表其额定速率是1 Gb&#x2F;s，这个数值也是该以太网的<strong>吞吐量的绝对上限值</strong>。因此，对于带宽1 Gb&#x2F;s的以太网，可能实际吞吐量只有 700 Mb&#x2F;s，甚至更低。</p><p>注意：吞吐量还可以用每秒传送的字节数或帧数表示</p></blockquote><h3 id="时延￥"><a href="#时延￥" class="headerlink" title="时延￥"></a>时延￥</h3><p>时延时指数据（一个报文或分组，甚至比特）从网络（或链路）的一端传送到另一端所需的时间。</p><p>网络时延由几部分组成：</p><ul><li>发送时延</li></ul><p>主机或路由器发送数据帧所需要的时间，也就是从发送数据帧的第一个比特算起，到该帧的最后一个比特发送完毕所需的时间。</p><ul><li>传播时延</li></ul><p>电磁波在信道中传播一定的距离需要花费的时间。</p><ul><li>处理时延</li></ul><p>主机或路由器在收到分组时要花费一定时间进行处理</p><ul><li>排队时延</li></ul><p>分组在进过网络传输时，要经过许多路由器。但分组在进入路由器后要先在输入队列中排队等待处理。</p><blockquote><p>有时会把排队时延看成<strong>处理时延 一部分</strong></p><p>总时延 &#x3D; 发送时延 + 传播时延 + 处理时延 （处理时延 + 排队时延）</p></blockquote><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-02-15_11-42-57.png" alt="Snipaste_2022-02-15_11-42-57"></p><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-02-15_11-43-06.png" alt="Snipaste_2022-02-15_11-43-06"></p><blockquote><p>当处理时延忽略不计时，发送时延 和 传播时延谁占主导，要具体情况具体分析</p></blockquote><h3 id="时延带宽积"><a href="#时延带宽积" class="headerlink" title="时延带宽积"></a>时延带宽积</h3><p>时延带宽积 &#x3D; 传播时延 * 带宽</p><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-02-15_11-43-23.png" alt="Snipaste_2022-02-15_11-43-23"></p><h3 id="往返时间"><a href="#往返时间" class="headerlink" title="往返时间"></a>往返时间</h3><p>互联网上的信息不仅仅单方向传输而是双向交互的。因此，我们有时很需要知道<strong>双向交互一次所需的时间</strong>。</p><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-02-15_11-43-33.png" alt="Snipaste_2022-02-15_11-43-33"></p><h3 id="利用率￥"><a href="#利用率￥" class="headerlink" title="利用率￥"></a>利用率￥</h3><p>利用率有<strong>信道利用率</strong>和<strong>网络利用率</strong>两种。</p><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-02-15_11-43-42.png" alt="Snipaste_2022-02-15_11-43-42"></p><h3 id="丢包率"><a href="#丢包率" class="headerlink" title="丢包率"></a>丢包率</h3><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-02-15_11-43-48.png" alt="Snipaste_2022-02-15_11-43-48"></p><hr><h2 id="6-计算机网络体系结构￥"><a href="#6-计算机网络体系结构￥" class="headerlink" title="6.计算机网络体系结构￥"></a>6.计算机网络体系结构￥</h2><h3 id="1、常见的计算机网络体系结构"><a href="#1、常见的计算机网络体系结构" class="headerlink" title="1、常见的计算机网络体系结构"></a>1、常见的计算机网络体系结构</h3><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-02-15_11-55-07.png" alt="Snipaste_2022-02-15_11-55-07"></p><blockquote><p>如今用的最多的是TCP&#x2F;IP体系结构，现今规模最大的、覆盖全球的、基于TCP&#x2F;IP的互联网并未使用OSI标准。</p><p>TCP&#x2F;IP体系结构相当于将OSI体系结构的<strong>物理层</strong>和<strong>数据链路层</strong>合并为了<strong>网络接口层</strong>，并去掉了<strong>会话层</strong>和<strong>表示层</strong>。</p><p>TCP&#x2F;IP在网络层使用的协议是IP协议，IP协议的意思是网际协议，因此<strong>TCP&#x2F;IP体系结构的网络层称为网际层</strong></p></blockquote><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-02-15_11-55-18.png" alt="Snipaste_2022-02-15_11-55-18"></p><blockquote><p>在用户主机的操作系统中，通常都带有符合TCP&#x2F;IP体系结构标准的TCP&#x2F;IP协议族。</p><p>而用于网络互连的路由器中，也带有符合TCP&#x2F;IP体系结构标准的TCP&#x2F;IP协议族。</p><p>只不过路由器一般只包含网络接口层和网际层。</p></blockquote><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-02-15_11-56-03.png" alt="Snipaste_2022-02-15_11-56-03"></p><blockquote><p><strong>网络接口层</strong>：并没有规定具体内容，这样做的目的是可以互连全世界各种不同的网络接口，例如：有线的以太网接口，无线局域网的WIFI接口等。</p><p><strong>网际层</strong>：它的核心协议是IP协议。</p><p><strong>运输层</strong>：TCP和UDP是这层的两个重要协议。</p><p><strong>应用层</strong>：这层包含了大量的应用层协议，如 HTTP , DNS 等。</p></blockquote><blockquote><p><strong>IP协议（网际层）</strong>可以将不同的<strong>网络接口（网络接口层）</strong>进行互连，并向其上的<strong>TCP协议和UDP协议（运输层）</strong>提供网络互连服务</p><p>而<strong>TCP协议</strong>在享受IP协议提供的网络互连服务的基础上，可向<strong>应用层的相应协议</strong>提供<strong>可靠</strong>的传输服务。</p><p><strong>UDP协议</strong>在享受IP协议提供的网络互连服务的基础上，可向<strong>应用层的相应协议</strong>提供<strong>不可靠</strong>的传输服务。</p></blockquote><blockquote><p>TCP&#x2F;IP体系结构中最重要的是<strong>IP协议</strong>和<strong>TCP协议</strong>，因此用TCP和IP来表示整个协议大家族。</p></blockquote><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-02-15_11-57-11.png" alt="Snipaste_2022-02-15_11-57-11"></p><blockquote><p>教学时把TCP&#x2F;IP体系结构的<strong>网络接口层</strong>分成了<strong>物理层</strong>和<strong>数据链路层</strong></p></blockquote><h3 id="2、计算机网络体系结构分层的必要性"><a href="#2、计算机网络体系结构分层的必要性" class="headerlink" title="2、计算机网络体系结构分层的必要性"></a>2、计算机网络体系结构分层的必要性</h3><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-02-15_12-37-47.png" alt="Snipaste_2022-02-15_12-37-47"></p><p><strong>物理层问题</strong></p><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-02-15_12-37-55.png" alt="Snipaste_2022-02-15_12-37-55"></p><blockquote><p>这图说明</p><ul><li><p>第一，严格来说，传输媒体并不属于物理层</p></li><li><p>计算机传输的信号，并不是图示的方波信号</p></li></ul><p>这样举例只是让初学者容易理解</p></blockquote><p><strong>数据链路层问题</strong></p><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-02-15_12-38-05.png" alt="Snipaste_2022-02-15_12-38-05"></p><p><strong>网络层问题</strong></p><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-02-15_12-38-19.png" alt="Snipaste_2022-02-15_12-38-19"></p><p><strong>运输层问题</strong></p><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-02-15_12-38-29.png" alt="Snipaste_2022-02-15_12-38-29"></p><blockquote><p>如何标识与网络通信相关的应用进程：一个分组到来，我们应该交给哪个进程处理呢？浏览器进程还是QQ进程</p></blockquote><p><strong>应用层问题</strong></p><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-02-15_12-38-35.png" alt="Snipaste_2022-02-15_12-38-35"></p><blockquote><p>应用层该用什么方法（应用层协议）去解析数据</p></blockquote><p><strong>总结</strong></p><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-02-15_12-38-43.png" alt="Snipaste_2022-02-15_12-38-43"></p><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-02-15_12-38-55.png" alt="Snipaste_2022-02-15_12-38-55"></p><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-02-15_12-58-19.png" alt="Snipaste_2022-02-15_12-58-19"></p><h3 id="3、计算机网络体系结构分层思想举例"><a href="#3、计算机网络体系结构分层思想举例" class="headerlink" title="3、计算机网络体系结构分层思想举例"></a>3、计算机网络体系结构分层思想举例</h3><p>例子：主机的浏览器如何与Web服务器进行通信</p><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-02-15_12-39-14.png" alt="Snipaste_2022-02-15_12-39-14"></p><p><strong>解析：</strong></p><p>主机和Web服务器之间基于网络的通信，实际上是主机中的<strong>浏览器应用进程</strong>与Web服务器中的<strong>Web服务器应用进程</strong>之间基于<strong>网络的通信</strong></p><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-02-15_12-41-25.png" alt="Snipaste_2022-02-15_12-41-25"></p><p><strong>体系结构的各层在整个过程中起到怎样的作用？</strong></p><p><strong>1、发送方发送</strong></p><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-02-15_12-41-36.png" alt="Snipaste_2022-02-15_12-41-36"></p><blockquote><p>第一步：</p><ul><li><p><strong>应用层</strong>按照HTTP协议的规定构建一个<strong>HTTP请求报文</strong></p></li><li><p>应用层将<strong>HTTP请求报文</strong>交付给<strong>运输层</strong>处理</p></li></ul></blockquote><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-02-15_12-41-44.png" alt="Snipaste_2022-02-15_12-41-44"></p><blockquote><p>第二步：</p><ul><li><p><strong>运输层</strong>给<strong>HTTP请求报文</strong>添加一个<strong>TCP首部</strong>，使之成为<strong>TCP报文段</strong></p></li><li><p><strong>TCP报文段的首部格式</strong>作用是区分应用进程以及实现可靠传输</p></li><li><p><strong>运输层</strong>将T<strong>CP报文段</strong>交付给<strong>网络层</strong>处理</p></li></ul></blockquote><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-02-15_12-41-52.png" alt="Snipaste_2022-02-15_12-41-52"></p><blockquote><p>第三步：</p><ul><li><p><strong>网络层</strong>给<strong>TCP报文段</strong>添加一个<strong>IP首部</strong>，使之成为<strong>IP数据报</strong></p></li><li><p><strong>IP数据报的首部格式</strong>作用是使<strong>IP数据报</strong>可以在互联网传输，也就是被路由器转发</p></li><li><p><strong>网络层</strong>将<strong>IP数据报</strong>交付给<strong>数据链路层</strong>处理</p></li></ul></blockquote><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-02-15_12-41-58.png" alt="Snipaste_2022-02-15_12-41-58"></p><blockquote><p>第四步：</p><ul><li><p><strong>数据链路层</strong>给<strong>IP数据报</strong>添加一个<strong>首部</strong>和一个<strong>尾部</strong>，使之成为<strong>帧</strong> （图示右边为首部，左边为尾部）</p></li><li><p>该<strong>首部</strong>的作用主要是为了让<strong>帧</strong>能够在一段链路上或一个网络上传输，能够被相应的目的主机接收</p></li><li><p>该<strong>尾部</strong>的作用是让目的主机检查所接收到的<strong>帧</strong>是否有误码</p></li><li><p><strong>数据链路层</strong>将<strong>帧</strong>交付给<strong>物理层</strong></p></li></ul></blockquote><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-02-15_12-42-08.png" alt="Snipaste_2022-02-15_12-42-08"></p><blockquote><p>第五步：</p><ul><li><p><strong>物理层</strong>先将<strong>帧</strong>看做是<strong>比特流</strong>，这里的网络N1假设是以太网，所以<strong>物理层</strong>还会给该<strong>比特流</strong>前面添加<strong>前导码</strong></p></li><li><p><strong>前导码</strong>的作用是为了让目的主机做好接收帧的准备</p></li><li><p><strong>物理层</strong>将装有<strong>前导码</strong>的<strong>比特流</strong>变换成相应的<strong>信号</strong>发送给传输媒体</p></li></ul></blockquote><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-02-15_12-42-18.png" alt="Snipaste_2022-02-15_12-42-18"></p><blockquote><p>第六步：</p><ul><li><strong>信号</strong>通过<strong>传输媒体</strong>到达<strong>路由器</strong></li></ul></blockquote><p><strong>2、路由器转发</strong></p><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-02-15_12-42-26.png" alt="Snipaste_2022-02-15_12-42-26"></p><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-02-15_12-42-32.png" alt="Snipaste_2022-02-15_12-42-32"></p><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-02-15_12-42-37.png" alt="Snipaste_2022-02-15_12-42-37"></p><blockquote><p>在路由器中</p><ul><li><p><strong>物理层</strong>将<strong>信号</strong>变为<strong>比特流</strong>，然后去掉<strong>前导码</strong>后，将其交付给<strong>数据链路层</strong></p></li><li><p><strong>数据链路层</strong>将<strong>帧</strong>的<strong>首部</strong>和<strong>尾部</strong>去掉后，将其交付给<strong>网络层</strong>，这实际交付的是<strong>IP数据报</strong></p></li><li><p><strong>网络层</strong>解析<strong>IP数据报</strong>的<strong>首部</strong>，从中提取<strong>目的网络地址</strong></p></li></ul></blockquote><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-02-15_12-42-51.png" alt="Snipaste_2022-02-15_12-42-51"></p><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-02-15_12-42-58.png" alt="Snipaste_2022-02-15_12-42-58"></p><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-02-15_12-43-04.png" alt="Snipaste_2022-02-15_12-43-04"></p><blockquote><p>在路由器中</p><ul><li><p>提取<strong>目的网络地址</strong>后查找<strong>自身路由表</strong>。确定<strong>转发端口</strong>， 以便进行转发</p></li><li><p><strong>网络层</strong>将<strong>IP数据报</strong>交付给<strong>数据链路层</strong></p></li><li><p><strong>数据链路层</strong>给<strong>IP数据报</strong>添加一个<strong>首部</strong>和一个<strong>尾部</strong>，使之成为<strong>帧</strong></p></li><li><p><strong>数据链路层</strong>将帧交付给<strong>物理层</strong></p></li><li><p><strong>物理层</strong>先将<strong>帧</strong>看成<strong>比特流</strong>，这里的网络N2假设是以太网，所以<strong>物理层</strong>还会给该<strong>比特流</strong>前面添加<strong>前导码</strong></p></li><li><p>物理层将装有<strong>前导码</strong>的<strong>比特流</strong>变换成相应的<strong>信号</strong>发送给传输媒体，信号通过传输媒体到达<strong>Web服务器</strong></p></li></ul></blockquote><p><strong>3、接收方接收</strong></p><blockquote><p>和发送方（主机）发送过程的封装正好是反着来</p><p>在Web 服务器上</p><ul><li><p><strong>物理层</strong>将<strong>信号</strong>变换为<strong>比特流</strong>，然后去掉<strong>前导码</strong>后成为<strong>帧</strong>，交付给<strong>数据链路层</strong></p></li><li><p><strong>数据链路层</strong>将<strong>帧</strong>的<strong>首部</strong>和<strong>尾部</strong>去掉后成为<strong>IP数据报</strong>，将其交付给<strong>网络层</strong></p></li><li><p><strong>网络层</strong>将<strong>IP数据报</strong>的<strong>首部</strong>去掉后成为<strong>TCP报文段</strong>，将其交付给<strong>运输层</strong></p></li><li><p><strong>运输层</strong>将<strong>TCP报文段</strong>的<strong>首部</strong>去掉后成为<strong>HTTP请求报文</strong>，将其交付给<strong>应用层</strong></p></li><li><p><strong>应用层</strong>对<strong>HTTP请求报文</strong>进行<strong>解析</strong>，然后给主机发回<strong>响应报文</strong></p></li></ul><p><strong>发回响应报文的步骤和之前过程类似</strong></p></blockquote><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-02-15_12-43-13.png" alt="Snipaste_2022-02-15_12-43-13"></p><h3 id="4、计算机网络体系结构中的专用术语"><a href="#4、计算机网络体系结构中的专用术语" class="headerlink" title="4、计算机网络体系结构中的专用术语"></a>4、计算机网络体系结构中的专用术语</h3><p>以下介绍的专用术语来源于OSI的七层协议体系结构，但也适用于TCP&#x2F;IP的四层体系结构和五层协议体系结构</p><p><strong>实体</strong></p><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-02-15_12-48-16.png" alt="Snipaste_2022-02-15_12-48-16"></p><p><strong>协议</strong></p><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-02-15_12-48-25.png" alt="Snipaste_2022-02-15_12-48-25"></p><blockquote><p>协议：控制两个对等实体进行逻辑通信的规则的集合</p><p>协议三要素：</p><ul><li><p>语法：定义所交换信息的格式</p></li><li><p>语义：定义收发双方所要完成的操作</p></li><li><p>同步：定义收发双发的时序关系</p></li></ul></blockquote><p><strong>服务</strong></p><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-02-15_12-48-45.png" alt="Snipaste_2022-02-15_12-48-45"></p><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-02-15_12-49-15.png" alt="Snipaste_2022-02-15_12-49-15"></p><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-02-15_12-49-33.png" alt="Snipaste_2022-02-15_12-49-33"></p><h2 id="第一章习题课"><a href="#第一章习题课" class="headerlink" title="第一章习题课"></a>第一章习题课</h2><h3 id="第一部分"><a href="#第一部分" class="headerlink" title="第一部分"></a>第一部分</h3><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-02-15_13-05-26.png" alt="Snipaste_2022-02-15_13-05-26"></p><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-02-15_12-59-32.png" alt="Snipaste_2022-02-15_12-59-32"></p><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-02-15_12-58-19.png" alt="Snipaste_2022-02-15_12-58-19"></p><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-02-15_13-05-14.png" alt="Snipaste_2022-02-15_13-05-14"></p><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-02-15_13-05-01.png" alt="Snipaste_2022-02-15_13-05-01"></p><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-02-15_13-09-14.png" alt="Snipaste_2022-02-15_13-09-14"></p><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-02-15_13-10-24.png" alt="Snipaste_2022-02-15_13-10-24"></p><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-02-15_13-11-07.png" alt="Snipaste_2022-02-15_13-11-07"></p><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-02-15_13-12-58.png" alt="Snipaste_2022-02-15_13-12-58"></p><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-02-15_13-13-43.png" alt="Snipaste_2022-02-15_13-13-43"></p><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-02-15_13-14-28.png" alt="Snipaste_2022-02-15_13-14-28"></p><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-02-15_14-33-53.png" alt="Snipaste_2022-02-15_14-33-53"></p><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-02-15_14-42-11.png" alt="Snipaste_2022-02-15_14-42-11"></p><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-02-15_14-45-56.png" alt="Snipaste_2022-02-15_14-45-56"></p><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-02-15_14-53-19.png" alt="Snipaste_2022-02-15_14-53-19"></p><h3 id="第二部分"><a href="#第二部分" class="headerlink" title="第二部分"></a>第二部分</h3><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-02-15_15-54-47.png" alt="Snipaste_2022-02-15_15-54-47"></p><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-02-15_15-55-40.png" alt="Snipaste_2022-02-15_15-55-40"></p><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-02-15_15-56-25.png" alt="Snipaste_2022-02-15_15-56-25"></p><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-02-15_15-14-55.png" alt="Snipaste_2022-02-15_15-14-55"></p><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-02-15_15-26-54.png" alt="Snipaste_2022-02-15_15-26-54"></p><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-02-15_15-30-41.png" alt="Snipaste_2022-02-15_15-30-41"></p><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-02-15_15-41-44.png" alt="Snipaste_2022-02-15_15-41-44"></p><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-02-15_15-54-01.png" alt="Snipaste_2022-02-15_15-54-01"></p><h1 id="2-物理层"><a href="#2-物理层" class="headerlink" title="2.物理层"></a>2.物理层</h1><h2 id="1-物理层的基本概念￥"><a href="#1-物理层的基本概念￥" class="headerlink" title="1.物理层的基本概念￥"></a>1.物理层的基本概念￥</h2><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-02-15_20-36-52.png" alt="Snipaste_2022-02-15_20-36-52"></p><hr><h2 id="2-物理层下面的传输媒体"><a href="#2-物理层下面的传输媒体" class="headerlink" title="2.物理层下面的传输媒体"></a>2.物理层下面的传输媒体</h2><p><strong>传输媒体</strong>也称为传输介质或传输媒介，他就是数据传输系统中在发送器和接收器之间的物理通路。<strong>传输媒体</strong>课分为两大类，即<strong>导引型传输媒体</strong>和<strong>非导引型传输媒体</strong></p><p>传输媒体不属于计算机网络体系结构的任何一层。如果非要将它添加到体系结构中，那只能将其放置到物理层之下。</p><h3 id="导引型传输媒体"><a href="#导引型传输媒体" class="headerlink" title="导引型传输媒体"></a>导引型传输媒体</h3><p>在导引型传输媒体中，电磁波被导引沿着固体媒体传播。</p><p><strong>同轴电缆</strong></p><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-02-15_20-37-32.png" alt="Snipaste_2022-02-15_20-37-32"></p><p><strong>双绞线￥</strong></p><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-02-15_20-37-50.png" alt="Snipaste_2022-02-15_20-37-50"></p><p><strong>光纤￥</strong></p><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-02-15_21-04-16.png" alt="Snipaste_2022-02-15_20-38-05"></p><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-02-15_20-38-22.png" alt="Snipaste_2022-02-15_20-38-22"></p><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-02-15_21-08-58.png" alt="Snipaste_2022-02-15_21-08-58"></p><blockquote><p><strong>多模光纤</strong></p><ul><li>可以存在多条不同角度入射的光线在一条光纤中传输。这种光纤就称为<strong>多模光纤</strong>。</li></ul><p><strong>单模光纤</strong></p><ul><li>若光纤的直径减小到只有一个光的波长，则光纤就像一根波导那样，它可使光线一直向前传播，而不会产生多次反射。这样的光纤称为<strong>单模光纤</strong>。</li></ul></blockquote><p><strong>电力线</strong></p><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-02-15_20-38-47.png" alt="Snipaste_2022-02-15_20-38-47"></p><h3 id="非导引型传输媒体"><a href="#非导引型传输媒体" class="headerlink" title="非导引型传输媒体"></a>非导引型传输媒体</h3><p>非导引型传输媒体是指自由空间。</p><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-02-15_20-39-01.png" alt="Snipaste_2022-02-15_20-39-01"></p><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-02-15_20-39-15.png" alt="Snipaste_2022-02-15_20-39-15"></p><p><strong>无线电波</strong></p><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-02-15_20-39-34.png" alt="Snipaste_2022-02-15_20-39-34"></p><p><strong>微波￥</strong></p><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-02-15_20-40-06.png" alt="Snipaste_2022-02-15_20-40-06"></p><p><strong>红外线</strong></p><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-02-15_20-40-32.png" alt="Snipaste_2022-02-15_20-40-32"></p><p><strong>可见光</strong></p><p>LIFI，对应WIFI,是一种未来的新无线技术</p><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-02-15_20-40-45.png" alt="Snipaste_2022-02-15_20-40-45"></p><hr><h2 id="3-传输方式"><a href="#3-传输方式" class="headerlink" title="3.传输方式"></a>3.传输方式</h2><h3 id="串行传输和并行传输￥"><a href="#串行传输和并行传输￥" class="headerlink" title="串行传输和并行传输￥"></a>串行传输和并行传输￥</h3><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-02-15_20-41-08.png" alt="Snipaste_2022-02-15_20-41-08"></p><blockquote><p><strong>串行传输</strong>：</p><ul><li>数据是一个比特一个比特依次发送的，因此在发送端与接收端之间，只需要一条数据传输线路即可</li></ul><p><strong>并行传输</strong>：</p><ul><li><p>一次发送n个比特，因此，在发送端和接收端之间需要有n条传输线路</p></li><li><p>并行传输的优点是比串行传输的速度n倍，但成本高</p></li></ul><p>数据在传输线路上的传输采用是<strong>串行传输</strong>，计算机内部的数据传输常用<strong>并行传输</strong></p></blockquote><h3 id="同步传输和异步传输￥"><a href="#同步传输和异步传输￥" class="headerlink" title="同步传输和异步传输￥"></a>同步传输和异步传输￥</h3><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-02-15_20-41-21.png" alt="Snipaste_2022-02-15_20-41-21"></p><blockquote><p><strong>同步传输</strong>：</p><ul><li><p>数据块以稳定的比特流的形式传输。字节之间没有间隔</p></li><li><p>接收端在每个比特信号的中间时刻进行检测，以判别接收到的是比特0还是比特1</p></li><li><p>由于不同设备的时钟频率存在一定差异，不可能做到完全相同，在传输大量数据的过程中，所产生的判别时刻的累计误差，会导致接收端对比特信号的判别错位</p></li></ul><p>所以要使收发双发时钟保持同步</p></blockquote><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-02-15_20-42-03.png" alt="Snipaste_2022-02-15_20-42-03"></p><blockquote><p><strong>异步传输</strong>：</p><ul><li><p>以字节为独立的传输单位，字节之间的时间间隔不是固定</p></li><li><p>接收端仅在每个字节的起始处对字节内的比特实现同步</p></li><li><p>通常在每个字节前后分别加上起始位和结束位</p></li></ul></blockquote><h3 id="单向通信（单工）、双向交替通信（半双工）和双向同时通信（全双工）"><a href="#单向通信（单工）、双向交替通信（半双工）和双向同时通信（全双工）" class="headerlink" title="单向通信（单工）、双向交替通信（半双工）和双向同时通信（全双工）"></a>单向通信（单工）、双向交替通信（半双工）和双向同时通信（全双工）</h3><p>在许多情况下，我们要使用“<strong>信道（channel）</strong>”这一名词。信道和电路并不等同。信道一般都是用来表示向某一个方向传送信息的媒体。因此，一条通信电路往往包含一条发送信道和一条接收信道。</p><p>从通信的双方信息交互的方式来看，可以有以下三种基本方式：</p><p><strong>单向通信</strong>：</p><p>又称为<strong>单工通信</strong>，即只能有一个方向的通信而没有反方向的交互。无线电广播或有线电以及电视广播就属于这种类型</p><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-02-15_20-42-33.png" alt="Snipaste_2022-02-15_20-42-33"></p><p><strong>双向交替通信</strong>：</p><p>又称为<strong>半双工通信</strong>，即通信的双方可以发送信息，但不能双方同时发送（当然也就不能同时接收）。这种通信方式使一方发送另一方接收，过一段时间后可以再反过来</p><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-02-15_20-42-40.png" alt="Snipaste_2022-02-15_20-42-40"></p><p><strong>双向同时通信</strong>：</p><p>又称为<strong>全双工通信</strong>，即通信的双发可以同时发送和接收信息。</p><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-02-15_20-42-47.png" alt="Snipaste_2022-02-15_20-42-47"></p><blockquote><p><strong>单向通信</strong>只需要一条信道，而<strong>双向交替通信</strong>或<strong>双向同时通信</strong>则需要两条信道（每个方向各一条）</p><p><strong>双向同时通信</strong>的传输效率最高</p></blockquote><h2 id="4-编码与调制"><a href="#4-编码与调制" class="headerlink" title="4.编码与调制"></a>4.编码与调制</h2><h3 id="数据通信中常用术语"><a href="#数据通信中常用术语" class="headerlink" title="数据通信中常用术语"></a>数据通信中常用术语</h3><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-02-15_20-43-02.png" alt="Snipaste_2022-02-15_20-43-02"></p><blockquote><p><strong>常用术语</strong></p><ul><li><p>消息(message)：需要计算机处理的文字、图片、音频、以及视频等统称为消息</p></li><li><p><strong>数据 (data)</strong> —— 运送消息的实体。计算机只能处理二进制数据。</p></li><li><p><strong>信号 (signal)</strong> —— 数据的电气的或电磁的表现。</p></li><li><p><strong>基带信号</strong>（即基本频带信号）—— 来自信源的信号。像计算机输出的代表各种文字或图像文件的数据信号都属于基带信号。</p></li><li><p><strong>模拟信号 (analogous signal)</strong> —— 代表消息的参数的取值是连续的。</p></li><li><p>模拟基带信号：例如麦克风采集到声音后所产生的音频信号。</p></li><li><p><strong>数字信号 (digital signal)</strong> —— 代表消息的参数的取值是离散的。</p></li><li><p>数字基带信号：例如在计算机内部，CPU与内存之间所传输的信号。</p></li><li><p><strong>编码：</strong>在不改变信号性质的前提下，仅对数字信号的波形进行变换，称为<strong>编码</strong>。编码后产生的信号仍为数字信号可以在数字信道中传输。</p></li><li><p><strong>调制：</strong>数字信号–&gt;模拟信号：把数字基带信号的频率范围搬移到较高的频段，并称为模拟信号，称为调制。调制后产生的信号仍为模拟信号可以在模拟信道中传输。</p></li><li><p>基带信号往往包含有较多的低频成分，甚至有直流成分，而许多信道并不能传输这种低频分量或直流分量。因此必须对基带信号进行<strong>调制</strong> (modulation)。</p></li><li><p><strong>码元 (code)</strong> —— 在使用时间域（或简称为时域）的波形表示数字信号时，代表不同离散数值的基本波形。</p></li></ul></blockquote><p>在计算机网络中，常见的是将<strong>数字基带信号</strong>通过<strong>编码或调制</strong>的方法在相应信道进行传输</p><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-02-15_20-43-18.png" alt="Snipaste_2022-02-15_20-43-18"></p><h3 id="传输媒体与信道的关系"><a href="#传输媒体与信道的关系" class="headerlink" title="传输媒体与信道的关系"></a><strong>传输媒体与信道的关系</strong></h3><blockquote><p><strong>信道的几个基本概念</strong></p><ul><li><p><strong>信道</strong> —— 一般用来表示向某一个方向传送信息的媒体。</p></li><li><p><strong>单向通信（单工通信）</strong>——只能有一个方向的通信而没有反方向的交互。单方面通信</p></li><li><p><strong>双向交替通信（半双工通信）</strong>——通信的双方都可以发送信息，但不能双方同时发送(当然也就不能同时接收)。–对讲机</p></li><li><p><strong>双向同时通信（全双工通信）</strong>——通信的双方可以同时发送和接收信息。–打电话</p></li></ul></blockquote><p>严格来说，传输媒体不能和信道划等号</p><p>对于单工传输，传输媒体只包含一个信道，要么是发送信道，要么是接收信道</p><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-02-15_20-43-28.png" alt="Snipaste_2022-02-15_20-43-28"></p><p>对于半双工和全双工，传输媒体中要包含两个信道，一个发送信道，另一个是接收信道</p><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-02-15_20-43-37.png" alt="Snipaste_2022-02-15_20-43-37"></p><blockquote><p>如果使用信道复用技术，一条传输媒体还可以包含多个信道</p></blockquote><h3 id="编码￥"><a href="#编码￥" class="headerlink" title="编码￥"></a>编码￥</h3><p>1.数字信号转换为另一种数字信号，在数字信道中传输。例如以太网使用曼特斯特编码、4B&#x2F;5B、8B&#x2F;10B等编码。</p><p>2.模拟信号转换为数字信号，在数字信道中传输。例如对音频信号进行编码的脉码调制PCM</p><h4 id="常用编码"><a href="#常用编码" class="headerlink" title="常用编码"></a>常用编码</h4><p><strong>不归零编码NRZ</strong></p><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-02-15_20-43-47.png" alt="Snipaste_2022-02-15_20-43-47"></p><blockquote><ul><li><p>正电平表示比特1&#x2F;0</p></li><li><p>负电平表示比特0&#x2F;1</p></li></ul><p>中间的虚线是零电平，所谓不归零编码，就是指在整个码元时间内，电平不会出现零电平</p><p><strong>实际比特1和比特0的表示要看现实怎么规定</strong></p></blockquote><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-02-15_20-44-00.png" alt="Snipaste_2022-02-15_20-44-00"></p><blockquote><p>这需要发送方的发送与接收方的接收做到严格的同步</p><ul><li><p>需要<strong>额外一根传输线来传输时钟信号</strong>，使发送方和接收方同步，接收方按时钟信号的节拍来逐个接收码元</p></li><li><p><strong>但是</strong>对于计算机网络，<strong>宁愿利用这根传输线传输数据信号</strong>，而不是传输时钟信号</p></li></ul><p>由于<strong>不归零编码</strong>存在<strong>同步问题</strong>，因此计算机网络中的数据传输不采用这类编码！</p></blockquote><p><strong>归零编码RZ</strong></p><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-02-15_20-44-12.png" alt="Snipaste_2022-02-15_20-44-12"></p><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-02-15_20-44-23.png" alt="Snipaste_2022-02-15_20-44-23"></p><blockquote><p><strong>归零编码</strong>虽然<strong>自同步</strong>，但<strong>编码效率低</strong></p></blockquote><p><strong>曼彻斯特编码</strong></p><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-02-15_20-44-33.png" alt="Snipaste_2022-02-15_20-44-33"></p><blockquote><p>在每个码元时间的中间时刻，信号都会发生跳变</p><ul><li><p>负跳变表示比特1&#x2F;0</p></li><li><p>正跳变表示比特0&#x2F;1</p></li><li><p>码元中间时刻的跳变即表示时钟，又表示数据</p></li></ul><p><strong>实际比特1和比特0的表示要看现实怎么规定</strong></p><p>传统以太网使用的就是曼切斯特编码</p></blockquote><p><strong>差分曼彻斯特编码</strong></p><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-02-15_20-44-43.png" alt="Snipaste_2022-02-15_20-44-43"></p><blockquote><p>在每个码元时间的中间时刻，信号都会发送跳变，但与<strong>曼彻斯特不同</strong></p><ul><li><p><strong>跳变仅表示时钟</strong></p></li><li><p><strong>码元开始处电平是否变换表示数据</strong></p><ul><li><p>变化表示比特1&#x2F;0</p><ul><li>不变化表示比特0&#x2F;1</li></ul></li></ul></li></ul><p><strong>实际比特1和比特0的表示要看现实怎么规定</strong></p><p>比曼彻斯特编码变化少，更适合较高的传输速率</p></blockquote><p><strong>总结</strong></p><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-02-15_20-45-05.png" alt="Snipaste_2022-02-15_20-45-05"></p><h3 id="调制￥"><a href="#调制￥" class="headerlink" title="调制￥"></a>调制￥</h3><p>数字信号转换为模拟信号，在模拟信道中传输，例如WiFi，采用补码键控CCK&#x2F;直接序列扩频DSSS&#x2F;正交频分复用OFDM等<strong>调制</strong>方式。</p><p>模拟信号转换为另一种模拟信号，在模拟信道中传输，例如，语音数据加载到模拟的载波信号中传输。频分复用FDM技术，充分利用带宽资源。</p><h4 id="基本调制-二元制"><a href="#基本调制-二元制" class="headerlink" title="基本调制(二元制)"></a>基本调制(二元制)</h4><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-02-15_20-45-27.png" alt="Snipaste_2022-02-15_20-45-27"></p><blockquote><ul><li><p><strong>调幅AM</strong>：所调制的信号由两种不同振幅的基本波形构成。每个基本波形只能表示1比特信息量。</p></li><li><p><strong>调频FM</strong>：所调制的信号由两种不同频率的基本波形构成。每个基本波形只能表示1比特信息量。</p></li><li><p><strong>调相PM</strong>：所调制的信号由两种不同初相位的基本波形构成。每个基本波形只能表示1比特信息量。</p></li></ul><p>但是使用基本调制方法，<strong>1个码元只能包含1个比特信息</strong></p></blockquote><h4 id="混合调制-多元制"><a href="#混合调制-多元制" class="headerlink" title="混合调制(多元制)"></a>混合调制(多元制)</h4><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-02-15_20-45-49.png" alt="Snipaste_2022-02-15_20-45-49"></p><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-02-15_20-45-57.png" alt="Snipaste_2022-02-15_20-45-57"></p><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-02-15_20-46-05.png" alt="Snipaste_2022-02-15_20-46-05"></p><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-02-15_20-46-11.png" alt="Snipaste_2022-02-15_20-46-11"></p><blockquote><p>上图码元所对应的4个比特是错误的，码元不能随便对应4个比特，因采用对应关系的格雷码</p></blockquote><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-02-15_20-46-18.png" alt="Snipaste_2022-02-15_20-46-18"></p><h3 id="码元￥"><a href="#码元￥" class="headerlink" title="码元￥"></a>码元￥</h3><ul><li>在使用时间域的波形表示数字信号时，代表不同离散数值的基本波形。</li><li>简单来说，码元就是一段调制号的基本波形，可以表示比特信息</li></ul><h3 id="习题："><a href="#习题：" class="headerlink" title="习题："></a>习题：</h3><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-02-15_20-30-39.png" alt="Snipaste_2022-02-15_20-30-39"></p><h2 id="5-信道的极限容量"><a href="#5-信道的极限容量" class="headerlink" title="5.信道的极限容量"></a>5.信道的极限容量</h2><ul><li>任何实际的信道都不是理想的，在传输信号时会产生各种失真以及带来多种干扰。</li><li>码元传输的速率越高，或信号传输的距离越远，或传输媒体质量越差，在信道的输出端的波形的失真就越严重。</li></ul><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-02-16_12-38-34.png" alt="Snipaste_2022-02-16_12-38-34"></p><p>失真的原因：</p><ul><li>码元传输的速率越高</li><li>信号传输的距离越远</li><li>噪声干扰越大</li><li>传输媒体质量越差</li></ul><h3 id="奈氏准则"><a href="#奈氏准则" class="headerlink" title="奈氏准则"></a>奈氏准则</h3><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-02-16_12-38-48.png" alt="Snipaste_2022-02-16_12-38-48"></p><h3 id="香农公式"><a href="#香农公式" class="headerlink" title="香农公式"></a>香农公式</h3><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-02-16_12-39-01.png" alt="Snipaste_2022-02-16_12-39-01"></p><h3 id="奈氏准则和香农公式对比及意义："><a href="#奈氏准则和香农公式对比及意义：" class="headerlink" title="奈氏准则和香农公式对比及意义："></a>奈氏准则和香农公式对比及意义：</h3><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-02-16_12-39-12.png" alt="Snipaste_2022-02-16_12-39-12"></p><h3 id="本节习题"><a href="#本节习题" class="headerlink" title="本节习题"></a>本节习题</h3><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-02-16_11-14-59.png" alt="Snipaste_2022-02-16_11-14-59"></p><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-02-16_11-21-08.png" alt="Snipaste_2022-02-16_11-21-08"></p><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-02-16_11-28-53.png" alt="Snipaste_2022-02-16_11-28-53"></p><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-02-16_11-34-21.png" alt="Snipaste_2022-02-16_11-34-21"></p><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-02-16_11-40-32.png" alt="Snipaste_2022-02-16_11-40-32"></p><h3 id="补充：信道复用技术"><a href="#补充：信道复用技术" class="headerlink" title="补充：信道复用技术"></a>补充：信道复用技术</h3><p>本节内容视频未讲到，是《计算机网络（第7版）谢希仁》物理层的内容</p><h4 id="频分复用、时分复用和统计时分复用"><a href="#频分复用、时分复用和统计时分复用" class="headerlink" title="频分复用、时分复用和统计时分复用"></a>频分复用、时分复用和统计时分复用</h4><p>复用 (multiplexing) 是通信技术中的基本概念。</p><p>它允许用户使用一个共享信道进行通信，降低成本，提高利用率。</p><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-02-16_12-39-33.png" alt="Snipaste_2022-02-16_12-39-33"></p><p><strong>频分复用 FDM (Frequency Division Multiplexing)</strong></p><ul><li>将整个带宽分为多份，用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带。</li><li><strong>频分复用</strong>的所有用户在同样的时间<strong>占用不同的带宽资源</strong>（请注意，这里的“带宽”是频率带宽而不是数据的发送速率）。</li></ul><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-02-16_12-39-50.png" alt="Snipaste_2022-02-16_12-39-50"></p><p><strong>时分复用TDM (Time Division Multiplexing)</strong></p><ul><li><strong>时分复用</strong>则是将时间划分为一段段等长的<strong>时分复用帧（TDM帧）</strong>。每一个时分复用的用户在每一个 TDM 帧中占用固定序号的时隙。</li><li>每一个用户所占用的时隙是<strong>周期性地出现</strong>（其周期就是TDM帧的长度）的。</li><li>TDM 信号也称为<strong>等时</strong> (isochronous) 信号。</li><li><strong>时分复用的所有用户在不同的时间占用同样的频带宽度。</strong></li></ul><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-02-16_12-40-02.png" alt="Snipaste_2022-02-16_12-40-02"></p><ul><li><strong>时分复用可能会造成线路资源的浪费</strong><ul><li>使用时分复用系统传送计算机数据时，由于计算机数据的突发性质，用户对分配到的子信道的利用率一般是不高的。</li></ul></li></ul><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-02-16_12-40-13.png" alt="Snipaste_2022-02-16_12-40-13"></p><p><strong>统计时分复用 STDM (Statistic TDM)</strong></p><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-02-16_12-40-25.png" alt="Snipaste_2022-02-16_12-40-25"></p><h4 id="波分复用"><a href="#波分复用" class="headerlink" title="波分复用"></a>波分复用</h4><p>波分复用 WDM(Wavelength Division Multiplexing)</p><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-02-16_12-40-46.png" alt="Snipaste_2022-02-16_12-40-46"></p><h4 id="码分复用"><a href="#码分复用" class="headerlink" title="码分复用"></a>码分复用</h4><p>码分复用 CDM (Code Division Multiplexing)</p><ul><li>常用的名词是<strong>码分多址</strong> CDMA (Code Division Multiple Access)。</li><li>各用户使用经过特殊挑选的不同码型，因此彼此不会造成干扰。</li><li>这种系统发送的信号有很强的抗干扰能力，其频谱类似于白噪声，不易被敌人发现。</li></ul><h2 id="本章习题课"><a href="#本章习题课" class="headerlink" title="本章习题课"></a>本章习题课</h2><p>包括新讲的和已有的在小节中讲过的</p><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-02-16_13-12-29.png" alt="Snipaste_2022-02-16_13-12-29"></p><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-02-16_13-48-23.png" alt="Snipaste_2022-02-16_13-48-23"></p><h1 id="3-数据链路层"><a href="#3-数据链路层" class="headerlink" title="3.数据链路层"></a>3.数据链路层</h1><h2 id="1-数据链路层概述"><a href="#1-数据链路层概述" class="headerlink" title="1.数据链路层概述"></a>1.数据链路层概述</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><strong>链路</strong>是从一个结点到相邻结点的一段物理线路，<strong>数据链路</strong>则是在链路的基础上增加了一些必要的硬件（如网络适配器）和软件（如协议的实现）</p><p><strong>网络中的主机、路由器等都必须实现数据链路层</strong></p><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Learn_data\计算机网络\计算机网络/webp" alt="img"></p><p>image-20201011102531462</p><p><strong>局域网中的主机、交换机等都必须实现数据链路层</strong></p><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Learn_data\计算机网络\计算机网络\webp.webp" alt="img"></p><p>image-20201014004326549</p><p><strong>从层次上来看数据的流动</strong></p><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Learn_data\计算机网络\计算机网络\webp-16519361804912.webp" alt="img"></p><p>image-20201011102618878</p><p><strong>仅从数据链路层观察帧的流动</strong></p><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Learn_data\计算机网络\计算机网络\webp-16519361860814.webp" alt="img"></p><p>image-20201011102653161</p><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Learn_data\计算机网络\计算机网络\webp-16519361897066.webp" alt="img"></p><p>image-20201011102733584</p><blockquote><p>主机H1 到主机H2 所经过的网络可以是多种不同类型的</p><p><strong>注意：不同的链路层可能采用不同的数据链路层协议</strong></p></blockquote><p><strong>数据链路层使用的信道</strong></p><p>数据链路层属于计算机网路的低层。<strong>数据链路层使用的信道主要有以下两种类型：</strong></p><ul><li>点对点信道</li><li>广播信道</li></ul><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Learn_data\计算机网络\计算机网络\webp-16519362010458.webp" alt="img"></p><p>image-20201014004459744</p><blockquote><p><strong>局域网属于数据链路层</strong></p><p>局域网虽然是个网络。但我们并不把局域网放在网络层中讨论。这是因为在网络层要讨论的是多个网络互连的问题，是讨论分组怎么从一个网络，通过路由器，转发到另一个网络。</p><p>而在同一个局域网中，分组怎么从一台主机传送到另一台主机，但并不经过路由器转发。从整个互联网来看，<strong>局域网仍属于数据链路层</strong>的范围</p></blockquote><h3 id="三个重要问题"><a href="#三个重要问题" class="headerlink" title="三个重要问题"></a>三个重要问题</h3><p>数据链路层传送的协议数据单元是<strong>帧</strong></p><p><strong>封装成帧</strong></p><ul><li><strong>封装成帧</strong> (framing) 就是在一段数据的前后分别添加首部和尾部，然后就构成了一个帧。</li><li>首部和尾部的一个重要作用就是进行<strong>帧定界</strong>。</li></ul><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Learn_data\计算机网络\计算机网络\webp-165193620592210.webp" alt="img"></p><p>image-20201011103650253</p><p><strong>差错控制</strong></p><p>在传输过程中可能会产生<strong>比特差错</strong>：1 可能会变成 0， 而 0 也可能变成 1。</p><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Learn_data\计算机网络\计算机网络\webp-165193621046512.webp" alt="img"></p><p>image-20201011103917512</p><p><strong>可靠传输</strong></p><p>接收方主机收到有误码的帧后，是不会接受该帧的，会将它丢弃</p><p>如果数据链路层向其上层提供的是不可靠服务，那么丢弃就丢弃了，不会再有更多措施</p><p><strong>如果数据链路层向其上层提供的是可靠服务，那就还需要其他措施，来确保接收方主机还可以重新收到被丢弃的这个帧的正确副本</strong></p><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Learn_data\计算机网络\计算机网络\webp-165193621974514.webp" alt="img"></p><p>image-20201011105314053</p><blockquote><p>以上三个问题都是使用<strong>点对点信道的数据链路层</strong>来举例的</p></blockquote><p><strong>如果使用广播信道的数据链路层除了包含上面三个问题外，还有一些问题要解决</strong></p><p>如图所示，主机A，B，C，D，E通过一根总线进行互连，主机A要给主机C发送数据，代表帧的信号会通过总线传输到总线上的其他各主机，那么主机B，D，E如何知道所收到的帧不是发送给她们的，主机C如何知道发送的帧是发送给自己的</p><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Learn_data\计算机网络\计算机网络\webp-165193622273416.webp" alt="img"></p><p>image-20201011105824466</p><p>可以用编址（地址）的来解决</p><p>将帧的目的地址添加在帧中一起传输</p><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Learn_data\计算机网络\计算机网络\webp-165193622620918.webp" alt="img"></p><p>image-20201011110017415</p><p>还有数据碰撞问题</p><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Learn_data\计算机网络\计算机网络\webp-165193622857120.webp" alt="img"></p><p>image-20201011110129994</p><blockquote><p>随着技术的发展，交换技术的成熟，</p><p>在有线（局域网）领域 使用<strong>点对点链路</strong>和<strong>链路层交换机</strong>的<strong>交换式局域网</strong>取代了<del>共享式局域网</del></p><p>在无线局域网中仍然使用的是共享信道技术</p></blockquote><hr><h2 id="2-封装成帧"><a href="#2-封装成帧" class="headerlink" title="2.封装成帧"></a>2.封装成帧</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>封装成帧是指数据链路层给上层交付的协议数据单元添加帧头和帧尾使之成为帧</p><ul><li><strong>帧头和帧尾中包含有重要的控制信息</strong></li></ul><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Learn_data\计算机网络\计算机网络\webp-165193623116122.webp" alt="img"></p><p>image-20201011110851301</p><p>发送方的数据链路层将上层交付下来的协议数据单元封装成帧后，还要通过物理层，将构成帧的各比特，转换成电信号交给传输媒体，那么接收方的数据链路层如何从物理层交付的比特流中提取出一个个的帧？</p><p>答：需要帧头和帧尾来做<strong>帧定界</strong></p><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Learn_data\计算机网络\计算机网络\webp-165193623386524.webp" alt="img"></p><p>image-20201011111334052</p><p>但比不是每一种数据链路层协议的帧都包含有帧定界标志，例如下面例子</p><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Learn_data\计算机网络\计算机网络\webp-165193623641726.webp" alt="img"></p><p>image-20201011111729324</p><blockquote><p>前导码</p><ul><li><p>前同步码：作用是使接收方的时钟同步</p></li><li><p>帧开始定界符：表明其后面紧跟着的就是MAC帧</p></li></ul></blockquote><p>另外以太网还规定了帧间间隔为96比特时间，因此，MAC帧不需要帧结束定界符</p><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Learn_data\计算机网络\计算机网络\webp-165193623927528.webp" alt="img"></p><p>image-20201011112450187</p><h3 id="透明传输"><a href="#透明传输" class="headerlink" title="透明传输"></a>透明传输</h3><blockquote><p><strong>透明</strong>指某一个实际存在的事物看起来却好像不存在一样。</p></blockquote><p>透明传输是指<strong>数据链路层对上层交付的传输数据没有任何限制</strong>，好像数据链路层不存在一样</p><p>帧界定标志也就是个特定数据值，如果在上层交付的协议数据单元中， 恰好也包含这个特定数值，接收方就不能正确接收</p><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Learn_data\计算机网络\计算机网络\webp-165193624231330.webp" alt="img"></p><p>image-20201011113207944</p><blockquote><p>所以数据链路层应该对上层交付的数据有限制，其内容不能包含帧定界符的值</p></blockquote><p><strong>解决透明传输问题</strong></p><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Learn_data\计算机网络\计算机网络\webp-165193624548632.webp" alt="img"></p><p>image-20201011113804721</p><ul><li><strong>解决方法</strong>：面向字节的物理链路使用<strong>字节填充</strong> (byte stuffing) 或<strong>字符填充</strong> (character stuffing)，面向比特的物理链路使用<strong>比特填充</strong>的方法实现透明传输</li><li>发送端的数据链路层在<strong>数据中出现控制字符“SOH”或“EOT”</strong>的前面<strong>插入一个转义字符“ESC”</strong>(其十六进制编码是1B)。</li><li>接收端的数据链路层在将数据送往网络层之前删除插入的转义字符。</li><li>如果<strong>转义字符也出现在数据当</strong>中，那么应在转义字符前面插入一个转义字符 ESC。当接收端收到连续的两个转义字符时，就删除其中前面的一个。</li></ul><p><strong>帧的数据部分长度</strong></p><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Learn_data\计算机网络\计算机网络\webp-165193624890634.webp" alt="img"></p><p>image-20201011115008209</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="http://upload-images.jianshu.io/upload_images/24878825-6d39c2f162ddcae5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201011115049672</p><hr><h2 id="3-差错检测"><a href="#3-差错检测" class="headerlink" title="3.差错检测"></a>3.差错检测</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p><img src="http://upload-images.jianshu.io/upload_images/24878825-fa8e42040c9adf41.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201011133757804</p><h3 id="奇偶校验"><a href="#奇偶校验" class="headerlink" title="奇偶校验"></a>奇偶校验</h3><p><img src="http://upload-images.jianshu.io/upload_images/24878825-8a049d137b19e372.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201011234428217</p><h3 id="循环冗余校验CRC-Cyclic-Redundancy-Check"><a href="#循环冗余校验CRC-Cyclic-Redundancy-Check" class="headerlink" title="循环冗余校验CRC(Cyclic Redundancy Check)"></a>循环冗余校验CRC(Cyclic Redundancy Check)</h3><p><img src="http://upload-images.jianshu.io/upload_images/24878825-190a469aba121c1f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201011234605045</p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-e3a6540cad78b41e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201011234701845</p><p><strong>例题</strong></p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-52140f44375b471a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201011235128869</p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-01ea200a849a5e31.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201011235325022</p><p><strong>总结</strong></p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-5b743916f5355e14.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201011235726437</p><blockquote><p>循环冗余校验 CRC 是一种检错方法，而帧校验序列 FCS 是添加在数据后面的冗余码</p></blockquote><hr><h2 id="4-可靠传输"><a href="#4-可靠传输" class="headerlink" title="4.可靠传输"></a>4.可靠传输</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p><strong>下面是比特差错</strong></p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-570f7783660d9c10.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201012153605893</p><p><strong>其他传输差错</strong></p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-1a955429af0480a5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201012153811724</p><ul><li>分组丢失</li></ul><p>路由器输入队列快满了，主动丢弃收到的分组</p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-f805603357f3a3a3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201012154910921</p><ul><li>分组失序</li></ul><p>数据并未按照发送顺序依次到达接收端</p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-6fdae389d4679bf3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201012155300937</p><ul><li>分组重复</li></ul><p>由于某些原因，有些分组在网络中滞留了，没有及时到达接收端，这可能会造成发送端对该分组的重发，重发的分组到达接收端，但一段时间后，滞留在网络的分组也到达了接收端，这就造成<strong>分组重复</strong>的传输差错</p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-88599fefa01ee548.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201012160026362</p><h3 id="三种可靠协议"><a href="#三种可靠协议" class="headerlink" title="三种可靠协议"></a>三种可靠协议</h3><ul><li>停止-等待协议SW</li><li>回退N帧协议GBN</li><li>选择重传协议SR</li></ul><blockquote><p>这三种可靠传输实现机制的基本原理并不仅限于数据链路层，可以应用到计算机网络体系结构的各层协议中</p></blockquote><h3 id="停止-等待协议"><a href="#停止-等待协议" class="headerlink" title="停止-等待协议"></a>停止-等待协议</h3><h4 id="停止-等待协议可能遇到的四个问题"><a href="#停止-等待协议可能遇到的四个问题" class="headerlink" title="停止-等待协议可能遇到的四个问题"></a>停止-等待协议可能遇到的四个问题</h4><p><strong>确认与否认</strong></p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-68772b26b0ef0d3a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/518/format/webp" alt="img"></p><p>image-20201012162009780</p><p><strong>超时重传</strong></p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-af381efb26eee719.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201012162112151</p><p><strong>确认丢失</strong></p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-e30648ec8764ab02.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/958/format/webp" alt="img"></p><p>image-20201012162318298</p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-34bf2b8a370feab8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/462/format/webp" alt="img"></p><p>image-20201012162348428</p><blockquote><p>既然数据分组需要编号，确认分组是否需要编号？</p><p>要。如下图所示</p></blockquote><p><strong>确认迟到</strong></p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-da5036b780359576.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/486/format/webp" alt="img"></p><p>image-20201012162815885</p><blockquote><p>注意，图中最下面那个数据分组与之前序号为0的那个数据分组不是同一个数据分组</p></blockquote><p><strong>注意事项</strong></p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-8dbdfdbac8087fd2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201012164008780</p><h4 id="停止-等待协议的信道利用率"><a href="#停止-等待协议的信道利用率" class="headerlink" title="停止-等待协议的信道利用率"></a>停止-等待协议的信道利用率</h4><p>假设收发双方之间是一条直通的信道</p><ul><li><strong>TD</strong>：是发送方发送数据分组所耗费的发送时延</li><li><strong>RTT</strong>：是收发双方之间的往返时间</li><li><strong>TA</strong>：是接收方发送确认分组所耗费的发送时延</li></ul><p>TA一般都远小于TD，可以忽略，当RTT远大于TD时，信道利用率会非常低</p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-3b4b0d81e5dd78eb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201012164924635</p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-4015447553ed26b5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/888/format/webp" alt="img"></p><p>image-20201012181005719</p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-372ef347c338b585.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201012181047665</p><blockquote><p>像停止-等待协议这样通过确认和重传机制实现的可靠传输协议，常称为自动请求重传协议ARQ(<strong>A</strong>utomatic <strong>R</strong>epeat re<strong>Q</strong>uest)，意思是重传的请求是自动进行，因为不需要接收方显式地请求，发送方重传某个发送的分组</p></blockquote><h3 id="回退N帧协议GBN"><a href="#回退N帧协议GBN" class="headerlink" title="回退N帧协议GBN"></a>回退N帧协议GBN</h3><h4 id="为什么用回退N帧协议"><a href="#为什么用回退N帧协议" class="headerlink" title="为什么用回退N帧协议"></a>为什么用回退N帧协议</h4><p>在相同的时间内，使用停止-等待协议的发送方只能发送一个数据分组，而采用流水线传输的发送方，可以发送多个数据分组</p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-cc9d42f63bd259cc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201012190027828</p><p>回退N帧协议在流水线传输的基础上，利用发送窗口来限制发送方可连续发送数据分组的个数</p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-2a7141766ab1aa80.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201012190632086</p><h4 id="无差错情况流程"><a href="#无差错情况流程" class="headerlink" title="无差错情况流程"></a>无差错情况流程</h4><p>发送方将序号落在发送窗口内的0~4号数据分组，依次连续发送出去</p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-eee45713110af40a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201012191936466</p><p>他们经过互联网传输正确到达接收方，就是没有乱序和误码，接收方按序接收它们，每接收一个，接收窗口就向前滑动一个位置，并给发送方发送针对所接收分组的确认分组，在通过互联网的传输正确到达了发送方</p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-13f6dabf165db4e5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201012192932035</p><p>发送方每接收一个、发送窗口就向前滑动一个位置，这样就有新的序号落入发送窗口，发送方可以将收到确认的数据分组从缓存中删除了，而接收方可以择机将已接收的数据分组交付上层处理</p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-0dfe16aee5eb8d75.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201012193212419</p><h4 id="累计确认"><a href="#累计确认" class="headerlink" title="累计确认"></a><strong>累计确认</strong></h4><p><img src="http://upload-images.jianshu.io/upload_images/24878825-1414be9bd8307609.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201012194304696</p><blockquote><p>累计确认</p><p>优点:</p><ul><li><p>即使确认分组丢失，发送方也可能不必重传 (接收1~4，发送确认1，后又发确认4，1丢失4未丢失，接收方不会在重传)</p></li><li><p>减小接收方的开销</p></li><li><p>减小对网络资源的占用</p></li></ul><p>缺点：</p><ul><li>不能向发送方及时反映出接收方已经正确接收的数据分组信息</li></ul></blockquote><h4 id="有差错情况"><a href="#有差错情况" class="headerlink" title="有差错情况"></a><strong>有差错情况</strong></h4><p>例如</p><p>在传输数据分组时，5号数据分组出现误码，接收方通过数据分组中的检错码发现了错误</p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-7a8c7e3ec6ebaca6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201012195440780</p><p>于是丢弃该分组，而后续到达的这剩下四个分组与接收窗口的序号不匹配</p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-7621ee1bc4ab1619.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201012195629368</p><p>接收同样也不能接收它们，将它们丢弃，并对之前按序接收的最后一个数据分组进行确认，发送ACK4，<strong>每丢弃一个数据分组，就发送一个ACK4</strong></p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-c3f86dad2611e347.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201012195836902</p><p>当收到重复的ACK4时，就知道之前所发送的数据分组出现了差错，于是可以不等超时计时器超时就立刻开始重传，具体收到几个重复确认就立刻重传，根据具体实现决定</p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-215e8704b22ef7f2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201012200120166</p><p>如果收到这4个重复的确认并不会触发发送立刻重传，一段时间后。超时计时器超时，也会将发送窗口内以发送过的这些数据分组全部重传</p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-1df324a9b09dffb4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201012200454557</p><p>若WT超过取值范围，例如WT&#x3D;8，会出现什么情况？</p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-d2789fe0732f13ba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201012201109774</p><p>习题</p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-23afd873fb1ef8d0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201012202419107</p><p><strong>总结</strong></p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-0d5f64664d096287.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201012202222138</p><ul><li>回退N帧协议在流水线传输的基础上利用发送窗口来限制发送方连续发送数据分组的数量，是一种连续ARQ协议</li><li>在协议的工作过程中发送窗口和接收窗口不断向前滑动，因此这类协议又称为滑动窗口协议</li><li>由于回退N帧协议的特性，当通信线路质量不好时，其信道利用率并不比停止-等待协议高</li></ul><h3 id="选择重传协议SR"><a href="#选择重传协议SR" class="headerlink" title="选择重传协议SR"></a>选择重传协议SR</h3><p><img src="http://upload-images.jianshu.io/upload_images/24878825-2ab9c838fac0cb24.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><h4 id="流程演示："><a href="#流程演示：" class="headerlink" title="流程演示："></a><strong>流程演示：</strong></h4><p>发送方发送0~3号帧，其中二号帧丢失</p><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-02-17_12-17-22.png" alt="Snipaste_2022-02-17_12-17-22"></p><p>接收方接收01号，并发送01号确认分组，纳入45号接收窗口，后接收3号发送3号确认分组，因为3号是未按序到达的，所以接收窗口不会纳入新号码</p><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-02-17_12-21-58.png" alt="Snipaste_2022-02-17_12-21-58"></p><p>发送方接收到01号确认分组，纳入45号发送窗口，将45号发送出去。后接收3号，由于3号是未按序接收到的，给它标记，发送窗口不会在纳入新号码</p><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-02-17_12-25-26.png" alt="Snipaste_2022-02-17_12-25-26"></p><p>接收方接收45号并发送45号确认分组，还是不会纳入新接收窗口</p><p>2号重传计时器超时，重传2号</p><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-02-17_12-28-32.png" alt="Snipaste_2022-02-17_12-28-32"></p><p>接收方收到2号并发送2号确认分组，接收窗口四个都集齐后接收窗口向后移动四位</p><p>如2号确认分组也到达发送方，发送窗口四个都集齐后发送窗口向后移动四位</p><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-02-17_12-30-57.png" alt="Snipaste_2022-02-17_12-30-57"></p><p> 若WT超过取值范围，例如WT&#x3D;5，会出现什么情况？</p><p>发送窗口发送0~4号五个分组，接收方正确接收并发回五个确认分组，接收窗口向后移动5位</p><p>回来途中，0号确认分组丢失</p><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-02-17_12-35-54.png" alt="Snipaste_2022-02-17_12-30-57"></p><p>0号重传计时器超时，重传0号分组，有两个0号，接收方无法分辨新、旧数据分组</p><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-02-17_12-35-20.png" alt="Snipaste_2022-02-17_12-35-20"></p><p><strong>习题</strong></p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-dfeaa84ab40845d4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201012205250996</p><p><strong>总结</strong></p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-bcb835b2adac5b3a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201012204742870</p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-dab51e8895eb9313.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201012205133924</p><hr><h2 id="5-点对点协议PPP"><a href="#5-点对点协议PPP" class="headerlink" title="5.点对点协议PPP"></a>5.点对点协议PPP</h2><ul><li>点对点协议PPP（Point-to-Point Protocol）是目前使用最广泛的点对点数据链路层协议</li><li>PPP协议是因特网工程任务组IEIF在1992年制定的。经过1993年和1994年的修订，现在的PPP协议已成为因特网的正式标准[RFC1661，RFC1662]</li><li>数据链路层使用的一种协议，<strong>它的特点是：简单；只检测差错，而不是纠正差错；不使用序号，也不进行流量控制；可同时支持多种网络层协议</strong></li></ul><p><img src="http://upload-images.jianshu.io/upload_images/24878825-fd145efb1acc73fa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201012210844629</p><ul><li>PPPoE 是为宽带上网的主机使用的链路层协议</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/24878825-bbc4187b9e27ef4c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201012211423528</p><h3 id="帧格式"><a href="#帧格式" class="headerlink" title="帧格式"></a>帧格式</h3><p>必须规定特殊的字符作为<strong>帧定界符</strong></p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-b384615e861000f3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201012211826281</p><h3 id="透明传输-1"><a href="#透明传输-1" class="headerlink" title="透明传输"></a>透明传输</h3><p>必须保证数据传输的透明性</p><p>实现透明传输的方法</p><ul><li>面向字节的异步链路：字节填充法（插入“转义字符”）</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/24878825-d40da4575c590f5c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201012212148803</p><ul><li>面向比特的同步链路：比特填充法（插入“比特0”）</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/24878825-6290c73d8957ee8d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201012212255550</p><h3 id="差错检测"><a href="#差错检测" class="headerlink" title="差错检测"></a>差错检测</h3><p>能够对接收端收到的帧进行检测，并立即丢弃有差错的帧。</p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-501e6b9dd2afcee3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201012212558654</p><h3 id="工作状态"><a href="#工作状态" class="headerlink" title="工作状态"></a>工作状态</h3><ul><li>当用户拨号接入 ISP 时，路由器的调制解调器对拨号做出确认，并建立一条物理连接。</li><li>PC 机向路由器发送一系列的 LCP 分组（封装成多个 PPP 帧）。</li><li>这些分组及其响应选择一些 PPP 参数，并进行网络层配置，NCP 给新接入的 PC 机</li><li>分配一个临时的 IP 地址，使 PC 机成为因特网上的一个主机。</li><li>通信完毕时，NCP 释放网络层连接，收回原来分配出去的 IP 地址。接着，LCP 释放数据链路层连接。最后释放的是物理层的连接。</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/24878825-96bbde153c114cf8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201012213021860</p><blockquote><p>可见，PPP 协议已不是纯粹的数据链路层的协议，它还包含了物理层和网络层的内容。</p></blockquote><hr><h2 id="6-媒体接入控制（介质访问控制）——广播信道"><a href="#6-媒体接入控制（介质访问控制）——广播信道" class="headerlink" title="6.媒体接入控制（介质访问控制）——广播信道"></a>6.媒体接入控制（介质访问控制）——广播信道</h2><p><strong>媒体接入控制（介质访问控制）使用一对多的广播通信方式</strong></p><blockquote><p><strong>Medium Access Control</strong>翻译成媒体接入控制，有些翻译成介质访问控制</p></blockquote><p><strong>局域网的数据链路层</strong></p><ul><li>局域网最主要的<strong>特点</strong>是：<ul><li>网络为一个单位所拥有；</li><li>地理范围和站点数目均有限。</li></ul></li><li>局域网具有如下<strong>主要优点</strong>：<ul><li>具有广播功能，从一个站点可很方便地访问全网。局域网上的主机可共享连接在局域网上的各种硬件和软件资源。</li><li>便于系统的扩展和逐渐地演变，各设备的位置可灵活调整和改变。</li><li>提高了系统的可靠性、可用性和残存性。</li></ul></li></ul><p><img src="http://upload-images.jianshu.io/upload_images/24878825-4acef21a5275fab6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/849/format/webp" alt="img"></p><p>image-20201013201521915</p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-6a109c1bb8576571.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/847/format/webp" alt="img"></p><p>image-20201013201533445</p><p><strong>数据链路层的两个子层</strong></p><p>为了使数据链路层能更好地适应多种局域网标准，IEEE 802 委员会就将局域网的数据链路层拆成<strong>两个子层</strong>：</p><ol><li><strong>逻辑链路控制</strong> LLC (Logical Link Control)子层；</li><li><strong>媒体接入控制</strong> MAC (Medium Access Control)子层。</li></ol><p>与接入到传输媒体有关的内容都放在 MAC子层，而 LLC 子层则与传输媒体无关。  <strong>不管采用何种协议的局域网，对 LLC 子层来说都是透明的。</strong></p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-faea2c7d90c97f4d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/831/format/webp" alt="img"></p><p>image-20201013201133903</p><h3 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h3><p>为什么要媒体接入控制（介质访问控制）？</p><p><strong>共享信道带来的问题</strong></p><p>若多个设备在共享信道上同时发送数据，则会造成彼此干扰，导致发送失败。</p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-e8558245e4dd7086.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201013152007335</p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-3d6792f6b442b459.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201013152453425</p><blockquote><p>随着技术的发展，交换技术的成熟和成本的降低，具有更高性能的使用点对点链路和链路层交换机的交换式局域网在有线领域已完全取代了共享式局域网，但由于无线信道的广播天性，无线局域网仍然使用的是共享媒体技术</p></blockquote><h3 id="静态划分信道"><a href="#静态划分信道" class="headerlink" title="静态划分信道"></a>静态划分信道</h3><p><strong>信道复用</strong></p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-f42ef63e4cf0d34b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201013153642544</p><p><strong>频分复用FDM (Frequency Division Multiplexing)</strong></p><ul><li>将整个带宽分为多份，用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带。</li><li><strong>频分复用</strong>的所有用户在同样的时间<strong>占用不同的带宽资源</strong>（请注意，这里的“带宽”是频率带宽而不是数据的发送速率）。</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/24878825-7b3574f649543f8e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201013153947668</p><p><strong>时分复用TDM (Time Division Multiplexing)</strong></p><ul><li><strong>时分复用</strong>则是将时间划分为一段段等长的<strong>时分复用帧（TDM帧）</strong>。每一个时分复用的用户在每一个 TDM 帧中占用固定序号的时隙。</li><li>每一个用户所占用的时隙是<strong>周期性地出现</strong>（其周期就是TDM帧的长度）的。</li><li>TDM 信号也称为<strong>等时</strong> (isochronous) 信号。</li><li><strong>时分复用的所有用户在不同的时间占用同样的频带宽度。</strong></li></ul><p><img src="http://upload-images.jianshu.io/upload_images/24878825-85128fb198aad76c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201013154142540</p><p><strong>波分复用 WDM(Wavelength Division Multiplexing)</strong></p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-9f1dfdd7ce2cb611.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201013202218132</p><blockquote><p>波分复用就是光的频分复用，使用一根光纤来同时传输多个光载波信号</p><p>光信号传输一段距离后悔衰减，所以要用 掺铒光纤放大器 放大光信号</p></blockquote><p><strong>码分复用 CDM (Code Division Multiplexing)</strong></p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-753efa9c750d4ef1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201013203126625</p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-91ed6f416ae8fad6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201013203324709</p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-91b959793d2ac0de.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201013203459640</p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-8d81f17d93395b48.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201013203819578</p><h3 id="动态接入控制"><a href="#动态接入控制" class="headerlink" title="动态接入控制"></a>动态接入控制</h3><p>受控接入</p><p><strong>受控接入在局域网中使用得较少，本书不再讨论</strong></p><p><strong>随机接入</strong></p><p><strong>重点</strong></p><h3 id="随机接入（CSMA-x2F-CD协议）"><a href="#随机接入（CSMA-x2F-CD协议）" class="headerlink" title="随机接入（CSMA&#x2F;CD协议）"></a>随机接入（CSMA&#x2F;CD协议）</h3><p><strong>总线局域网使用协议：CSMA&#x2F;CD</strong></p><h4 id="基本概念-2"><a href="#基本概念-2" class="headerlink" title="基本概念"></a>基本概念</h4><p><strong>最初</strong>的<strong>以太网</strong>是将许多计算机都连接到一根总线上。易于实现广播通信。当初认为这样的连接方法既简单又可靠，因为总线上没有有源器件。</p><blockquote><p><strong>以太网（Ethernet）</strong>是一种计算机<strong>局域网技术</strong>。IEEE组织的IEEE 802.3标准制定了<strong>以太网（Ethernet）</strong>的技术标准</p><p>以太网采用无连接的工作方式，对发送的数据帧不进行编号，也不要求对方发回确认。目的站收到有差错帧就把它丢弃，其他什么也不做</p></blockquote><p><img src="http://upload-images.jianshu.io/upload_images/24878825-daba961daee80d20.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201013211620687</p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-00eb7fba113030d2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201013213102777</p><h4 id="多址接入MA"><a href="#多址接入MA" class="headerlink" title="多址接入MA"></a>多址接入MA</h4><p>表示许多主机以多点接入的方式连接在一根总线上。</p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-a26a912dcecd040a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201013215400688</p><h4 id="载波监听CS"><a href="#载波监听CS" class="headerlink" title="载波监听CS"></a>载波监听CS</h4><p>是指每一个站在发送数据之前先要检测一下总线上是否有其他计算机在发送数据，如果有，则暂时不要发送数据，以免发生碰撞。</p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-9dc7a68973377382.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201013215530979</p><p>总线上并没有什么“载波”。因此， <strong>“载波监听”就是用电子技术检测总线上有没有其他计算机发送的数据信号。</strong></p><h4 id="碰撞检测CD"><a href="#碰撞检测CD" class="headerlink" title="碰撞检测CD"></a>碰撞检测CD</h4><ul><li><strong>“碰撞检测”</strong>就是计算机<strong>边发送数据边检测</strong>信道上的信号电压大小。</li><li>当几个站同时在总线上发送数据时，总线上的信号电压摆动值将会增大（互相叠加）。</li><li>当一个站检测到的信号电压摆动值超过一定的门限值时，就认为总线上至少有两个站同时在发送数据，表明产生了碰撞。</li><li><strong>所谓“碰撞”就是发生了冲突。因此“碰撞检测”也称为“冲突检测”。</strong></li><li>在发生碰撞时，总线上传输的信号产生了严重的失真，无法从中恢复出有用的信息来。</li><li><strong>每一个正在发送数据的站，一旦发现总线上出现了碰撞，就要立即停止发送，免得继续浪费网络资源，然后等待一段随机时间后再次发送。</strong></li></ul><p><img src="http://upload-images.jianshu.io/upload_images/24878825-574d77a51611a634.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201013221240514</p><p>为什么要进行碰撞检测？ 因为信号传播时延对载波监听产生了影响</p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-a03963c28232dfb8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/940/format/webp" alt="img"></p><p>image-20201013221834942</p><blockquote><p>A 需要单程传播时延的 2 倍的时间，才能检测到与 B 的发送产生了冲突</p></blockquote><h4 id="CSMA-x2F-CD-协议工作流程"><a href="#CSMA-x2F-CD-协议工作流程" class="headerlink" title="CSMA&#x2F;CD 协议工作流程"></a>CSMA&#x2F;CD 协议工作流程</h4><p><img src="http://upload-images.jianshu.io/upload_images/24878825-5621a9827bd41bf5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/669/format/webp" alt="img"></p><p>image-20201013221705893</p><h4 id="CSMA-x2F-CD-协议工作——争用期（碰撞窗口）"><a href="#CSMA-x2F-CD-协议工作——争用期（碰撞窗口）" class="headerlink" title="CSMA&#x2F;CD 协议工作——争用期（碰撞窗口）"></a>CSMA&#x2F;CD 协议工作——争用期（碰撞窗口）</h4><p><img src="http://upload-images.jianshu.io/upload_images/24878825-a77d88a950995527.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201013223235305</p><h4 id="CSMA-x2F-CD-协议工作——最小帧长"><a href="#CSMA-x2F-CD-协议工作——最小帧长" class="headerlink" title="CSMA&#x2F;CD 协议工作——最小帧长"></a>CSMA&#x2F;CD 协议工作——最小帧长</h4><p><img src="http://upload-images.jianshu.io/upload_images/24878825-423fe21ffdbacb81.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201013224051932</p><h4 id="CSMA-x2F-CD-协议工作——最大帧长"><a href="#CSMA-x2F-CD-协议工作——最大帧长" class="headerlink" title="CSMA&#x2F;CD 协议工作——最大帧长"></a>CSMA&#x2F;CD 协议工作——最大帧长</h4><p><img src="http://upload-images.jianshu.io/upload_images/24878825-fa63a8f164fb9191.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201013225400777</p><h4 id="CSMA-x2F-CD-协议工作——截断二进制指数退避算法"><a href="#CSMA-x2F-CD-协议工作——截断二进制指数退避算法" class="headerlink" title="CSMA&#x2F;CD 协议工作——截断二进制指数退避算法"></a>CSMA&#x2F;CD 协议工作——截断二进制指数退避算法</h4><p><img src="http://upload-images.jianshu.io/upload_images/24878825-93f832e4b0a569ae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201013230717856</p><h4 id="CSMA-x2F-CD-协议工作——信道利用率"><a href="#CSMA-x2F-CD-协议工作——信道利用率" class="headerlink" title="CSMA&#x2F;CD 协议工作——信道利用率"></a>CSMA&#x2F;CD 协议工作——信道利用率</h4><p><img src="http://upload-images.jianshu.io/upload_images/24878825-dc35877bb4bead1a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201013231430295</p><h4 id="CSMA-x2F-CD-协议工作——帧接收流程"><a href="#CSMA-x2F-CD-协议工作——帧接收流程" class="headerlink" title="CSMA&#x2F;CD 协议工作——帧接收流程"></a>CSMA&#x2F;CD 协议工作——帧接收流程</h4><p><img src="http://upload-images.jianshu.io/upload_images/24878825-cf2d95546ecf2664.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201013231703302</p><h4 id="CSMA-x2F-CD-协议的重要特性"><a href="#CSMA-x2F-CD-协议的重要特性" class="headerlink" title="CSMA&#x2F;CD 协议的重要特性"></a>CSMA&#x2F;CD 协议的重要特性</h4><ul><li>使用 CSMA&#x2F;CD 协议的以太网不能进行全双工通信而<strong>只能进行双向交替通信（半双工通信）。</strong></li><li>每个站在发送数据之后的一小段时间内，存在着遭遇碰撞的可能性。</li><li>这种<strong>发送的不确定性</strong>使整个以太网的平均通信量远小于以太网的最高数据率。</li></ul><blockquote><p>CSMA&#x2F;CD协议曾经用于各种总线结构以太网和双绞线以太网的早起版本中。</p><p><strong>现在的以太网基于交换机和全双工连接，不会有碰撞，因此没有必要使用CSMA&#x2F;CD协议</strong></p></blockquote><h3 id="随机接入（CSMA-x2F-CA协议）"><a href="#随机接入（CSMA-x2F-CA协议）" class="headerlink" title="随机接入（CSMA&#x2F;CA协议）"></a>随机接入（CSMA&#x2F;CA协议）</h3><p><strong>无线局域网使用的协议：CSMA&#x2F;CA</strong></p><h4 id="为什么无线局域网要使用CSMA-x2F-CA协议"><a href="#为什么无线局域网要使用CSMA-x2F-CA协议" class="headerlink" title="为什么无线局域网要使用CSMA&#x2F;CA协议"></a>为什么无线局域网要使用CSMA&#x2F;CA协议</h4><p><img src="http://upload-images.jianshu.io/upload_images/24878825-dd01f296832d017a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201014192811760</p><h4 id="帧间间隔IFS（InterFrame-Space）"><a href="#帧间间隔IFS（InterFrame-Space）" class="headerlink" title="帧间间隔IFS（InterFrame Space）"></a>帧间间隔IFS（InterFrame Space）</h4><p><img src="http://upload-images.jianshu.io/upload_images/24878825-6c9fe4ae6927eb02.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201014200149717</p><h4 id="CSMA-x2F-CA协议的工作原理"><a href="#CSMA-x2F-CA协议的工作原理" class="headerlink" title="CSMA&#x2F;CA协议的工作原理"></a>CSMA&#x2F;CA协议的工作原理</h4><p><img src="http://upload-images.jianshu.io/upload_images/24878825-c0ce898b417b3228.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201014200833233</p><blockquote><p><strong>源站为什么在检测到信道空闲后还要再等待一段时间DIFS？</strong></p><ul><li>考虑到可能有其他的站有高优先级的帧要发送。若有，就要让高优先级帧先发送</li></ul><p><strong>目的站为什么正确接收数据帧后还要等待一段时间SIFS才能发送ACK帧？</strong></p><ul><li>SIFS是最短的帧间间隔，用来分隔开属于一次对话的各帧，在这段时间内，一个站点应当能够从发送方式切换到接收方式</li></ul></blockquote><p><img src="http://upload-images.jianshu.io/upload_images/24878825-a756ebbd569e600a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201014201511741</p><blockquote><p><strong>信道由忙转为空闲且经过DIFS时间后，还要退避一段随机时间才能使用信道？</strong></p><p>防止多个站点同时发送数据而产生碰撞</p></blockquote><p><strong>使用退避算法的时机</strong></p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-f0d70f0b26645fb4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201014201927680</p><h4 id="CSMA-x2F-CA协议的退避算法"><a href="#CSMA-x2F-CA协议的退避算法" class="headerlink" title="CSMA&#x2F;CA协议的退避算法"></a>CSMA&#x2F;CA协议的退避算法</h4><p><img src="http://upload-images.jianshu.io/upload_images/24878825-1de197cb6f859f3c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201014202213766</p><p><strong>退避算法的示例</strong></p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-12262e66fc986d52.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201014202819851</p><h4 id="CSMA-x2F-CA协议的信道预约和虚拟载波监听"><a href="#CSMA-x2F-CA协议的信道预约和虚拟载波监听" class="headerlink" title="CSMA&#x2F;CA协议的信道预约和虚拟载波监听"></a>CSMA&#x2F;CA协议的信道预约和虚拟载波监听</h4><p><img src="http://upload-images.jianshu.io/upload_images/24878825-98353d62c0ef033f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201014203119710</p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-ac35b15f5f22bf7d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201014203506878</p><p><strong>虚拟载波监听机制能减少隐蔽站带来的碰撞问题的示例</strong></p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-c8d7aca5f6faec4a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201014203859033</p><hr><h2 id="7-MAC地址、IP地址以及ARP协议"><a href="#7-MAC地址、IP地址以及ARP协议" class="headerlink" title="7.MAC地址、IP地址以及ARP协议"></a>7.MAC地址、IP地址以及ARP协议</h2><p><img src="http://upload-images.jianshu.io/upload_images/24878825-ede2c92a0c809e6c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201014222831663</p><h3 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h3><blockquote><ul><li><p>使用点对点信道的数据链路层不需要使用地址</p></li><li><p>使用广播信道的数据链路层必须使用地址来区分各主机</p></li></ul></blockquote><p><img src="http://upload-images.jianshu.io/upload_images/24878825-b498a111836f82c0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201014223659993</p><h4 id="广播信道的数据链路层必须使用地址（MAC）"><a href="#广播信道的数据链路层必须使用地址（MAC）" class="headerlink" title="广播信道的数据链路层必须使用地址（MAC）"></a>广播信道的数据链路层必须使用地址（MAC）</h4><p><img src="http://upload-images.jianshu.io/upload_images/24878825-eabec58905a9aad1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1199/format/webp" alt="img"></p><p>image-20201014224732019</p><blockquote><p><strong>MAC地址又称为硬件地址或物理地址</strong>。请注意：不要被 “物理” 二字误导认为物理地址属于物理层范畴，物理地址属于数据链路层范畴</p></blockquote><h4 id="IEEE-802局域网的MAC地址格式"><a href="#IEEE-802局域网的MAC地址格式" class="headerlink" title="IEEE 802局域网的MAC地址格式"></a>IEEE 802局域网的MAC地址格式</h4><p><img src="http://upload-images.jianshu.io/upload_images/24878825-5a66994327412b90.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201014225358570</p><blockquote><p><strong>组织唯一标识符OUI</strong></p><ul><li>生产网络设备的厂商，需要向IEEE的注册管理机构申请一个或多个OUI</li></ul><p><strong>网络接口标识符</strong></p><ul><li>由获得OUI的厂商自行随意分配</li></ul><p><strong>EUI-48</strong></p><ul><li>48是这个MAC地址的位数</li></ul></blockquote><p><img src="http://upload-images.jianshu.io/upload_images/24878825-70ee74506eca1df4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201014230248959</p><blockquote><p>对于使用EUI-48空间的应用程序，IEEE的目标寿命为100年（直到2080年），但是鼓励采用EUI-64作为替代</p></blockquote><p><strong>关于无效的 MAC 帧</strong></p><ul><li>数据字段的长度与长度字段的值不一致；</li><li>帧的长度不是整数个字节；</li><li>用收到的帧检验序列 FCS 查出有差错；</li><li>数据字段的长度不在 46 ~ 1500 字节之间。</li><li>有效的 MAC 帧长度为 64 ~ 1518 字节之间。</li></ul><blockquote><p><strong>对于检查出的无效</strong>  <strong>MAC</strong>  <strong>帧就简单地丢弃。以太网不负责重传丢弃的帧。</strong></p></blockquote><h4 id="IEEE-802局域网的MAC地址发送顺序"><a href="#IEEE-802局域网的MAC地址发送顺序" class="headerlink" title="IEEE 802局域网的MAC地址发送顺序"></a>IEEE 802局域网的MAC地址发送顺序</h4><p><img src="http://upload-images.jianshu.io/upload_images/24878825-d0cf5b54089e4b40.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201014230625182</p><h4 id="单播MAC地址举例"><a href="#单播MAC地址举例" class="headerlink" title="单播MAC地址举例"></a>单播MAC地址举例</h4><p><img src="http://upload-images.jianshu.io/upload_images/24878825-db7d480bafececad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201014230822305</p><blockquote><p>主机B给主机C发送<strong>单播帧</strong>，主机B首先要构建该<strong>单播帧</strong>，<strong>在帧首部中的目的地址字段填入主机C的MAC地址</strong>，源地址字段填入自己的MAC地址，再加上帧首部的其他字段、数据载荷以及帧尾部，就构成了该<strong>单播帧</strong></p></blockquote><p><img src="http://upload-images.jianshu.io/upload_images/24878825-a69b9384665e17aa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201014231244655</p><blockquote><p>主机B将该<strong>单播帧</strong>发送出去，主机A和C都会收到该<strong>单播帧</strong></p><p>主机A的网卡发现该<strong>单播帧</strong>的目的MAC地址与自己的MAC地址不匹配，丢弃该帧</p><p>主机C的网卡发现该<strong>单播帧</strong>的目的MAC地址与自己的MAC地址匹配，接受该帧</p><p>并将该帧交给其上层处理</p></blockquote><h4 id="广播MAC地址举例"><a href="#广播MAC地址举例" class="headerlink" title="广播MAC地址举例"></a>广播MAC地址举例</h4><p><img src="http://upload-images.jianshu.io/upload_images/24878825-7a825d6f30766d99.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201014231754669</p><blockquote><p>假设主机B要发送一个<strong>广播帧</strong>，主机B首先要构建该<strong>广播帧</strong>，<strong>在帧首部中的目的地址字段填入广播地址</strong>，也就是十六进制的全F，源地址字段填入自己的MAC地址，再加上帧首部中的其他字段、数据载荷以及帧尾部，就构成了该<strong>广播帧</strong></p></blockquote><p><img src="http://upload-images.jianshu.io/upload_images/24878825-04fe098832094ecb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><blockquote><p>主机B讲该<strong>广播帧</strong>发送出去，主机A和C都会收到该<strong>广播帧</strong>，<strong>发现该帧首部中的目的地址字段的内容是广播地址</strong>，就知道该帧是<strong>广播帧</strong>，主机A和主机C都接受该帧，并将该帧交给上层处理</p></blockquote><h4 id="多播MAC地址举例"><a href="#多播MAC地址举例" class="headerlink" title="多播MAC地址举例"></a>多播MAC地址举例</h4><p><img src="http://upload-images.jianshu.io/upload_images/24878825-3f3a22fe2fbfa3ee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><blockquote><p>假设主机A要发送<strong>多播帧</strong>给该<strong>多播地址</strong>。将该<strong>多播地址</strong>的左起第一个字节写成8个比特，第一个字节的最低比特位是1，这就表明该地址是<strong>多播地址</strong>。</p><p>快速判断地址是不是<strong>多播地址</strong>，就是上图所示箭头所指的第十六进制数不能整除2（1,3,5,7,9,B,D,F），则该地址是<strong>多播地址</strong></p><p>假设主机B，C和D支持多播，各用户给自己的主机配置多播组列表<strong>如下所示</strong></p></blockquote><p><img src="http://upload-images.jianshu.io/upload_images/24878825-f274d401c24ad4d4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201015001243584</p><blockquote><p>主机B属于两个多播组，主机C也属于两个多播组，而主机D不属于任何多播组</p></blockquote><p><img src="http://upload-images.jianshu.io/upload_images/24878825-1d6c26260c21ba6a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201015001535528</p><blockquote><p>主机A首先要构建该<strong>多播帧</strong>，<strong>在帧首部中的目的地址字段填入该多播地址</strong>，源地址点填入自己的MAC地址，再加上帧首部中的其他字段、数据载荷以及帧尾部，就构成了该<strong>多播帧</strong></p></blockquote><p><img src="http://upload-images.jianshu.io/upload_images/24878825-70e6e705d20e5c20.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201015002054876</p><blockquote><p>主机A将该<strong>多播帧</strong>发送出去，主机B、C、D都会收到该<strong>多播帧</strong></p><p><strong>主机B和C发现该多播帧的目的MAC地址在自己的多播组列表中</strong>，主机B和C都会接受该帧</p><p>主机D发现该<strong>多播帧</strong>的目的MAC地址不在自己得多播组列表中，则丢弃该<strong>多播帧</strong></p></blockquote><blockquote><p>给主机配置多播组列表进行私有应用时，不得使用公有的标准多播地址</p></blockquote><h3 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h3><p>IP地址属于网络层的范畴，不属于数据链路层的范畴</p><p>下面内容讲的是IP地址的使用，详细的IP地址内容在网络层中介绍</p><h4 id="基本概念-3"><a href="#基本概念-3" class="headerlink" title="基本概念"></a>基本概念</h4><p><img src="http://upload-images.jianshu.io/upload_images/24878825-597f8c69867e595b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201015104441580</p><h4 id="从网络体系结构看IP地址与MAC地址"><a href="#从网络体系结构看IP地址与MAC地址" class="headerlink" title="从网络体系结构看IP地址与MAC地址"></a>从网络体系结构看IP地址与MAC地址</h4><p><img src="http://upload-images.jianshu.io/upload_images/24878825-407cbc74e63b0e50.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201015104913755</p><h4 id="数据包转发过程中IP地址与MAC地址的变化情况"><a href="#数据包转发过程中IP地址与MAC地址的变化情况" class="headerlink" title="数据包转发过程中IP地址与MAC地址的变化情况"></a>数据包转发过程中IP地址与MAC地址的变化情况</h4><p>图上各主机和路由器各接口的IP地址和MAC地址用简单的标识符来表示</p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-77c204bc8181b3ed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201015105455043</p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-f12548de1d3cebe1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20210103212224961.png</p><blockquote><p>如何从IP地址找出其对应的MAC地址？</p><p>ARP协议</p></blockquote><h3 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h3><p><strong>如何从IP地址找出其对应的MAC地址？</strong></p><p>ARP（地址解析协议）</p><h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><p><img src="http://upload-images.jianshu.io/upload_images/24878825-5e1fd5537944a420.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201015113826197</p><p>ARP高速缓存表</p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-13b5ca5d08126cde.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201015114052206</p><blockquote><p>当主机B要给主机C发送数据包时，会首先在自己的ARP高速缓存表中查找主机C的IP地址所对应的MAC地址，但未找到，因此，主机B需要发送ARP请求报文，来获取主机C的MAC地址</p></blockquote><p><img src="http://upload-images.jianshu.io/upload_images/24878825-9de96c1c37c62e26.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201015114444263</p><blockquote><p>ARP请求报文有具体的格式，上图的只是简单描述</p><p>ARP请求报文被封装在MAC帧中发送，目的地址为广播地址</p><p>主机B发送封装有ARP请求报文的广播帧，总线上的其他主机都能收到该广播帧</p></blockquote><p><img src="http://upload-images.jianshu.io/upload_images/24878825-97a253fd9b87b3be.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><blockquote><p>收到ARP请求报文的主机A和主机C会把ARP请求报文交给上层的ARP进程</p><p>主机A发现所询问的IP地址不是自己的IP地址，因此不用理会</p><p>主机C的发现所询问的IP地址是自己的IP地址，需要进行相应</p></blockquote><p><img src="http://upload-images.jianshu.io/upload_images/24878825-d852b42ef4dbea32.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-87f01b333e4599d7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-a3f00154df65aac0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201015115252972</p><p><strong>动态与静态的区别</strong></p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-a013636443263063.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201015115831543</p><p><strong>ARP协议只能在一段链路或一个网络上使用，而不能跨网络使用</strong></p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-d5847fbcc133c6b8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201015120108028</p><blockquote><p>ARP协议的使用是逐段链路进行的</p></blockquote><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p><img src="http://upload-images.jianshu.io/upload_images/24878825-11cd254f6251a6ad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/624/format/webp" alt="img"></p><p>image-20201015120707150</p><blockquote><p>ARP表中的IP地址与MAC地址的对应关系记录，是<strong>会定期自动删除的</strong>，<strong>因为IP地址与MAC地址的对应关系不是永久性的(例如，MAC地址会随者网卡的变更而变更)</strong></p></blockquote><hr><h2 id="8-集线器与交换机的区别"><a href="#8-集线器与交换机的区别" class="headerlink" title="8.集线器与交换机的区别"></a>8.集线器与交换机的区别</h2><h3 id="集线器-在物理层扩展以太网"><a href="#集线器-在物理层扩展以太网" class="headerlink" title="集线器-在物理层扩展以太网"></a>集线器-在物理层扩展以太网</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p><img src="http://upload-images.jianshu.io/upload_images/24878825-dc092bbcb4344cf5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><blockquote><ul><li><p>传统以太网最初是使用粗同轴电缆，后来演进到使用比较便宜的细同轴电缆，最后发展为使用更便宜和更灵活的双绞线。</p></li><li><p>采用双绞线的以太网采用星形拓扑，在星形的中心则增加了一种可靠性非常高的设备，叫做<strong>集线器</strong> (hub)。</p></li><li><p><strong>集线器</strong>是也可以看做多口中继器，每个端口都可以成为一个中继器，中继器是对减弱的信号进行放大和发送的设备</p></li><li><p><strong>集线器</strong>的以太网在逻辑上仍是个总线网，需要使用CSMA&#x2F;CD协议来协调各主机争用总线，只能工作在<strong>半双工模式，收发帧不能同时进行</strong></p></li></ul></blockquote><h4 id="集线器HUB在物理层扩展以太网"><a href="#集线器HUB在物理层扩展以太网" class="headerlink" title="集线器HUB在物理层扩展以太网"></a>集线器HUB在物理层扩展以太网</h4><p><strong>使用集线器扩展</strong>：将多个以太网段连成更大的、多级星形结构的以太网</p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-0f8d87b7f79e94c8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201015145732275</p><blockquote><ul><li><strong>优点</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.  使原来属于不同碰撞域的以太网上的计算机能够进行跨碰撞域的通信。 </span><br><span class="line">    </span><br><span class="line">2.  扩大了以太网覆盖的地理范围。</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><strong>缺点</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.  碰撞域增大了，但总的吞吐量并未提高。</span><br><span class="line">    </span><br><span class="line">2.  如果不同的碰撞域使用不同的数据率，那么就不能用集线器将它们互连起来。</span><br><span class="line"></span><br></pre></td></tr></table></figure></blockquote><p><strong>碰撞域</strong></p><ul><li><strong>碰撞域（collision domain）</strong>又称为<strong>冲突域</strong>，是指网络中一个站点发出的帧会与其他站点发出的帧产生碰撞或冲突的那部分网络。</li><li>碰撞域越大，发生碰撞的概率越高。</li></ul><h3 id="以太网交换机-在数据链路层扩展以太网"><a href="#以太网交换机-在数据链路层扩展以太网" class="headerlink" title="以太网交换机-在数据链路层扩展以太网"></a>以太网交换机-在数据链路层扩展以太网</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><ul><li>扩展以太网更常用的方法是在数据链路层进行。</li><li>早期使用<strong>网桥</strong>，现在使用<strong>以太网交换机</strong>。</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/24878825-001d34e299bee061.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/876/format/webp" alt="img"></p><p>image-20201015150620067</p><blockquote><p><strong>网桥</strong></p><ul><li><p>网桥工作在数据链路层。</p></li><li><p>它根据 MAC 帧的目的地址对收到的帧进行转发和过滤。</p></li><li><p>当网桥收到一个帧时，并不是向所有的接口转发此帧，而是先检查此帧的目的MAC 地址，然后再确定将该帧转发到哪一个接口，或把它丢弃。</p></li></ul><p><strong>交换机</strong></p><ul><li><p>1990 年问世的交换式集线器 (switching hub) 可明显地提高以太网的性能。</p></li><li><p>交换式集线器常称为<strong>以太网交换机</strong> (switch) 或<strong>第二层交换机</strong> (L2 switch)，强调这种交换机工作在数据链路层。</p></li><li><p>以太网交换机实质上就是一个<strong>多接口的网桥</strong></p></li></ul></blockquote><h4 id="集线器HUB与交换机SWITCH区别"><a href="#集线器HUB与交换机SWITCH区别" class="headerlink" title="集线器HUB与交换机SWITCH区别"></a><strong>集线器HUB与交换机SWITCH区别</strong></h4><p><img src="http://upload-images.jianshu.io/upload_images/24878825-a8f68b1ee60923c3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201015152232158</p><blockquote><p>使用<strong>集线器</strong>互连而成的共享总线式以太网上的某个主机，要给另一个主机发送单播帧，该单播帧会通过共享总线传输到<strong>总线上的其他各个主机</strong></p><p>使用<strong>交换机</strong>互连而成的交换式以太网上的某个主机，要给另一个主机发送单播帧，该单播帧进入交换机后，交换机会将该单播帧转发给目的主机，<strong>而不是网络中的其他各个主机</strong></p><p><strong>这个例子的前提条件是忽略ARP过程，并假设交换机的帧交换表已经学习或配置好了</strong></p></blockquote><p><img src="http://upload-images.jianshu.io/upload_images/24878825-bd7d832dc7f8ffbe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201015152858146</p><blockquote><p><strong>以太网交换机的交换方式</strong></p><ul><li>存储转发方式</li></ul><ul><li>把整个数据帧<strong>先缓存</strong>后再进行处理。</li></ul><ul><li>直通 (cut-through) 方式</li></ul><ul><li>收数据帧的同时就<strong>立即按数据帧的目的 MAC 地址决定该帧的转发接口</strong>，因而提高了帧的转发速度。</li><li><strong>缺点</strong>是它不检查差错就直接将帧转发出去，因此有可能也将一些无效帧转发给其他的站。</li></ul><p><strong>这个例子的前提条件是忽略ARP过程，并假设交换机的帧交换表已经学习或配置好了</strong></p></blockquote><p><strong>对比集线器和交换机</strong></p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-2e2faba35d2d7852.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/741/format/webp" alt="img"></p><p>image-20201015153907268</p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-4638409baba882e8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201015154523036</p><blockquote><p>多台主机同时给另一台主机发送单播帧</p><p>集线器以太网：会产生碰撞，遭遇碰撞的帧会传播到总线上的各主机</p><p>交换机以太网：会将它们缓存起来，然后逐个转发给目的主机，不会产生碰撞</p><p><strong>这个例子的前提条件是忽略ARP过程，并假设交换机的帧交换表已经学习或配置好了</strong></p></blockquote><p><strong>集线器扩展以太网和交换机扩展以太网区别</strong></p><p><strong>单播</strong></p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-34c587f82d3a1286.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201015155408692</p><p><strong>广播</strong></p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-134f67554e64e22b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201015155440402</p><p><strong>多个单播</strong></p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-d80949431bd76379.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201015155526386</p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-d5c429a2f92149ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201015155706698</p><p>广播域（broadcast domain）：指这样一部分网络，其中任何一台设备发出的广播通信都能被该部分网络中的所有其他设备所接收。</p><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p><img src="http://upload-images.jianshu.io/upload_images/24878825-25db1be3ca96bc2f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-df6859d2396549cf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/925/format/webp" alt="img"></p><blockquote><p>工作在数据链路层的以太网交换机，其性能远远超过工作在物理层的集线器，而且价格并不贵，这就使得集线器逐渐被市场淘汰</p></blockquote><hr><h2 id="9-以太网交换机自学习和转发帧的流程"><a href="#9-以太网交换机自学习和转发帧的流程" class="headerlink" title="9.以太网交换机自学习和转发帧的流程"></a>9.以太网交换机自学习和转发帧的流程</h2><h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><p><img src="http://upload-images.jianshu.io/upload_images/24878825-5f9db8088bf224f9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><h3 id="自学习和转发帧的例子"><a href="#自学习和转发帧的例子" class="headerlink" title="自学习和转发帧的例子"></a>自学习和转发帧的例子</h3><p>以下例子假设各主机知道网络中其他各主机的MAC地址（无需进行ARP）</p><p><strong>A -&gt; B</strong></p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-1ef3dc4a6841b1ce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201015161458528</p><blockquote><ol><li><p>A 先向 B 发送一帧。该帧从接口 1 进入到交换机</p></li><li><p>交换机收到帧后，先查找（图中左边）交换表。没有查到应从哪个接口转发这个帧给 B</p></li><li><p>交换机把这个帧的源地址 A 和接口 1 写入（图中左边）交换表中</p></li><li><p>交换机向除接口 1 以外的所有的接口广播这个帧</p></li><li><p>接口 4到接口 2，先查找（图中右边）交换表。没有查到应从哪个接口转发这个帧给 B</p></li><li><p>交换机把这个帧的源地址 A 和接口 1 写入（图中右边）交换表中</p></li><li><p>除B主机之外与该帧的目的地址不相符，将丢弃该帧</p></li><li><p>主机B发现是给自己的帧，接受该帧</p></li></ol></blockquote><p><strong>B -&gt; A</strong></p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-dbe273924b7c8eea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201015162310922</p><blockquote><ol><li><p>B 向 A 发送一帧。该帧从接口 3 进入到交换机</p></li><li><p>交换机收到帧后，先查找（图中左边）交换表。发现（图中左边）交换表中的 MAC 地址有 A，表明要发送给A的帧应从接口1转发出去。于是就把这个帧传送到接口 1 转发给 A。</p></li><li><p>主机 A 发现目的地址是它，就接受该帧</p></li><li><p>交换机把这个帧的源地址 B 和接口 3 写入（图中左边）交换表中</p></li></ol></blockquote><p><strong>E -&gt; A</strong></p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-cf46c0c890cfa2a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201015162622462</p><blockquote><ol><li><p>E 向 A发送一帧</p></li><li><p>交换机收到帧后，先查找（图中右边）交换表。发现（图中右边）交换表中的 MAC 地址有 A，表明要发送给A的帧应从接口2转发出去。于是就把这个帧传送到接口 2 转发给 接口 4。</p></li><li><p>交换机把这个帧的源地址 E 和接口 3 写入（图中右边）交换表中</p></li><li><p>接口 4 到 左边的交换机，先查找（图中左边）交换表。发现（图中左边）交换表中的 MAC 地址有 A，表明要发送给A的帧应从接口1转发出去。于是就把这个帧传送到接口 1 转发给 A。</p></li><li><p>交换机把这个帧的源地址 E 和接口 4 写入（图中左边）交换表中</p></li><li><p>主机 A 发现目的地址是它，就接受该帧</p></li></ol></blockquote><p><strong>G -&gt; A</strong></p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-4ee1af4bc8187125.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201015163157140</p><blockquote><p>主机 A、主机 G、交换机 1的接口 1就共享同一条总线（相当于总线式网络，可以想象成用集线器连接了）</p><ol><li><p>主机 G 发送给 主机 A 一个帧</p></li><li><p>主机 A 和 交换机接口 1都能接收到</p></li><li><p>主机 A 的网卡收到后，根据帧的目的MAC地址A，就知道是发送给自己的帧，就接受该帧</p></li><li><p>交换机 1收到该帧后，首先进行登记工作</p></li><li><p>然后交换机 1对该帧进行转发，该帧的MAC地址是A，在（图中左边）交换表查找MAC 地址有 A</p></li><li><p>MAC 地址为 A的接口号是1，但是该帧正是从接口 1 进入交换机的，交换机不会再从该接口 1 讲帧转发出去，因为这是没有必要，于是丢弃该帧</p></li></ol></blockquote><p>随着网络中各主机都发送了帧后，网络中的各交换机就可以学习到各主机的MAC地址，以及它们与自己各接口的对应关系</p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-071ec78303db43c3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201015164210543</p><blockquote><p>考虑到可能有时要在交换机的接口更换主机，或者主机要更换其网络适配器，这就需要更改交换表中的项目。为此，在交换表中每个项目都设有一定的<strong>有效时间</strong>。<strong>过期的项目就自动被删除</strong>。</p><p><strong>以太网交换机的这种自学习方法使得以太网交换机能够即插即用，不必人工进行配置，因此非常方便。</strong></p></blockquote><p>网络适配器：又称网卡，基本功能从并行到串行的数据转换，包的装配和拆装，网络存取控制，数据缓存和网络信号。</p><h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p><strong>交换机自学习和转发帧的步骤归纳</strong></p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-b39e4a9145068aca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/983/format/webp" alt="img"></p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-3fc4ca18dcbaef03.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201015170739679</p><hr><h2 id="10-以太网交换机的生成树协议STP"><a href="#10-以太网交换机的生成树协议STP" class="headerlink" title="10.以太网交换机的生成树协议STP"></a>10.以太网交换机的生成树协议STP</h2><h3 id="如何提高以太网的可靠性"><a href="#如何提高以太网的可靠性" class="headerlink" title="如何提高以太网的可靠性"></a>如何提高以太网的可靠性</h3><p><img src="http://upload-images.jianshu.io/upload_images/24878825-04211a392a1b4b1c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/983/format/webp" alt="img"></p><p>image-20201015171453001</p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-5033bf0f4c26a32b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/850/format/webp" alt="img"></p><p>image-20201015171515481</p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-a65d811129786ec6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201015171900775</p><h3 id="生成树协议STP"><a href="#生成树协议STP" class="headerlink" title="生成树协议STP"></a>生成树协议STP</h3><p><img src="http://upload-images.jianshu.io/upload_images/24878825-d43f5c0c9ddbaf93.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1133/format/webp" alt="img"></p><p>image-20201015172204419</p><blockquote><ul><li><p>IEEE 802.1D 标准制定了一个<strong>生成树协议 STP</strong> (Spanning Tree Protocol)。</p></li><li><p>其<strong>要点</strong>是：<strong>不改变</strong>网络的实际拓扑，但在逻辑上则切断某些链路，使得从一台主机到所有其他主机的路径是<strong>无环路的树状结构</strong>，从而消除了兜圈子现象。</p></li></ul></blockquote><p><img src="http://upload-images.jianshu.io/upload_images/24878825-36746a91a09f583c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/895/format/webp" alt="img"></p><hr><h2 id="11-虚拟局域网VLAN"><a href="#11-虚拟局域网VLAN" class="headerlink" title="11.虚拟局域网VLAN"></a>11.虚拟局域网VLAN</h2><h3 id="为什么要虚拟局域网VLAN"><a href="#为什么要虚拟局域网VLAN" class="headerlink" title="为什么要虚拟局域网VLAN"></a>为什么要虚拟局域网VLAN</h3><p><strong>广播风暴</strong></p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-a2a78b40ae5307db.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p><strong>分割广播域的方法</strong></p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-89e9ef3fdfcc530c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><blockquote><p>为了分割广播域，所以虚拟局域网VLAN技术应运而生</p></blockquote><h3 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h3><p><img src="http://upload-images.jianshu.io/upload_images/24878825-3f98534c040b90f4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><blockquote><ul><li><p><strong>利用以太网交换机可以很方便地实现虚拟局域网 VLAN (Virtual LAN)。</strong></p></li><li><p>IEEE 802.1Q 对虚拟局域网 VLAN 的<strong>定义</strong>：  <strong>虚拟局域网 VLAN</strong> 是由一些局域网网段构成的<strong>与物理位置无关的逻辑组</strong>，而这些网段具有某些共同的需求。每一个 VLAN 的帧都有一个明确的标识符，指明发送这个帧的计算机是属于哪一个 VLAN。</p></li><li><p><strong>同一个VLAN内部可以广播通信，不同VLAN不可以广播通信</strong></p></li><li><p><strong>虚拟局域网其实只是局域网给用户提供的一种服务，而并不是一种新型局域网。</strong></p></li><li><p>由于虚拟局域网是用户和网络资源的逻辑组合，因此可按照需要将有关设备和资源非常方便地重新组合，使用户从不同的服务器或数据库中存取所需的资源。</p></li></ul></blockquote><h3 id="虚拟局域网VLAN的实现机制"><a href="#虚拟局域网VLAN的实现机制" class="headerlink" title="虚拟局域网VLAN的实现机制"></a>虚拟局域网VLAN的实现机制</h3><p>虚拟局域网VLAN技术是在交换机上实现的，需要交换机能够实现以下功能</p><ul><li>能够处理带有VLAN标记的帧——IEEE 802.1 Q帧</li><li>交换机的各端口可以支持不同的端口类型，不同端口类型的端口对帧的处理方式有所不同</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/24878825-5d3549cc02f9a3b4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-6af352f81b800a98.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p><strong>Access端口</strong></p><p>交换机与用户计算机之间的互连</p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-44a2e259c33ecfd3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/938/format/webp" alt="img"></p><blockquote><p>同一个VLAN内部可以广播通信，不同VLAN不可以广播通信</p></blockquote><p><strong>Truck端口</strong></p><p>交换机之间或交换机与路由器之间的互连</p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-a93996aae716c6aa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1184/format/webp" alt="img"></p><blockquote><p>对于交换机之间，VID和PIVD不相等的，不去标签，直接转发</p></blockquote><p><strong>小例题</strong></p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-dbf84ad8998fae58.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201015210417695</p><p><strong>华为交换机私有的Hybrid端口类型</strong></p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-653b80a66c3cc5bb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/908/format/webp" alt="img"></p><p>image-20201015211031361</p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-239ec8f47d072a9b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1069/format/webp" alt="img"></p><h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><p><img src="http://upload-images.jianshu.io/upload_images/24878825-dd58aec183276962.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><blockquote><p><strong>虚拟局域网优点</strong></p><p>虚拟局域网（VLAN）技术具有以下主要优点：</p><ol><li>改善了性能</li><li>简化了管理</li><li>降低了成本</li><li>改善了安全性</li></ol></blockquote><h1 id="4-网络层"><a href="#4-网络层" class="headerlink" title="4.网络层"></a>4.网络层</h1><h2 id="1-网络层概述"><a href="#1-网络层概述" class="headerlink" title="1.网络层概述"></a>1.网络层概述</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ul><li>网络层的主要任务是<strong>实现网络互连</strong>，进而<strong>实现数据包在各网络之间的传输</strong></li></ul><p><img src="http://upload-images.jianshu.io/upload_images/24878825-afcf88ff0d16dc80.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1190/format/webp" alt="img"></p><blockquote><p>这些异构型网络N1~N7如果只是需要各自内部通信，他们只要实现各自的物理层和数据链路层即可</p><p>但是如果要将这些异构型网络互连起来，形成一个更大的互联网，就需要实现网络层设备路由器</p><p>有时为了简单起见，可以不用画出这些网络，图中N1~N7，而将他们看做是一条链路即可</p></blockquote><ul><li><p>要实现网络层任务，需要解决一下主要问题：</p><ul><li>网络层向运输层提供怎样的服务（“可靠传输”还是“不可靠传输”）</li></ul><p>在数据链路层那课讲过的可靠传输，详情可以看那边的笔记：网络层对以下的<strong>分组丢失</strong>、<strong>分组失序</strong>、<strong>分组重复</strong>的传输错误采取措施，使得接收方能正确接受发送方发送的数据，就是<strong>可靠传输</strong>，反之，如果什么措施也不采取，则是<strong>不可靠传输</strong></p><ul><li>网络层寻址问题</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/24878825-5993e7f74bf3a7ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201017135644630</p><ul><li>路由选择问题</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/24878825-8db9ef0ef83c53ba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201017135710478</p><blockquote><p>路由器收到数据后，是依据什么来决定将数据包从自己的哪个接口转发出去？</p><p><strong>依据数据包的目的地址和路由器中的路由表</strong></p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-14fffa90e5256d53.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/438/format/webp" alt="img"></p><p>image-20201017135914985</p><p>但在实际当中，路由器是怎样知道这些路由记录？</p><ul><li><p>由用户或网络管理员进行人工配置，这种方法只适用于规模较小且网络拓扑不改变的小型互联网</p></li><li><p><strong>另一种是实现各种路由选择协议，由路由器执行路由选择协议中所规定的路由选择算法，而自动得出路由表中的路有记录，这种方法更适合规模较大且网络拓扑经常改变的大型互联网</strong></p></li></ul></blockquote></li></ul><p><img src="http://upload-images.jianshu.io/upload_images/24878825-87fc7ad0cc9ba272.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201017142545630</p><blockquote><p>补充 <strong>网络层（网际层）</strong>除了 <strong>IP协议</strong>外，还有之前介绍过的<strong>地址解析协议ARP</strong>，还有<strong>网际控制报文协议ICMP</strong>，<strong>网际组管理协议IGMP</strong></p></blockquote><h3 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h3><p><img src="http://upload-images.jianshu.io/upload_images/24878825-a692d0cb739f39ea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201017140623851</p><hr><h2 id="2-网络层提供的两种服务"><a href="#2-网络层提供的两种服务" class="headerlink" title="2.网络层提供的两种服务"></a>2.网络层提供的两种服务</h2><ul><li>在计算机网络领域，网络层应该向运输层提供怎样的服务（“<strong>面向连接</strong>”还是“<strong>无连接</strong>”）曾引起了长期的争论。</li><li>争论焦点的实质就是：<strong>在计算机通信中，可靠交付应当由谁来负责</strong>？是<strong>网络</strong>还是<strong>端系统</strong>？</li></ul><h3 id="面向连接的虚电路服务"><a href="#面向连接的虚电路服务" class="headerlink" title="面向连接的虚电路服务"></a>面向连接的虚电路服务</h3><p><strong>一种观点：让网络负责可靠交付</strong></p><ul><li>这种观点认为，应借助于电信网的成功经验，让网络负责可靠交付，计算机网络应模仿电信网络，使用<strong>面向连接</strong>的通信方式。</li><li>通信之前先建立<strong>虚电路</strong> (Virtual Circuit)，以保证双方通信所需的一切网络资源。</li><li>如果再使用<strong>可靠传输</strong>的网络协议 ，就可使所发送的分组无差错按序到达终点，不丢失、不重复。</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/24878825-3e9eab4cca1d0298.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p><strong>发送方</strong> 发送给 <strong>接收方</strong> 的所有分组都沿着同一条虚电路传送</p><blockquote><ul><li><p>虚电路表示这只是一条逻辑上的连接，分组都沿着这条逻辑连接按照存储转发方式传送，而并不是真正建立了一条物理连接。</p></li><li><p>请注意，电路交换的电话通信是先建立了一条真正的连接。</p></li><li><p>因此分组交换的虚连接和电路交换的连接只是类似，但并不完全一样</p></li></ul></blockquote><h3 id="无连接的数据报服务"><a href="#无连接的数据报服务" class="headerlink" title="无连接的数据报服务"></a>无连接的数据报服务</h3><p><strong>另一种观点：网络提供数据报服务</strong></p><ul><li>互联网的先驱者提出了一种崭新的网络设计思路。</li><li>网络层向上只提供简单灵活的、<strong>无连接的</strong>、<strong>尽最大努力交付</strong>的<strong>数据报服务</strong>。</li><li>网络在发送分组时不需要先建立连接。每一个分组（即 IP 数据报）独立发送，与其前后的分组无关（不进行编号）。</li><li><strong>网络层不提供服务质量的承诺</strong>。即所传送的分组可能出错、丢失、重复和失序（不按序到达终点），当然也不保证分组传送的时限。</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/24878825-0a52c46cee7f1ffd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p><strong>发送方</strong> 发送给 <strong>接收方</strong> 的分组可能沿着不同路径传送</p><blockquote><p><strong>尽最大努力交付</strong></p><ul><li><p>如果主机（即端系统）中的进程之间的通信需要是可靠的，那么就由网络的<strong>主机中的运输层负责可靠交付（包括差错处理、流量控制等）</strong> 。</p></li><li><p><strong>采用这种设计思路的好处是</strong>：网络的造价大大降低，运行方式灵活，能够适应多种应用。</p></li><li><p>互连网能够发展到今日的规模，充分证明了当初采用这种设计思路的正确性。</p></li></ul></blockquote><h3 id="虚电路服务与数据报服务的对比"><a href="#虚电路服务与数据报服务的对比" class="headerlink" title="虚电路服务与数据报服务的对比"></a>虚电路服务与数据报服务的对比</h3><table><thead><tr><th><strong>对比的方面</strong></th><th><strong>虚电路服务</strong></th><th><strong>数据报服务</strong></th></tr></thead><tbody><tr><td><strong>思路</strong></td><td><strong>可靠通信应当由网络来保证</strong></td><td><strong>可靠通信应当由用户主机来保证</strong></td></tr><tr><td><strong>连接的建立</strong></td><td><strong>必须有</strong></td><td><strong>不需要</strong></td></tr><tr><td><strong>终点地址</strong></td><td><strong>仅在连接建立阶段使用，每个分组使用短的虚电路号</strong></td><td><strong>每个分组都有终点的完整地址</strong></td></tr><tr><td><strong>分组的转发</strong></td><td><strong>属于同一条虚电路的分组均按照同一路由进行转发</strong></td><td><strong>每个分组独立选择路由进行转发</strong></td></tr><tr><td><strong>当结点出故障时</strong></td><td><strong>所有通过出故障的结点的虚电路均不能工作</strong></td><td><strong>出故障的结点可能会丢失分组，一些路由可能会发生变化</strong></td></tr><tr><td><strong>分组的顺序</strong></td><td><strong>总是按发送顺序到达终点</strong></td><td><strong>到达终点时不一定按发送顺序</strong></td></tr><tr><td><strong>端到端的差错处理和流量控制</strong></td><td><strong>可以由网络负责，也可以由用户主机负责</strong></td><td><strong>由用户主机负责</strong></td></tr></tbody></table><hr><h2 id="3-IPv4"><a href="#3-IPv4" class="headerlink" title="3.IPv4"></a>3.IPv4</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p><img src="http://upload-images.jianshu.io/upload_images/24878825-90e2d995adf53e57.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1199/format/webp" alt="img"></p><h3 id="分类编制的IPv4地址"><a href="#分类编制的IPv4地址" class="headerlink" title="分类编制的IPv4地址"></a>分类编制的IPv4地址</h3><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><p><img src="http://upload-images.jianshu.io/upload_images/24878825-617a75508f564e07.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201017144317166</p><blockquote><ul><li>每一类地址都由两个固定长度的字段组成，其中一个字段是<strong>网络号 net-id</strong>，它标志主机（或路由器）所连接到的网络，而另一个字段则是<strong>主机号 host-id</strong>，它标志该主机（或路由器）。</li><li>主机号在它前面的网络号所指明的网络范围内必须是唯一的。</li><li>由此可见，<strong>一个 IP 地址在整个互联网范围内是唯一的</strong>。</li></ul></blockquote><p><strong>A类地址</strong></p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-eacc61b12148d0fe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201017145210533</p><p><strong>B类地址</strong></p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-3e51c8657163a587.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201017145508001</p><p><strong>C类地址</strong></p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-82018abf428effc4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201017150204774</p><p><strong>练习</strong></p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-c1a55b79b312df0a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201017150543386</p><h4 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h4><p><strong>IP 地址的指派范围</strong></p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-0fd510a88683ce19.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/881/format/webp" alt="img"></p><p>image-20201017152911541</p><p><strong>一般不使用的特殊的 IP 地址</strong></p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-6ac646caef2b89d6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/882/format/webp" alt="img"></p><p>image-20201017152959586</p><p><strong>IP 地址的一些重要特点</strong></p><p>(1) <strong>IP 地址是一种分等级的地址结构</strong>。分两个等级的好处是：</p><blockquote><ul><li><strong>第一</strong>，IP 地址管理机构在分配 IP 地址时只分配网络号，而剩下的主机号则由得到该网络号的单位自行分配。这样就方便了 IP 地址的管理。</li><li><strong>第二</strong>，<strong>路由器仅根据目的主机所连接的网络号来转发分组（而不考虑目的主机号）</strong>，这样就可以使路由表中的项目数大幅度减少，从而减小了路由表所占的存储空间。</li></ul></blockquote><p>(2) <strong>实际上 IP 地址是标志一个主机（或路由器）和一条链路的接口</strong>。</p><blockquote><ul><li>当一个主机同时连接到两个网络上时，该主机就必须同时具有两个相应的 IP 地址，其网络号 net-id 必须是不同的。这种主机称为<strong>多归属主机</strong> (multihomed host)。</li><li>由于一个路由器至少应当连接到两个网络（这样它才能将 IP 数据报从一个网络转发到另一个网络），因此<strong>一个路由器至少应当有两个不同的 IP 地址</strong>。</li></ul></blockquote><p>(3) <strong>用转发器或网桥连接起来的若干个局域网仍为一个网络，因此这些局域网都具有同样的网络号 net-id。</strong></p><p>(4) <strong>所有分配到网络号 net-id 的网络，无论是范围很小的局域网，还是可能覆盖很大地理范围的广域网，都是平等的。</strong></p><h3 id="划分子网的IPv4地址"><a href="#划分子网的IPv4地址" class="headerlink" title="划分子网的IPv4地址"></a>划分子网的IPv4地址</h3><h4 id="为什么要划分子网"><a href="#为什么要划分子网" class="headerlink" title="为什么要划分子网"></a>为什么要划分子网</h4><p>在 ARPANET 的早期，IP 地址的设计确实不够合理：</p><ul><li><strong>IP 地址空间的利用率有时很低。</strong></li><li>给<strong>每一个物理网络分配一个网络号会使路由表变得太大</strong>因而使网络性能变坏。</li><li>两级的 IP 地址不够灵活。</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/24878825-7e6aa3fe4c6184e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>如果想要将原来的网络划分成三个独立的网路</p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-9c21430ca1484519.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201017154852896</p><p>所以是否可以从主机号部分借用一部分作为子网号</p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-5925336afb4dfe54.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201017155026814</p><blockquote><p>但是如果未在图中标记子网号部分，那么我们和计算机又如何知道分类地址中主机号有多少比特被用作子网号了呢？</p><p>所以就有了划分子网的工具：<strong>子网掩码</strong></p><ul><li><p>从 1985 年起在 IP 地址中又增加了一个“<strong>子网号字段</strong>”，使两级的 IP 地址变成为<strong>三级的 IP 地址</strong>。</p></li><li><p>这种做法叫做<strong>划分子网</strong> (subnetting) 。</p></li><li><p>划分子网已成为互联网的正式标准协议。</p></li></ul></blockquote><h4 id="如何划分子网"><a href="#如何划分子网" class="headerlink" title="如何划分子网"></a>如何划分子网</h4><p>基本思路</p><ul><li>划分子网纯属一个<strong>单位内部的事情</strong>。单位对外仍然表现为没有划分子网的网络。</li><li>从主机号<strong>借用</strong>若干个位作为<strong>子网号</strong> subnet-id，而主机号 host-id 也就相应减少了若干个位。</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/24878825-5006c8be601f1a11.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/545/format/webp" alt="img"></p><ul><li>凡是从其他网络发送给本单位某个主机的 IP 数据报，仍然是根据 IP 数据报的<strong>目的网络号</strong> net-id，先找到连接在本单位网络上的路由器。</li><li>然后<strong>此路由器</strong>在收到 IP 数据报后，再按<strong>目的网络号</strong> net-id 和<strong>子网号</strong> subnet-id 找到目的子网。</li><li>最后就将 IP 数据报直接交付目的主机。</li></ul><p>划分为三个子网后对外仍是一个网络</p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-5eaab61ca2770932.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/773/format/webp" alt="img"></p><p>image-20201017160116239</p><blockquote><ul><li><strong>优点</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.  减少了 IP 地址的浪费</span><br><span class="line">    </span><br><span class="line">2.  使网络的组织更加灵活</span><br><span class="line">    </span><br><span class="line">3.  更便于维护和管理</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><strong>划分子网纯属一个单位内部的事情，对外部网络透明</strong>，对外仍然表现为没有划分子网的一个网络。</li></ul></blockquote><h4 id="关于子网号全0和全1的问题"><a href="#关于子网号全0和全1的问题" class="headerlink" title="关于子网号全0和全1的问题"></a>关于子网号全0和全1的问题</h4><p><a href="https://blog.csdn.net/qq_43378689/article/details/111434104">(76条消息) 关于子网划分—为什么全0全1子网号不能使用_秋了个白的博客-CSDN博客_子网号</a></p><p>对于第一个子网，网络地址和主网络的网络地址是重叠的，对于最后一个子网，广播地址和主网络的广播地址也是重叠的。这样的重叠将导致极大的混乱。比如，一个发往192.168.0.255的广播是发给主网络的还是子网的？这就是为什么在当时不建议使用全0和全1子网。</p><p>不应该使用全0全1子网这个规定是源于RFC950标准，但后来RFC950在RFC1878中被废止了</p><h4 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h4><p><img src="http://upload-images.jianshu.io/upload_images/24878825-0050159cd99737aa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201017160252066</p><blockquote><p><strong>(IP 地址) AND (子网掩码) &#x3D; 网络地址</strong> 重要，下面很多相关知识都会用到</p></blockquote><p>举例</p><p>例子1</p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-24fc0f5e02ad49ab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/969/format/webp" alt="img"></p><p><strong>补充</strong>：子网掩码<strong>主机号部分</strong>二进制数中有<strong>几个1</strong>，表示该网络用<strong>几个比特</strong>来划分子网</p><p>例子2</p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-4e988e8ed1e154e3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201017161719339</p><p><strong>默认子网掩码</strong></p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-5e9d1b71bd598e62.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201017162807076</p><h4 id="总结-7"><a href="#总结-7" class="headerlink" title="总结"></a>总结</h4><p><img src="http://upload-images.jianshu.io/upload_images/24878825-143b8b8433293353.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201017162938612</p><blockquote><ul><li><p>子网掩码是一个网络或一个子网的重要属性。</p></li><li><p>路由器在和相邻路由器交换路由信息时，必须把自己所在网络（或子网）的子网掩码告诉相邻路由器。</p></li><li><p>路由器的路由表中的每一个项目，除了要给出目的网络地址外，还必须同时给出该网络的子网掩码。</p></li><li><p>若一个路由器连接在两个子网上，就拥有两个网络地址和两个子网掩码。</p></li></ul></blockquote><h3 id="无分类编址的IPv4地址"><a href="#无分类编址的IPv4地址" class="headerlink" title="无分类编址的IPv4地址"></a>无分类编址的IPv4地址</h3><h4 id="为什么使用无分类编址"><a href="#为什么使用无分类编址" class="headerlink" title="为什么使用无分类编址"></a>为什么使用无分类编址</h4><p><strong>无分类域间路由选择 CIDR</strong> (Classless Inter-Domain Routing)。</p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-dc335c4f88cede6c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><blockquote><p><strong>CIDR 最主要的特点</strong></p><ul><li><p>CIDR使用各种长度的“<strong>网络前缀</strong>”(network-prefix)来代替分类地址中的网络号和子网号。</p></li><li><p><strong>IP 地址从三级编址（使用子网掩码）又回到了两级编址</strong>。</p></li></ul></blockquote><h4 id="如何使用无分类编址"><a href="#如何使用无分类编址" class="headerlink" title="如何使用无分类编址"></a>如何使用无分类编址</h4><p><img src="http://upload-images.jianshu.io/upload_images/24878825-88843ec1d5739f3c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201017165037268</p><p>举例</p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-bdff407b4d15ec43.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201017165113442</p><h4 id="路由聚合（构造超网）"><a href="#路由聚合（构造超网）" class="headerlink" title="路由聚合（构造超网）"></a>路由聚合（构造超网）</h4><p><img src="http://upload-images.jianshu.io/upload_images/24878825-a495310e8e5bc13a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><h4 id="总结-8"><a href="#总结-8" class="headerlink" title="总结"></a>总结</h4><p><img src="http://upload-images.jianshu.io/upload_images/24878825-38c44dc0521cfc1b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1181/format/webp" alt="img"></p><p>image-20201020152711493</p><h3 id="IPv4地址的应用规划"><a href="#IPv4地址的应用规划" class="headerlink" title="IPv4地址的应用规划"></a>IPv4地址的应用规划</h3><p>给定一个IPv4地址快，如何将其划分成几个更小的地址块，并将这些地址块分配给互联网中不同网络，进而可以给各网络中的主机和路由器接口分配IPv4地址</p><h4 id="定长的子网掩码FLSM（Fixed-Length-Subnet-Mask）"><a href="#定长的子网掩码FLSM（Fixed-Length-Subnet-Mask）" class="headerlink" title="定长的子网掩码FLSM（Fixed Length Subnet Mask）"></a>定长的子网掩码FLSM（Fixed Length Subnet Mask）</h4><p><img src="http://upload-images.jianshu.io/upload_images/24878825-097ed78c469f6c87.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/882/format/webp" alt="img"></p><p><strong>划分子网的IPv4就是定长的子网掩码</strong></p><p>举例</p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-814f06bb5874b724.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201018140809079</p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-a90a636c0ff5f71c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1156/format/webp" alt="img"></p><p>image-20201018140916631</p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-da16abd19e811578.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1146/format/webp" alt="img"></p><blockquote><p>通过上面步骤分析，就可以从子网1 ~ 8中任选5个分配给左图中的N1 ~ N5</p><p><strong>采用定长的子网掩码划分，只能划分出2^n个子网，其中n是从主机号部分借用的用来作为子网号的比特数量，每个子网所分配的IP地址数量相同</strong></p><p><strong>但是也因为每个子网所分配的IP地址数量相同，不够灵活，容易造成IP地址的浪费</strong></p></blockquote><h4 id="变长的子网掩码VLSM（Variable-Length-Subnet-Mask）"><a href="#变长的子网掩码VLSM（Variable-Length-Subnet-Mask）" class="headerlink" title="变长的子网掩码VLSM（Variable Length Subnet Mask）"></a>变长的子网掩码VLSM（Variable Length Subnet Mask）</h4><p><img src="http://upload-images.jianshu.io/upload_images/24878825-2c1bfb1250975630.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/874/format/webp" alt="img"></p><p><strong>无分类编址的IPv4就是变长的子网掩码</strong></p><p>举例</p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-e7a3b3efa0032ed5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-b855ffbf02fe4306.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><hr><h2 id="4-IP数据报的发送和转发过程"><a href="#4-IP数据报的发送和转发过程" class="headerlink" title="4.IP数据报的发送和转发过程"></a>4.IP数据报的发送和转发过程</h2><p><img src="http://upload-images.jianshu.io/upload_images/24878825-591d4b10e724a0c2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>举例</p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-cb603ff4350d2927.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201018151314019</p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-6017dc6fd05d7dc3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201018150151171</p><p>源主机如何知道目的主机是否与自己在同一个网络中，是直接交付，还是间接交付？</p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-1350e20953ab73c3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201018150223497</p><blockquote><p>可以通过<strong>目的地址IP</strong>和<strong>源地址的子网掩码</strong>进行<strong>逻辑与运算</strong>得到<strong>目的网络地址</strong></p><ul><li><p>如果<strong>目的网络地址</strong>和<strong>源网络地址</strong>  <strong>相同</strong>，就是<strong>在同一个网络</strong>中，属于<strong>直接交付</strong></p></li><li><p>如果<strong>目的网络地址</strong>和<strong>源网络地址</strong>  <strong>不相同</strong>，就<strong>不在同一个网络</strong>中，属于<strong>间接交付</strong>，传输给主机所在网络的<strong>默认网关</strong>（路由器——下图会讲解）,由默认网关帮忙转发</p></li></ul></blockquote><p>主机C如何知道路由器R的存在？</p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-5f7abd26ae50d253.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201018145501063</p><blockquote><p>用户为了让本网络中的主机能和其他网络中的主机进行通信，就必须给其指定本网络的一个路由器的接口，由该路由器帮忙进行转发，所指定的路由器，也被称为<strong>默认网关</strong></p><p>例如。路由器的接口0的IP地址192.168.0.126做为左边网络的默认网关</p></blockquote><p><img src="http://upload-images.jianshu.io/upload_images/24878825-0351946f5505b37a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><blockquote><p>主机A会将该IP数据报传输给自己的默认网关，也就是图中所示的路由器接口0</p></blockquote><p>路由器收到IP数据报后如何转发？</p><ul><li>检查IP数据报首部是否出错：<ul><li>若出错，则直接丢弃该IP数据报并通告源主机</li><li>若没有出错，则进行转发</li></ul></li><li>根据IP数据报的目的地址在路由表中查找匹配的条目：<ul><li>若找到匹配的条目，则转发给条目中指示的下一跳</li><li>若找不到，则丢弃该数据报并通告源主机</li></ul></li></ul><p>假设IP数据报首部没有出错，路由器取出IP数据报首部各地址字段的值</p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-09e48a4a2debf9dd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201018151108989</p><p>接下来路由器对该IP数据报进行查表转发</p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-6ec850736125c7f6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201018151528027</p><blockquote><p>逐条检查路由条目，将<strong>目的地址与路由条目中的地址掩码进行逻辑与运算得到目的网络地址</strong>，然后与路由条目中的目的网络进行比较，如果相同，则这条路由条目就是匹配的路由条目，按照它的下一条指示，图中所示的也就是接口1转发该IP数据报</p></blockquote><p><img src="http://upload-images.jianshu.io/upload_images/24878825-4ff7f2294cf39cef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201018151956275</p><p><strong>路由器是隔离广播域的</strong></p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-f38fdc3eb91af37f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><hr><h2 id="5-静态路由配置及其可能产生的路由环路问题"><a href="#5-静态路由配置及其可能产生的路由环路问题" class="headerlink" title="5.静态路由配置及其可能产生的路由环路问题"></a>5.静态路由配置及其可能产生的路由环路问题</h2><h3 id="概念-4"><a href="#概念-4" class="headerlink" title="概念"></a>概念</h3><p><img src="http://upload-images.jianshu.io/upload_images/24878825-cf80167248b787a0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201018155702081</p><h3 id="多种情况举例"><a href="#多种情况举例" class="headerlink" title="多种情况举例"></a>多种情况举例</h3><p><strong>静态路由配置</strong></p><p>举例</p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-214e6a6830649edd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201018160349375</p><p><strong>默认路由</strong></p><p>举例</p><p>默认路由可以被所有网络匹配，但路由匹配有优先级，默认路由是优先级最低的</p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-8887ba23edaae006.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201018160906284</p><p><strong>特定主机路由</strong></p><p>举例</p><p>有时候，我们可以给路由器添加针对某个主机的特定主机路由条目</p><p>一般用于网络管理人员对网络的管理和测试</p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-434c1eec83abd86f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201018161440257</p><blockquote><p>多条路由可选，匹配路由最具体的</p></blockquote><p><strong>静态路由配置错误导致路由环路</strong></p><p>举例</p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-8b1a3cadc08a931f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201018161542579</p><p>假设将R2的路由表中第三条目录配置错了下一跳</p><p>这导致R2和R3之间产生了路由环路</p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-d30fc31c76fe75b2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201020153154773</p><p><strong>聚合了不存在的网络而导致路由环路</strong></p><p>举例</p><p>正常情况</p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-9e22a85322dfb654.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201018162333671</p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-56bce2f676ef8d09.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201018162759562</p><p>错误情况</p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-030c93bce1443043.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201018163323343</p><p>解决方法 — 人工配置黑洞路由</p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-caeddc52bde20f9c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201018163933715</p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-d91cb3837cfc2b6f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201018164453398</p><blockquote><p>黑洞路由的下一跳为null0，这是路由器内部的虚拟接口，IP数据报进入它后就被丢弃</p></blockquote><p><strong>网络故障而导致路由环路</strong></p><p>举例</p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-e3848e2bfcfc2c62.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201018164811811</p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-99cc1b342b3f645f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201018164913684</p><p>解决方法 —人工配置的</p><p>添加故障的网络为黑洞路由</p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-0c30655d3122a50d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201018165122023</p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-d8107f8fc71dd1f4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201018165153517</p><p>假设。一段时间后故障网络恢复了</p><p>R1又自动地得出了其接口0的直连网络的路由条目</p><p>针对该网络的黑洞网络会自动失效</p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-3f60a84d11d15f41.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201018165328319</p><p>如果又故障</p><p>则生效该网络的黑洞网络</p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-dfe2cfdcdd6af09e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201018165521938</p><h3 id="总结-9"><a href="#总结-9" class="headerlink" title="总结"></a>总结</h3><p><img src="http://upload-images.jianshu.io/upload_images/24878825-3bc2906b99f6940d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201018165709294</p><hr><h2 id="6-路由选择协议"><a href="#6-路由选择协议" class="headerlink" title="6.路由选择协议"></a>6.路由选择协议</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><p><img src="http://upload-images.jianshu.io/upload_images/24878825-a6ddde977e3398ad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201019134827343</p><p><strong>因特网所采用的路由选择协议的主要特点</strong></p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-b3382290a3965ffc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201019134946971</p><p><strong>因特网采用分层次的路由选择协议</strong></p><ul><li><strong>自治系统 AS</strong>：在单一的技术管理下的一组路由器，而这些路由器使用一种 AS 内部的路由选择协议和共同的度量以确定分组在该 AS 内的路由，同时还使用一种 AS 之间的路由选择协议用以确定分组在 AS之间的路由。</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/24878825-9e37d1229ec7836e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201019135122326</p><blockquote><p>自治系统之间的路由选择简称为域间路由选择，自治系统内部的路由选择简称为域内路由选择</p></blockquote><p><img src="http://upload-images.jianshu.io/upload_images/24878825-8729bdd2bd367edf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201019135328925</p><blockquote><p>域间路由选择使用外部网关协议EGP这个类别的路由选择协议</p><p>域内路由选择使用内部网关协议IGP这个类别的路由选择协议</p><p><strong>网关协议</strong>的名称可称为<strong>路由协议</strong></p></blockquote><p><strong>常见的路由选择协议</strong></p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-6b1876963d6d9de0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201019140009740</p><p><strong>路由器的基本结构</strong></p><p>路由器是一种具有多个输入端口，和输出端口的专用计算机，其任务是转发分组</p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-e6b69c1f176e24c5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201019140234652</p><p>路由器结构可划分为两大部分：</p><p>1、<strong>分组转发部分</strong></p><p>由三部分构成</p><ul><li><p>交换结构</p></li><li><p>一组输入端口：</p><p>信号从某个输入端口进入路由器</p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-2bd1e24a95010cc8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/742/format/webp" alt="img"></p><p>image-20201019141149194</p><p>物理层将信号转换成比特流，送交数据链路层处理</p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-93fa25cf949ddf32.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/627/format/webp" alt="img"></p><p>image-20201019141210774</p><p>数据链路层识别从比特流中识别出帧，去掉帧头和帧尾后，送交网络层处理</p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-be61420be381fce0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/632/format/webp" alt="img"></p><p>image-20201019141242246</p><p>如果送交网络层的分组是普通待转发的数据分组</p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-13bf3933ea84f8cf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/625/format/webp" alt="img"></p><p>image-20201019141305650</p><p>则根据分组首部中的目的地址进行查表转发</p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-6e0cce7487b0555c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/452/format/webp" alt="img"></p><p>image-20201019141327380</p><p>若找不到匹配的转发条目，则丢弃该分组，否则，按照匹配条目中所指示的端口进行转发</p></li><li><p>一组输出端口</p><p>网络层更新数据分组首部中某些字段的值，例如将数据分组的生存时间减1（防止环路出现），然后送交数据链路层进行封装</p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-c20bbb057497a7dd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/661/format/webp" alt="img"></p><p>image-20201019141745375</p><p>数据链路层将数据分组封装成帧，交给物理层处理</p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-243c60046346ab42.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/566/format/webp" alt="img"></p><p>image-20201019141838032</p><p>物理层将帧看成比特流将其变换成相应的电信号进行发送</p></li></ul><blockquote><p>路由器的各端口还会有输入缓冲区和输出缓冲区</p><ul><li><p>输入缓冲区用来暂存新进入路由器但还来不及处理的分组</p></li><li><p>输出缓冲区用来暂存已经处理完毕但还来不及发送的分组</p></li></ul><p><img src="http://upload-images.jianshu.io/upload_images/24878825-af72fd2149d2c01e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201019143040253</p><p><strong>路由器的端口一般都具有输入和输出功能</strong>，这些实例分出了输入端口和输出端口是更好演示路由基本工作过程</p></blockquote><p>2、<strong>路由选择部分</strong></p><ul><li><p>路由选择部分的核心构件是路由选择处理机，它的任务是根据所使用的路由选择协议。周期性地与其他路由器 进行路由信息的交互，来更新路由表</p><p>如果送交给输入端口的网络层的分组是路由器之间交换路由信息的路由报文，则把这种分组送交给路由选择处理机</p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-109a369b44639a9a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/419/format/webp" alt="img"></p><p>image-20201019142228360</p><p>路由选择处理机根据分组的内容来更新自己的<strong>路由表</strong></p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-af4af7e182ea3f97.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201019142415055</p><p>路由选择处理机还会周期性地给其他路由器发送自己所知道的路由信息</p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-9c1dca34462b76ab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1106/format/webp" alt="img"></p><p>image-20201019142924889</p></li></ul><h3 id="路由信息协议RIP"><a href="#路由信息协议RIP" class="headerlink" title="路由信息协议RIP"></a>路由信息协议RIP</h3><p><img src="http://upload-images.jianshu.io/upload_images/24878825-850c29aaf1e744d6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201019144915687</p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-81a38e546cd55ec2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/913/format/webp" alt="img"></p><p>image-20201019145247606</p><p><strong>RIP的基本工作过程</strong></p><p>举例</p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-6bf4e045a90846e0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201019145510947</p><p><strong>RIP的路由条目的更新规则</strong></p><p>举例1</p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-671231845f242b38.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201019145627339</p><blockquote><p>路由器C的表到达各目的网络的下一条都记为问号，可以理解为路由器D并不需要关心路由器C的这些内容</p><p>假设路由器C的RIP更新报文发送周期到了，则路由器C将自己路由表中的相关路由信息封装到RIP更新报文中发送给路由器D</p></blockquote><p><img src="http://upload-images.jianshu.io/upload_images/24878825-bacf546778de9f8a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201019150120900</p><blockquote><p>路由器C能到达这些网络，说明路由器C的相邻路由器也能到达，只是比路由器C的距离大1，于是根据距离的对比，路由器D更新自己的路由表</p></blockquote><p><img src="http://upload-images.jianshu.io/upload_images/24878825-79852776853b7463.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201019150412666</p><p>举例2</p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-7a0db5b1f8900318.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201019150525711</p><p><strong>RIP存在“坏消息传播得慢”的问题</strong></p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-edc2c694de1a9ec9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201019151041492</p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-bedb4b539faf44dd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><blockquote><p>R1被谣言误导，路径+1 更新路由表，到时候又转发给R2</p></blockquote><p>image-20201019151135255</p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-4d1eda70d2f555bf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><blockquote><p>反复更新，直到路径都位16后结束</p></blockquote><p>image-20201019151332767</p><p>解决方法</p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-3a055002b79a9cda.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201019151639181</p><blockquote><p>但是，这些方法也不能完全解决“坏消息传播得慢”的问题，这是距离向量的本质决定</p></blockquote><p><strong>总结</strong></p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-6bcb92e542416b41.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201019152526098</p><blockquote><p>RIP 协议的优缺点</p><p>优点：</p><ol><li>实现简单，开销较小。</li></ol><p>缺点：</p><ol><li><p>RIP 限制了网络的规模，它能使用的最大距离为 15（16 表示不可达）。</p></li><li><p>路由器之间交换的路由信息是路由器中的完整路由表，因而随着网络规模的扩大，开销也就增加。</p></li><li><p>“坏消息传播得慢”，使更新过程的收敛时间过长。</p></li></ol></blockquote><h3 id="开放最短路径优先OSPF"><a href="#开放最短路径优先OSPF" class="headerlink" title="开放最短路径优先OSPF"></a>开放最短路径优先OSPF</h3><p><strong>开放最短路径优先 OSPF (Open Shortest Path First)</strong></p><p><strong>注意</strong>：OSPF 只是一个协议的名字，它并不表示其他的路由选择协议不是“最短路径优先”。</p><p><strong>概念</strong></p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-f5dc77f36b5b1047.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/940/format/webp" alt="img"></p><p>image-20201019161841695</p><p><strong>问候（Hello）分组</strong></p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-f9c642e76e871651.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201019161653875</p><blockquote><p>IP数据报首部中协议号字段的取值应为89，来表明IP数据报的数据载荷为OSPF分组</p></blockquote><p><strong>发送链路状态通告LSA</strong></p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-bbed8a0d31bf19c3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201019162341151</p><blockquote><p>洪泛法有点类似于广播，就是从一个接口进来，从其他剩余所有接口出去</p></blockquote><p><strong>链路状态数据库同步</strong></p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-6b8e10e2d82cfa6f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201019162933483</p><p><strong>使用SPF算法计算出各自路由器到达其他路由器的最短路径</strong></p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-4239eee0b6040f52.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201019163148068</p><p><strong>OSPF五种分组类型</strong></p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-a2a83ab2654e270f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201019163250129</p><p><strong>OSPF的基本工作过程</strong></p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-339786779f0e1a82.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201019163746254</p><p><strong>OSPF在多点接入网络中路由器邻居关系建立</strong></p><p>如果不采用其他机制，将会产生大量的多播分组</p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-6420e503df73b7ef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201019164657606</p><blockquote><p>若DR出现问题，则由BDR顶替DR</p></blockquote><p><strong>为了使OSPF能够用于规模很大的网络，OSPF把一个自治系统再划分为若干个更小的范围，叫做区域（Area）</strong></p><ul><li>在该自治系统内，所有路由器都使用OSPF协议，OSPF将该自治系统再划分成4个更小的区域</li><li>每个区域都有一个32比特的区域标识符</li><li>主干区域的区域标识符必须为0，主干区域用于连通其他区域</li><li>其他区域的区域标识符不能为0且不相同</li><li>每个区域一般不应包含路由器超过200个</li><li>划分区域的好处就是，利用洪泛法交换链路状态信息局限于每一个区域而不是自治系统，这样减少整个网络上的通信量</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/24878825-725b3aab5aa350b1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201019170100568</p><p><strong>总结</strong></p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-6382df507ddd76d6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201019170217622</p><h3 id="边界网关协议BGP"><a href="#边界网关协议BGP" class="headerlink" title="边界网关协议BGP"></a>边界网关协议BGP</h3><p>BGP（Border Gateway Protocol） 是<strong>不同自治系统的路由器之间</strong>交换路由信息的协议</p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-5aae9c53795e17a7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/970/format/webp" alt="img"></p><p>image-20201019191438399</p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-04fe6f98036db57c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201019191718506</p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-bc71c2ee5976ac53.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201019191836397</p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-b472dd1a51f30666.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201019192031087</p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-67b837e6c27d5e9c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201019192059962</p><p><strong>总结</strong></p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-ce7dcde013985e95.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201020153832824</p><h3 id="直接封装RIP、OSPF和BGP报文的协议"><a href="#直接封装RIP、OSPF和BGP报文的协议" class="headerlink" title="直接封装RIP、OSPF和BGP报文的协议"></a>直接封装RIP、OSPF和BGP报文的协议</h3><p><img src="http://upload-images.jianshu.io/upload_images/24878825-40cf22cbd65e9ed8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201019192800829</p><hr><h2 id="7-IPv4数据报的首部格式"><a href="#7-IPv4数据报的首部格式" class="headerlink" title="7.IPv4数据报的首部格式"></a>7.IPv4数据报的首部格式</h2><h3 id="各字段的作用"><a href="#各字段的作用" class="headerlink" title="各字段的作用"></a>各字段的作用</h3><ul><li>一个 IP 数据报由<strong>首部</strong>和<strong>数据</strong>两部分组成。</li><li><strong>首部的前一部分是固定长度，共 20 字节，是所有 IP 数据报必须具有的。</strong></li><li>在首部的固定部分的后面是一些可选字段，其长度是可变的。</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/24878825-73800cce52c3a91e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>图中的每一行都由32个比特（也就是4个字节）构成，每个小格子称为字段或者域，每个字段或某些字段的组合用来表达IP协议的相关功能</p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-f1cf7dd2ea4eb52e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1196/format/webp" alt="img"></p><p>image-20201019211719880</p><blockquote><p><strong>IP数据报的首部长度一定是4字节的整数倍</strong></p><p>因为首部中的可选字段的长度从1个字节到40个字节不等，那么，当20字节的固定部分加上1到40个字节长度不等的可变部分，<strong>会造成首部长度不是4字节整数倍时，就用取值为全0的填充字段填充相应个字节</strong>，以确保IP数据报的首部长度是4字节的整数倍</p></blockquote><p><img src="http://upload-images.jianshu.io/upload_images/24878825-f7bb4a2e440abdc6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201019212617006</p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-a014cde6b0ff9691.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201019220435415</p><p><strong>对IPv4数据报进行分片</strong></p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-d7b3a6145ac1dde9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201019221021157</p><p>现在假定分片2的IP数据报经过某个网络时还需要进行分片</p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-5d538557f988dc41.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201019221246870</p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-45ab400eac660e4a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201019222512112</p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-94a3b7c0b1f01488.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201019222552444</p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-b074f6fffe538c0e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201019222729797</p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-07ac459878b48666.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220402131156182.png" alt="image-20220402131156182"></p><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220402131241935.png" alt="image-20220402131241935"></p><h3 id="总结-10"><a href="#总结-10" class="headerlink" title="总结"></a>总结</h3><p><img src="http://upload-images.jianshu.io/upload_images/24878825-95863501601f7757.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201020154031295</p><hr><h2 id="8-网际控制报文协议ICMP"><a href="#8-网际控制报文协议ICMP" class="headerlink" title="8.网际控制报文协议ICMP"></a>8.网际控制报文协议ICMP</h2><h3 id="概念-5"><a href="#概念-5" class="headerlink" title="概念"></a>概念</h3><p>架构IP网络时需要特别注意两点：</p><ul><li>确认网络是否正常工作</li><li>遇到异常时进行问题诊断</li></ul><p><strong>而ICMP就是实现这些问题的协议</strong></p><p>ICMP的主要功能包括：</p><ul><li>确认IP包是否成功送达目标地址</li><li>通知在发送过程当中IP包被废弃的具体原因</li><li>改善网络设置等</li></ul><p><strong>有了这些功能以后，就可以获得网络是否正常，设置是否有误以及设备有何异常等信息，从而便于进行网络上的问题诊断</strong></p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-8739d970a0300acc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201019232539898</p><p><strong>ICMP 不是高层协议（看起来好像是高层协议，因为 ICMP 报文是装在 IP 数据报中，作为其中的数据部分），而是 IP 层的协议</strong></p><p>ICMP 报文的格式</p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-6a02675fccdc2958.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/813/format/webp" alt="img"></p><p>image-20201020001035813</p><h3 id="ICMP差错报告报文"><a href="#ICMP差错报告报文" class="headerlink" title="ICMP差错报告报文"></a>ICMP差错报告报文</h3><h4 id="终点不可达"><a href="#终点不可达" class="headerlink" title="终点不可达"></a>终点不可达</h4><p><img src="http://upload-images.jianshu.io/upload_images/24878825-855edabd9c1e6298.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201019230838587</p><h4 id="源点抑制"><a href="#源点抑制" class="headerlink" title="源点抑制"></a>源点抑制</h4><p><img src="http://upload-images.jianshu.io/upload_images/24878825-e7f27ef6c93c9621.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201019231022291</p><h4 id="时间超过"><a href="#时间超过" class="headerlink" title="时间超过"></a>时间超过</h4><p><img src="http://upload-images.jianshu.io/upload_images/24878825-49d82185c88813fe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1191/format/webp" alt="img"></p><p>image-20201019231230798</p><h4 id="参数问题"><a href="#参数问题" class="headerlink" title="参数问题"></a>参数问题</h4><p><img src="http://upload-images.jianshu.io/upload_images/24878825-e2457fe1291c9bca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201019231355471</p><h4 id="改变路由（重定向）"><a href="#改变路由（重定向）" class="headerlink" title="改变路由（重定向）"></a>改变路由（重定向）</h4><p><img src="http://upload-images.jianshu.io/upload_images/24878825-0ef50227f921ca79.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1186/format/webp" alt="img"></p><p>image-20201019231553990</p><h4 id="不应发送ICMP差错报告报文情况"><a href="#不应发送ICMP差错报告报文情况" class="headerlink" title="不应发送ICMP差错报告报文情况"></a>不应发送ICMP差错报告报文情况</h4><p><img src="http://upload-images.jianshu.io/upload_images/24878825-a0c3a21bb04ede42.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201019231733673</p><h3 id="ICMP应用举例"><a href="#ICMP应用举例" class="headerlink" title="ICMP应用举例"></a>ICMP应用举例</h3><h4 id="分组网间探测PING（Packet-InterNet-Groper）"><a href="#分组网间探测PING（Packet-InterNet-Groper）" class="headerlink" title="分组网间探测PING（Packet InterNet Groper）"></a>分组网间探测PING（Packet InterNet Groper）</h4><p><img src="http://upload-images.jianshu.io/upload_images/24878825-75d7bc12ca942415.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201019233817921</p><h4 id="跟踪路由（traceroute）"><a href="#跟踪路由（traceroute）" class="headerlink" title="跟踪路由（traceroute）"></a>跟踪路由（traceroute）</h4><p><img src="http://upload-images.jianshu.io/upload_images/24878825-185af899d5e5a922.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/964/format/webp" alt="img"></p><p>image-20201019234123026</p><p><strong>tracert命令的实现原理</strong></p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-f59a9cacb015f074.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1191/format/webp" alt="img"></p><p>image-20201019234718107</p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-982e09181a0bc4ab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1191/format/webp" alt="img"></p><p>image-20201019234741268</p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-aeefc9f3ac87d9d7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201019234758693</p><h3 id="总结-11"><a href="#总结-11" class="headerlink" title="总结"></a>总结</h3><p><img src="http://upload-images.jianshu.io/upload_images/24878825-571c2187a7833f0d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201019234909146</p><hr><h2 id="9-虚拟专用网VPN与网络地址转换NAT"><a href="#9-虚拟专用网VPN与网络地址转换NAT" class="headerlink" title="9.虚拟专用网VPN与网络地址转换NAT"></a>9.虚拟专用网VPN与网络地址转换NAT</h2><h3 id="虚拟专用网VPN（Virtual-Private-Network）"><a href="#虚拟专用网VPN（Virtual-Private-Network）" class="headerlink" title="虚拟专用网VPN（Virtual Private Network）"></a>虚拟专用网VPN（Virtual Private Network）</h3><ul><li>由于 <strong>IP 地址的紧缺</strong>，一个机构能够申请到的IP地址数往往远小于本机构所拥有的主机数。</li><li>考虑到<strong>互联网并不很安全</strong>，一个机构内也并不需要把所有的主机接入到外部的互联网。</li><li>假定在一个机构内部的计算机通信也是采用 TCP&#x2F;IP 协议，那么从原则上讲，对于这些仅在<strong>机构内部使用</strong>的计算机就可以由本机构<strong>自行分配其 IP 地址</strong>。</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/24878825-f295c690e2c90d69.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201019235534728</p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-aee1ae10f8ccb65f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201019235631474</p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-f983b11370b6f354.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201019235718010</p><blockquote><p>上图是因特网数字分配机构IANA官网查看IPv4地址空间中特殊地址的分配方案</p><p>用粉红色标出来的地址就是无需申请的、可自由分配的专用地址，或称私有地址</p></blockquote><p><img src="http://upload-images.jianshu.io/upload_images/24878825-93cca695182bf40f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201020000136443</p><blockquote><p>私有地址只能用于一个机构的内部通信，而不能用于和因特网上的主机通信</p><p>私有地址只能用作本地地址而不能用作全球地址</p><p>因特网中所有路由器对目的地址是私有地址的IP数据报一律不进行转发</p><p><strong>本地地址与全球地址</strong></p><ul><li><p><strong>本地地址</strong>——仅在机构内部使用的 IP 地址，可以由本机构自行分配，而不需要向互联网的管理机构申请。</p></li><li><p><strong>全球地址</strong>——全球唯一的 IP 地址，必须向互联网的管理机构申请。</p></li><li><p><strong>问题</strong>：在内部使用的本地地址就有可能和互联网中某个 IP 地址重合，这样就会出现地址的二义性问题。</p></li></ul></blockquote><p>所以部门A和部门B至少需要一个 路由器具有合法的全球IP地址，这样各自的专用网才能利用公用的因特网进行通信</p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-ab2d75fcfc34f709.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201020000618797</p><p>部门A向部门B发送数据流程</p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-3a739ef0d60a031e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201020001107425</p><blockquote><p>两个专用网内的主机间发送的数据报是通过了公用的因特网，但在效果上就好像是在本机构的专用网上传送一样</p><p>数据报在因特网中可能要经过多个网络和路由器，但从逻辑上看，R1和R2之间好像是一条直通的点对点链路</p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-ad9e5dcca8c0a1c9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201020001528569</p><p>因此也被称为IP隧道技术</p></blockquote><p><img src="http://upload-images.jianshu.io/upload_images/24878825-6731dbc8b1ee1abc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201020001935801</p><h3 id="网络地址转换NAT（Network-Address-Translation）"><a href="#网络地址转换NAT（Network-Address-Translation）" class="headerlink" title="网络地址转换NAT（Network Address Translation）"></a>网络地址转换NAT（Network Address Translation）</h3><p><img src="http://upload-images.jianshu.io/upload_images/24878825-f9f42bd392a2375a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201020002020607</p><p>举例</p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-c489215f07bc88f6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201020002439942</p><blockquote><p>使用私有地址的主机，如何才能与因特网上使用全球IP地址的主机进行通信？</p><p>这需要在专用网络连接到因特网的路由器上安装NAT软件</p></blockquote><p><img src="http://upload-images.jianshu.io/upload_images/24878825-41ae75149e86d0fc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201020002734192</p><blockquote><p>专有NAT软件的路由器叫做NAT路由器</p><p>它至少有一个有效的外部全球IP地址</p><p>这样，所有使用私有地址的主机在和外界通信时，都要在NAT路由器上将其私有地址转换为全球IP地址</p></blockquote><p>假设，使用私有地址的主机要给因特网上使用全球IP地址的另一台主机发送IP数据报</p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-a74e4efad5297fc9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201020003238729</p><p>因特网上的这台主机给源主机发回数据报</p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-c0463dd919523857.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201020003411024</p><p>当专用网中的这两台使用私有地址的主机都要给因特网使用全球地址的另一台主机发送数据报时，在NAT路由器的NAT转换表中就会产生两条记录，分别记录两个私有地址与全球地址的对应关系</p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-3f71256d68f6a39a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201020003658349</p><p>这种基本转换存在一个问题</p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-ff2eca30cc7a7b41.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/953/format/webp" alt="img"></p><p>image-20201020003733863</p><p>解决方法</p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-05d3e1e3fd4b1998.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201020003840584</p><blockquote><p>我们现在用的很多家用路由器都是这种NART路由器</p></blockquote><p>内网主机与外网主机的通信，是否能由外网主机首先发起？</p><p>否定</p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-d2fd109d060e4853.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201020004159360</p><p><img src="http://upload-images.jianshu.io/upload_images/24878825-ff43ea52e61da271.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><blockquote><p>通过NET切换外网IP发出去了，发回来时IP又转为内网出外网的IP</p></blockquote><p>image-20201020004312942</p><h3 id="总结-12"><a href="#总结-12" class="headerlink" title="总结"></a>总结</h3><p><img src="http://upload-images.jianshu.io/upload_images/24878825-2a40d3a6e5d9e15a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201020154403617</p><h1 id="5-运输层"><a href="#5-运输层" class="headerlink" title="5.运输层"></a>5.运输层</h1><h2 id="1-运输层概述"><a href="#1-运输层概述" class="headerlink" title="1.运输层概述"></a>1.运输层概述</h2><h3 id="概念-6"><a href="#概念-6" class="headerlink" title="概念"></a>概念</h3><p><strong>进程之间的通信</strong></p><p><img src="https://upload-images.jianshu.io/upload_images/24878825-86df51cb4523e3bf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/607/format/webp" alt="img"></p><p>image-20201020211725185</p><ul><li>从通信和信息处理的角度看，运输层向它上面的应用层提供通信服务，<strong>它属于面向通信部分的最高层，同时也是用户功能中的最低层</strong>。</li><li>当网络的边缘部分中的两个主机使用网络的核心部分的功能进行端到端的通信时，<strong>只有位于网络边缘部分的主机的协议栈才有运输层</strong>，而网络核心部分中的路由器在转发分组时都只用到三层（到网络层）的功能。</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/24878825-09b69e8c98c856d9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201020211339131</p><p><strong>进程之间通信流程</strong></p><p><img src="https://upload-images.jianshu.io/upload_images/24878825-d9a70806edc95dc0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201020213721054</p><p>“逻辑通信”是指运输层之间的通信好像是沿水平方向传送数据，但事实上，这两条数据并没有一条水平方向的物理连接，要传送的数据是沿着图中上下多次的虚线方向传送的</p><blockquote><p>进程Ap1与Ap4之间进行基于网络的通信，进程Ap2与Ap3之间进行基于网络的通信</p><p>在运输层使用不同的端口，来对应不同的应用进程</p><p>然后通过网络层及其下层来传输应用层报文</p><p>接收方的运输层通过不同的端口，将收到的应用层报文，交付给应用层中相应的应用进程</p><p>这里端口并不是指看得见、摸得着的物理端口，而是指用来区分不同应用进程的标识符</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/24878825-a6a6ccc0bbd7f56f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201020220439303</p><h3 id="总结-13"><a href="#总结-13" class="headerlink" title="总结"></a>总结</h3><p><img src="https://upload-images.jianshu.io/upload_images/24878825-49194e15f1010ebe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201020220545411</p><p><img src="https://upload-images.jianshu.io/upload_images/24878825-04161b0a03409d04.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/951/format/webp" alt="img"></p><p>image-20201020222828878</p><hr><h2 id="2-运输层端口号、复用与分用的概念"><a href="#2-运输层端口号、复用与分用的概念" class="headerlink" title="2.运输层端口号、复用与分用的概念"></a>2.运输层端口号、复用与分用的概念</h2><h3 id="为什么用端口号"><a href="#为什么用端口号" class="headerlink" title="为什么用端口号"></a>为什么用端口号</h3><p><img src="https://upload-images.jianshu.io/upload_images/24878825-de597eda77aa6acd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201020223242364</p><h3 id="发送方的复用和接收方的分用"><a href="#发送方的复用和接收方的分用" class="headerlink" title="发送方的复用和接收方的分用"></a>发送方的复用和接收方的分用</h3><p><img src="https://upload-images.jianshu.io/upload_images/24878825-2a4ec3f5d5c11433.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201020223920225</p><blockquote><p><strong>多个进程（这里一个端口表示一个进程）</strong> 利用一个运输层协议（或者称为运输层接口）<strong>发送</strong>数据称为 <strong>复用</strong></p><p><strong>多个进程（这里一个端口表示一个进程）</strong> 利用一个运输层协议（或者称为运输层接口）<strong>接收</strong>时叫做 <strong>分用</strong>。</p></blockquote><h3 id="TCP-x2F-IP体系的应用层常用协议所使用的运输层熟知端口号"><a href="#TCP-x2F-IP体系的应用层常用协议所使用的运输层熟知端口号" class="headerlink" title="TCP&#x2F;IP体系的应用层常用协议所使用的运输层熟知端口号"></a>TCP&#x2F;IP体系的应用层常用协议所使用的运输层熟知端口号</h3><p><img src="https://upload-images.jianshu.io/upload_images/24878825-2117fa99a7f2a89c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201020224521744</p><h3 id="运输层传输流程"><a href="#运输层传输流程" class="headerlink" title="运输层传输流程"></a>运输层传输流程</h3><p>举例</p><p><img src="https://upload-images.jianshu.io/upload_images/24878825-1a74e63c3af96dda.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201020224658524</p><blockquote><p>在浏览器输入域名，回车浏览</p><p>然后用户PC中的DNS客户端进程会发送一个DNS查询请求报文</p><p>DNS查询请求报文需要使用运输层的UDP协议</p><p>首部中的源端口字段的值，在短暂端口号49151~65535中挑选一个未被占用的，用来表示DNS客户端进程</p><p>首部中的目的端口字段的值：53，是DNS服务器端进程所使用的熟知端口号</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/24878825-30701c2470e290ca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201020225830336</p><blockquote><p>之后，将UDP用户数据报封装在IP数据报中，通过以太网发送给DNS服务器</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/24878825-c4b699dfdd16826d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201020230059196</p><blockquote><p>DNS服务器收到该IP数据报后，从中解封出UDP用户数据报</p><p>UDP首部中的目的端口号为53，这表明应将该UDP用户数据报的数据载荷部分，也就是DNS查询请求报文，交付给本服务器中的DNS服务器端进程</p><p>DNS服务器端进程解析DNS查询请求报文的内容，然后按其要求查找对应的IP地址</p><p>之后，会给用户PC发送DNS响应报文，DNS响应报文需要使用运输层的UDP协议封装成UDP用户数据报</p><p>其首部中的源端口字段的值设置为熟知端口号53，表明这是DNS服务器端进程所发送的UDP用户数据报，目的端口的值设置为49152，这是之前用户PC中发送DNS查询请求报文的DNS客户端进程所使用的短暂端口号</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/24878825-6912810cd1134dc5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201020231032812</p><blockquote><p>将UDP用户数据报封装在IP数据报中，通过以太网发送给用户PC</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/24878825-eddf54c480b0a2b4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201020231308120</p><blockquote><p>用户PC收到该数据报后，从中解封出UDP用户数据报</p><p>UDP首部中的目的端口号为49152，这表明应将该UDP用户数据报的数据载荷部分，也就是DNS响应报文，交付给用户PC中的DNS客户端进程</p><p>DNS客户端进程解析DNS响应报文的内容，就可知道自己之前所请求的Web服务器的域名对应的IP地址</p></blockquote><p>现在用户PC中的HTTP客户端进程可以向Web服务器发送HTTP请求报文（和DNS发送和接收流程差不多）</p><p><img src="https://upload-images.jianshu.io/upload_images/24878825-e60fa3dedd69fae7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201020231935656</p><p><img src="https://upload-images.jianshu.io/upload_images/24878825-1184eefc458e27b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201020232517383</p><p><img src="https://upload-images.jianshu.io/upload_images/24878825-5fd36c843b4e1bab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201020232132890</p><p><img src="https://upload-images.jianshu.io/upload_images/24878825-62b9ed69203838ad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201020232548833</p><p><img src="https://upload-images.jianshu.io/upload_images/24878825-4e8b2e2943e1ec81.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201020232337332</p><hr><h2 id="3-UDP和TCP的对比"><a href="#3-UDP和TCP的对比" class="headerlink" title="3.UDP和TCP的对比"></a>3.UDP和TCP的对比</h2><h3 id="概念-7"><a href="#概念-7" class="headerlink" title="概念"></a>概念</h3><ul><li><strong>UDP</strong> 和 <strong>TCP</strong> 是TCP&#x2F;IP体系结构<strong>运输层</strong>中的两个重要协议</li><li>当运输层采用面向连接的 <strong>TCP</strong> 协议时，尽管下面的网络是不可靠的（只提供尽最大努力服务），但这种逻辑通信信道就相当于一条<strong>全双工的可靠信道</strong>。</li><li>当运输层采用无连接的 <strong>UDP</strong> 协议时，这种逻辑通信信道是一条<strong>不可靠信道</strong>。</li></ul><p>可靠信道与不可靠信道</p><p><img src="https://upload-images.jianshu.io/upload_images/24878825-fceecce4ac04df77.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/909/format/webp" alt="img"></p><p>image-20201021192221061</p><ul><li>两个对等运输实体在通信时传送的数据单位叫作<strong>运输协议数据单元</strong> TPDU (Transport Protocol Data Unit)。</li><li>TCP 传送的数据单位协议是 <strong>TCP 报文段</strong>(segment)。</li><li>UDP 传送的数据单位协议是 <strong>UDP 报文</strong>或<strong>用户数据报</strong>。</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/24878825-58c94f043969af9a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201021193640130</p><p>UDP的通信是无连接的，不需要套接字（Socket）</p><p>TCP是面向连接的，TCP之间的通信必须要在两个套接字（Socket）之间建立连接</p><h3 id="用户数据报协议UDP（User-Datagram-Protocol）"><a href="#用户数据报协议UDP（User-Datagram-Protocol）" class="headerlink" title="用户数据报协议UDP（User Datagram Protocol）"></a>用户数据报协议UDP（User Datagram Protocol）</h3><p>可以发送广播</p><p><img src="https://upload-images.jianshu.io/upload_images/24878825-6b064807ce85da9d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/937/format/webp" alt="img"></p><p>image-20201021194104694</p><p>可以向某个多播组发送多播</p><p><img src="https://upload-images.jianshu.io/upload_images/24878825-ad578349b071fd1f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/983/format/webp" alt="img"></p><p>image-20201021194225567</p><p>还可以发送单播</p><p><img src="https://upload-images.jianshu.io/upload_images/24878825-4d5ff7d4922fd433.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/914/format/webp" alt="img"></p><p>image-20201021194341256</p><blockquote><p>UDP 支持单播、多播以及广播</p><p>换句话说，UDP支持一对一，一对多，以及一对全的通信</p></blockquote><p>运输过程</p><p><img src="https://upload-images.jianshu.io/upload_images/24878825-93e3dea8064d7a6c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/949/format/webp" alt="img"></p><p>image-20201021195034383</p><blockquote><p>UDP对应用进程交下来的报文既不合并也不拆分，而是保留这些报文的边界</p><p>换句话说，UDP是面向应用报文的</p></blockquote><p>UDP向上层提供无连接不可靠传输服务</p><p><img src="https://upload-images.jianshu.io/upload_images/24878825-ce94f5cade6a0e97.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/970/format/webp" alt="img"></p><p>image-20201021204152175</p><p>UDP结构</p><p><img src="https://upload-images.jianshu.io/upload_images/24878825-624005a24bc5bfcd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/871/format/webp" alt="img"></p><p>image-20201021205214512</p><p>传输控制协议TCP（Transmission Control Protocol）</p><p>使用TCP协议的通信双方，在进行数据传输之前，必须使用“三报文握手”建立TCP连接</p><p><img src="https://upload-images.jianshu.io/upload_images/24878825-fe9d1bdd35dbd5d4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/920/format/webp" alt="img"></p><p>image-20201021194557102</p><p>TCP连接建立成功后，通信双方之间就好像有一条可靠的通信信道，通信双方使用这条基于TCP连接的可靠信道进行通信</p><p><img src="https://upload-images.jianshu.io/upload_images/24878825-e193eb63d50a9c79.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/932/format/webp" alt="img"></p><p>image-20201021194749562</p><blockquote><p>很显然，TCP仅支持单播，也就是一对一的通信</p></blockquote><p>运输过程</p><p><img src="https://upload-images.jianshu.io/upload_images/24878825-cd38698ad784fcea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/951/format/webp" alt="img"></p><p>image-20201021195435677</p><blockquote><p>发送方</p><ul><li><p>TCP会把应用进程交付下来的数据块看作是一连串无结构的字节流，TCP并不知道这些待传送的字节流的含义</p></li><li><p>并将他们编号，并存储在自己发送缓存中</p></li><li><p>TCP会根据发送策略，提取一定量的字节构建TCP报文并发送</p></li></ul><p>接收方</p><ul><li><p>一方面从所接受到的TCP报文段中，取出数据载荷部分并存储在接收缓存中；一方面将接收缓存中的一些字节交付给应用进程</p></li><li><p>TCP不保证接收方应用进程所收到的数据块与发送方发送的数据块，具有对应大小的关系（例如，发送方应用进程交给发送方的TCP共10个数据块，但接收方的TCP可能只用了4个数据块，就把收到的字节流交付给了上层的应用进程，但接收方收到的字节流必须和发送方应用进程发出的字节流完全一样）</p></li><li><p>接收方的应用进程必须有能力识别收到的字节流，把它还原成有意义的应用层数据</p></li></ul><p>TCP是面向字节流的，这正是TCP实现可靠传输、流量控制、以及拥塞控制的基础</p><p>本图只画了一个方向的数据流，在实际网络中，基于TCP连接的两端，可以同时进行TCP报文段的发送和接收</p></blockquote><p>TCP向上层提供面向连接的可靠传输服务</p><p><img src="https://upload-images.jianshu.io/upload_images/24878825-915eafb17567c438.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/932/format/webp" alt="img"></p><p>image-20201021204508839</p><p>TCP结构</p><p><img src="https://upload-images.jianshu.io/upload_images/24878825-db48b70af7fb7884.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/897/format/webp" alt="img"></p><p>image-20201021205307406</p><h3 id="总结-14"><a href="#总结-14" class="headerlink" title="总结"></a>总结</h3><p><img src="https://upload-images.jianshu.io/upload_images/24878825-b0c1d4146735458a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201023004653315</p><hr><h2 id="4-TCP的流量控制"><a href="#4-TCP的流量控制" class="headerlink" title="4.TCP的流量控制"></a>4.TCP的流量控制</h2><h3 id="概念-8"><a href="#概念-8" class="headerlink" title="概念"></a>概念</h3><p><img src="https://upload-images.jianshu.io/upload_images/24878825-2265c15b05b648dd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201021223432091</p><p>举例</p><p><a href="https://links.jianshu.com/go?to=https://www.bilibili.com/video/BV1c4411d7jb?p=60">具体流程的视频</a></p><p><img src="https://upload-images.jianshu.io/upload_images/24878825-b05bfb5781a99f95.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201021231801076</p><p>上图主机A现在可将发送缓存中序号1~200的字节数据全部删除，因为已经收到了主机B对它们的累计确认</p><p><img src="https://upload-images.jianshu.io/upload_images/24878825-822d96dec58ce11f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201021231904707</p><p>上图主机A现在可将发送缓存中序号201~500的字节数据全部删除，因为已经收到了主机B对它们的累计确认</p><p><img src="https://upload-images.jianshu.io/upload_images/24878825-43345f50233197a7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201021231945653</p><p><img src="https://upload-images.jianshu.io/upload_images/24878825-f73e94f75e94ea4c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201021232027721</p><p>上图主机A现在可将发送缓存中序号501~600的字节数据全部删除，因为已经收到了主机B对它们的累计确认</p><p><img src="https://upload-images.jianshu.io/upload_images/24878825-5bd53b8a5a5ac400.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201021232600497</p><p><img src="https://upload-images.jianshu.io/upload_images/24878825-ea9dc3589e6c6bd1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201021232645300</p><blockquote><p>上图如果零窗口探测报文在发送过程中如果丢失，还是能打破死锁局面</p><p>因为零窗口探测报文段也有重传计时器，重传计时器超时后，零窗口探测报文段会被重传</p></blockquote><h3 id="总结-15"><a href="#总结-15" class="headerlink" title="总结"></a>总结</h3><p><img src="https://upload-images.jianshu.io/upload_images/24878825-d8221e9dda7919f9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201021234004254</p><hr><h2 id="5-TCP的拥塞控制"><a href="#5-TCP的拥塞控制" class="headerlink" title="5.TCP的拥塞控制"></a>5.TCP的拥塞控制</h2><h3 id="概念-9"><a href="#概念-9" class="headerlink" title="概念"></a>概念</h3><p><img src="https://upload-images.jianshu.io/upload_images/24878825-9d4b410b2a44c125.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201022141057083</p><p><strong>网络拥塞往往是由许多因素引起的。例如：</strong></p><ol><li>点缓存的容量太小；</li><li>链路的容量不足；</li><li>处理机处理的速率太慢；</li><li>拥塞本身会进一步加剧拥塞；</li></ol><p><strong>拥塞控制的一般原理</strong></p><ul><li>拥塞控制的前提：网络能够承受现有的网络负荷。</li><li>实践证明，拥塞控制是很难设计的，因为它是一个<strong>动态问题</strong>。</li><li>分组的丢失是网络发生拥塞的<strong>征兆</strong>而不是原因。</li><li>在许多情况下，甚至正是<strong>拥塞控制本身</strong>成为引起网络性能恶化、甚至发生死锁的原因。</li></ul><p><strong>开环控制和闭环控制</strong></p><p><img src="https://upload-images.jianshu.io/upload_images/24878825-2740d71c5e1d6aac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/884/format/webp" alt="img"></p><p>image-20201022142108309</p><p><strong>监测网络的拥塞</strong></p><p>主要指标有：</p><ol><li>由于缺少缓存空间而被丢弃的分组的百分数；</li><li>平均队列长度；</li><li>超时重传的分组数；</li><li>平均分组时延；</li><li>分组时延的标准差，等等。</li></ol><p>上述这些指标的上升都标志着拥塞的增长。</p><h3 id="拥塞控制的算法"><a href="#拥塞控制的算法" class="headerlink" title="拥塞控制的算法"></a>拥塞控制的算法</h3><p><img src="https://upload-images.jianshu.io/upload_images/24878825-67852fc13fc0e263.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201022141423443</p><p><img src="https://upload-images.jianshu.io/upload_images/24878825-c7682fe29ebcb6fd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201022141556134</p><blockquote><p>真正的发送窗口值 &#x3D; Min (接收方窗口值，拥塞窗口值)</p></blockquote><p>下图的实例横纵坐标的意思</p><p>传输轮次：</p><ul><li>发送方给接收方发送数据报文段后，接收方给发送方发发回相应的确认报文段</li><li>一个传输轮次所经历的时间其实就是往返时间，往返时间并非是恒定的数值</li><li>使用传输轮次是为了强调把拥塞窗口所允许发送的报文段都连续发送出去，并受到了对已发送的最后一个报文段的确认</li></ul><p>拥塞窗口：</p><ul><li>它会随网络拥塞程度，以及所使用的拥塞控制算法动态变化</li></ul><h4 id="慢开始和拥塞避免"><a href="#慢开始和拥塞避免" class="headerlink" title="慢开始和拥塞避免"></a>慢开始和拥塞避免</h4><h5 id="慢开始（slow-start）"><a href="#慢开始（slow-start）" class="headerlink" title="慢开始（slow-start）"></a>慢开始（slow-start）</h5><ul><li>目的：用来确定网络的负载能力或拥塞程度。</li><li>算法的思路：由小到大逐渐增大拥塞窗口数值。</li><li>两个变量：<ul><li><strong>拥塞窗口（cwnd）</strong>：初始拥塞窗口值：2 种设置方法。窗口值逐渐增大。<ul><li>1 至 2 个最大报文段 （旧标准）</li><li>2 至 4 个最大报文段 （RFC 5681）</li></ul></li><li><strong>慢开始门限（ssthresh）</strong>：防止拥塞窗口增长过大引起网络拥塞。</li></ul></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/24878825-47dba7f2068f35df.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201022145631052</p><p><img src="https://upload-images.jianshu.io/upload_images/24878825-1bca665e8eaa965a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/713/format/webp" alt="img"></p><p>image-20201022144725100</p><blockquote><p>图中swnd是发送窗口</p><p>每经过一个传输轮次，拥塞窗口就加倍</p><p>窗口大小按<strong>指数增加</strong>，2的n-1次方</p></blockquote><h5 id="拥塞避免（congestion-avoidance）"><a href="#拥塞避免（congestion-avoidance）" class="headerlink" title="拥塞避免（congestion avoidance）"></a>拥塞避免（congestion avoidance）</h5><ul><li>思路：让拥塞窗口 cwnd <strong>缓慢地增大</strong>，避免出现拥塞。</li><li>每经过一个传输轮次，拥塞窗口 <strong>cwnd &#x3D; cwnd + 1</strong>。</li><li>使拥塞窗口 cwnd 按线性规律缓慢增长。</li><li>在拥塞避免阶段，具有 “<strong>加法增大</strong>” (Additive Increase) 的特点。</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/24878825-28dacc122d9ef398.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201022150143886</p><p>如果在发送过程中出现部分报文段丢失，这必然会造成发送方对这些丢失报文段的超时重传</p><p><img src="https://upload-images.jianshu.io/upload_images/24878825-c35271774108d273.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201022145749592</p><p>这个时候又回到了慢开始</p><p><img src="https://upload-images.jianshu.io/upload_images/24878825-233c4e9e061dc1d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201022145544163</p><p><img src="https://upload-images.jianshu.io/upload_images/24878825-98094e880a6fad4e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201022145824004</p><h5 id="两个算法完整示意图"><a href="#两个算法完整示意图" class="headerlink" title="两个算法完整示意图"></a>两个算法完整示意图</h5><p><img src="https://upload-images.jianshu.io/upload_images/24878825-f5db7ea25d8aca73.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201022150236926</p><h4 id="快重传和快恢复"><a href="#快重传和快恢复" class="headerlink" title="快重传和快恢复"></a>快重传和快恢复</h4><p><img src="https://upload-images.jianshu.io/upload_images/24878825-fee86fb3707a175c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201022150902709</p><h5 id="快重传（fast-retrasmit）"><a href="#快重传（fast-retrasmit）" class="headerlink" title="快重传（fast retrasmit）"></a>快重传（fast retrasmit）</h5><p><img src="https://upload-images.jianshu.io/upload_images/24878825-a57c7cc819aa4bae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201022151250183</p><h5 id="快恢复（fast-recovery）"><a href="#快恢复（fast-recovery）" class="headerlink" title="快恢复（fast recovery）"></a>快恢复（fast recovery）</h5><p><img src="https://upload-images.jianshu.io/upload_images/24878825-ab5a63efbd586eb8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201022151819265</p><h5 id="改进后的整体算法的示意图"><a href="#改进后的整体算法的示意图" class="headerlink" title="改进后的整体算法的示意图"></a>改进后的整体算法的示意图</h5><p><img src="https://upload-images.jianshu.io/upload_images/24878825-8f61b8eddb5b2624.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201022152041751</p><hr><h2 id="6-TCP超时重传时间的选择"><a href="#6-TCP超时重传时间的选择" class="headerlink" title="6.TCP超时重传时间的选择"></a>6.TCP超时重传时间的选择</h2><p><img src="https://upload-images.jianshu.io/upload_images/24878825-855245410fc0ff17.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201022152651184</p><blockquote><p>如果超时重传时间RTO的值设置得比RTT0的值小很多，这会引起报文段不必要的重传，使网络负荷增大</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/24878825-789e0116477a41df.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201022152708875</p><blockquote><p>如果超时重传时间RTO的值设置得远大于RTT0的值，这会使重传时间推迟的太长，使网络的空闲时间增大，降低传输效率</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/24878825-994128acb2576516.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201022153244047</p><p><img src="https://upload-images.jianshu.io/upload_images/24878825-20d1cf6bb211fe7e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201022153518218</p><p><strong>RFC6298建议使用下式计算超时重传时间RTO</strong></p><p><img src="https://upload-images.jianshu.io/upload_images/24878825-39ab62874e65b623.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201022153758413</p><p><strong>往返时间RTT的测量比较复杂</strong></p><p><img src="https://upload-images.jianshu.io/upload_images/24878825-d454ebe83c1133ef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201022154045440</p><p><img src="https://upload-images.jianshu.io/upload_images/24878825-dbc63525eab966e1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201022154137911</p><p><strong>TCP超时重传的计算</strong></p><p>举例</p><p><img src="https://upload-images.jianshu.io/upload_images/24878825-7d23bd8b0a165628.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p><strong>总结</strong></p><p><img src="https://upload-images.jianshu.io/upload_images/24878825-c94fa8a3ad6b277f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201022154418863</p><hr><h2 id="7-TCP可靠传输的实现"><a href="#7-TCP可靠传输的实现" class="headerlink" title="7.TCP可靠传输的实现"></a>7.TCP可靠传输的实现</h2><p><a href="https://links.jianshu.com/go?to=https://www.bilibili.com/video/BV1c4411d7jb?p=63">本集具体讲解</a></p><p><img src="https://upload-images.jianshu.io/upload_images/24878825-6d10ea76a1ea032b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201022161436801</p><p><img src="https://upload-images.jianshu.io/upload_images/24878825-92d975bc880db892.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201022161734997</p><p><img src="https://upload-images.jianshu.io/upload_images/24878825-35bff0a8cc5b0d71.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201022164339902</p><hr><h2 id="8-TCP的运输连接管理"><a href="#8-TCP的运输连接管理" class="headerlink" title="8.TCP的运输连接管理"></a>8.TCP的运输连接管理</h2><h3 id="概念-10"><a href="#概念-10" class="headerlink" title="概念"></a>概念</h3><p><img src="https://upload-images.jianshu.io/upload_images/24878825-e7d2329746de8e6a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201022193215183</p><h3 id="TCP的连接建立"><a href="#TCP的连接建立" class="headerlink" title="TCP的连接建立"></a>TCP的连接建立</h3><ul><li>TCP 建立连接的过程叫做<strong>握手</strong>。</li><li>握手需要在客户和服务器之间交换三个 TCP 报文段。称之为<strong>三报文握手</strong>。</li><li>采用<strong>三报文握手</strong>主要是为了防止已失效的连接请求报文段突然又传送到了，因而产生错误。</li></ul><h4 id="TCP的连接建立要解决以下三个问题"><a href="#TCP的连接建立要解决以下三个问题" class="headerlink" title="TCP的连接建立要解决以下三个问题"></a>TCP的连接建立要解决以下三个问题</h4><p><img src="https://upload-images.jianshu.io/upload_images/24878825-84c2b6dbb20379bd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201022193418673</p><h4 id="TCP使用“三报文握手”建立连接"><a href="#TCP使用“三报文握手”建立连接" class="headerlink" title="TCP使用“三报文握手”建立连接"></a>TCP使用“三报文握手”建立连接</h4><ul><li>TCP 连接的建立<strong>采用客户服务器方式</strong>。</li><li>主动发起连接建立的应用进程叫做<strong>TCP客户</strong> (client)。</li><li>被动等待连接建立的应用进程叫做<strong>TCP服务器</strong> (server)。</li></ul><p>“握手”需要在TCP客户端和服务器之间交换三个TCP报文段</p><p>过程</p><p><img src="https://upload-images.jianshu.io/upload_images/24878825-9f509a892fb0f5c1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201022194219693</p><blockquote><p>最初两端的TCP进程都处于关闭状态</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/24878825-e69d0e450b080e1f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201022194350899</p><blockquote><p>一开始，TCP服务器进程首先创建传输控制块，用来存储TCP连接中的一些重要信息。例如TCP连接表、指向发送和接收缓存的指针、指向重传队列的指针，当前的发送和接收序号等</p><p>之后，就准备接受TCP客户端进程的连接请求</p><p>此时，TCP服务器进程就进入监听状态，等待TCP客户端进程的连接请求</p></blockquote><p>TCP服务器进程是被动等待来自TCP客户端进程的连接请求，因此成为<strong>被动打开</strong>连接</p><p><img src="https://upload-images.jianshu.io/upload_images/24878825-9e597559ec8fcae8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201022194926877</p><blockquote><p>TCP客户进程也是首先创建传输控制块</p></blockquote><p>由于TCP连接建立是由TCP客户端主动发起的，因此称为<strong>主动打开</strong>连接</p><p><img src="https://upload-images.jianshu.io/upload_images/24878825-46865d700124bfd1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201022195108616</p><blockquote><p>然后，在打算建立TCP连接时，向TCP服务器进程发送TCP连接请求报文段，并进入同步已发送状态</p><p>TCP连接请求报文段首部中</p><ul><li><p>同步位SYN被设置为1，表明这是一个TCP连接请求报文段</p></li><li><p>序号字段seq被设置了一个初始值x，作为TCP客户端进程所选择的初始序号</p></li></ul><p>请注意：TCP规定SYN被设置为1的报文段不能携带数据，但要消耗掉一个序号</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/24878825-f8dec0443dc56584.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201022195847144</p><blockquote><p>TCP服务器进程收到TCP连接请求报文段后，如果同意建立连接，则向TCP客户进程发送TCP连接请求确认报文段，并进入同步已接收状态</p><p>TCP连接请求确认报文段首部中</p><ul><li><p>同步位SYN和确认为ACK都设置为1，表明这是一个TCP连接请求确认报文段</p></li><li><p>序号字段seq被设置了一个初始值y，作为TCP服务器进程所选择的初始序号，</p></li><li><p>确认号字段ack的值被设置成了x+1，这是对TCP客户进程所选择的初始序号（seq）的确认</p></li></ul><p>请注意：这个报文段也不能携带数据，因为它是SYN被设置为1的报文段，但同样要消耗掉一个序号</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/24878825-c6b6b91049a352db.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp"></p><p>image-20201022202010182</p><blockquote><p>TCP客户进程收到TCP连接请求确认报文段后，还要向TCP服务器进程发送一个普通的TCP确认报文段，并进入连接已连接状态</p><p>普通的TCP确认报文段首部中</p><ul><li><p>确认位ACK被设置为1，表明这是一个普通的TCP确认报文段</p></li><li><p>序号字段seq被设置为x+1，这是因为TCP客户进程发送的第一个TCP报文段的序号为x，所以TCP客户进程发送的第二个报文段的序号为x+1</p></li><li><p>确认号字段ack被设置为y+1，这是对TCP服务器进程所选择的初始序号的确认</p></li></ul><p>请注意：TCP规定普通的TCP确认报文段可以携带数据，但如果不携带数据，则不消耗序号</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/24878825-987d5c8512392422.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201022202932905</p><blockquote><p>TCP服务器进程收到该确认报文段后也进入连接已建立状态</p><p>现在，TCP双方都进入了连接已建立状态，它们可以基于已建立好的TCP连接，进行可靠的数据传输</p></blockquote><p>为什么TCP客户进程最后还要发送一个普通的TCP确认报文段？能否使用“两报文握手”建立连接？</p><p>下图实例是“两报文握手”</p><p><img src="https://upload-images.jianshu.io/upload_images/24878825-0a5773a600817c41.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201022203744174</p><blockquote><p>为了防止已经失效的连接请求报文段突然又传到服务端，因而产生错误”，这种情况是：一端(client)A发出去的第一个连接请求报文并没有&gt; 丢失，而是因为某些未知的原因在某个网络节点上发生滞留，导致延迟到连接释放以后的某个时间才到达另一端(server)B。本来这是一个&gt; 早已失效的报文段，但是B收到此失效的报文之后，会误认为是A再次发出的一个新的连接请求，于是B端就向A又发出确认报文，表示同&gt; 意建立连接。如果不采用“三次握手”，那么只要B端发出确认报文就会认为新的连接已经建立了，但是A端并没有发出建立连接的请求，因&gt; 此不会去向B端发送数据，B端没有收到数据就会一直等待，这样B端就会白白浪费掉很多资源。<br> 所以并不<strong>多余</strong>，这是为了防止已失效的连接请求报文段突然又传送到了TCP服务器，因而导致错误</p></blockquote><h4 id="总结-16"><a href="#总结-16" class="headerlink" title="总结"></a>总结</h4><p><img src="https://upload-images.jianshu.io/upload_images/24878825-3205fd7d7d75b62e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201022204422775</p><h3 id="TCP的连接释放"><a href="#TCP的连接释放" class="headerlink" title="TCP的连接释放"></a>TCP的连接释放</h3><ul><li>TCP 连接释放过程比较复杂。</li><li>数据传输结束后，通信的双方都可释放连接。</li><li>TCP 连接释放过程是<strong>四报文握手</strong>。</li></ul><h4 id="TCP通过“四报文挥手”来释放连接"><a href="#TCP通过“四报文挥手”来释放连接" class="headerlink" title="TCP通过“四报文挥手”来释放连接"></a>TCP通过“四报文挥手”来释放连接</h4><ul><li>TCP 连接的建立<strong>采用客户服务器方式</strong>。</li><li>主动发起连接建立的应用进程叫做<strong>TCP客户</strong> (client)。</li><li>被动等待连接建立的应用进程叫做<strong>TCP服务器</strong> (server)。</li><li><strong>任何一方都可以在数据传送结束后发出连接释放的通知</strong></li></ul><p>过程</p><p><img src="https://upload-images.jianshu.io/upload_images/24878825-d56a05b1da63bf01.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201022205124204</p><blockquote><p>现在TCP客户进程和TCP服务器进程都处于连接已建立状态</p><p>TCP客户进程的应用进程通知其主动关闭TCP连接</p><p>TCP客户进程会发送TCP连接释放报文段，并进入终止等待1状态</p><p>TCP连接释放报文段首部中</p><ul><li><p>终止位FIN和确认为ACK的值都被设置为1，表明这是一个TCP连接释放报文段，同时也对之前收到的报文段进行确认</p></li><li><p>序号seq字段的值设置为u，它等于TCP客户进程之前已传送过的数据的最后一个字节的序号加1</p></li><li><p>确认号ack字段的值设置为v，它等于TCP客户进程之前已收到的、数据的最后一个字节的序号加1</p></li></ul><p>请注意：TCP规定终止位FIN等于1的报文段即使不携带数据，也要消耗掉一个序号</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/24878825-d8be7c2c584d245a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201022210030419</p><blockquote><p>TCP服务器进程收到TCP连接释放报文段后，会发送一个普通的TCP确认报文段并进入关闭等待状态</p><p>普通的TCP确认报文段首部中</p><ul><li><p>确认位ACK的值被设置为1，表明这是一个普通的TCP确认报文段</p></li><li><p>序号seq字段的值设置为v，它等于TCP服务器进程之前已传送过的数据的最后一个字节的序号加1，这也与之前收到的TCP连接释放报文段中的确认号匹配</p></li><li><p>确认号ack字段的值设置为u+1，这是对TCP连接释放报文段的确认</p></li></ul></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/24878825-733705e761921b6b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201022232158631</p><blockquote><p>TCP服务器进程应该通知高层应用进程，TCP客户进程要断开与自己的TCP连接</p><p>此时，从TCP客户进程到TCP服务器进程这个方向的连接就释放了</p><p>这时的TCP连接属于半关闭状态，也就是TCP客户进程已经没有数据要发送了</p><p>但如果TCP服务器进程还有数据要发送，TCP客户进程仍要接收，也就是说从TCP服务器进程到TCP客户进程这个方向的连接并未关闭</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/24878825-583da1984154448c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201022233050922</p><blockquote><p>TCP客户进程收到TCP确认报文段后就进入终止等待2状态，等待TCP服务器进程发出的TCP连接释放报文段</p><p>若使用TCP服务器进程的应用进程已经没有数据要发送了，应用进程就通知其TCP服务器进程释放连接</p><p>由于TCP连接释放是由TCP客户进程主动发起的，因此TCP服务器进程对TCP连接的释放称为被动关闭连接</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/24878825-60b55978f2d24a50.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201022233941557</p><blockquote><p>TCP服务器进程发送TCP连接释放报文段并进入最后确认状态</p><p>该报文段首部中</p><ul><li><p>终止位FIN和确认位ACK的值都被设置为1，表明这是一个TCP连接释放报文段，同时也对之前收到的报文段进行确认</p></li><li><p>序号seq字段的值为w，这是因为在半关闭状态下，TCP服务器进程可能又发送</p></li><li><p>确认号ack字段的值为u+1，这是对之前收到的TCP连接释放报文段的重复确认</p></li></ul></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/24878825-1c5e0c6357d039ed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201022234741310</p><blockquote><p>TCP客户进程收到TCP连接释放报文段后，必须针对该报文段发送普通的TCP确认报文段，之后进入时间等待状态</p><p>该报文段首部中</p><ul><li><p>确认为ACK的值被设置为1，表明这是一个普通的TCP确认报文段</p></li><li><p>序号seq字段的值设置为u+1，这是因为TCP客户进程之前发送的TCP连接释放报文段虽然不携带数据，但要消耗掉一个序号</p></li><li><p>确认号ack字段的值设置为w+1，这是对所收到的TCP连接释放报文段的确认</p></li></ul><p>TCP服务器进程收到该报文段后就进入关闭状态，而TCP客户进程还要进过2MSL后才能进入关闭状态</p></blockquote><p>TCP客户进程在发送完最后一个确认报文后，为什么不直接进入关闭状态？而是要进入时间等待状态？</p><p><img src="https://upload-images.jianshu.io/upload_images/24878825-ef85470fe120f146.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201022234942562</p><blockquote><p>因为时间等待状态以及处于该状态2MSL时长，可以确保TCP服务器进程可以收到最后一个TCP确认报文段而进入关闭状态</p><p>另外，TCP客户进程在发送完最后一个TCP确认报文段后，在经过2MSL时长，就可以使本次连接持续时间内所产生的所有报文段都从网络中消失，这样就可以使下一个新的TCP连接中，不会出现旧连接中的报文段</p></blockquote><h4 id="TCP保活计时器的作用"><a href="#TCP保活计时器的作用" class="headerlink" title="TCP保活计时器的作用"></a>TCP保活计时器的作用</h4><p>TCP双方已经建立了连接，后来，TCP客户进程所在的主机突然出现了故障</p><p>TCP服务器进程以后就不能再收到TCP客户进程发来的数据</p><p>因此，应当有措施使TCP服务器进程不要再白白等待下去</p><p><img src="https://upload-images.jianshu.io/upload_images/24878825-2dc97e06fe1d82ed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201022235800155</p><hr><h2 id="9-TCP报文段的首部格式"><a href="#9-TCP报文段的首部格式" class="headerlink" title="9.TCP报文段的首部格式"></a>9.TCP报文段的首部格式</h2><p><img src="https://upload-images.jianshu.io/upload_images/24878825-df9263a14e1da2c1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201023000859363</p><h3 id="各字段的作用-1"><a href="#各字段的作用-1" class="headerlink" title="各字段的作用"></a>各字段的作用</h3><p>源端口和目的端口</p><p><img src="https://upload-images.jianshu.io/upload_images/24878825-27e4bd51d5db2f8e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201023005210010</p><p>序号、确认号和确认标志位</p><p><img src="https://upload-images.jianshu.io/upload_images/24878825-fd0e64d8be3f598b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201023003826059</p><p>数据偏移、保留、窗口和校验和</p><p><img src="https://upload-images.jianshu.io/upload_images/24878825-d3d4c61af68fdb6d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201023004227265</p><p>同步标志位、终止标志位、复位标志位、推送标志位、紧急标志位和紧急指针</p><p><img src="https://upload-images.jianshu.io/upload_images/24878825-f09bdaba863c4ca3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201023005001450</p><p>选项和填充</p><p><img src="https://upload-images.jianshu.io/upload_images/24878825-d1a8d3ca5ac7f39d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1185/format/webp" alt="img"></p><p>image-20201023005132426</p><h1 id="6-应用层"><a href="#6-应用层" class="headerlink" title="6.应用层"></a>6.应用层</h1><h2 id="1-应用层概述"><a href="#1-应用层概述" class="headerlink" title="1.应用层概述"></a>1.应用层概述</h2><p><img src="https://upload-images.jianshu.io/upload_images/24878825-968c1bcea54ea1f4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201023195112701</p><p><img src="https://upload-images.jianshu.io/upload_images/24878825-3d48b52ccf2bda5f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201023200511781</p><p>我们在浏览器的地址中输入某个网站的域名后，就可以访问该网站的内容，这个就是<strong>万维网WWW应用</strong>，其相关的应用层协议为<strong>超文本传送协议HTTP</strong></p><p><img src="https://upload-images.jianshu.io/upload_images/24878825-877daae73d0011c0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201023200819770</p><p>用户在浏览器地址栏中输入的是“见名知意”的<strong>域名</strong>，而TCP&#x2F;IP的网际层使用<strong>IP地址</strong>来表示目的主机，从域名到IP地址的装转换，由属于<strong>应用层范畴的域名系统DNS</strong>，在后台帮用户完成</p><p><img src="https://upload-images.jianshu.io/upload_images/24878825-295acc2503d1ac7d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201023201028141</p><p>常见的应用</p><p><img src="https://upload-images.jianshu.io/upload_images/24878825-4e9858624d4835ae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201023201101024</p><p>总结</p><p><img src="https://upload-images.jianshu.io/upload_images/24878825-c1c3868fb5e127b1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201023201137047</p><hr><h2 id="2-客户-x2F-服务器方式（C-x2F-S方式）和对等方式（P2P方式）"><a href="#2-客户-x2F-服务器方式（C-x2F-S方式）和对等方式（P2P方式）" class="headerlink" title="2.客户&#x2F;服务器方式（C&#x2F;S方式）和对等方式（P2P方式）"></a>2.客户&#x2F;服务器方式（C&#x2F;S方式）和对等方式（P2P方式）</h2><h3 id="概念-11"><a href="#概念-11" class="headerlink" title="概念"></a>概念</h3><p><img src="https://upload-images.jianshu.io/upload_images/24878825-983cfa1e406fd20c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201023201308269</p><h3 id="客户-x2F-服务器方式（C-x2F-S方式）"><a href="#客户-x2F-服务器方式（C-x2F-S方式）" class="headerlink" title="客户&#x2F;服务器方式（C&#x2F;S方式）"></a>客户&#x2F;服务器方式（C&#x2F;S方式）</h3><p><img src="https://upload-images.jianshu.io/upload_images/24878825-bbfb139bb8ffd796.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1189/format/webp" alt="img"></p><p>image-20201023201610088</p><h3 id="对等方式（P2P方式）"><a href="#对等方式（P2P方式）" class="headerlink" title="对等方式（P2P方式）"></a>对等方式（P2P方式）</h3><p><img src="https://upload-images.jianshu.io/upload_images/24878825-598b1158f5c33a11.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1184/format/webp" alt="img"></p><p>image-20201023202017683</p><h3 id="总结-17"><a href="#总结-17" class="headerlink" title="总结"></a>总结</h3><p><img src="https://upload-images.jianshu.io/upload_images/24878825-7fce507085bc7053.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1178/format/webp" alt="img"></p><p>image-20201025112851738</p><hr><h2 id="3-动态主机配置协议DHCP"><a href="#3-动态主机配置协议DHCP" class="headerlink" title="3.动态主机配置协议DHCP"></a>3.动态主机配置协议DHCP</h2><h3 id="概念-12"><a href="#概念-12" class="headerlink" title="概念"></a>概念</h3><ul><li>互联网广泛使用的<strong>动态主机配置协议 DHCP</strong> (Dynamic Host Configuration Protocol) 提供了<strong>即插即用连网</strong> (plug-and-play networking) 的机制。</li><li>这种机制允许一台计算机加入新的网络和获取 IP 地址，而不用手工配置。</li></ul><h3 id="DHCP的作用"><a href="#DHCP的作用" class="headerlink" title="DHCP的作用"></a>DHCP的作用</h3><p>在之前，如果要正常访问Web服务器，需要该主机手动配置网络的相关配置信息</p><p><img src="https://upload-images.jianshu.io/upload_images/24878825-5b86de9e3dfe3c59.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201023205719672</p><blockquote><p>如果主机数很多，就工作量大，容易出错</p></blockquote><p>如果我们给网络中添加一台DHCP服务器</p><p><img src="https://upload-images.jianshu.io/upload_images/24878825-4d701885461e9193.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201023210345650</p><h3 id="DHCP的工作过程"><a href="#DHCP的工作过程" class="headerlink" title="DHCP的工作过程"></a>DHCP的工作过程</h3><p><strong>DHCP 使用客户 - 服务器方式</strong></p><ul><li>需要 IP 地址的主机在启动时就向 DHCP 服务器广播发送发现报文  （DHCP DISCOVER），这时该主机就成为 DHCP 客户。</li><li>本地网络上所有主机都能收到此广播报文，但只有 DHCP 服务器才回答此广播报文。</li><li>DHCP 服务器先在其数据库中查找该计算机的配置信息。若找到，则返回找到的信息。若找不到，则从服务器的 IP 地址池 (address pool) 中取一个地址分配给该计算机。DHCP服务器的回答报文叫做提供报文（DHCP OFFER）。</li></ul><p><strong>DHCP 工作方式</strong></p><ul><li>DHCP 使用客户-服务器方式，采用请求&#x2F;应答方式工作。</li><li>DHCP 基于 UDP 工作（DHCP报文在运输层会被封装成为UDP用户数据报），DHCP 服务器运行在 67 号端口， DHCP客户运行在 68 号端口。</li></ul><p><strong>DHCP交互过程</strong></p><p><img src="https://upload-images.jianshu.io/upload_images/24878825-6f9a9715f8b1c74a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201023211525686</p><blockquote><p><strong>DHCP客户端将广播发送DHCP发现报文（DHCP DISCOVER）</strong></p><ul><li><p>事务ID</p></li><li><p>DHCP客户端的MAC地址</p></li></ul><p><strong>封装该报文的IP数据报的源IP地址为0.0.0.0，这是因为主机目前还未分配到IP地址</strong>，因此使用该地址代替</p><p><strong>目的IP地址为广播地址255.255.255.255，之所以广播发送，是因为主机现在并不知道网络中有哪几个DHCP服务器</strong>。它们的IP地址各是什么</p><p><strong>DHCP服务器收到DHCP发现报文后，根据其中封装的DHCP客户端的MAC地址来查找自己的数据库</strong>，如果查到匹配信息，则使用这些配置信息来构建并发送DHCP提供报文，如果没有则采用默认配置信息来构建报文并发送</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/24878825-03ecd6d2838d4274.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201023213058543</p><blockquote><p><strong>DHCP服务端将广播发送DHCP提供报文（DHCP OFFER）</strong></p><ul><li><p>事务ID：DHCP客户端会与之前DHCP发现报文的事务ID做对比，来判断该DHCP提供报文是否是自己的</p></li><li><p>配置信息：</p><ul><li>IP地址：DHCP服务器从自己的IP地址池中挑选待租用给主机的IP地址（使用ARP来确保所选IP地址未被网络中其他主机占用）</li><li>子网掩码</li><li>地址租期</li><li>默认网关</li><li>DNS服务器</li></ul></li></ul><p>源IP地址：发送DHCP提供报文的DHCP服务器的IP</p><p>目的地址：因为目的主机还没分配到IP，所以使用广播地址</p></blockquote><p>在本例中，DHCP客户会收到两个DHCP服务器发来的DHCP提供报文，<strong>DHCP客户从中选择一个，一般选择先到的，并向所选择的DHCP服务器发送DHCP请求报文</strong></p><p><img src="https://upload-images.jianshu.io/upload_images/24878825-009b1e9a88976880.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201023214542329</p><blockquote><p><strong>DHCP客户端将广播发送DHCP请求报文（DHCP REQUEST）</strong></p><ul><li><p>事务ID</p></li><li><p>DHCP客户端的MAC地址</p></li><li><p>接收的租约中的IP地址</p></li><li><p>提供此租约的DHCP服务器端的IP地址</p></li></ul><p>源地址：0.0.0.0，因为此时DHCP客户才从多个DHCP服务器中挑选一个作为自己的DHCP服务器。它首先要征得该服务器的同意，之后才能正式使用向该DHCP服务器租用的IP地址</p><p>目的地址：广播地址，这样可以一次性向所有DHCP服务器发送DHCP请求报文，来告知它们是否请求它们作为自己的DHCP服务器</p></blockquote><p>在本例中，假设DHCP客户端选择DHCP服务器1作为自己的DHCP服务器，DHCP服务器1接受该请求，于是DHCP服务器1给DHCP客户端发送DHCP确认报文</p><p><img src="https://upload-images.jianshu.io/upload_images/24878825-35c9002bba766476.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201023215341522</p><blockquote><p>源地址：DHCP服务器1的IP地址</p><p>目的地址：广播地址</p><p><strong>DHCP客户收到该报文后就可以使用租用的IP地址</strong></p><p><strong>在使用前还会进行ARP检测</strong></p><p><img src="https://upload-images.jianshu.io/upload_images/24878825-044fb99d76bd279c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/673/format/webp" alt="img"></p><p>image-20201023215652859</p></blockquote><p>剩下流程图示</p><p><img src="https://upload-images.jianshu.io/upload_images/24878825-a01eacfba40e9098.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201025113140803</p><h3 id="DHCP中继代理"><a href="#DHCP中继代理" class="headerlink" title="DHCP中继代理"></a>DHCP中继代理</h3><p>下图的网络拓扑中的各主机是否可以通过DHCP来自动获取到网络配置？</p><p><img src="https://upload-images.jianshu.io/upload_images/24878825-33c64efac75f0ad2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201023221111923</p><blockquote><p>使用DHCP中继代理是因为我们不用给每一个网络上都设置一个DHCP服务器，这样会使DHCP服务器的数量太多</p></blockquote><h3 id="总结-18"><a href="#总结-18" class="headerlink" title="总结"></a>总结</h3><p><img src="https://upload-images.jianshu.io/upload_images/24878825-37d8836f5ed85036.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201023221251022</p><hr><h2 id="4-域名系统DNS"><a href="#4-域名系统DNS" class="headerlink" title="4.域名系统DNS"></a>4.域名系统DNS</h2><h3 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h3><p>域名相比IP地址更容易记忆</p><p><img src="https://upload-images.jianshu.io/upload_images/24878825-418d77c262da3948.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201025113245213</p><p>因特网是否可以只使用一台DNS服务器？</p><p>不行</p><p><img src="https://upload-images.jianshu.io/upload_images/24878825-423a48c721a4a5d0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201023235123151</p><p><img src="https://upload-images.jianshu.io/upload_images/24878825-8dc45fb61122f775.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201023235231869</p><p><img src="https://upload-images.jianshu.io/upload_images/24878825-31a3076fe8055379.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201023235457857</p><blockquote><p>名称相同的域名其等级未必相同</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/24878825-4655232a57435f63.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201023235617575</p><p><img src="https://upload-images.jianshu.io/upload_images/24878825-c2350ce866abf74e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201025113436842</p><h3 id="域名解析过程"><a href="#域名解析过程" class="headerlink" title="域名解析过程"></a>域名解析过程</h3><p><img src="https://upload-images.jianshu.io/upload_images/24878825-aae45d426ec7fa49.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201024000255580</p><p><img src="https://upload-images.jianshu.io/upload_images/24878825-d2652511b6f2280d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201024000335147</p><p><img src="https://upload-images.jianshu.io/upload_images/24878825-0b01d9ca32d995f3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201024000408396</p><p><img src="https://upload-images.jianshu.io/upload_images/24878825-2df66d338296916f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201024002135210</p><h3 id="总结-19"><a href="#总结-19" class="headerlink" title="总结"></a>总结</h3><p><img src="https://upload-images.jianshu.io/upload_images/24878825-93d3fbaa54195112.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201024002224354</p><hr><h2 id="5-文件传送协议FTP"><a href="#5-文件传送协议FTP" class="headerlink" title="5.文件传送协议FTP"></a>5.文件传送协议FTP</h2><h3 id="概念-13"><a href="#概念-13" class="headerlink" title="概念"></a>概念</h3><p><img src="https://upload-images.jianshu.io/upload_images/24878825-df91fe396712c633.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201024132745558</p><h3 id="文件传送协议FTP的应用"><a href="#文件传送协议FTP的应用" class="headerlink" title="文件传送协议FTP的应用"></a>文件传送协议FTP的应用</h3><p>FTP采用C&#x2F;S方式（客户&#x2F;服务器方式）</p><p>FTP客户计算机可将各种类型的文件上传到FTP服务器计算机</p><p><img src="https://upload-images.jianshu.io/upload_images/24878825-523d37958c02b33c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1119/format/webp" alt="img"></p><p>image-20201024133155327</p><p>FTP客户计算机也可以从FTP服务器计算机下载文件</p><p><img src="https://upload-images.jianshu.io/upload_images/24878825-510f63b63db4ba4f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1073/format/webp" alt="img"></p><p>image-20201024133247537</p><p><img src="https://upload-images.jianshu.io/upload_images/24878825-bd1aca704fbfff6d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/421/format/webp" alt="img"></p><p>image-20201024133400777</p><p><img src="https://upload-images.jianshu.io/upload_images/24878825-fc1bb372ad88d1f3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/677/format/webp" alt="img"></p><p>image-20201024133601943</p><h3 id="FTP基本工作原理"><a href="#FTP基本工作原理" class="headerlink" title="FTP基本工作原理"></a>FTP基本工作原理</h3><p>FTP服务器监听熟知端口（端口号为 21），使客户进程能够连接上。</p><p>FTP客户随机选择一个临时端口号与其建立TCP连接，这条TCP连接用于FTP客户与服务器之间传送FTP的相关控制命令（这条连接是FTP客户与服务器之间的命令通道）</p><p><img src="https://upload-images.jianshu.io/upload_images/24878825-fe8243f273df1c3b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1111/format/webp" alt="img"></p><p>image-20201024134319922</p><p>下图为建立数据通道的TCP连接</p><p>FTP服务器使用自己的熟知端口号20与其建立TCP连接，这条TCP连接用于FTP客户与服务器之间传送文件</p><p><img src="https://upload-images.jianshu.io/upload_images/24878825-37858686cb4a05aa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201024134624114</p><blockquote><p>上面例子是主动模式：建立数据通道时，FTP服务器主动连接FTP客户</p></blockquote><p>下图实例为被动模式</p><p><img src="https://upload-images.jianshu.io/upload_images/24878825-7125f10efdf012e1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1023/format/webp" alt="img"></p><p>image-20201024135018620</p><p>两种模式对比</p><p><img src="https://upload-images.jianshu.io/upload_images/24878825-885981a43745ae55.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201024135050743</p><blockquote><p>注意两种模式都是</p><p>控制连接在整个会话期间保持打开状态</p><p>数据连接传输完毕后就关闭</p></blockquote><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-04-08_16-14-49.png" alt="Snipaste_2022-04-08_16-14-49"></p><h3 id="总结-20"><a href="#总结-20" class="headerlink" title="总结"></a>总结</h3><p><img src="https://upload-images.jianshu.io/upload_images/24878825-2b566956ff071b24.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201025113647139</p><hr><h2 id="6-电子邮件"><a href="#6-电子邮件" class="headerlink" title="6.电子邮件"></a>6.电子邮件</h2><h3 id="概念-14"><a href="#概念-14" class="headerlink" title="概念"></a>概念</h3><p><img src="https://upload-images.jianshu.io/upload_images/24878825-905f080fde0331a5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201024151757221</p><h3 id="邮件发送和接收过程"><a href="#邮件发送和接收过程" class="headerlink" title="邮件发送和接收过程"></a>邮件发送和接收过程</h3><p><img src="https://upload-images.jianshu.io/upload_images/24878825-a55537e03d980133.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201024152052056</p><h3 id="简单邮件传送协议SMTP（Simple-Mail-Transfer-Protocol）的基本工作原理"><a href="#简单邮件传送协议SMTP（Simple-Mail-Transfer-Protocol）的基本工作原理" class="headerlink" title="简单邮件传送协议SMTP（Simple Mail Transfer Protocol）的基本工作原理"></a>简单邮件传送协议SMTP（Simple Mail Transfer Protocol）的基本工作原理</h3><p><img src="https://upload-images.jianshu.io/upload_images/24878825-03f4877d2621c261.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201024152628966</p><h3 id="电子邮件的信息格式"><a href="#电子邮件的信息格式" class="headerlink" title="电子邮件的信息格式"></a>电子邮件的信息格式</h3><p><img src="https://upload-images.jianshu.io/upload_images/24878825-fb16b5ace5466b25.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp" alt="img"></p><p>image-20201024153425016</p><h3 id="邮件读取"><a href="#邮件读取" class="headerlink" title="邮件读取"></a>邮件读取</h3><p><img src="https://upload-images.jianshu.io/upload_images/24878825-c825d1ad122bd41c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201024153736033</p><h3 id="基于万维网的电子邮件"><a href="#基于万维网的电子邮件" class="headerlink" title="基于万维网的电子邮件"></a>基于万维网的电子邮件</h3><p><img src="https://upload-images.jianshu.io/upload_images/24878825-46b15b10a17604fa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201024154039565</p><h3 id="总结-21"><a href="#总结-21" class="headerlink" title="总结"></a>总结</h3><p><img src="https://upload-images.jianshu.io/upload_images/24878825-b400e3f6c0a87238.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201025113819151</p><hr><h2 id="7-万维网WWW"><a href="#7-万维网WWW" class="headerlink" title="7.万维网WWW"></a>7.万维网WWW</h2><h3 id="概念-15"><a href="#概念-15" class="headerlink" title="概念"></a>概念</h3><p><strong>概述</strong></p><ul><li><strong>万维网</strong> WWW (World Wide Web) 并非某种特殊的计算机网络。</li><li>万维网是一个大规模的、联机式的<strong>信息储藏所</strong>。</li><li>万维网用链接的方法能非常方便地从互联网上的一个站点访问另一个站点，从而主动地按需获取丰富的信息。</li><li>这种访问方式称为“<strong>链接</strong>”。</li></ul><p><strong>万维网的工作方式</strong></p><ul><li>万维网以<strong>客户 - 服务器</strong>方式工作。</li><li><strong>浏览器</strong>就是在用户计算机上的万维网<strong>客户程序</strong>。万维网文档所驻留的计算机则运行<strong>服务器程序</strong>，因此这个计算机也称为<strong>万维网服务器</strong>。</li><li>客户程序向服务器程序发出请求，服务器程序向客户程序送回客户所要的<strong>万维网文档</strong>。</li><li>在一个客户程序主窗口上显示出的万维网文档称为<strong>页面</strong> (page)。</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/24878825-68dbe2651f5e5a80.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201024170819303</p><p><img src="https://upload-images.jianshu.io/upload_images/24878825-8646898df7461ca3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/907/format/webp" alt="img"></p><p>image-20201024171432743</p><p><strong>万维网应用举例</strong></p><p>访问网页</p><p><img src="https://upload-images.jianshu.io/upload_images/24878825-cd07ed4a1a595490.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201024170923530</p><p><strong>怎样标志分布在整个互联网上的万维网文档？</strong></p><p><img src="https://upload-images.jianshu.io/upload_images/24878825-05ae15f55de2ba0a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201024171058583</p><p><strong>万维网的文档</strong></p><p><img src="https://upload-images.jianshu.io/upload_images/24878825-5240e0cba8fd0a62.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201024171724030</p><h3 id="超文本传输协议HTTP（Hyper-Transfer-Protocol）"><a href="#超文本传输协议HTTP（Hyper-Transfer-Protocol）" class="headerlink" title="超文本传输协议HTTP（Hyper Transfer Protocol）"></a>超文本传输协议HTTP（Hyper Transfer Protocol）</h3><h4 id="概念和传输过程"><a href="#概念和传输过程" class="headerlink" title="概念和传输过程"></a>概念和传输过程</h4><ul><li>在万维网客户程序与万维网服务器程序之间进行交互所使用的协议，是<strong>超文本传送协议</strong> HTTP (HyperText Transfer Protocol)。</li><li>HTTP 是一个应用层协议，它使用 TCP 连接进行可靠的传送。</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/24878825-41e8ed466986db36.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201024222457800</p><ul><li>每个万维网网点都有一个服务器进程，它不断地<strong>监听 TCP 的端口 80</strong>，以便发现是否有浏览器向它发出连接建立请求。</li><li>一旦监听到连接建立请求并建立了 TCP 连接之后，浏览器就向万维网服务器发出浏览某个页面的请求，服务器接着就返回所请求的页面作为响应。</li><li>最后，TCP 连接就被释放了。</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/24878825-614d1960b2b805d9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201024222825888</p><h4 id="HTTP报文格式"><a href="#HTTP报文格式" class="headerlink" title="HTTP报文格式"></a>HTTP报文格式</h4><p><strong>HTTP请求报文格式</strong></p><p><img src="https://upload-images.jianshu.io/upload_images/24878825-22dfb8a34acf459c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201024224828528</p><p><strong>HTTP响应报文格式</strong></p><p><img src="https://upload-images.jianshu.io/upload_images/24878825-0409ca153701fbb4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201024224920638</p><h4 id="使用Cookie在服务器上记录用户信息"><a href="#使用Cookie在服务器上记录用户信息" class="headerlink" title="使用Cookie在服务器上记录用户信息"></a>使用Cookie在服务器上记录用户信息</h4><p><img src="https://upload-images.jianshu.io/upload_images/24878825-969dc15b42399e98.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201024224945200</p><h4 id="万维网缓存与代理服务器"><a href="#万维网缓存与代理服务器" class="headerlink" title="万维网缓存与代理服务器"></a>万维网缓存与代理服务器</h4><p><img src="https://upload-images.jianshu.io/upload_images/24878825-e7f4b696946ffafa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201024224632514</p><p>如果该请求有缓存</p><p><img src="https://upload-images.jianshu.io/upload_images/24878825-b0ccf228d3132c12.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201024224720124</p><p>如果该请求没有缓存</p><p><img src="https://upload-images.jianshu.io/upload_images/24878825-049121882eafde97.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201024225013288</p><blockquote><p>若WEb缓存的命中率比较高</p><p>则会大大减小了该链路上的通信量，因而减少了访问因特网的时延</p></blockquote><p>假设原始服务器的文档被更改，这样代理服务器的文档就不是最新的</p><p>所以原始服务器通常会为每个响应的对象设定一个<strong>修改时间字段</strong>和一个<strong>有效日期字段</strong></p><p>若未过期</p><p><img src="https://upload-images.jianshu.io/upload_images/24878825-a5de1829c0777328.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201024225504869</p><p>若过期并且代理服务器的文档和原始服务器的<strong>文档一致</strong>，原始服务器则给代理服务器发送不包含实体主体的响应</p><p><img src="https://upload-images.jianshu.io/upload_images/24878825-abf0fcf785757c26.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201024225846863</p><p>若过期并且代理服务器的文档和原始服务器的<strong>文档不一致</strong>，原始服务器则给代理服务器发送封装有该文档的响应报文</p><p><img src="https://upload-images.jianshu.io/upload_images/24878825-14ec3f45c4af32f9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201024230242550</p><p><img src="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Snipaste_2022-04-08_17-22-35.png" alt="Snipaste_2022-04-08_17-22-35"></p><h3 id="总结-22"><a href="#总结-22" class="headerlink" title="总结"></a>总结</h3><p><img src="https://upload-images.jianshu.io/upload_images/24878825-dab94fae0e969502.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image-20201025114144313</p><p>作者：BloothOfYouth<br>链接：<a href="https://www.jianshu.com/p/3b490c10d129">https://www.jianshu.com/p/3b490c10d129</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-计算机网络概述&quot;&gt;&lt;a href=&quot;#1-计算机网络概述&quot; class=&quot;headerlink&quot; title=&quot;1.计算机网络概述&quot;&gt;&lt;/a&gt;1.计算机网络概述&lt;/h1&gt;&lt;h2 id=&quot;1-计算机网络在信息时代的作用&quot;&gt;&lt;a href=&quot;#1-计算机网络在信息</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Linux静态网络配置</title>
    <link href="http://example.com/2022/09/07/Linux%E9%9D%99%E6%80%81%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/"/>
    <id>http://example.com/2022/09/07/Linux%E9%9D%99%E6%80%81%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/</id>
    <published>2022-09-07T13:22:52.000Z</published>
    <updated>2022-09-07T14:06:12.014Z</updated>
    
    <content type="html"><![CDATA[<p>发士大夫十分</p><p>基本环境：</p><p>电脑：Windows10</p><p>虚拟机：VMware</p><p>Linux：CentOS 7</p><p>基本操作：</p><ul><li>步骤一：查看VMware 虚拟网络编辑器</li></ul><p><img src="/2022/09/07/Linux%E9%9D%99%E6%80%81%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/image-20220907212906951.png" alt="image-20220907212906951"></p><ul><li>步骤二：取消DHCP勾选</li></ul><img src="/2022/09/07/Linux%E9%9D%99%E6%80%81%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/image-20220907213330974.png" alt="image-20220907213330974" style="zoom:67%;"><ul><li>步骤三：查看网络信息，待会儿用</li></ul><img src="/2022/09/07/Linux%E9%9D%99%E6%80%81%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/image-20220907213433960.png" alt="image-20220907213433960" style="zoom: 67%;"><ul><li><p>步骤四：修改电脑上的VMnet8网卡的ip</p><p>VMnet8是windows为虚拟机虚拟出来的网卡</p></li></ul><img src="/2022/09/07/Linux%E9%9D%99%E6%80%81%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/image-20220907213812894.png" alt="image-20220907213812894" style="zoom:67%;"><img src="/2022/09/07/Linux%E9%9D%99%E6%80%81%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/image-20220907213853648.png" alt="image-20220907213853648" style="zoom: 67%;"><img src="/2022/09/07/Linux%E9%9D%99%E6%80%81%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/image-20220907213921391.png" alt="image-20220907213921391" style="zoom:67%;"><img src="/2022/09/07/Linux%E9%9D%99%E6%80%81%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/image-20220907214005008.png" alt="image-20220907214005008" style="zoom:67%;"><blockquote><p>IP地址：步骤三查看的网络信息为192.168.227.0，这里使用192.168.227.1</p><p>子网掩码：同步骤三的子网掩码</p><p>网关：同步骤三的网关</p><p>首选DNS：可以和网关一样，备用的随便写一个</p></blockquote><ul><li>步骤五：虚拟设置里选择NAT模式，就可以启动虚拟机了</li></ul><p>![image-20220907214737319]Linux静态网络配置&#x2F;&#x2F;image-20220907214737319.png)</p><ul><li><p>步骤六：修改网卡配置文件</p><ul><li><p>在root用户下</p></li><li><p>打开ifcfg-ens33文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/sysconfig/network-scripts/ifcfg-ens33</span><br></pre></td></tr></table></figure></li></ul><p>![image-20220907215447567]Linux静态网络配置&#x2F;&#x2F;image-20220907215447567.png)</p></li></ul><blockquote><p>ip地址选择192.168.227.3末位为3及以上的，因为末位为0、1和2都被占用了</p></blockquote><p>:wq 或 :wq! 保存并退出</p><ul><li>步骤七：重启网络</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart network </span><br><span class="line">或 </span><br><span class="line">service network restart</span><br></pre></td></tr></table></figure><p> 查看网卡信息，看到你的 ip地址说明配置完成了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip addr</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;发士大夫十分&lt;/p&gt;
&lt;p&gt;基本环境：&lt;/p&gt;
&lt;p&gt;电脑：Windows10&lt;/p&gt;
&lt;p&gt;虚拟机：VMware&lt;/p&gt;
&lt;p&gt;Linux：CentOS 7&lt;/p&gt;
&lt;p&gt;基本操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;步骤一：查看VMware 虚拟网络编辑器&lt;/li&gt;
&lt;/ul&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Linux克隆后无法重启网络</title>
    <link href="http://example.com/2022/09/07/Linux%E5%85%8B%E9%9A%86%E5%90%8E%E6%97%A0%E6%B3%95%E9%87%8D%E5%90%AF%E7%BD%91%E7%BB%9C/"/>
    <id>http://example.com/2022/09/07/Linux%E5%85%8B%E9%9A%86%E5%90%8E%E6%97%A0%E6%B3%95%E9%87%8D%E5%90%AF%E7%BD%91%E7%BB%9C/</id>
    <published>2022-09-07T13:04:31.000Z</published>
    <updated>2022-09-07T13:21:20.022Z</updated>
    
    <content type="html"><![CDATA[<p>转载文章：<a href="https://blog.csdn.net/qq_37010445/article/details/115727074">https://blog.csdn.net/qq_37010445/article/details/115727074</a></p><p>由于最近在学习Hadoop的需要，在虚拟机VM上，搭建Linux以CentOS7例，在原始机上配置了静态网络，之后克隆两台一样的虚拟机。</p><p>打开原始机，发现ip没有了，使用service network restart一直显示错误，在两台克隆机上也是同样问题</p><p>查找了一下午，终于找到了篇对症下药的文章：</p><ul><li>这是NetworkManager本身的问题启动网卡方面应该是出现了漏洞导致。</li><li>在CentOS系统上，目前有NetworkManager和network两种网络管理工具。</li><li>配置了静态网络使用network就行了。</li></ul><p>解决方案：</p><ul><li>第一步：暂停NetworkManager</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop NetworkManager</span><br></pre></td></tr></table></figure><ul><li>第二步：永久暂停NetworkManager</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl disable NetworkManager</span><br></pre></td></tr></table></figure><p>之后就可以重启网络了</p><p>克隆机需要修改网卡配置文件ifcfg-ens33中的IP地址，在重启网络</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;转载文章：&lt;a href=&quot;https://blog.csdn.net/qq_37010445/article/details/115727074&quot;&gt;https://blog.csdn.net/qq_37010445/article/details/115727074&lt;/a</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>操作系统笔记</title>
    <link href="http://example.com/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/"/>
    <id>http://example.com/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/</id>
    <published>2022-08-31T16:00:00.000Z</published>
    <updated>2022-10-05T10:40:19.511Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、操作系统概述"><a href="#一、操作系统概述" class="headerlink" title="一、操作系统概述"></a>一、操作系统概述</h1><h2 id="1、课程导读"><a href="#1、课程导读" class="headerlink" title="1、课程导读"></a>1、课程导读</h2><h4 id="课程地址"><a href="#课程地址" class="headerlink" title="课程地址"></a>课程地址</h4><p><a href="https://www.xuetangx.com/learn/THU08091000267/THU08091000267/10322317/video/17399395?channel=i.area.recent_search">操作系统 - 清华大学 - 学堂在线 (xuetangx.com)</a></p><p><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220517170805637.png" alt="image-20220517170805637"></p><h4 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h4><p>计算机结构原理（lntel80386+）<br>C与汇编程序设计<br>数据结构</p><h4 id="操作系统实验"><a href="#操作系统实验" class="headerlink" title="操作系统实验"></a>操作系统实验</h4><p>实验0：实验环境准备<br>实验1：系统启动及中断<br>实验2：物理内存管理<br>实验3：虚拟内存管理<br>实验4：内核线程管理</p><p>实验5：用户进程管理<br>实验6：CPU调度<br>实验7：同步与互序<br>实验8：文件系统</p><h2 id="2、什么是操作系统"><a href="#2、什么是操作系统" class="headerlink" title="2、什么是操作系统"></a>2、什么是操作系统</h2><h4 id="操作系统定义"><a href="#操作系统定义" class="headerlink" title="操作系统定义"></a>操作系统定义</h4><p>没有公认的精确定义</p><p>操作系统是一个控制程序</p><ul><li>一个系统软件</li><li>控制程序执行过程，防止错误和计算机的不当使用</li><li>执行用户程序，给用户程序提供各种服务</li><li>方便用户使用计算机系统</li></ul><p>操作系统是一个资源管理器</p><ul><li>应用程序与硬件之间的中间层</li><li>管理各种计算机软硬件资源</li><li>提供访问计算机软硬件资源的高效手段</li><li>解决资源访问冲突，确保资源公平使用</li></ul><h4 id="操作系统的地位"><a href="#操作系统的地位" class="headerlink" title="操作系统的地位"></a>操作系统的地位</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220517174205883.png" alt="image-20220517174205883" style="zoom:50%;"><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220517174245022.png" alt="image-20220517174245022" style="zoom:50%;"><h4 id="操作系统软件的分类"><a href="#操作系统软件的分类" class="headerlink" title="操作系统软件的分类"></a>操作系统软件的分类</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220517174342359.png" alt="image-20220517174342359" style="zoom:50%;"><h4 id="操作系统软件的组成"><a href="#操作系统软件的组成" class="headerlink" title="操作系统软件的组成"></a>操作系统软件的组成</h4><ul><li><p>&#x3D;&#x3D;Shell&#x3D;&#x3D;–命令行接口</p><ul><li>通过键盘操纵。</li><li>方便用户进行命令输入</li></ul></li><li><p>&#x3D;&#x3D;GUI&#x3D;&#x3D;–图形用户接口</p></li><li><p>WIMP<br>（视窗（Window）、图标（Icon）、选单（Menu）、指标（Point)</p></li><li><p>直接操作和所见即所得</p></li><li><p>&#x3D;&#x3D;Kernel&#x3D;&#x3D;–操作系统的内部</p><ul><li>执行各种资源管理等功能</li></ul></li></ul><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220517174524837.png" alt="image-20220517174524837" style="zoom:50%;"><h4 id="ucore教学操作系统内核"><a href="#ucore教学操作系统内核" class="headerlink" title="ucore教学操作系统内核"></a>ucore教学操作系统内核</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220517174733933.png" alt="image-20220517174733933" style="zoom:50%;"><h4 id="操作系统内核特征"><a href="#操作系统内核特征" class="headerlink" title="操作系统内核特征"></a>操作系统内核特征</h4><ul><li><p>并发</p><ul><li>计算机系统中同时存在多个运行的程序，需要OS管理和调度</li></ul></li><li><p>共享</p><ul><li>“同时”访问</li><li>互斥共享</li></ul></li><li><p>虚拟</p><ul><li>利用多道程序设计技术，让每个用户</li><li>都觉得有一个计算机专门为他服务</li></ul></li><li><p>异步</p><ul><li>程序的执行不是一贯到底，而是走走停停，向前推进的速度不可预知</li><li>只要运行环境相同，OS需要保证程序运行的结果也要相同</li></ul></li></ul><h2 id="3、操作系统实例"><a href="#3、操作系统实例" class="headerlink" title="3、操作系统实例"></a>3、操作系统实例</h2><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220517180634316.png" alt="image-20220517180634316" style="zoom: 33%;"><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220517180603555.png" alt="image-20220517180603555" style="zoom:33%;"><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220517180526360.png" alt="image-20220517180526360" style="zoom: 50%;"><h2 id="4、操作系统的演变"><a href="#4、操作系统的演变" class="headerlink" title="4、操作系统的演变"></a>4、操作系统的演变</h2><h4 id="单用户系统"><a href="#单用户系统" class="headerlink" title="单用户系统"></a>单用户系统</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220517181011338.png" alt="image-20220517181011338" style="zoom:50%;"><p>目的是仅为用户提供运算，但是通过用户自己输入，输入输出效率很差</p><h4 id="批处理系统"><a href="#批处理系统" class="headerlink" title="批处理系统"></a>批处理系统</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220517181231026.png" alt="image-20220517181231026" style="zoom:50%;"><p>提前输入很多任务，CPU一个接一个执行</p><h4 id="多道程序"><a href="#多道程序" class="headerlink" title="多道程序"></a>多道程序</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220517181529161.png" alt="image-20220517181529161" style="zoom:50%;"><p>为了提高CPU利用率，例如程序A占用CPU，之后需要一段IO，这时则调度程序B进行占用CPU</p><h4 id="分时系统"><a href="#分时系统" class="headerlink" title="分时系统"></a>分时系统</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220517201307650.png" alt="image-20220517201307650" style="zoom:50%;"><p>多道程序系统基础上，将CPU使用时间分为一个个时间片，即程序执行过程中加了个时钟中断</p><p>好处：</p><ul><li>改善了程序执行的公平性</li><li>对短作业的好处很大，即时响应用户</li></ul><p>坏处：每次中断加上了调度程序，开销也会增大</p><h4 id="个人电脑操作系统"><a href="#个人电脑操作系统" class="headerlink" title="个人电脑操作系统"></a>个人电脑操作系统</h4><p>个人电脑系统</p><ul><li>单用户</li><li>利用率已不再是关注点</li><li>重点是用户界面和多媒体功能</li><li>很多老的服务和功能不存在</li></ul><p>演变</p><ul><li>最初：操作系统作为一个简单的服务提供者（简单库）</li><li>现在：支持协调和沟通的多应用系统</li><li>越来越多的安全问题（如，电子商务、医疗记录）</li></ul><h4 id="分布式操作系统"><a href="#分布式操作系统" class="headerlink" title="分布式操作系统"></a>分布式操作系统</h4><ul><li>网络支持成为一个重要的功能</li><li>通常支持分布式服务<ul><li>跨多系统的数据共享和协调</li></ul></li><li>可能使用多个处理器<ul><li>松、紧耦合系统</li></ul></li><li>高可用性与可靠性的要求</li></ul><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220517202037841.png" alt="image-20220517202037841" style="zoom:50%;"><h4 id="操作系统演变中的计算机系统"><a href="#操作系统演变中的计算机系统" class="headerlink" title="操作系统演变中的计算机系统"></a>操作系统演变中的计算机系统</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220517202335641.png" alt="image-20220517202335641" style="zoom:50%;"><h2 id="5、操作系统的结构"><a href="#5、操作系统的结构" class="headerlink" title="5、操作系统的结构"></a>5、操作系统的结构</h2><h4 id="简单结构"><a href="#简单结构" class="headerlink" title="简单结构"></a>简单结构</h4><p>MS-DOS-在最小的空间，设计用于提供大部分功能（1981~1994）</p><ul><li>没有拆分为模块</li><li>虽然MS-DOS在接口和功能水平没有很好地分离，主要用汇编编写</li></ul><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220906082720949.png" alt="image-20220906082720949" style="zoom: 67%;"><blockquote><p>此时操作系统移植性不强，只是针对特定硬件编写的操作系统</p></blockquote><h4 id="分层结构"><a href="#分层结构" class="headerlink" title="分层结构"></a>分层结构</h4><p>操作系统分为很多层（levels）</p><ul><li>每层建立在低层之上</li><li>最底层（layer0），是硬件</li><li>最高层（layerN）是用户界面</li></ul><p>使用模块化，每一层仅使用更低一层的功能（操作）和服务。</p><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220906082957746.png" alt="image-20220906082957746" style="zoom: 80%;"><blockquote><p>分层过后移植性得到提升</p></blockquote><h4 id="微内核结构"><a href="#微内核结构" class="headerlink" title="微内核结构"></a>微内核结构</h4><ul><li><p>尽可能把内核功能移到用户空间</p></li><li><p>用户模块间的通信使用消息传递</p></li><li><p>好处：灵活&#x2F;安全..</p></li><li><p>缺点：性能</p></li></ul><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220906083148675.png" alt="image-20220906083148675" style="zoom:50%;"><blockquote><p>随着分层越来越多，出现微内核结构，将其分为内核态和用户态</p><p>好处是：安全性和可扩展性提高</p><p>缺点是：性能下降了</p></blockquote><h4 id="外核结构"><a href="#外核结构" class="headerlink" title="外核结构"></a>外核结构</h4><ul><li>让内核分配机器的物理资源给多个应用程序，并让每个程序决定如何处理这些资源</li><li>程序能链接到操作系统库（libos）实现了操作系统抽象保护与控制分离</li></ul><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220906083256065.png" alt="image-20220906083256065" style="zoom:67%;"><blockquote><p>对内核结构的进一步改善，在内核里放更少的东西，起到资源的保护和隔离的作用，把资源的管理的任务交给应用态的代码去完成，而原来的操作系统的功能有用户的态的函数库提供</p><p>安全绑定：规定那些资源归那些系统使用，系统负责管理这些资源</p><p>这种情况下，一个系统上能够运行多个操作系统服务，这就是早期虚拟机的原型</p></blockquote><h4 id="VMM（虚拟机管理）"><a href="#VMM（虚拟机管理）" class="headerlink" title="VMM（虚拟机管理）"></a>VMM（虚拟机管理）</h4><p>虚拟机管理器将单独的机器接口转换成很多的虚拟机，每个虚拟机都是一个原始计算机系统的有效副本，并能完成所有的处理器指令。</p><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220906083603592.png" alt="image-20220906083603592" style="zoom:50%;"><blockquote><p>虚拟机管理器直接接触硬件，将硬件虚拟为若干个虚拟硬件共上层操作系统使用</p><p>虚拟机管理器负责资源的隔离，操作系统负责资源的管理</p></blockquote><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220517204720298.png" alt="image-20220517204720298" style="zoom:50%;"><h2 id="6、实验课程设计"><a href="#6、实验课程设计" class="headerlink" title="6、实验课程设计"></a>6、实验课程设计</h2><h4 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h4><p>方便且利用理解细节</p><ul><li>大量采用开源软件</li><li>实验环境：Windows&#x2F;Linux</li><li>源码阅读工具：understand</li><li>源码文档自动生成工具：Doxygen</li><li>编译环境：gcc，make，Binutils</li><li>真实&#x2F;虚拟运行环境：X86机器或QEMU</li><li>调试工具：改进的QEMU+（GDB O.R.IDE）</li><li>IDE工具：Eclipse-CDT</li></ul><h4 id="实验内容及涉及代码量"><a href="#实验内容及涉及代码量" class="headerlink" title="实验内容及涉及代码量"></a>实验内容及涉及代码量</h4><p>1 0S启动、中断与设备管理  0200<del>1800行<br>2 物理内存管理 1800</del>2500行<br>3 虚拟内存管理  2500<del>3200行<br>4 内核线程管理  3200-3600行<br>5 用户进程管理 3600</del>4300行<br>6 处理器调度  4300<del>5100行<br>7 同步互序  5100</del>6400行<br>8 文件系统  6400~9999行</p><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220517210630490.png" alt="image-20220517210630490" style="zoom:50%;"><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220517210827324.png" alt="image-20220517210827324" style="zoom: 67%;"><h4 id="使用工具简单介绍"><a href="#使用工具简单介绍" class="headerlink" title="使用工具简单介绍"></a>使用工具简单介绍</h4><p>安装实验环境</p><ul><li>在虚拟机上使用安装好的ubuntu实验环境</li></ul><p>使用实验工具</p><ul><li>shell命令：Is、cd、rm、pwd…</li><li>系统维护工具：apt、git</li><li>源码阅读与编辑工具：eclipse-CDT、understand、gedit、vim</li><li>源码比较工具：diff、meld</li><li>开发编译调试工具：gcc、gdb、make</li><li>硬件模拟器：qemu</li></ul><p>系统维护工具：apt、git</p><ul><li>apt：安装管理各种软件</li><li>git：开发版本维护软件</li></ul><p>源码编辑工具：Eclipse-CDT、understand、gedit、vim</p><ul><li><p>Eclipse-CDT：基于Eclipse的C&#x2F;C++集成开发环境</p><p>跨平台、丰富的分析理解代码的功能</p><p>可与qemu结合，联机源码级Debug ucore OS</p></li><li><p>Understand：跨平台、丰富的分析理解代码的功能</p><p>Windows上有类似的sourceinsigh饮件</p></li><li><p>gedit：Linux中的常用文本编辑</p><p>Windows上有类似的notepad</p></li><li><p>vim:Linux&#x2F;unix中的传统编辑器</p><p>类似有emacs等</p><p>可通过exuberant-ctags、cscope等实现代码定位</p></li></ul><p>源码比较工具：diff、meld</p><ul><li>比较不同目录或不同文件的区别</li><li>diff是命令行工具，使用简单</li><li>meld是图形界面的工具，功能相对直观和方便</li></ul><p>开发编译调试工具：gcc、gdb、make</p><ul><li>gcc：C语言编译器</li><li>gdb：执行程序调试器</li><li>make：软件工程管理工具</li><li>make命令执行时，需要一个makefile文件，以告诉</li><li>make命令如何去编译和链接程序</li></ul><p>硬件模拟器：qemu</p><ul><li>qemu可模拟多种CPU硬件环境，本实验中，用于</li><li>模拟一台intelx86-32的计算机系统</li></ul><h2 id="7、X86-32硬件架构了解"><a href="#7、X86-32硬件架构了解" class="headerlink" title="7、X86-32硬件架构了解"></a>7、X86-32硬件架构了解</h2><h4 id="四种运行模式"><a href="#四种运行模式" class="headerlink" title="四种运行模式"></a>四种运行模式</h4><p>80386有四种运行模式:</p><ul><li>实模式、保护模式、SMM模式和虚拟8086模式</li></ul><p>实模式：</p><ul><li>80386加电启动后处于实模式运行状态，在这种状态下软件可访问的物理内存空间不能超过1MB，且无法发挥Intel80386以上级别的32位CPU的4GB内存管理能力。</li></ul><p>保护模式：</p><ul><li>支持内存分页机制，提供了对虚拟内存的良好支持。保护模式下80386支持多任务，还支持优先级机制，不同的程序可以运行在不同的优先级上。<br>优先级一共分0~34个级别，操作系统运行在最高的优先级0上，应用程序则运行在比较低的级别上；配合良好的检查机制后，既可以在任务间实现数据的安全共享也可以很好地隔离各个任务。</li></ul><h4 id="内存架构"><a href="#内存架构" class="headerlink" title="内存架构"></a>内存架构</h4><ul><li>地址是访问内存空间的索引</li><li>80386是32位的处理器，即可以寻址的物理内存地址空间为232&#x3D;4G字节</li><li>物理内存地址空间是处理器提交到总线上用于访问计算机系统中的内存和外设的最终地址。一个计算机系统中只有一个物理地址空间</li><li>线性地址空间是在操作系统的虚存管理之下每个运行的应用程序能访问的地址空间。每个运行的应用程序都认为自己独享整个计算机系统的地址空间，这样可让多个运行的应用程序之间相互隔离</li><li><strong>逻辑地址空间是应用程序直接使用的地址空间。</strong><br>段机制启动、页机制未启动：逻辑地址-&gt;&#x3D;&#x3D;段机制处理&#x3D;&#x3D;-&gt;线性地址&#x3D;物理地址<br>段机制和页机制都启动：逻辑地址-&gt;&#x3D;&#x3D;段机制处理&#x3D;&#x3D;-&gt;线性地址-&gt;&#x3D;&#x3D;页机制处理&#x3D;&#x3D;-&gt;物理地址</li></ul><h4 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h4><p>80386的寄存器可以分为8组：</p><ul><li>通用寄存器</li><li>段寄存器</li><li>指令指针寄存器</li><li>标志寄存器</li><li>控制寄存器</li><li>系统地址寄存器，调试寄存器，测试寄存器</li></ul><p>通用寄存器</p><ul><li>EAX：累加器</li><li>EBX：基址寄存器</li><li>ECX：计数器</li><li>EDX：数据寄存器</li><li>ESI：源地址指针寄存器</li><li>EDI：目的地址指针寄存器</li><li>EBP：基址指针寄存器</li><li>ESP：堆栈指针寄存器</li></ul><p>段寄存器</p><ul><li>CS：代码段（Code Segment）</li><li>DS：数据段（Data Segment）</li><li>ES：附加数据段（Extra Segment）</li><li>SS：堆栈段（Stack Segment）</li><li>FS：附加段</li><li>GS：附加段</li></ul><blockquote><p>段寄存器是用来寻址，CS里面的值，在实模式下和保护模式下含义是不一样的</p></blockquote><p>指令寄存器和标志寄存器</p><ul><li><p>&#x3D;&#x3D;EIP：指令寄存器&#x3D;&#x3D;</p><p>EIP的低16位就是8086的IP，它存储的是下一条要执行指令的内存地址，在分段地址转换中，表示指令的段内偏移地址</p></li><li><p>EFLAGS：标志寄存器</p><p>lF（InterruptFlag）：中断允许标志位，由CLI，STI两条指令来控制；设置IF使CPU可识别外部（可屏蔽）中断请求。复位IF则禁止中断。IF对不可屏蔽外部中断和故障中断的识别没有任何作用。CF,PF，ZF，…</p></li></ul><h1 id="二、启动-中断-异常和系统调用"><a href="#二、启动-中断-异常和系统调用" class="headerlink" title="二、启动.中断.异常和系统调用"></a>二、启动.中断.异常和系统调用</h1><h2 id="1、BIOS"><a href="#1、BIOS" class="headerlink" title="1、BIOS"></a>1、BIOS</h2><h4 id="RAM和ROM"><a href="#RAM和ROM" class="headerlink" title="RAM和ROM"></a>RAM和ROM</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220519160931485.png" alt="image-20220519160931485" style="zoom:33%;"><p>CPU在加电之后进行读取的第一条指令在内存(ROM)中</p><p>内存分为：</p><ul><li>RAM：随机访问存储 (断电时数据会随之消失)，随机储存器 ，就是电脑的内存条。用于存放动态数据。(也叫运行内存)系统运行的时候，需要把操作系统从ROM中读取出来，放在RAM中运行。</li><li>ROM：只读储存器 ，对于电脑来讲就是硬盘，对于手机来讲就是内置储存，对于单片机来讲就是Flash。用于存放操作系统的软件。</li></ul><h4 id="启动时计算机内存和磁盘布局"><a href="#启动时计算机内存和磁盘布局" class="headerlink" title="启动时计算机内存和磁盘布局"></a>启动时计算机内存和磁盘布局</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220519161508124.png" alt="image-20220519161508124" style="zoom:50%;"><p>计算系统加电后，CPU将CS左移四位：IP两段地址拼接，跳转BIOS启动固件</p><p>BIOS启动固件有基本功能</p><ul><li>基本输入输出：从磁盘读数据，从键盘上读用户的输入，在显示器输出</li><li>系统配置信息：例如决定从硬盘，网络，光盘启动</li></ul><h4 id="加载程序的内存地址空间"><a href="#加载程序的内存地址空间" class="headerlink" title="加载程序的内存地址空间"></a>加载程序的内存地址空间</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220519163623584.png" alt="image-20220519163623584" style="zoom: 50%;"><p>BIOS完成相关初始化后，将加载程序从磁盘的引导扇区加载到进内存，将控制权交给加载程序</p><p>加载程序将操作系统的代码和数据从硬盘加载到内存中，控制权在交给操作系统内核，就此计算机就运行起来了</p><p>为什么不直接从BIOS直接读取操作系统进内存呢？</p><p>因为有文件系统，如果有多个文件系统，BIOS得存放多种数据，显然BIOS空间大小不允许，这呢还需要多了解</p><h4 id="BIOS系统调用"><a href="#BIOS系统调用" class="headerlink" title="BIOS系统调用"></a>BIOS系统调用</h4><p>BIOS以中断调用的方式 提供了基本的I&#x2F;O功能</p><ul><li>INT10h:字符显示</li><li>INT13h:磁盘扇区读写心</li><li>INT15h:检测内存大小</li><li>INT16h:键盘输入</li></ul><p>只能在×86的实模式下访问</p><h2 id="2、系统启动流程"><a href="#2、系统启动流程" class="headerlink" title="2、系统启动流程"></a>2、系统启动流程</h2><h4 id="系统启动流程"><a href="#系统启动流程" class="headerlink" title="系统启动流程"></a>系统启动流程</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220519164628886.png" alt="image-20220519164628886" style="zoom:50%;"><p>现在计算磁盘不只是有唯一 的分区，而是多个分区，所以需要有主引导记录，记录每一个分区的位置，当用户选择时，跳转到响应的活动分区读取对应加载程序</p><h4 id="CPU初始化"><a href="#CPU初始化" class="headerlink" title="CPU初始化"></a>CPU初始化</h4><p>CPU加电稳定后从OXFFFF0读第一条指令</p><ul><li>CS:IP&#x3D;0xf000:fff0</li><li>第一条指令是跳转指令</li></ul><p>CPU初始状态为16位实模式</p><ul><li>CS：IP是16位寄存器</li><li>指令指针PC&#x3D;16*CS+IP</li><li>最大地址空间是1MB</li></ul><blockquote><p>实模式地址20位，最大地址空间2^20&#x3D;1MB</p></blockquote><h4 id="BIOS的初始化"><a href="#BIOS的初始化" class="headerlink" title="BIOS的初始化"></a>BIOS的初始化</h4><ul><li>硬件自检POST</li><li>检测系统中内存和显卡等关键部件的存在和工作状态</li><li>查找并执行显卡等接口卡BIOS，进行设备初始化；</li><li>执行系统BIOS，进行系统检测；<ul><li>检测和配置系统中安装的即插即用设备；</li></ul></li><li>更新CMOS中的扩展系统配置数据ESCD</li><li>按指定启动顺序从软盘、硬盘或光驱启动</li></ul><blockquote><p>硬件自检：例如你的内容地址可能出错，进行设备初始化</p><p>ESCD：计算当前检测到的硬件的硬件表</p></blockquote><h4 id="主引导记录MBR格式"><a href="#主引导记录MBR格式" class="headerlink" title="主引导记录MBR格式"></a>主引导记录MBR格式</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220906104246721.png" alt="image-20220906104246721" style="zoom:50%;"><p>启动代码：446字节</p><ul><li>检查分区表正确性</li><li>加载并跳转到磁盘上的引导程序</li></ul><p>硬盘分区表：64字节</p><ul><li>描述分区状态和位置</li><li>每个分区描述信息占据16字节</li></ul><p>结束标志字：2字节（55AA）</p><ul><li>主引导记录的有效标志</li></ul><blockquote><p>MBR一般是在第一个分区，将512字节划分出64字节来作为分区表，446字节来作为启动代码</p></blockquote><h4 id="分区引导扇区格式"><a href="#分区引导扇区格式" class="headerlink" title="分区引导扇区格式"></a>分区引导扇区格式</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220906092323911.png" alt="image-20220906092323911" style="zoom:50%;"><p>跳转指令：跳转到启动代码</p><ul><li>与平台相关代码</li></ul><p>文件卷头：文件系统描述信息</p><p>启动代码：跳转到加载程序</p><p>结束标志：55AA</p><h4 id="加载程序（bootloader）"><a href="#加载程序（bootloader）" class="headerlink" title="加载程序（bootloader）"></a>加载程序（bootloader）</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220519170741257.png" alt="image-20220519170741257" style="zoom: 50%;"><blockquote><p>每个操作系统的文件系统都不一样，所以bootloader加载程序也有不同</p><p>启动菜单：例如你要以什么模式进入系统，安全模式、普通模式、调试模式等，不同模式内核也会有些出入</p></blockquote><h4 id="系统启动规范"><a href="#系统启动规范" class="headerlink" title="系统启动规范"></a>系统启动规范</h4><p>BIOS</p><ul><li>固化到计算机主板上的程序</li><li>包括系统设置、自检程序和系统自启动程序</li><li>BIOS-MBR、BIOS-GPT、PXE</li></ul><p>UEFI</p><ul><li>接口标准</li><li>在所有平台上一致的操作系统启动服务</li></ul><blockquote><p>BIOS-MBR：主引导记录，分出64字节来记录四个分区的位置</p><p>BIOS-GPT：全局分区唯一标识符表，由于MBR只能记录四个分区，衍生出了GPT能记录四个以上的分区</p><p>PXE：网络启动，从服务器上下载镜像内核进行启动</p><p>UEFI ：</p><ul><li>统一可扩展固定接口</li><li>可信度检查：在分区中加上可信签名，有签名才会将控制权交给该分区</li></ul></blockquote><h2 id="3、中断-异常和系统调用的比较"><a href="#3、中断-异常和系统调用的比较" class="headerlink" title="3、中断.异常和系统调用的比较"></a>3、中断.异常和系统调用的比较</h2><h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>为什么需要中断、异常和系统调用</p><ul><li>在计算机运行中，内核是被信任的第三方</li><li>只有内核可以执行特权指令</li><li>方便应用程序</li></ul><p>为什么需要中断、异常和系统调用</p><ul><li>当外设连接计算机时，会出现什么现象？</li><li>当应用程序处理意想不到的行为时，会出现什么现象？</li></ul><p>系统调用希望解决的问题</p><ul><li>用户应用程序是如何得到系统服务？</li><li>系统调用和功能调用的不同之处是什么？</li></ul><h4 id="内核的进入与退出"><a href="#内核的进入与退出" class="headerlink" title="内核的进入与退出"></a>内核的进入与退出</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220519173405688.png" alt="image-20220519173405688" style="zoom: 50%;"><p>外界内核打交道基本是通过中断</p><p>外部设备：例如键盘打字，打印机缺纸或者完成，都会发出中断，内核收到后进行处理</p><p>应用进程：应用进程发出中断或调用系统调用接口来进行与内核的交互，中断有时会被检查是异常，进行处理</p><p>函数库：可以通过系统调用交互，例如文件的读写</p><h4 id="中断、异常和系统调用定义"><a href="#中断、异常和系统调用定义" class="headerlink" title="中断、异常和系统调用定义"></a>中断、异常和系统调用定义</h4><p>系统调用（system call）</p><ul><li>应用程序&#x3D;&#x3D;主动&#x3D;&#x3D;向操作系统发出的服务请求</li></ul><p>异常（exception）</p><ul><li><p>非法指令或者其他原因导致当前&#x3D;&#x3D;指令执行失败&#x3D;&#x3D;</p><p>（如：内存出错）后的处理请求</p></li></ul><p>中断（hardware interrupt）</p><ul><li>来自硬件设备的处理请求</li></ul><h4 id="中断、异常和系统调用的比较"><a href="#中断、异常和系统调用的比较" class="headerlink" title="中断、异常和系统调用的比较"></a>中断、异常和系统调用的比较</h4><p>三者大致能按这三种方式进行分类</p><ul><li><p>源头</p><ul><li>中断：外设</li><li>异常：应用程序意想不到的行为</li><li>系统调用：应用程序请求操作提供服务</li></ul></li><li><p>响应方式</p><ul><li>异步</li><li>同步</li><li>异步或同步</li></ul></li><li><p>处理机制</p><ul><li>&#x3D;&#x3D;中断：持续，对用户应用程序是透明的&#x3D;&#x3D;</li><li>异常：杀死或者重新执行意想不到的应用程序指令</li><li>&#x3D;&#x3D;系统调用：等待和持续&#x3D;&#x3D;</li></ul></li></ul><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220519173405688.png" alt="image-20220519173405688" style="zoom: 50%;"><blockquote><p>响应方式：</p><p>同步：发生异常，应用程序等待异常处理，处理完再去做别的事情</p><p>异步：发生中断请求，应用程序可以去干别的事情，等到处理完在回来</p></blockquote><h4 id="中断和异常的处理机制"><a href="#中断和异常的处理机制" class="headerlink" title="中断和异常的处理机制"></a>中断和异常的处理机制</h4><h5 id="硬件处理"><a href="#硬件处理" class="headerlink" title="硬件处理"></a>硬件处理</h5><ul><li>在CPU初始化时设置中断使能标志<ul><li>依据内部或外部事件设置中断标志</li><li>依据中断向量调用相应中断服务例程</li></ul></li></ul><p>这些都是由硬件完成的：</p><blockquote><p>中断使能标志：在CPU初始化时不接收任何中断请求</p><p>中断标志：标志外部事件或内部事件</p><p>中断类型（中断向量）：提供相应服务</p></blockquote><h5 id="软件处理"><a href="#软件处理" class="headerlink" title="软件处理"></a>软件处理</h5><ul><li>现场保存（编译器）</li><li>中断服务处理（服务例程）</li><li>清除中断标记（服务例程）</li><li>现场恢复（编译器）</li></ul><p><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220519175800417.png" alt="image-20220519175800417"></p><h4 id="中断嵌套"><a href="#中断嵌套" class="headerlink" title="中断嵌套"></a>中断嵌套</h4><p>硬件中断服务例程可被打断</p><ul><li>不同硬件中断源可能硬件中断处理时出现</li><li>硬件中断服务例程中需要临时禁止中断请求</li><li>中断请求会保持到CPU做出响应</li></ul><p>异常服务例程可被打断</p><ul><li>异常服务例程执行时可能出现硬件中断</li></ul><p>异常服务例程可嵌套</p><ul><li>异常服务例程可能出现缺页</li></ul><blockquote><p>中断的优先级判断打断当前中断处理</p><p>在执行中断有一段时间里要禁止中断请求（关中断）</p></blockquote><h2 id="4、系统调用"><a href="#4、系统调用" class="headerlink" title="4、系统调用"></a>4、系统调用</h2><h4 id="标准C库例子"><a href="#标准C库例子" class="headerlink" title="标准C库例子"></a>标准C库例子</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220519180746448.png" alt="image-20220519180746448" style="zoom:50%;"><h4 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h4><ul><li>操作系统服务的编程接口</li><li>通常由高级语言编写（C或者C++）</li><li>程序访问通常是通过高层次的API接口而不是直接进行系统调用</li><li>三种最常用的应用程序编程接口（API）<ul><li>Win32 API用于Windows</li><li>POSIX API用于POSIX-based systems（包括UNIX，LINUX，Mac OS X的所有版本）</li><li>Java API用于JAVA虚拟机（JVM）</li></ul></li></ul><h4 id="系统调用的实现"><a href="#系统调用的实现" class="headerlink" title="系统调用的实现"></a>系统调用的实现</h4><p>每个系统调用对应一个系统调用号</p><ul><li>系统调用接口根据系统调用号来维护表的索引</li></ul><p>系统调用接口调用内核态中的系统调用功能实现，并返回系统调用的状态和结果</p><p>用户不需要知道系统调用的实现</p><ul><li>需要设置调用参数和获取返回结果</li><li>操作系统接口的细节大部分都隐藏在应用编程接口后，&#x3D;&#x3D;通过运行程序支持的库来管理&#x3D;&#x3D;</li></ul><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220519173405688.png" alt="image-20220519173405688" style="zoom: 50%;"><blockquote><p>系统调用号：用来查找系统调用表上对应号的系统调用</p></blockquote><h4 id="函数调用和系统调用的不同处"><a href="#函数调用和系统调用的不同处" class="headerlink" title="函数调用和系统调用的不同处"></a>函数调用和系统调用的不同处</h4><p>系统调用</p><ul><li><p>INT和IRET指令用于系统调用</p><p>&#x3D;&#x3D;系统调用时，堆栈切换和特权级的转换&#x3D;&#x3D;</p></li></ul><p>函数调用</p><ul><li><p>CALL和RET用于常规调用</p><p>&#x3D;&#x3D;常规调用时没有堆栈切换&#x3D;&#x3D;</p></li></ul><p>Intel 64 and IA-32 Architectures Software Developer(英特尔 64 位和 IA-32 架构软件开发人员手册)</p><blockquote><p>Manuals <a href="http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html">http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html</a></p></blockquote><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220519173405688.png" alt="image-20220519173405688" style="zoom: 50%;"><blockquote><p>系统调用：</p><ul><li>需要堆栈的切换，内核态和用户态不能共用一个堆栈来存取信息，不安全</li><li>切换到内核态后拥有特权去完成响应工作</li></ul><p>函数调用：</p><ul><li>一直在用户态没有堆栈切换</li></ul></blockquote><h4 id="中断、异常和系统调用的开销"><a href="#中断、异常和系统调用的开销" class="headerlink" title="中断、异常和系统调用的开销"></a>中断、异常和系统调用的开销</h4><ul><li><p>超过函数调用</p></li><li><p>中断、异常和系统调用</p><ul><li><p>引导机制</p></li><li><p>建立内核堆栈</p></li><li><p>验证参数</p></li><li><p>内核态映射到用户态的地址空间</p><p>&#x3D;&#x3D;更新页面映射权限&#x3D;&#x3D;</p></li></ul></li><li><p>内核态独立地址空间</p><p>&#x3D;&#x3D;TLB&#x3D;&#x3D;</p></li></ul><blockquote><p>用户态切换到内核态的开销大</p><p>TLB（快表） TLB价值：<strong>能够有效减少寻找物理地址所消耗时间</strong>。TLB(Translation Lookaside Buffer)转换检测缓冲区是一个内存管理单元,用于改进虚拟地址到物理地址转换速度的缓存。</p></blockquote><h2 id="5、系统调用示例"><a href="#5、系统调用示例" class="headerlink" title="5、系统调用示例"></a>5、系统调用示例</h2><h4 id="文件复制过程中的系统调用序列"><a href="#文件复制过程中的系统调用序列" class="headerlink" title="文件复制过程中的系统调用序列"></a>文件复制过程中的系统调用序列</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220519191756545.png" alt="image-20220519191756545" style="zoom:50%;"><blockquote><p>各种设备在文件系统中都被抽象为文件，例如键盘、显示器</p></blockquote><h4 id="系统调用示例"><a href="#系统调用示例" class="headerlink" title="系统调用示例"></a>系统调用示例</h4><p>在ucore中库函数read()的功能是读文件</p><ul><li>user&#x2F;libs&#x2F;file.h:int read(int fd, void * buf ,int length)</li></ul><p>库函数read()的参数和返回值</p><ul><li>int fd—文件句柄</li><li>void * buf—数据缓冲区指针</li><li>int length一数据缓冲区长度</li><li>int return_value:返回读出数据长度</li></ul><p>库函数read()使用示例</p><ul><li>in sfs filetestl.c: ret &#x3D; read(fd，data，len）；</li></ul><h4 id="系统调用库的接口示例"><a href="#系统调用库的接口示例" class="headerlink" title="系统调用库的接口示例"></a>系统调用库的接口示例</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220519192343705.png" alt="image-20220519192343705" style="zoom:50%;"><blockquote><p>第一部分是将各种元素压栈，之后调用函数调用，int是系统调用指令</p></blockquote><h4 id="ucore系统调用read-fd-buffer-length-的实现"><a href="#ucore系统调用read-fd-buffer-length-的实现" class="headerlink" title="ucore系统调用read(fd , buffer , length)的实现"></a>ucore系统调用read(fd , buffer , length)的实现</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220519193732177.png" alt="image-20220519193732177" style="zoom: 50%;"><p>1、进入到内核态的中断（软中断），都会转到一段汇编程序，alltraps程序，在这里你会得到中断的相关信息组成的数据结构，即 tf 这个数据结构</p><p>2、查看中断向量trapno ，跳转到系统调用的函数中</p><p>3、读取eax，即系统调用编号，跳转到响应的系统调用函数</p><p>4、读取sp，那三个参数</p><p>5、调用硬件驱动设备开始执行</p><p>6、返回读取长度到用户态，执行结束</p><h1 id="三、物理内存管理-连续内存分配"><a href="#三、物理内存管理-连续内存分配" class="headerlink" title="三、物理内存管理::连续内存分配"></a>三、物理内存管理::连续内存分配</h1><h2 id="1、计算机体系结构和内存层次"><a href="#1、计算机体系结构和内存层次" class="headerlink" title="1、计算机体系结构和内存层次"></a>1、计算机体系结构和内存层次</h2><h4 id="计算机体系结构"><a href="#计算机体系结构" class="headerlink" title="计算机体系结构"></a>计算机体系结构</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220519160931485.png" alt="image-20220519160931485" style="zoom:50%;"><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220519200008560.png" alt="image-20220519200008560" style="zoom:50%;"><blockquote><p>高速缓存：将常用的数据、要用的数据、等等提前放入高速缓存中，不需要在到内存中取</p></blockquote><h4 id="内存层次"><a href="#内存层次" class="headerlink" title="内存层次"></a>内存层次</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220519200327222.png" alt="image-20220519200327222" style="zoom:50%;"><h4 id="操作系统的内存管理"><a href="#操作系统的内存管理" class="headerlink" title="操作系统的内存管理"></a>操作系统的内存管理</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220519201100008.png" alt="image-20220519201100008" style="zoom:50%;"><blockquote><p>外存：例如磁盘</p><p>所有的进程他们地址空间中都有一段相同的地址，即操作系统内核</p><p>MMU：其作用是逻辑地址和物理地址之间的转换</p><p>抽象：将线性的物理地址转化为逻辑地址</p><p>保护：进程间，逻辑地址一样，但是拥有独立的地址空间，互不干扰</p><p>共享：访问相同的内存</p><p>逻辑地址一样，存入内存中实际的物理是不一样的</p></blockquote><h4 id="操作系统的内存管理方式"><a href="#操作系统的内存管理方式" class="headerlink" title="操作系统的内存管理方式"></a>操作系统的内存管理方式</h4><p>操作系统中采用的内存管理方式</p><ul><li><p>重定位（relocation）</p></li><li><p>分段（segmentation）</p></li><li><p>分页（paging）</p></li><li><p>虚拟存储（virtual memory）</p><p>目前多数系统（如Linux）采用按需页式虚拟存储</p></li></ul><p>实现高度依赖硬件</p><ul><li>与计算机存储架构紧耦合</li><li>MMU（内存管理单元）：处理CPU存储访问请求的硬件</li></ul><blockquote><p>重定位：将逻辑地址重定位到真正的物理地址</p><p>分段：由于分页式虚拟存储器中，页面大小固定，可能遇到一个数据包含在不同的页面，因此引入段式虚拟存储方式</p><p>分页：把内存分成若干个页，页是存储的基本单位</p></blockquote><h2 id="2、地址空间和地址生成"><a href="#2、地址空间和地址生成" class="headerlink" title="2、地址空间和地址生成"></a>2、地址空间和地址生成</h2><h4 id="地址空间的定义"><a href="#地址空间的定义" class="headerlink" title="地址空间的定义"></a>地址空间的定义</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220519204116358.png" alt="image-20220519204116358" style="zoom: 50%;"><blockquote><p>物理地址空间，最大值&#x3D;2^地址总线位数</p><p>逻辑地址空间，正在运行的进程所看到的，在寻址时，会将逻辑地址转换为物理地址</p></blockquote><h4 id="逻辑地址的生成"><a href="#逻辑地址的生成" class="headerlink" title="逻辑地址的生成"></a>逻辑地址的生成</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220519204836338.png" alt="image-20220519204836338" style="zoom:50%;"><h4 id="地址的生成和限制"><a href="#地址的生成和限制" class="headerlink" title="地址的生成和限制"></a>地址的生成和限制</h4><p>这里说的地址是实际的地址，物理地址</p><p>编译时</p><ul><li>假设起始地址已知</li><li>如果起始地址改变，必须重新编译</li></ul><p>加载时</p><ul><li>如编译时起始位置未知，编译器需生成可重定位的代码（relocatable code）</li><li>加载时，生成绝对地址</li></ul><p>执行时</p><ul><li>执行时代码可移动</li><li>需地址转换（映射）硬件支持</li></ul><blockquote><p>编译时生成，例如老人机，里面的程序都是写死的，地址开始就生成，也不会变</p><p>加载时生成，不灵活，可能在执行时地址被占用</p></blockquote><h4 id="地址生成过程"><a href="#地址生成过程" class="headerlink" title="地址生成过程"></a>地址生成过程</h4><p>CPU</p><ul><li>ALU：需要逻辑地址的内存内容</li><li>MMU：进行逻辑地址和物理地址的转换</li><li>CPU控制逻辑：给总线发送物理地址请求</li></ul><p>内存</p><ul><li>发送物理地址的内容给CPU</li><li>或接收CPU数据到物理地址</li></ul><p>操作系统</p><ul><li>建立逻辑地址LA和物理地址PA的映射</li></ul><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220906095538812.png" alt="image-20220906095538812" style="zoom: 80%;"><blockquote><p>物理地址的生成是靠硬件MMU完成，操作系统给提供<strong>页表</strong>帮助地址映射的转换</p></blockquote><h4 id="地址检查"><a href="#地址检查" class="headerlink" title="地址检查"></a>地址检查</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220519210731187.png" alt="image-20220519210731187" style="zoom: 50%;"><blockquote><p>查看访问的起始位置是不是合法范围内，合法之后加上你的段基址，得到物理地址</p></blockquote><h2 id="3、连续内存分配"><a href="#3、连续内存分配" class="headerlink" title="3、连续内存分配"></a>3、连续内存分配</h2><h4 id="连续内存分配和内存碎片"><a href="#连续内存分配和内存碎片" class="headerlink" title="连续内存分配和内存碎片"></a>连续内存分配和内存碎片</h4><p>计算机体系结构&#x2F;内存层次</p><ul><li>给进程分配一块不小于指定大小的连续的物理内存区域</li></ul><p>内存碎片</p><ul><li>空闲内存不能被利用</li></ul><p>外部碎片</p><ul><li>分配单元之间的未被使用内存</li></ul><p>内部碎片</p><ul><li>分配单元内部的未被使用内存</li><li>取决于分配单元大小是否要取整</li></ul><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220906095800541.png" alt="image-20220906095800541" style="zoom:67%;"><blockquote><p>碎片会造成内存的浪费</p></blockquote><h4 id="动态分区分配"><a href="#动态分区分配" class="headerlink" title="动态分区分配"></a>动态分区分配</h4><p>动态分区分配</p><ul><li>当程序被加载执行时，分配一个进程指定大小可变的分区（块、内存块）</li><li>分区的地址是连续的</li></ul><p>操作系统需要维护的数据结构</p><ul><li>当所有进程的已分配分区</li><li>空闲分区（Empty-blocks）</li></ul><p>动态分区分配策略</p><ul><li>最先匹配（First-fit）</li><li>最佳匹配（Best-fit）</li><li>最差匹配（Worst-fit）</li></ul><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220906095957720.png" alt="image-20220906095957720" style="zoom: 67%;"><h4 id="最先匹配策略"><a href="#最先匹配策略" class="headerlink" title="最先匹配策略"></a>最先匹配策略</h4><p>思路：<br>分配n个字节，使用第一个可用的空间比n大的空闲块<br>示例：<br>分配400字节，使用第一个1KB的空闲块。</p><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220906100032876.png" alt="image-20220906100032876" style="zoom:50%;"><blockquote><p>按地址顺序找空闲分区，只要找到第一个大于他所需的分区即可</p><p>例如需要400字节，则按地址顺序找，则第一个找到1k字节，分配后表明是哪个进程使用的，剩余在600字节表明空闲分区</p></blockquote><p>&#x3D;&#x3D;原理和实现&#x3D;&#x3D;</p><ul><li>空闲分区列表按地址顺序排序</li><li>分配过程时，搜索一个合适的分区</li><li>释放分区时，检查是否可与临近的空闲分区合并</li></ul><p>&#x3D;&#x3D;优点&#x3D;&#x3D;</p><ul><li>简单</li><li>在高地址空间有大块的空闲分区</li></ul><p>&#x3D;&#x3D;缺点&#x3D;&#x3D;</p><ul><li>外部碎片</li><li>分配大块时较慢</li></ul><blockquote><p>优点：都是先找前面，后面有大块还没被分配，如果进程需要大块分区，也可满足</p><p>缺点：不是按需分配，所以会有更多的碎片；在分配大块时，向后找时间也会更慢</p></blockquote><h4 id="最佳匹配策略"><a href="#最佳匹配策略" class="headerlink" title="最佳匹配策略"></a>最佳匹配策略</h4><p>思路：<br>分配n字节分区时，查找并使用不小于n的最小空闲分区<br>示例：<br>分配400字节，使用第3个空闲块（最小）</p><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220906100243804.png" alt="image-20220906100243804" style="zoom:50%;"><blockquote><p>将空闲分区按大小排序，找比需求大的少的进行分配</p></blockquote><p>&#x3D;&#x3D;原理和实现&#x3D;&#x3D;</p><ul><li>空闲分区列表按照大小排序</li><li>分配时，查找一个合适的分区</li><li>释放时，查找并且合并临近的空闲分区（如果找到）</li></ul><p>&#x3D;&#x3D;优点&#x3D;&#x3D;</p><ul><li><p>大部分分配的尺寸较小时，效果很好</p><p>可避免大的空闲分区被拆分</p><p>可减小外部碎片的大小</p><p>相对简单</p></li></ul><p>&#x3D;&#x3D;缺点&#x3D;&#x3D;</p><ul><li>外部碎片</li><li>释放分区较慢</li><li>容易产生很多无用的小碎片</li></ul><blockquote><p>小碎片基本没用</p></blockquote><h4 id="最差匹配策略"><a href="#最差匹配策略" class="headerlink" title="最差匹配策略"></a>最差匹配策略</h4><p>思路：<br>分配n字节，使用尺寸不小于n的最大空闲分区<br>示例：<br>分配400字节，使用第2个空闲块（最大）</p><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220906100456573.png" alt="image-20220906100456573" style="zoom:50%;"><blockquote><p>空闲分区按由大到小进行排序，找最大的分区进行分配</p></blockquote><p>&#x3D;&#x3D;原理和实现&#x3D;&#x3D;</p><ul><li>空闲分区列表按由大到小排序</li><li>分配时，选最大的分区</li><li>释放时，检查是否可与临近的空闲分区合并，进行可能的合并</li><li>并调整空闲分区列表顺序</li></ul><p>&#x3D;&#x3D;优点&#x3D;&#x3D;</p><ul><li>中等大小的分配较多时，效果最好</li><li>避免出现太多的小碎片</li></ul><p>&#x3D;&#x3D;缺点&#x3D;&#x3D;</p><ul><li>释放分区较慢</li><li>外部碎片</li><li>容易破坏大的空闲分区，因此后续难以分配大的分区</li></ul><blockquote><p>释放分区慢：释放时，进行搜索空闲分区表，查看是否有与自己相近的空闲分区进行合并，然后合并过后在放入空闲分区表中，过程开销大</p></blockquote><h2 id="4、碎片整理"><a href="#4、碎片整理" class="headerlink" title="4、碎片整理"></a>4、碎片整理</h2><h4 id="碎片紧凑"><a href="#碎片紧凑" class="headerlink" title="碎片紧凑"></a>碎片紧凑</h4><p>碎片整理</p><ul><li>通过调整进程占用的分区位置来减少或避免分区碎片</li></ul><p>碎片紧凑</p><ul><li><p>通过移动分配给进程的内存分区，以合并外部碎片</p></li><li><p>碎片紧凑的条件</p><p>所有的应用程序可动态重定位</p></li><li><p>需要解决的问题</p><p>什么时候移动？</p><p>开销</p></li></ul><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220906100818444.png" alt="image-20220906100818444" style="zoom:50%;"><blockquote><p>条件：</p><ul><li>静态加载地址：程序在装入内存前就已经生成绝对地址了，如果进行碎片紧凑，则会导致一些地址找不到而无法执行，需要&#x3D;&#x3D;动态的重定位&#x3D;&#x3D;</li><li>动态重定位：即程序在执行期间生成绝对地址，因此在碎片紧凑时只需要将程序的首地址更换为紧凑后的新地址即可</li></ul><p>什么时候移动：</p><ul><li>当进程处于等待状态时，进行移动</li></ul><p>开销：</p><ul><li>如果为了大一点空闲空间移动所有进程，开销会很大，应按需移动</li></ul><p>静态装入是指在编程阶段就把物理地址计算好。</p><p>可重定位是指在装入时把逻辑地址转换成物理地址，但装入后不能改变</p><p>动态重定位是指在执行时再决定装入的地址并装入，装入后有可能会换出，所以同一个模块在内存中的物理地址是可能改变的。</p><p>动态重定位是指在作业运行过程中执行到一条访存指令时，再把逻辑地址转换为主存中的物理地址，实际中是通过硬件地址转换机制实现的。</p></blockquote><h4 id="对换分区"><a href="#对换分区" class="headerlink" title="对换分区"></a>对换分区</h4><p>通过抢占并回收处于等待状态进程的分区，以增大可用内存空间</p><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220906100937826.png" alt="image-20220906100937826" style="zoom: 67%;"><p>将处于等待状态的进程放入外存，空出内存空间让给新进来的进程</p><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220520113237056.png" alt="image-20220520113237056" style="zoom:50%;"><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220520113648224.png" alt="image-20220520113648224" style="zoom:50%;"><blockquote><p>对换分区方式，例如Linux下的swap分区，这使得内存的利用得到很大提升</p><p>由于内存和外存的速度差异大，进行交换时开销也会大，还要考虑交换拿些程序比较合适</p></blockquote><h2 id="5、伙伴系统"><a href="#5、伙伴系统" class="headerlink" title="5、伙伴系统"></a>5、伙伴系统</h2><h4 id="伙伴系统"><a href="#伙伴系统" class="headerlink" title="伙伴系统"></a>伙伴系统</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220520114705657.png" alt="image-20220520114705657" style="zoom:50%;"><p>把可分配的分区看成2^u，如果你需要的分区大小比2^u的一般还大，则就把这块分区给你，否则继续分割一半在与你所需的分区比较</p><p>最大内碎片：可能你刚到比它的一半大1个字节，那么它就将这块分区分配给你，内碎片就比你小一个字节</p><h4 id="伙伴系统的实现"><a href="#伙伴系统的实现" class="headerlink" title="伙伴系统的实现"></a>伙伴系统的实现</h4><p>数据结构</p><ul><li>空闲块按大小和起始地址组织成二维数组</li><li>初始状态：只有一个大小为2^u的空闲块</li></ul><p>分配过程</p><ul><li>由小到大在空闲块数组中找最小的可用空闲块</li><li>如空闲块过大，对可用空闲块进行二等分，直到得到合适的可用空闲块</li></ul><h4 id="伙伴系统中的分配内存"><a href="#伙伴系统中的分配内存" class="headerlink" title="伙伴系统中的分配内存"></a>伙伴系统中的分配内存</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220520115854076.png" alt="image-20220520115854076" style="zoom: 80%;"><p>释放合并时，合并起来的块得是2的幂次方，否则不能合并</p><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220520120628423.png" alt="image-20220520120628423" style="zoom:50%;"><blockquote><p>在Linux、Unix中都用伙伴系统的实现，主要用于内核的存储管理</p></blockquote><h4 id="ucore中的物理内存管理"><a href="#ucore中的物理内存管理" class="headerlink" title="ucore中的物理内存管理"></a>ucore中的物理内存管理</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220520121111878.png" alt="image-20220520121111878" style="zoom:50%;"><h4 id="ucore中伙伴系统的实现"><a href="#ucore中伙伴系统的实现" class="headerlink" title="ucore中伙伴系统的实现"></a>ucore中伙伴系统的实现</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220520121032645.png" alt="image-20220520121032645" style="zoom:50%;"><h1 id="四、物理内存管理-非连续存储分配"><a href="#四、物理内存管理-非连续存储分配" class="headerlink" title="四、物理内存管理::非连续存储分配"></a>四、物理内存管理::非连续存储分配</h1><h2 id="1、非连续存储分配的需求背景"><a href="#1、非连续存储分配的需求背景" class="headerlink" title="1、非连续存储分配的需求背景"></a>1、非连续存储分配的需求背景</h2><h4 id="连续分配的缺点"><a href="#连续分配的缺点" class="headerlink" title="连续分配的缺点"></a>连续分配的缺点</h4><ul><li>分配给程序的物理内存必须连续</li><li>存在外碎片和内碎片</li><li>内存分配的动态修改困难</li><li>&#x3D;&#x3D;内存利用率较低&#x3D;&#x3D;</li></ul><h4 id="非连续分配的设计目标"><a href="#非连续分配的设计目标" class="headerlink" title="非连续分配的设计目标"></a>非连续分配的设计目标</h4><ul><li><p>连续分配的缺点</p></li><li><p>非连续分配的设计目标：提高内存利用效率和管理灵活性</p><ul><li>允许一个程序的使用非连续的物理地址空间</li><li>允许共享代码与数据</li><li>支持动态加载和动态链接</li></ul></li></ul><blockquote><p>允许共享代码与数据：很多程序可能用到的同一个函数库，那么可以通过共享这些代码和数据，减少内存的占用</p><p>支持动态加载和动态链接：当分配的内存小了，可以动态的进行链接和加载</p></blockquote><h4 id="非连续分配需要解决的问题"><a href="#非连续分配需要解决的问题" class="headerlink" title="非连续分配需要解决的问题"></a>非连续分配需要解决的问题</h4><p>如何实现虚拟地址和物理地址的转换</p><ul><li>软件实现（灵活，开销大）</li><li>硬件实现（够用，开销小）</li></ul><blockquote><p>地址转换：虚拟地址是连续的，转换为物理地址又不连续了</p><p>软件实现：例如你的程序代码非常大，可设计一些数据结构，先将当前要执行一部分代码装入内存，计算好后在拿出在放入另一部分要执行的代码装入内存</p><p>硬件实现：地址转换过于频繁，用硬件实现效果更好</p></blockquote><h4 id="非连续分配的硬件辅助机制"><a href="#非连续分配的硬件辅助机制" class="headerlink" title="非连续分配的硬件辅助机制"></a>非连续分配的硬件辅助机制</h4><p>如何选择非连续分配中的内存分块大小</p><ul><li>段式存储管理（segmentation）</li><li>页式存储管理（paging）</li></ul><blockquote><p>段式存储：以一个段为基本单位，段的单位比较大，在段内的内容物理地址是连续的</p><p>页式存储：以一个页为基本单位，页与页之间的物理地址是不连续的</p></blockquote><h2 id="2、段式存储管理"><a href="#2、段式存储管理" class="headerlink" title="2、段式存储管理"></a>2、段式存储管理</h2><h4 id="段地址空间"><a href="#段地址空间" class="headerlink" title="段地址空间"></a>段地址空间</h4><p>进程的段地址空间由多个段组成</p><ul><li>主代码段</li><li>子模块代码段</li><li>公用库代码段</li><li>堆栈段（stack）</li><li>堆数据（heap）</li><li>初始化数据段</li><li>符号表等</li></ul><p>段式存储管理的目的</p><ul><li>&#x3D;&#x3D;更细粒度和灵活的分离与共享&#x3D;&#x3D;</li></ul><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220906101523811.png" alt="image-20220906101523811" style="zoom: 67%;"><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220521170136268.png" alt="image-20220521170136268" style="zoom:50%;"><blockquote><p>段内地址是连续的，可以通过偏移量来进行访问，段与段之间很少有进行跨段访问的</p></blockquote><h4 id="段地址空间的逻辑视图"><a href="#段地址空间的逻辑视图" class="headerlink" title="段地址空间的逻辑视图"></a>段地址空间的逻辑视图</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220521170355171.png" alt="image-20220521170355171" style="zoom:50%;"><blockquote><p>段与段之间，逻辑地址是连续的，分配段物理地址空间可以是不连续的</p></blockquote><h4 id="段的概念和段访问机制"><a href="#段的概念和段访问机制" class="headerlink" title="段的概念和段访问机制"></a>段的概念和段访问机制</h4><p>段的概念</p><ul><li>段表示访问方式和存储数据等属性相同的一段地址空间</li><li>对应一个连续的内存“块”</li><li>若干个段组成进程逻辑地址空间</li></ul><p>段访问：逻辑地址由二元组（s，addr）表示</p><ul><li>s — 段号</li><li>addr — 段内偏移</li></ul><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220906101815077.png" alt="image-20220906101815077" style="zoom: 67%;"><h4 id="段访问的硬件实现"><a href="#段访问的硬件实现" class="headerlink" title="段访问的硬件实现"></a>段访问的硬件实现</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220521170912527.png" alt="image-20220521170912527" style="zoom: 67%;"><blockquote><p>同段号查询对应段描述符，得到段基址和段长度，将硬件MMU将段内偏移与段长度比较判断是否存在访问越界，则加上段基址得到物理地址</p></blockquote><h2 id="3、页式存储管理"><a href="#3、页式存储管理" class="headerlink" title="3、页式存储管理"></a>3、页式存储管理</h2><h4 id="页帧和页面"><a href="#页帧和页面" class="headerlink" title="页帧和页面"></a>页帧和页面</h4><p>页帧（帧、物理页面，Frame，Page Frame）</p><ul><li>把物理地址空间划分为大小相同的基本分配单位</li><li>2的n次方，如512，4096，8192</li></ul><p>页面（页、逻辑页面，Page）</p><ul><li>把逻辑地址空间也划分为相同大小的基本分配单位</li><li>帧和页的大小必须是相同的</li></ul><blockquote><p>页帧为2的n次方：便于地址的快速转换，因为在计算机中二进制移位是快速乘法的一种方式</p><p>页帧是：描述物理页帧；页面是：描述逻辑页面</p></blockquote><p>页面到页顿</p><ul><li>逻辑地址到物理地址的转换</li><li>页表</li><li>&#x3D;&#x3D;MMU &#x2F; TLB&#x3D;&#x3D;</li></ul><h4 id="帧（frame）"><a href="#帧（frame）" class="headerlink" title="帧（frame）"></a>帧（frame）</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220521172040190.png" alt="image-20220521172040190" style="zoom: 67%;"><h4 id="基于页帧的物理地址计算实例"><a href="#基于页帧的物理地址计算实例" class="headerlink" title="基于页帧的物理地址计算实例"></a>基于页帧的物理地址计算实例</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220521172331127.png" alt="image-20220521172331127" style="zoom: 50%;"><h4 id="页（page）"><a href="#页（page）" class="headerlink" title="页（page）"></a>页（page）</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220521172558657.png" alt="image-20220521172558657" style="zoom: 67%;"><h4 id="页表：页式存储中的地址映射"><a href="#页表：页式存储中的地址映射" class="headerlink" title="页表：页式存储中的地址映射"></a>页表：页式存储中的地址映射</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220521172823206.png" alt="image-20220521172823206" style="zoom:67%;"><p>页表作为地址映射，可使得内存分配的页帧是不连续的</p><p><strong>页表</strong></p><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220521173039900.png" alt="image-20220521173039900" style="zoom: 50%;"><p>页表：逻辑页号到物理帧号之间的转换</p><h2 id="4、页表概述"><a href="#4、页表概述" class="headerlink" title="4、页表概述"></a>4、页表概述</h2><h4 id="页表的结构"><a href="#页表的结构" class="headerlink" title="页表的结构"></a>页表的结构</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220521173543107.png" alt="image-20220521173543107" style="zoom: 67%;"><p>存在位：是否存在一个逻辑页面对应的物理页面</p><p>修改位：该页内容是否被修改</p><p>引用位：该页最近是否有被引用</p><h4 id="页表地址转换示例"><a href="#页表地址转换示例" class="headerlink" title="页表地址转换示例"></a>页表地址转换示例</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220521174043826.png" alt="image-20220521174043826" style="zoom:67%;"><h4 id="页式存储管理机制的性能问题"><a href="#页式存储管理机制的性能问题" class="headerlink" title="页式存储管理机制的性能问题"></a>页式存储管理机制的性能问题</h4><p>内存访问性能问题</p><ul><li>访问一个内存单元需要2次内存访问</li><li>第一次访问：获取页表项</li><li>第二次访问：访问数据</li></ul><p>页表大小问题：</p><ul><li>页表可能非常大</li><li>64位机器如果每页1024字节，那么一个页表的大小会是多少？</li></ul><p>如何处理？</p><ul><li>&#x3D;&#x3D;缓存（Caching）&#x3D;&#x3D;</li><li>间接（Indirection）访问</li></ul><blockquote><p>页表大小问题：假设64位机器每页1024，就有2^54个页，假设每个页表项大小只有64位，8字节，那么所以会占用2^57的空间</p><p>如何处理：</p><p>缓存：由于访问有相邻性，可以一次取出相邻数据或者可能下一次会用的数据放在缓存中，后面会将到的快表</p><p>间接访问：页表很大，将页表在分为子表，后面会讲的多级页表</p></blockquote><h2 id="5、快表和多级页表"><a href="#5、快表和多级页表" class="headerlink" title="5、快表和多级页表"></a>5、快表和多级页表</h2><h4 id="快表（TLB）"><a href="#快表（TLB）" class="headerlink" title="快表（TLB）"></a>快表（TLB）</h4><p>缓存近期访问的页表项</p><ul><li>TLB使用关联存储（associative memory）实现，具备快速访问性能</li><li>如果TLB命中，物理页号可以很快被获取</li><li>如果TLB未命中，对应的表项被更新到TLB中</li></ul><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220906102239585.png" alt="image-20220906102239585" style="zoom: 80%;"><h4 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220521185452168.png" alt="image-20220521185452168" style="zoom: 50%;"><blockquote><p>多级页表并未减少页表的大小，但是在实际运行期间，有许多页表是用不到的，那么我们通过存在位判断并将其删除，这就达到大幅度减少页表大小的效果</p></blockquote><h4 id="二级页表实例"><a href="#二级页表实例" class="headerlink" title="二级页表实例"></a>二级页表实例</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220521185911680.png" alt="image-20220521185911680" style="zoom:50%;"><blockquote><p>一级页表的首地址存在CR3寄存器中，首地址 + p1（页内偏移）得到二级页表的首地址 ，再将其加p2得到内存中页的首地址加偏移量o得到访问位置</p></blockquote><h2 id="6、反置页表"><a href="#6、反置页表" class="headerlink" title="6、反置页表"></a>6、反置页表</h2><h4 id="大地址空间问题"><a href="#大地址空间问题" class="headerlink" title="大地址空间问题"></a>大地址空间问题</h4><p>对于大地址空间（64-bits）系统，多级页表变得&#x3D;&#x3D;繁琐&#x3D;&#x3D;</p><ul><li>比如：5级页表</li><li>逻辑（虚拟）地址空间增长速度快于物理地址空间</li></ul><p>页寄存器和反置页面的思路</p><ul><li>不让页表与逻辑地址空间的大小相对应</li><li>让页表与物理地址空间的大小相对应</li></ul><h4 id="页寄存器"><a href="#页寄存器" class="headerlink" title="页寄存器"></a>页寄存器</h4><p>每个帧与一个页寄存器（Page Register）关联，寄存器内容也括</p><ul><li>使用位（Residence bit）:此是否被进程占用</li><li>占用页号（Occupier）：对应的页号p</li><li>保护位（Protection bits）</li></ul><p>页寄存器示例</p><ul><li>物理内存大小：4096 * 4096&#x3D;4K * 4KB&#x3D;16MB</li><li>页面大小：4096bytes&#x3D;4KB</li><li>页顿数：4096&#x3D;4K</li><li>页寄存器使用的空间（假设每个页寄存器占8字节）<ul><li>N8 * 4096&#x3D;32 Kbytes</li></ul></li><li>页寄存器带来的额外开销<ul><li>32K &#x2F; 16M&#x3D;0.2%（大约）</li></ul></li><li>虚拟内存的大小：任意</li></ul><h4 id="页寄存器方案的特征"><a href="#页寄存器方案的特征" class="headerlink" title="页寄存器方案的特征"></a>页寄存器方案的特征</h4><p>优点</p><ul><li>页表大小相对于物理内存而言很小</li><li>页表大小与逻辑地址空间大小无关</li></ul><p>缺点</p><ul><li>页表信息对调后，需要依据帧号可找页号</li><li>在页寄存器中搜索逻辑地址中的页号</li></ul><h4 id="页寄存器中的地址转换"><a href="#页寄存器中的地址转换" class="headerlink" title="页寄存器中的地址转换"></a>页寄存器中的地址转换</h4><p>CPU生成的逻辑地址如何找对应的物理地址？</p><ul><li>对逻辑地址进行Hash映射，以减少搜索范围</li><li>需要解决可能的冲突</li></ul><p>用快表缓存页表项后的页寄存器搜索步骤</p><ul><li>对逻辑地址进行Hash变换</li><li>在快表中查找对应页表项</li><li>有冲突时遍历冲突项链表</li><li>查找失败时，产生异常</li></ul><p>快表的限制</p><ul><li>快表的容量限制</li><li>快表的功耗限制（Strong ARM上快表功耗占27%）</li></ul><h4 id="反置页表"><a href="#反置页表" class="headerlink" title="反置页表"></a>反置页表</h4><p>基于Hash映射值查找对应页表项中的帧号</p><ul><li>进程标识与页号的Hash值可能有冲突</li><li>页表项中包括保护位、修改位、访问位和存在位等标识</li></ul><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220906102650576.png" alt="image-20220906102650576" style="zoom:67%;"><p>反置页表的背景：</p><ul><li>为了减少页表所占用的空间，因为每个进程都要分配一个页表，当同时存在多个进程时，页表在内存中的占用会很多，造成内存资源的浪费</li></ul><p>反置页表的实现：</p><p>反置页表不依据进程的逻辑页号来生成页表，而是依据进程在内存的物理页号来组织的，即一个系统中大多数情况下都只存在一个反向页表，通过<strong>逻辑页号+进程ID</strong>进行HASH，通过链接指针来得到对应的帧号（物理页号）</p><h4 id="反置页表的hash冲突"><a href="#反置页表的hash冲突" class="headerlink" title="反置页表的hash冲突"></a>反置页表的hash冲突</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220521192158418.png" alt="image-20220521192158418" style="zoom: 50%;"><p>逻辑地址+进程ID进行hash后，找到hash值对应的反向页表的索引项，PID和页号与hash前的一样则不冲突，不一样则产生冲突，根据链接指针跳转，继续比较，直到找到为至。</p><h2 id="7、段页式存储管理"><a href="#7、段页式存储管理" class="headerlink" title="7、段页式存储管理"></a>7、段页式存储管理</h2><h4 id="段页式存储管理"><a href="#段页式存储管理" class="headerlink" title="段页式存储管理"></a>段页式存储管理</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220521193539938.png" alt="image-20220521193539938" style="zoom:67%;"><p>段式存储在内存保护方面有优势，页式存储在内存利用和优化转移到后备存储方面有优势</p><h4 id="段页式存储管理中内存共享"><a href="#段页式存储管理中内存共享" class="headerlink" title="段页式存储管理中内存共享"></a>段页式存储管理中内存共享</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220521194247188.png" alt="image-20220521194247188" style="zoom:67%;"><p>非连续的存储引入页和页表，随着页表的引入也带来了很多问题，又引入快表、多级页表、反置页表、来解决了这些问题</p><h1 id="五、虚拟存储概念"><a href="#五、虚拟存储概念" class="headerlink" title="五、虚拟存储概念"></a>五、虚拟存储概念</h1><h2 id="1、虚拟存储的需求背景"><a href="#1、虚拟存储的需求背景" class="headerlink" title="1、虚拟存储的需求背景"></a>1、虚拟存储的需求背景</h2><h4 id="虚拟存储的概述"><a href="#虚拟存储的概述" class="headerlink" title="虚拟存储的概述"></a>虚拟存储的概述</h4><p>前面讲的存储管理方式都是将一个进程内容全部装入内存才去运行</p><ul><li><p>当作业占用的空间很大时，超过了内存的空间，致使该作业无法运行</p></li><li><p>当有大量作业需要运行时，内存容量不足以容纳所有作业，只能将少数作业装入内存运行，将其他大量作业驻留外存中等待</p></li></ul><p>解决方法：</p><ul><li>扩大内存容量</li><li>从逻辑上扩充内存容量，即虚拟存储技术</li></ul><h4 id="增长迅速的存储需求"><a href="#增长迅速的存储需求" class="headerlink" title="增长迅速的存储需求"></a>增长迅速的存储需求</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220521200506021.png" alt="image-20220521200506021" style="zoom:50%;"><h4 id="存储层次结构"><a href="#存储层次结构" class="headerlink" title="存储层次结构"></a>存储层次结构</h4><p>理想中的存储器</p><ul><li>容量更大、速度更快、价格更便宜的非易失性存储器</li></ul><p>实际中的存储器</p><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220906102801235.png" alt="image-20220906102801235" style="zoom: 67%;"><h4 id="操作系统的存储抽象"><a href="#操作系统的存储抽象" class="headerlink" title="操作系统的存储抽象"></a>操作系统的存储抽象</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220521200923911.png" alt="image-20220521200923911" style="zoom: 50%;"><p>存储介质是多种多样的，如果直接让用户使用这里存储介质的话，那么写出来的程序通用性就会很受限制，所以使用操作系统进行抽象，这种映射关系由操作系统自动来做，用户见到的空间就是上面抽象到的地址空间，这样通用性就会不错</p><h4 id="虚拟存储的需求"><a href="#虚拟存储的需求" class="headerlink" title="虚拟存储的需求"></a>虚拟存储的需求</h4><p>计算机系统时常出现&#x3D;&#x3D;内存空间不够用&#x3D;&#x3D;</p><ul><li><p>覆盖（overlay）</p><p>应用程序&#x3D;&#x3D;手动&#x3D;&#x3D;把需要的指令和数据保存在内存中</p></li><li><p>交换（swapping）</p><p>操作系统&#x3D;&#x3D;自动&#x3D;&#x3D;把暂时不能执行的程序保存到外存中</p></li><li><p>虚拟存储</p><p>在有限容量的内存中，以页为单位&#x3D;&#x3D;自动&#x3D;&#x3D;装入&#x3D;&#x3D;更多更大&#x3D;&#x3D;的程序</p></li></ul><h2 id="2、覆盖和交换"><a href="#2、覆盖和交换" class="headerlink" title="2、覆盖和交换"></a>2、覆盖和交换</h2><h4 id="覆盖技术"><a href="#覆盖技术" class="headerlink" title="覆盖技术"></a>覆盖技术</h4><p>目标</p><ul><li>在较小的可用内存中运行较大的程序</li></ul><p>方法</p><ul><li><p>依据程序逻辑结构，将程序划分为&#x3D;&#x3D;若干功能相对独立&#x3D;&#x3D;<br>的模块</p></li><li><p>将不会同时执行的模块&#x3D;&#x3D;共享同一块内存&#x3D;&#x3D;区域</p><p>必要部分（常用功能）的代码和数据常驻内存</p><p>可选部分（不常用功能）放在其他程序模块中，只在需要用到时装入内存</p><p>不存在调用关系的模块可相互覆盖，共用同一块内存区域</p></li></ul><h4 id="覆盖技术实例"><a href="#覆盖技术实例" class="headerlink" title="覆盖技术实例"></a>覆盖技术实例</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220521203255864.png" alt="image-20220521203255864" style="zoom:50%;"><h4 id="覆盖技术的不足"><a href="#覆盖技术的不足" class="headerlink" title="覆盖技术的不足"></a>覆盖技术的不足</h4><p>增加编程困难</p><ul><li>需程序员划分功能模块，并确定模块间的覆盖关系</li><li>增加了编程的复杂度</li></ul><p>增加执行时间</p><ul><li>从外存装入覆盖模块</li><li>时间换空间</li></ul><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220906103209555.png" alt="image-20220906103209555" style="zoom:67%;"><h4 id="交换技术"><a href="#交换技术" class="headerlink" title="交换技术"></a>交换技术</h4><p>目标</p><ul><li>增加正在运行或需要运行的程序的内存</li></ul><p>实现方法</p><ul><li><p>可将暂时不能运行的程序放到外存</p></li><li><p>换入换出的基本单位</p><p>整个进程的地址空间</p></li><li><p>换出（swapout）</p><p>把一个进程的整个地址空间保存到外存</p></li><li><p>换入（swapin）</p><p>将外存中某进程的地址空间读入到内存</p></li></ul><blockquote><p>以进程为单位的交换技术</p></blockquote><h4 id="交换技术面临的问题"><a href="#交换技术面临的问题" class="headerlink" title="交换技术面临的问题"></a>交换技术面临的问题</h4><p>交换时机：何时需要发生交换？</p><ul><li>只当内存空间不够或有不够的可能时换出</li></ul><p>交换区大小</p><ul><li>存放所有用户进程的所有内存映像的接贝</li></ul><p>程序换入时的重定位：换出后再换入时要放在原处吗？</p><ul><li>采用动态地址映射的方法</li></ul><h3 id="覆盖和交换技术的比较"><a href="#覆盖和交换技术的比较" class="headerlink" title="覆盖和交换技术的比较"></a>覆盖和交换技术的比较</h3><p>覆盖</p><ul><li>只能发生在没有调用关系的模块间</li><li>程序员须给出模块间的逻辑覆盖结构</li><li>发生在运行程序的内部模块间</li></ul><p>交换</p><ul><li>以进程为单位</li><li>不需要模块间的逻辑覆盖结构</li><li>发生在内存进程间</li></ul><blockquote><p>交换技术是可以由操作系统来做的，覆盖技术对于操作系统来说还是有一定难度</p></blockquote><h2 id="3、局部性原理"><a href="#3、局部性原理" class="headerlink" title="3、局部性原理"></a>3、局部性原理</h2><h4 id="虚拟存储技术的目标"><a href="#虚拟存储技术的目标" class="headerlink" title="虚拟存储技术的目标"></a>虚拟存储技术的目标</h4><p><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220906103436316.png" alt="image-20220906103436316"></p><p>只把部分程序放到内存中，从而运行比物理内存大的程序</p><ul><li>由操作系统自动完成，无需程序员的干涉</li></ul><p>实现进程在内存与外存之间的交换，从而获得更多的空闲内存空间</p><ul><li>在内存和外存之间只交换进程的部分内容</li></ul><h4 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h4><p>程序在执行过程中的一个较短时期，所执行的指令地址和指令的操作数地址，分别局限于一定区域</p><ul><li><p>时间局部性</p><p>一条指令的一次执行和下次执行，一个数据的一次访问和下次访问都集中在一个较短时期内</p></li><li><p>空间局部性</p><p>当前指令和邻近的几条指令，当前访问的数据和邻近的几个数据都集中在一个较小区域内</p></li><li><p>分支局部性</p><p>一条跳转指令的两次执行，很可能跳到相同的内存位置</p></li><li><p>局部性原理的意义</p><p>从理论上来说，虚拟存储技术是能够实现的，而且可取得满意的效果</p></li></ul><h4 id="局部性特征举例"><a href="#局部性特征举例" class="headerlink" title="局部性特征举例"></a>局部性特征举例</h4><p>例子：页面大小为4K，分配给每个进程的物理页面数为1。在一个进程中，定义了如下的二维数组<br>int A [ 1024 ] [ 1024 ]，该数组按行存放在内存，<br>每一行放在一个页面中。</p><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220906103712904.png" alt="image-20220906103712904" style="zoom:67%;"><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220521210317046.png" alt="image-20220521210317046" style="zoom:50%;"><h2 id="4、虚拟存储概念"><a href="#4、虚拟存储概念" class="headerlink" title="4、虚拟存储概念"></a>4、虚拟存储概念</h2><h4 id="虚拟存储的基本概念"><a href="#虚拟存储的基本概念" class="headerlink" title="虚拟存储的基本概念"></a>虚拟存储的基本概念</h4><p>思路</p><ul><li>将不常用的部分内存块暂存到外存</li></ul><p>原理</p><ul><li><p>装载程序时</p><p>&#x3D;&#x3D;只将当前指令执行需要的部分页面或段装入内存&#x3D;&#x3D;</p></li><li><p>指令执行中需要的指令或数据不在内存（称为缺页或缺段）时</p><p>&#x3D;&#x3D;处理器通知操作系统将相应的页面或段调入内存&#x3D;&#x3D;</p></li><li><p>操作系统将内存中暂时不用的页面或段保存到外存</p></li></ul><p>实现方式</p><ul><li>虚拟页式存储</li><li>虚拟段式存储</li></ul><blockquote><p>后面讲的置换算法研究操作系统怎么讲内存中暂时不用的页面或段保存到外存</p></blockquote><h4 id="虚拟存储的基本特征"><a href="#虚拟存储的基本特征" class="headerlink" title="虚拟存储的基本特征"></a>虚拟存储的基本特征</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220906103436316.png" alt="image-20220906103436316" style="zoom:67%;"><p>不连续性</p><ul><li>物理内存分配非连续</li><li>虚拟地址空间使用非连续</li></ul><p>大用户空间</p><ul><li>提供给用户的虚拟内存可大于实际的物理内存</li></ul><p>部分交换</p><ul><li>虚拟存储只对部分虚拟地址空间进行调入和调出</li></ul><blockquote><p>虚拟存储改进了原来的覆盖和交换技术</p><p>改进交换技术：允许部分虚拟地址换进换出，而不是整个作业</p></blockquote><h4 id="虚拟存储的支持技术"><a href="#虚拟存储的支持技术" class="headerlink" title="虚拟存储的支持技术"></a>虚拟存储的支持技术</h4><p>硬件</p><ul><li>页式或短时存储中的地址转换机制</li></ul><p>操作系统</p><ul><li>管理内存和外存间页面或段的换入和换出</li></ul><h2 id="5、虚拟页式存储"><a href="#5、虚拟页式存储" class="headerlink" title="5、虚拟页式存储"></a>5、虚拟页式存储</h2><h4 id="虚拟页式存储管理"><a href="#虚拟页式存储管理" class="headerlink" title="虚拟页式存储管理"></a>虚拟页式存储管理</h4><p>在页式存储管理的基础上，增加请求调页和页面置换</p><p>思路:</p><ul><li>当用户程序要装载到内存运行时，只装入部分页面，就启动程序运行</li><li>进程在运行中发现有需要的代码或数据不在内存时，则向系统发出缺页异常请求</li><li>操作系统在处理缺页异常时，将外存中相应的页面调入内存，使得进程能继续运行</li></ul><h4 id="虚拟页式存储中的地址转换"><a href="#虚拟页式存储中的地址转换" class="headerlink" title="虚拟页式存储中的地址转换"></a>虚拟页式存储中的地址转换</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220522131245170.png" alt="image-20220522131245170" style="zoom: 50%;"><blockquote><p>不同于之前的存储管理，这里加上了标志位，表示该页号是否存在内存中，不存在则发生缺页异常，有操作系统接管进行处理，即将该页从外存中调入，将标志位设置为有效</p></blockquote><h4 id="虚拟页式存储中的页表项结构"><a href="#虚拟页式存储中的页表项结构" class="headerlink" title="虚拟页式存储中的页表项结构"></a>虚拟页式存储中的页表项结构</h4><p><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220906104152938.png" alt="image-20220906104152938"></p><p>驻留位：表示该页是否在内存</p><p>修改位：表示在内存中的该页是否被修改过</p><p>访问位：表示该页面是否被访问过（读或写）</p><p>保护位：表示该页的允许访问方式</p><ul><li>只读、可读写、可执行等</li></ul><blockquote><p>修改位：是否被修改，判断将该页替换后是否要写回内存还是删除</p></blockquote><h4 id="虚拟页式存储示例"><a href="#虚拟页式存储示例" class="headerlink" title="虚拟页式存储示例"></a>虚拟页式存储示例</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220522132449138.png" alt="image-20220522132449138" style="zoom:50%;"><h4 id="X86页表结构"><a href="#X86页表结构" class="headerlink" title="X86页表结构"></a>X86页表结构</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220522132756973.png" alt="image-20220522132756973" style="zoom:50%;"><p>这里的访问方式和页式存储没有差别，差别在于页表项多了许多标志位</p><h4 id="X86页表项结构"><a href="#X86页表项结构" class="headerlink" title="X86页表项结构"></a>X86页表项结构</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220522133259935.png" alt="image-20220522133259935" style="zoom:67%;"><h2 id="6、缺页异常"><a href="#6、缺页异常" class="headerlink" title="6、缺页异常"></a>6、缺页异常</h2><h4 id="缺页异常（缺页中断）的处理流程"><a href="#缺页异常（缺页中断）的处理流程" class="headerlink" title="缺页异常（缺页中断）的处理流程"></a>缺页异常（缺页中断）的处理流程</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220522133943566.png" alt="image-20220522133943566" style="zoom:67%;"><h4 id="虚拟页式存储中的外存管理"><a href="#虚拟页式存储中的外存管理" class="headerlink" title="虚拟页式存储中的外存管理"></a>虚拟页式存储中的外存管理</h4><p>在何处保存未被映射的页？</p><ul><li><p>应能方便地找到在外存中的页面内容</p></li><li><p>交换空间（磁盘或者文件）</p><p>&#x3D;&#x3D;采用特殊格式存储未被映射的页面&#x3D;&#x3D;</p></li></ul><p>虚拟页式存储中的外存选择</p><ul><li>代码段：可执行二进制文件</li><li>动态加载的共享库程序段：动态调用的库文件</li><li>其它段：交换空间</li></ul><blockquote><p>在外存以两种方式来存放文件：</p><ul><li>专门做一个分区来进行存放（文件区）</li><li>用一个特殊格式的文件来进行存放（对换区）</li></ul><p>文件区采用离散分配方式，对换区采用连续分配方式，所以对换区数据存取（磁盘I&#x2F;O）速度比文件区高。</p><p>外存的存储选择：</p><ul><li><p>可能会被修改的文件放到对换区，不会被修改的文件放到文件区</p></li><li><p>代码段和动态加载的共享库程序段都是直接指向对应的文件，一般不会去修改它，不用复制到交换空间去</p></li></ul></blockquote><h4 id="虚拟页式存储管理的性能"><a href="#虚拟页式存储管理的性能" class="headerlink" title="虚拟页式存储管理的性能"></a>虚拟页式存储管理的性能</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220522162531222.png" alt="image-20220522162531222" style="zoom: 50%;"><h1 id="六、页面置换算法"><a href="#六、页面置换算法" class="headerlink" title="六、页面置换算法"></a>六、页面置换算法</h1><h2 id="1、页面置换算法的概念"><a href="#1、页面置换算法的概念" class="headerlink" title="1、页面置换算法的概念"></a>1、页面置换算法的概念</h2><h4 id="置换算法的功能、目标和页面锁定"><a href="#置换算法的功能、目标和页面锁定" class="headerlink" title="置换算法的功能、目标和页面锁定"></a>置换算法的功能、目标和页面锁定</h4><p>功能</p><ul><li>当出现缺页异常，需调入新页面而内存已满时，置换算法&#x3D;&#x3D;选择被置换的物理页面&#x3D;&#x3D;</li></ul><p>设计目标</p><ul><li>尽可能&#x3D;&#x3D;减少页面的调入调出次数&#x3D;&#x3D;</li><li>把未来不再访问或短期内不访问的页面调出</li></ul><p>页面锁定（frame locking）</p><ul><li>描述必须常驻内存的逻辑页面</li><li>操作系统的关键部分</li><li>要求响应速度的代码和数据</li><li>页表中的锁定标志位（lock bit）</li></ul><h4 id="置换算法的评价方法"><a href="#置换算法的评价方法" class="headerlink" title="置换算法的评价方法"></a>置换算法的评价方法</h4><p>记录进程访问内存的页面轨迹</p><ul><li>举例：虚拟地址访问用（页号，位移）表示<br>（3,0），（1,9），（4,1），（2,1），（5,3），（2,0），（1,9）（2,4)，（3,1），（4.8）</li><li>对应的页面轨迹<br>3,1,4,2,5,2,1,2,3.4<br>替换如c，a，d，b，e，b，a，b，c，d</li></ul><p>评价方法</p><ul><li>模拟页面置换行为，记录产生缺页的次数</li><li>更少的缺页，更好的性能</li></ul><h4 id="页面置换算法分类"><a href="#页面置换算法分类" class="headerlink" title="页面置换算法分类"></a>页面置换算法分类</h4><p>局部页面置换算法</p><ul><li>置换页面的选择范围仅限于当前进程占用的物理页面内</li><li>最优算法、先进先出算法、最近最久未使用算法</li><li>时钟算法、最不常用算法</li></ul><p>全局页面置换算法</p><ul><li>置换页面的选择范围是所有可换出的物理页面</li><li>工作集算法、缺页率算法</li></ul><h2 id="2、最优算法、先进先出算法和最近最久未使用算法"><a href="#2、最优算法、先进先出算法和最近最久未使用算法" class="headerlink" title="2、最优算法、先进先出算法和最近最久未使用算法"></a>2、最优算法、先进先出算法和最近最久未使用算法</h2><h4 id="最优页面置换算法OPT"><a href="#最优页面置换算法OPT" class="headerlink" title="最优页面置换算法OPT"></a>最优页面置换算法OPT</h4><p>基本思路：</p><ul><li>置换在未来最长时间不访问的页面</li></ul><p>算法实现：</p><ul><li>缺页时，计算内存中每个逻辑页面的下一次访问时间</li><li>选择未来最长时间不访问页面</li></ul><p>算法特征：</p><ul><li>缺页最少，是理想情况</li><li>实际系统中<strong>无法实现</strong></li><li>无法预知每个页面在下次访问前的等待时间</li><li>作为置换算法的性能评价依据<ul><li>在模拟器上运行某个程序，并记录每一次的页面访问情况</li><li>第二遍运行时使用最优算法</li></ul></li></ul><blockquote><p>该算法在实际系统时无法实现的，但可以作为评判置换算法性能的依据</p></blockquote><h4 id="OPT算法示例"><a href="#OPT算法示例" class="headerlink" title="OPT算法示例"></a>OPT算法示例</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220522170323499.png" alt="image-20220522170323499" style="zoom: 67%;"><h4 id="先进先出算法FIFO"><a href="#先进先出算法FIFO" class="headerlink" title="先进先出算法FIFO"></a>先进先出算法FIFO</h4><p>思路</p><ul><li>选择<strong>在内存驻留时间最长</strong>的页面进行置换</li></ul><p>实现</p><ul><li>维护一个记录所有位于内存中的逻辑页面链表</li><li>链表元素<strong>按驻留内存的时间排序</strong>，链首最长，链尾最短</li><li>出现缺页时，选择链首页面进行置换，新页面加到链尾</li></ul><p>特征</p><ul><li>实现简单</li><li>性能较差，调出的页面可能是经常访问的</li><li>进程分配物理页面数增加时，缺页并不一定减少（Belady现象）</li><li>很少单独使用</li></ul><h4 id="FIFO算法示例"><a href="#FIFO算法示例" class="headerlink" title="FIFO算法示例"></a>FIFO算法示例</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220522171550635.png" alt="image-20220522171550635" style="zoom: 67%;"><h4 id="最近最未被使用算法LRU"><a href="#最近最未被使用算法LRU" class="headerlink" title="最近最未被使用算法LRU"></a>最近最未被使用算法LRU</h4><p>思路</p><ul><li><p>选择<strong>最长时间没有被引用</strong>的页面进行置换</p></li><li><p>如某些页面长时间未被访问，则它们在将来还可能会长时间不<br>会访问</p></li></ul><p>实现</p><ul><li>缺页时，计算内存中每个逻辑页面的<strong>上一次</strong>访问时间</li><li>选择<strong>上一次使用到当前时间最长的页面</strong></li></ul><p>特征</p><ul><li>最优置换算法的一种近似</li></ul><h4 id="LRU算法示例"><a href="#LRU算法示例" class="headerlink" title="LRU算法示例"></a>LRU算法示例</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220522172233044.png" alt="image-20220522172233044" style="zoom:67%;"><h4 id="LRU算法的可能实现方法"><a href="#LRU算法的可能实现方法" class="headerlink" title="LRU算法的可能实现方法"></a>LRU算法的可能实现方法</h4><p>页面链表</p><ul><li><p>系统维护一个按最近一次访问时间排序的页面链表</p><ul><li>&#x3D;&#x3D;链表首节点是最近刚刚使用过的页面&#x3D;&#x3D;</li><li>&#x3D;&#x3D;链表尾节点是最久未使用的页面&#x3D;&#x3D;</li></ul></li><li><p>访问内存时，找到相应页面，并把它移到链表之首</p></li><li><p>缺页时，置换链表尾节点的页面</p></li></ul><p>活动页面栈</p><ul><li>访问页面时，将此页号压入栈顶，并栈内相同的页号抽出</li><li>缺页时，置换栈底的页面</li></ul><p>特征</p><ul><li>开销比较大</li></ul><h4 id="用栈实现LRU算法"><a href="#用栈实现LRU算法" class="headerlink" title="用栈实现LRU算法"></a>用栈实现LRU算法</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220522173120350.png" alt="image-20220522173120350" style="zoom:67%;"><h2 id="3、时钟置换算法和最不常用算法"><a href="#3、时钟置换算法和最不常用算法" class="headerlink" title="3、时钟置换算法和最不常用算法"></a>3、时钟置换算法和最不常用算法</h2><h4 id="时钟置换算法Clock"><a href="#时钟置换算法Clock" class="headerlink" title="时钟置换算法Clock"></a>时钟置换算法Clock</h4><p>思路</p><ul><li>仅对页面的访问情况进行大致统计</li></ul><p>数据结构</p><ul><li>在页表项中增加<strong>访问位</strong>，描述页面在过去一段时间的内访问情况</li><li>各页面组织成<strong>环形链表</strong></li><li>*指针**指向最先调入的页面</li></ul><p>算法</p><ul><li>访问页面时，在页表项记录页面访问情况</li><li>缺页时，从指针处开始顺序查找未被访问的页面进行置换</li></ul><p>特征</p><ul><li>时钟算法是LRU和FIFO的折中</li></ul><blockquote><p>时钟算法是LRU和FIFO的折中，考虑过去使用情况没有LRU那么全面，但又不像FIFO不考虑</p><p>置换是将<strong>过去一段时间</strong>未被访问的进行置换，如果都没被访问就变成了FIFO</p></blockquote><h4 id="时钟置换算法的实现"><a href="#时钟置换算法的实现" class="headerlink" title="时钟置换算法的实现"></a>时钟置换算法的实现</h4><ul><li>页面装入内存时，访问位初始化为0</li><li>访问页面（读&#x2F;写）时，访问位置1</li><li>缺页时，从指针当前位置顺序检查环形链表<ul><li>访问位为0，则置换该页</li><li>访问位为1，则访问位置0，并指针移动到下一个页面，直到找到可置换的页思路<br>D减少修改页的缺页处理开销<br>算法<br>在页面中增加修改位，并在访问时进行相应修改<br>缺页时，修改页面标志位，以跳过有修改的页面</li><li>面</li></ul></li></ul><h4 id="时钟页面置换示例"><a href="#时钟页面置换示例" class="headerlink" title="时钟页面置换示例"></a>时钟页面置换示例</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220522175356749.png" alt="image-20220522175356749" style="zoom:67%;"><p>第六步的图错误：b应该是1</p><p>思路：</p><p>未缺页时，将该页置为1，指针向前移动一格</p><p>缺页时，从当前指针寻找0，途径1时将其置为0，找到0后将其置换并置为1，指针向前移动一格</p><h4 id="改进的时钟置换算法"><a href="#改进的时钟置换算法" class="headerlink" title="改进的时钟置换算法"></a>改进的时钟置换算法</h4><p>思路</p><ul><li>减少修改页的缺页处理开销</li></ul><p>算法</p><ul><li>在页面中增加修改位，并在访问时进行相应修改</li><li>缺页时，修改页面标志位，以跳过有修改的页面</li></ul><p><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220904094125613.png" alt="image-20220904094125613"></p><blockquote><p>不同于之前的置换页时，换进写出的开销，增加修改位，减少换进写出的开销</p><p>用修改位和访问位表示读写</p><ul><li>访问位为0，修改位为0时在将其置换</li><li>当访问位为1，修改位为1时，将访问位改0，修改位不变，不写出不置换，指针后移</li><li>当访问位为0，修改位为1时，将其修改位置为0，同时写出不置换，指针后移</li></ul></blockquote><h4 id="改进的时钟置换算法示例"><a href="#改进的时钟置换算法示例" class="headerlink" title="改进的时钟置换算法示例"></a>改进的时钟置换算法示例</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220522180910733.png" alt="image-20220522180910733" style="zoom: 67%;"><h4 id="最不常用算法LFU"><a href="#最不常用算法LFU" class="headerlink" title="最不常用算法LFU"></a>最不常用算法LFU</h4><p>思路</p><ul><li>缺页时，置换访问次数最少的页面</li></ul><p>实现</p><ul><li>每个页面设置一个访问计数</li><li><strong>访问页面时，访问计数加1</strong></li><li>缺页时，置换计数最小的页面</li></ul><p>特征</p><ul><li>算法开销大</li><li>开始时频繁使用，但以后不使用的页面很难置换<ul><li><strong>解决方法：计数定期右移</strong></li></ul></li></ul><p>LRU和LFU的区别</p><ul><li>LRU关注<strong>多久未访问</strong>，时间越短越好</li><li>LFU关注<strong>访问次数</strong>，次数越多越好</li></ul><h4 id="LFU算法示例"><a href="#LFU算法示例" class="headerlink" title="LFU算法示例"></a>LFU算法示例</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220522182312066.png" alt="image-20220522182312066" style="zoom: 67%;"><h2 id="4、Belady现象和局部置换算法比较"><a href="#4、Belady现象和局部置换算法比较" class="headerlink" title="4、Belady现象和局部置换算法比较"></a>4、Belady现象和局部置换算法比较</h2><h4 id="Belady现象"><a href="#Belady现象" class="headerlink" title="Belady现象"></a>Belady现象</h4><p>现象</p><ul><li>采用FIFO等算法时，可能出现分配的物理页面数增加，缺页次数反而升高的异常现象</li></ul><p>原因</p><ul><li><p>FIFO算法的置换特征与进程访问内存的动态特征矛盾</p></li><li><p>被它置换出去的页面并不一定是进程近期不会访问的</p></li></ul><p>思考</p><ul><li>哪些置换算法没有Belady现象？</li></ul><h4 id="FIFO算法有Belady现象"><a href="#FIFO算法有Belady现象" class="headerlink" title="FIFO算法有Belady现象"></a>FIFO算法有Belady现象</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220522183010772.png" alt="image-20220522183010772" style="zoom: 50%;"><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220522183049507.png" alt="image-20220522183049507" style="zoom: 50%;"><h4 id="LRU算法没有Belady现象"><a href="#LRU算法没有Belady现象" class="headerlink" title="LRU算法没有Belady现象"></a>LRU算法没有Belady现象</h4><p><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220522183217511.png" alt="image-20220522183217511"></p><h4 id="LRU、FIFO和Clock算法比较"><a href="#LRU、FIFO和Clock算法比较" class="headerlink" title="LRU、FIFO和Clock算法比较"></a>LRU、FIFO和Clock算法比较</h4><p>1）LRU算法和FIFO本质上都是先进先出的思路</p><ul><li>LRU依据页面的最近访问时间排序</li><li>LRU需要动态地调整顺序</li><li>FIFO依据页面进入内存的时间排序</li><li>FIFO的页面进入时间是固定不变的</li></ul><p>2）LRU可退化成FIFO</p><ul><li>如页面进入内存后没有被访问，最近访问时间与进入内存的时间相同</li><li>例如：给进程分配3个物理页面，逻辑页面的访问顺序为 1、2、3、4、5、6、1、2、3…</li></ul><p>3）LRU算法性能较好，但系统开销较大</p><p>4）FIFO算法系统开销较小，会发生Belady现象</p><p>5）Clock算法是它们的折中</p><ul><li>页面访问时，不动态调整页面在链表中的顺序，仅做标记</li><li>缺页时，再把它移动到链表末尾</li></ul><p>6）对于未被访问的页面，Clock和LRU算法的表现一样好</p><p>7）对于被访问过的页面，Clock算法不能记录准确访问顺序，而LRU算法可以</p><h2 id="5、工作集置换算法"><a href="#5、工作集置换算法" class="headerlink" title="5、工作集置换算法"></a>5、工作集置换算法</h2><h4 id="CPU利用率和并发进程数的关系"><a href="#CPU利用率和并发进程数的关系" class="headerlink" title="CPU利用率和并发进程数的关系"></a>CPU利用率和并发进程数的关系</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220904100513096.png" alt="image-20220904100513096" style="zoom:50%;"><p>CPU利用率与并发进程数存在相互促进和制约的关系</p><ul><li>进程数少时，提高并发进程数，可提高CPU利用率</li><li>并发进程导致内存访问增加</li><li>并发进程的内存访问会降低了访存的局部性特征</li><li>局部性特征的下降会导致缺页率上升和CPU利用率下降</li></ul><blockquote><p>当并发进程数量足够多时，局部性特征就会减少，导致进程频繁的换进换出，CPU效率下降</p></blockquote><h4 id="全局置换算法"><a href="#全局置换算法" class="headerlink" title="全局置换算法"></a>全局置换算法</h4><p>思路</p><ul><li>全局置换算法为进程分配<strong>可变数目</strong>的物理页面</li></ul><p>全局置换算法要解决的问题</p><ul><li>进程在不同阶段的内存需求是变化的</li><li>分配给进程的内存也需要在不同阶段有所变化</li><li>全局置换算法需要确定分配给进程的物理页面数</li></ul><blockquote><p>由于缺页率和进程所获得的物理页面成反比关系，但是当进程获得的物理页面到达一定数目，在增加1时缺页率不在明显，所以我们要动态分配给进程合适的物理页面数</p></blockquote><h4 id="工作集"><a href="#工作集" class="headerlink" title="工作集"></a>工作集</h4><p>一个进程当前正在使用的逻辑页面集合，可表示为二元函数W（t,△)</p><ul><li>t是当前的执行时刻</li><li>A称为工作集窗口（working-setwindow），即一个定长的页面访问时间窗口</li><li>W（t,△)是指在当前时刻t 前的△时间窗口中的所有访问页面所组成的集合</li><li>|W（t,△)|指工作集的大小，即页面数目</li></ul><blockquote><p>工作集：是指在某段时间间隔里，进程实际所要访问页面的集合</p></blockquote><h4 id="进程的工作集示例"><a href="#进程的工作集示例" class="headerlink" title="进程的工作集示例"></a>进程的工作集示例</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220522193632984.png" alt="image-20220522193632984" style="zoom:50%;"><h4 id="工作集变化"><a href="#工作集变化" class="headerlink" title="工作集变化"></a>工作集变化</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220904101713948.png" alt="image-20220904101713948" style="zoom:50%;"><ul><li>进程开始执行后，随着访问新页面逐步建立较稳定的工作集</li><li>当内存访问的局部性区域的位置<strong>大致稳定</strong>时，工作集大小也大致稳定</li><li>局部性区域的位置改变时，工作集<strong>快速扩张和收缩过渡</strong>到下一个稳定值</li></ul><h4 id="常驻集"><a href="#常驻集" class="headerlink" title="常驻集"></a>常驻集</h4><p>在当前时刻，进程实际驻留在内存当中的页面集合</p><ul><li>工作集与常驻集的关系<ul><li>工作集是进程在运行过程中固有的性质</li><li>常驻集取决于系统分配给进程的物理页面数目和页面置换算法</li></ul></li><li>缺页率与常驻集的关系<ul><li>常驻集 &gt;&#x3D; 工作集时，缺页较少</li><li>工作集发生剧烈变动（过渡）时，缺页较多</li><li>进程常驻集大小达到一定数目后，缺页率也不会明显下降</li></ul></li></ul><h4 id="工作集置换算法"><a href="#工作集置换算法" class="headerlink" title="工作集置换算法"></a>工作集置换算法</h4><p>思路</p><ul><li>换出不在工作集中的页面（在一段时间内，最久未被访问的页面）</li></ul><p>窗口大小</p><ul><li>当前时刻前T个内存访问的页引用是工作集，被称为窗口大小</li></ul><p>实现方法</p><ul><li>访存链表：维护窗口内的访存页面链表</li><li>每次访存时，换出不在工作集的页面：更新访存链表</li><li><strong>缺页时，换入页面；更新访存链表</strong></li></ul><h3 id="工作集置换算法示例"><a href="#工作集置换算法示例" class="headerlink" title="工作集置换算法示例"></a>工作集置换算法示例</h3><p><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220522200710250.png" alt="image-20220522200710250"></p><blockquote><p>窗口大小为4，t表示最近访问时间，假设开始之前就有三个页面并有相应的 t，当最近访问时间t为4时将其移出或换出</p><p>在每次访存时都要去维护链表数据结构，开销还是很大的</p></blockquote><h2 id="6、缺页率置换算法"><a href="#6、缺页率置换算法" class="headerlink" title="6、缺页率置换算法"></a>6、缺页率置换算法</h2><h4 id="缺页率"><a href="#缺页率" class="headerlink" title="缺页率"></a>缺页率</h4><p>缺页次数 &#x2F; 内存访问次数 或 缺页平均时间间隔的倒数</p><ul><li>影响缺页率的因素<ul><li>页面置换算法</li><li>分配给进程的物理页面数目</li><li>页面大小</li><li>程序的编写方法</li></ul></li></ul><h4 id="缺页率置换算法"><a href="#缺页率置换算法" class="headerlink" title="缺页率置换算法"></a>缺页率置换算法</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220904103828611.png" alt="image-20220904103828611" style="zoom:50%;"><p>通过调节常驻集大小，使每个进程的缺页率保持在一个合理的范围内</p><ul><li>若进程缺页率过高，则增加常驻集以分配更多的物理页</li><li>若进程缺页率过低，则减少常驻集以减少它的物理页面</li></ul><blockquote><p>缺页率过高，CPU大多执行换进换出，CPU效率降低</p><p>缺页率过低，并发度降低，CPU利用率降低</p></blockquote><h4 id="缺页率置换算法的实现"><a href="#缺页率置换算法的实现" class="headerlink" title="缺页率置换算法的实现"></a>缺页率置换算法的实现</h4><ul><li>访存时，设置引用位标志</li><li>缺页时，计算从上次缺页时间 t_last 到现在 t_current 的时间间隔（T为窗口大小）<ul><li>如果 t_current - t_last &gt; T，则增加缺失页到常驻集中，置换常驻集中所有在 [ t_last , t_current  ] 时间内没有被引用的页</li><li>如果 t_current - t_last &lt;&#x3D; T，则只增加缺失页到常驻集中</li></ul></li></ul><h4 id="缺页率置换算法示例"><a href="#缺页率置换算法示例" class="headerlink" title="缺页率置换算法示例"></a>缺页率置换算法示例</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220522202824545.png" alt="image-20220522202824545" style="zoom: 67%;"><blockquote><p>1到4间隔大于2，减少间隔内未被引用的页面，4到6间隔等于2，加上该页面</p><p>缺页率置换算法和工作集置换算法的区别：</p><p>工作集算法在每一次访存时都判断该淘汰哪一个，开销较大</p><p>缺页率算法在缺页中断时在进行淘汰判断，缺页间隔足够大时，其中的页面相当于可以在加进去的，所以该算法更接近于工作集的那条曲线的</p></blockquote><h2 id="7、抖动和负载控制"><a href="#7、抖动和负载控制" class="headerlink" title="7、抖动和负载控制"></a>7、抖动和负载控制</h2><h4 id="抖动问题"><a href="#抖动问题" class="headerlink" title="抖动问题"></a>抖动问题</h4><p>抖动</p><ul><li>进程物理页面太少，不能包含工作集</li><li>造成大量缺页，频繁置换</li><li>进程运行速度变慢</li></ul><p>产生抖动的原因</p><ul><li>随着驻留内存的进程数目增加，分配给每个进程的物理页<br>面数不断减小，缺页率不断上升</li></ul><p>操作系统需在并发水平和缺页率之间达到一个平衡</p><ul><li>选择一个适当的进程数目和进程需要的物理页面数</li></ul><h4 id="负载控制"><a href="#负载控制" class="headerlink" title="负载控制"></a>负载控制</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220522204507588.png" alt="image-20220522204507588" style="zoom:50%;"><blockquote><p>找到合适并发进程数，即Nmax，但是找它是很麻烦的，通过平均缺页间隔时间除以缺页异常处理时间&#x3D;1，找到接近的一个并发进程数</p></blockquote><h1 id="七、进程和线程"><a href="#七、进程和线程" class="headerlink" title="七、进程和线程"></a>七、进程和线程</h1><h2 id="1、进程的概念"><a href="#1、进程的概念" class="headerlink" title="1、进程的概念"></a>1、进程的概念</h2><h4 id="实际操作系统中的进程"><a href="#实际操作系统中的进程" class="headerlink" title="实际操作系统中的进程"></a>实际操作系统中的进程</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220523115539251.png" alt="image-20220523115539251" style="zoom:50%;"><h4 id="进程的定义"><a href="#进程的定义" class="headerlink" title="进程的定义"></a>进程的定义</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220523115716354.png" alt="image-20220523115716354" style="zoom:50%;"><blockquote><p>进程利于程序在运行时操作系统的维护</p></blockquote><h4 id="内存中的进程"><a href="#内存中的进程" class="headerlink" title="内存中的进程"></a>内存中的进程</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220904110448599.png" alt="image-20220904110448599" style="zoom: 67%;"><blockquote><p>相对于程序而言，进程将其分为数据段、代码段和堆栈段，分段便于维护</p><p>堆栈段是在这两段之间，堆栈段能存放函数调用的地址和返回地址</p></blockquote><h3 id="进程的组成"><a href="#进程的组成" class="headerlink" title="进程的组成"></a>进程的组成</h3><p>进程包含了正在运行的一个程序的<strong>所有状态</strong>信息</p><ul><li>代码</li><li>数据</li><li>状态寄存器<ul><li>CPU状态CRO、指令指针IP</li></ul></li><li>通用寄存器<ul><li>AX、BX、CX….</li></ul></li><li>进程占用系统资源<ul><li>打开文件、已分配内存….</li></ul></li></ul><h4 id="进程的特点"><a href="#进程的特点" class="headerlink" title="进程的特点"></a>进程的特点</h4><p>动态性：</p><ul><li>可动态地创建、结束进程</li></ul><p>并发性：</p><ul><li>进程可以被独立调度并占用处理机执行</li></ul><p>独立性：</p><ul><li>不同进程的工作不互相影响</li></ul><p>制约性：</p><ul><li>因访问共享数据 &#x2F; 资源 或 进程间同步而产生制约</li></ul><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220523121151891.png" alt="image-20220523121151891" style="zoom:50%;"><blockquote><p>处理机一个时间点上只能执行一个进程，而从宏观上来看，一段时间间隔里他们是并发执行的</p></blockquote><h4 id="进程与程序的联系"><a href="#进程与程序的联系" class="headerlink" title="进程与程序的联系"></a>进程与程序的联系</h4><p>进程是操作系统处于执行状态程序的抽象</p><ul><li>程序&#x3D;文件（静态的可执行文件）</li><li>进程&#x3D;执行中的程序&#x3D;程序+执行状态</li></ul><p>同一个程序的多次执行过程对应为不同进程</p><ul><li>如命令“Is”的多次执行对应多个进程</li></ul><p>进程执行需要的资源</p><ul><li>内存：保存代码和数据</li><li>CPU：执行指令</li></ul><h3 id="进程与程序的区别"><a href="#进程与程序的区别" class="headerlink" title="进程与程序的区别"></a>进程与程序的区别</h3><p>进程是动态的，程序是静态的</p><ul><li>程序是有序代码的集合</li><li>进程是程序的执行，进程有核心态&#x2F;用户态</li></ul><p>进程是暂时的，程序的永久的</p><ul><li>进程是一个状态变化的过程</li><li>程序可长久保存</li></ul><p>进程与程序的组成不同</p><ul><li>进程的组成包括程序、数据和进程控制块</li></ul><h2 id="2、进程控制块"><a href="#2、进程控制块" class="headerlink" title="2、进程控制块"></a>2、进程控制块</h2><h4 id="进程控制块PCB"><a href="#进程控制块PCB" class="headerlink" title="进程控制块PCB"></a>进程控制块PCB</h4><p>操作系统管理控制进程运行所用的信息集合</p><ul><li>操作系统用PCB来描述进程的基本情况以及运行变化的过程</li><li>PCB是进程存在的唯一标志<ul><li>每个进程都在操作系统中有一个对应的PCB</li></ul></li></ul><h4 id="进程控制块的使用"><a href="#进程控制块的使用" class="headerlink" title="进程控制块的使用"></a>进程控制块的使用</h4><ul><li>进程创建<ul><li>生成该进程的PCB</li></ul></li><li>进程终止<ul><li>回收它的PCB</li></ul></li><li>进程的组织管理<ul><li>通过对PCB的组织管理来实现</li></ul></li></ul><blockquote><p>PCB具体包含什么信息？如何组织的？</p><p>进程的状态转换…..？</p></blockquote><h4 id="进程控制块"><a href="#进程控制块" class="headerlink" title="进程控制块"></a>进程控制块</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220523122613499.png" alt="image-20220523122613499" style="zoom:50%;"><h4 id="进程控制的信息"><a href="#进程控制的信息" class="headerlink" title="进程控制的信息"></a>进程控制的信息</h4><ul><li>调度和状态信息<ul><li>进程和处理机使用情况调链表<br>同一状态的进程其PCB成一链表，多个状态对应多个不<br>同的链表<br>D各状态的进程形成不同的链表：就绪链表、阻塞链表<br>索引表<br>同一状态的进程归入一个索引表（由索引指向PCB）<br>多个状态对应多个不同的索引表<br>D各状态的进行形成不同的索引表：就绪索引表、阻塞索引表</li><li>度</li></ul></li><li>进程间通信信息<ul><li>进程间通信相关的各种标识</li></ul></li><li>存储管理信息<ul><li>指向进程映像存储空间数据结构</li></ul></li><li>进程所用资源<ul><li>进程使用的系统资源，如打开文件等</li></ul></li><li>有关数据结构连接信息<ul><li>与PCB相关的进程队列</li></ul></li></ul><h4 id="进程控制块的组织"><a href="#进程控制块的组织" class="headerlink" title="进程控制块的组织"></a>进程控制块的组织</h4><p><strong>链表</strong></p><ul><li>同一状态的进程其PCB成一链表，多个状态对应多个不同的链表<ul><li>各状态的进程形成不同的链表：就绪链表、阻塞链表</li></ul></li></ul><p><strong>索引表</strong></p><ul><li>同一状态的进程归入一个索引表（由索引指向PCB），多个状态对应多个不同的索引表<ul><li>各状态的进行形成不同的索引表：就绪索引表、阻塞索引表</li></ul></li></ul><p><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220904112139628.png" alt="image-20220904112139628"></p><h2 id="3、进程状态"><a href="#3、进程状态" class="headerlink" title="3、进程状态"></a>3、进程状态</h2><h4 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220523123425476.png" alt="image-20220523123425476" style="zoom: 67%;"><blockquote><p>生成该进程的PCB，加入到就绪队列</p></blockquote><h4 id="进程的执行"><a href="#进程的执行" class="headerlink" title="进程的执行"></a>进程的执行</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220523123529729.png" alt="image-20220523123529729" style="zoom:67%;"><blockquote><p>如何选择：处理机调度算法会讲，如何调度处理机资源给进程</p></blockquote><h4 id="进程等待"><a href="#进程等待" class="headerlink" title="进程等待"></a>进程等待</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220523123823473.png" alt="image-20220523123823473" style="zoom: 50%;"><h4 id="进程抢占"><a href="#进程抢占" class="headerlink" title="进程抢占"></a>进程抢占</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220523123949348.png" alt="image-20220523123949348" style="zoom:50%;"><h4 id="进程唤醒"><a href="#进程唤醒" class="headerlink" title="进程唤醒"></a>进程唤醒</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220523124120141.png" alt="image-20220523124120141" style="zoom: 67%;"><h4 id="进程结束"><a href="#进程结束" class="headerlink" title="进程结束"></a>进程结束</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220523124248358.png" alt="image-20220523124248358" style="zoom:50%;"><h4 id="进程的切换"><a href="#进程的切换" class="headerlink" title="进程的切换"></a>进程的切换</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220523124953557.png" alt="image-20220523124953557" style="zoom: 50%;"><h2 id="4、三状态进程模型及进程的变迁"><a href="#4、三状态进程模型及进程的变迁" class="headerlink" title="4、三状态进程模型及进程的变迁"></a>4、三状态进程模型及进程的变迁</h2><h4 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h4><p>三种<strong>最核心</strong>的状态：就绪、运行和等待，创建和退出都是辅助过渡的过程</p><p>运行状态：</p><ul><li>进程正在处理机上运行</li></ul><p>就绪状态：</p><ul><li>进程获得了除处理机之外的所需资源，得到处理机即可运行</li></ul><p>等待状态：</p><ul><li>进程正在等待某一事件的出现而暂停运行</li></ul><p>创建状态：</p><ul><li>一个进程正在被创建，还没被转到就绪状态之前的状态</li></ul><p>结束状态：</p><ul><li>一个进程正在从系统中消失时的状态，这是因为进程结束或由于其他原因所导致</li></ul><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220523153143325.png" alt="image-20220523153143325" style="zoom: 50%;"><h4 id="一个进程的变迁"><a href="#一个进程的变迁" class="headerlink" title="一个进程的变迁"></a>一个进程的变迁</h4><p>NULL –&gt; 创建：</p><ul><li>一个新进程被产生出来执行一个程序</li></ul><p>创建 –&gt; 就绪：</p><ul><li>当进程被创建完成并初始化后，一切就绪准备运行时，变为就绪状态</li></ul><p>就绪  –&gt; 运行：</p><ul><li>处于就绪状态被进程调度程序选中后，就分配搭配处理机上来运行</li></ul><p>运行 –&gt; 结束：</p><ul><li>当进程表示它已经完成或者因为出错，当前运行进程会由操作系统结束处理</li></ul><p>运行  –&gt; 就绪：</p><ul><li>处于运行状态的进程在其运行过程中，由于分配给它的处理机时间片用完而让出处理机</li></ul><p>运行 –&gt; 等待：</p><ul><li>当进程请求某资源且必须等待时</li></ul><p>等待 –&gt; 就绪：</p><ul><li>当进程要等待某事件到来时，它从阻塞状态编导就绪状态</li></ul><h2 id="5、挂起进程模型"><a href="#5、挂起进程模型" class="headerlink" title="5、挂起进程模型"></a>5、挂起进程模型</h2><h4 id="进程挂起"><a href="#进程挂起" class="headerlink" title="进程挂起"></a>进程挂起</h4><p>处在挂起状态的进程映像在磁盘上，目的是减少进程占用内存，让出更多内存给其他进程执行，与虚拟存储相关联</p><h4 id="挂起进程模型"><a href="#挂起进程模型" class="headerlink" title="挂起进程模型"></a>挂起进程模型</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220523160724812.png" alt="image-20220523160724812" style="zoom: 50%;"><h4 id="挂起状态"><a href="#挂起状态" class="headerlink" title="挂起状态"></a>挂起状态</h4><p>等待挂起状态：</p><ul><li>进程在外存并等待事件的出现</li></ul><p>就绪挂起状态：</p><ul><li>进程在外存，但只要进入内存，即可运行</li></ul><h4 id="与挂起相关的状态转换"><a href="#与挂起相关的状态转换" class="headerlink" title="与挂起相关的状态转换"></a>与挂起相关的状态转换</h4><p>&#x3D;&#x3D;挂起：把一个进程从内存转到外存&#x3D;&#x3D;</p><p>等待到等待挂起：</p><ul><li>没有进程处于就绪状态或就绪进程要求更多内存资源</li></ul><p>就绪到就绪挂起：</p><ul><li>当有高优先级等待（系统人会会很多就绪的）进程和低优先级就绪进程，将低优先级就绪进程转为就绪挂起，使高优先级等待进程进入就绪状态</li></ul><p>运行到就绪挂起：</p><ul><li>对抢占式分时系统，当有高优先级等待挂起进程因事件出现而进入就绪挂起</li></ul><p>&#x3D;&#x3D;在外存时的状态转换&#x3D;&#x3D;</p><p>等待挂起到就绪挂起：</p><ul><li>当有等待挂起进程因相关事件出现</li></ul><p>&#x3D;&#x3D;激活：把一个进程从外存转到内存&#x3D;&#x3D;</p><p>就绪挂起到就绪：</p><ul><li>没有就绪进程或挂起就绪进程优先级高于就绪进程</li></ul><p>等待挂起到等待：</p><ul><li>当有一个进程释放足够内存并有高优先级等待挂起进程</li></ul><h4 id="状态队列"><a href="#状态队列" class="headerlink" title="状态队列"></a>状态队列</h4><ul><li>由操作系统来维护一组队列，表示系统中所有进程的当前状态</li><li>不同队列表示不同状态<ul><li>就绪队列、各种等待队列</li></ul></li><li>根据进程状态不同，进程PCB加入相应队列<ul><li>进程状态变化时，它所在的PCB会从一个队列换到另一个</li></ul></li></ul><h4 id="进程状态的队列表现"><a href="#进程状态的队列表现" class="headerlink" title="进程状态的队列表现"></a>进程状态的队列表现</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220523162343983.png" alt="image-20220523162343983" style="zoom: 50%;"><blockquote><p>状态之间的变迁，变成了队列之间的变迁</p></blockquote><h2 id="6、线程的概念"><a href="#6、线程的概念" class="headerlink" title="6、线程的概念"></a>6、线程的概念</h2><h4 id="举例：为什么引入线程"><a href="#举例：为什么引入线程" class="headerlink" title="举例：为什么引入线程"></a>举例：为什么引入线程</h4><p>【案例】编写一个MP3播放软件。核心功能模块有三个<br>（1）从MP3音频文件当中读取数据<br>（2）对数据进行解压缩<br>（3）把解压缩后的音频数据播放出来</p><h4 id="单进程的实现方法"><a href="#单进程的实现方法" class="headerlink" title="单进程的实现方法"></a>单进程的实现方法</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220904113641052.png" alt="image-20220904113641052" style="zoom:50%;"><p>问题：<br>1.播放出来的声音能否连贯<br>2.各个函数之间不是并发执行，影响资源的使用效率</p><blockquote><p>函数不是并发执行的，都是一个个执行，资源的连贯性就会有问题，如读的很慢，CPU压缩的很快，这会导致播放的视频不连续</p></blockquote><h4 id="多进程的实现方法"><a href="#多进程的实现方法" class="headerlink" title="多进程的实现方法"></a>多进程的实现方法</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220904113907524.png" alt="image-20220904113907524" style="zoom:50%;"><p>存在的问题<br>1.进程之间如何通信，共享数据？<br>2.系统开销较大：创建进程、进程结束、进程切换</p><blockquote><p>多进程的实现方法，当你在读数据的等待阶段，操作系统可以让你CPU去执行解压</p></blockquote><h4 id="多线程的解决思路"><a href="#多线程的解决思路" class="headerlink" title="多线程的解决思路"></a>多线程的解决思路</h4><p>在进程内部增加一类实体，满足以下特性：</p><p>（1）实体之间可以并发执行</p><p>（2）实体之间共享相同的地址空间</p><p>这种实体就是线程（Thread）</p><h4 id="线程的概念"><a href="#线程的概念" class="headerlink" title="线程的概念"></a>线程的概念</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220523164454110.png" alt="image-20220523164454110" style="zoom:50%;"><blockquote><p>有了多个指令执行流，产生多个线程控制块，线程控制块是在进程控制块当中的</p></blockquote><h4 id="进程和线程的关系"><a href="#进程和线程的关系" class="headerlink" title="进程和线程的关系"></a>进程和线程的关系</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220523164734484.png" alt="image-20220523164734484" style="zoom: 67%;"><blockquote><p>将寄存器和堆栈分配多份给多线程使用</p></blockquote><h4 id="线程-x3D-进程-共享资源"><a href="#线程-x3D-进程-共享资源" class="headerlink" title="线程 &#x3D; 进程 - 共享资源"></a>线程 &#x3D; 进程 - 共享资源</h4><p>即各个线程共享进程中的资源</p><ul><li>线程的优点：<ul><li>一个进程中可以同时存在多个线程</li><li>各个线程之间可以并发地执行</li><li>各个线程之间可以共享地址空间和文件等资源</li></ul></li><li>线程的缺点：<ul><li>一个线程崩溃，会导致其所属进程的所有线程崩溃</li></ul></li></ul><h4 id="不同操作系统支持的线程"><a href="#不同操作系统支持的线程" class="headerlink" title="不同操作系统支持的线程"></a>不同操作系统支持的线程</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220523165528038.png" alt="image-20220523165528038" style="zoom: 67%;"><h4 id="线程和进程的比较"><a href="#线程和进程的比较" class="headerlink" title="线程和进程的比较"></a>线程和进程的比较</h4><ul><li>进程是资源分配单位，线程是CPU调度单位</li><li>进程拥有一个完整的资源平台，而线程只独享指令流执行的必要资源，如寄存器和栈</li><li>线程具有就绪、等待和运行三种基本状态和状态间的转换关系</li><li>线程能减少并发执行的时间和空间开销<ul><li>线程的创建时间比进程短</li><li>线程的终止时间比进程短</li><li>同一进程内的线程切换时间比进程短</li><li>由于同一进程的各线程间共享内存和文件资源，可不通过内核进行直接通信</li></ul></li></ul><h2 id="7、用户线程"><a href="#7、用户线程" class="headerlink" title="7、用户线程"></a>7、用户线程</h2><h4 id="线程的三种实现方式"><a href="#线程的三种实现方式" class="headerlink" title="线程的三种实现方式"></a>线程的三种实现方式</h4><ul><li>用户线程：在用户空间实现<br>POSIX Pthreads，Mach C-threads，Solaris threads</li><li>内核线程：在内核中实现<br>Windows，Solaris，Linux</li><li>轻量级进程：在内核中实现，支持用户线程<br>Solaris（LightWeight Process）</li></ul><h4 id="用户线程"><a href="#用户线程" class="headerlink" title="用户线程"></a>用户线程</h4><p>由一组用户级的线程库函数来完成线程的管理，包括线程的创建、终止、同步和调度等</p><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220904115049212.png" alt="image-20220904115049212" style="zoom:50%;"><h4 id="用户线程的特征"><a href="#用户线程的特征" class="headerlink" title="用户线程的特征"></a>用户线程的特征</h4><ul><li>不依赖于操作系统的内核<ul><li>内核不了解用户线程的存在</li><li>可用于不支持线程的多进程操作系统</li></ul></li><li>在用户空间实现的线程机制<ul><li>每个进程有私有的线程控制块（TCB）列表</li><li>TCB由线程库函数维护</li></ul></li><li>同一进程内的用户线程切换速度快<ul><li>无需用户态&#x2F;核心态切换</li></ul></li><li>允许每个进程拥有自已的线程调度算法</li></ul><h4 id="用户线程的不足"><a href="#用户线程的不足" class="headerlink" title="用户线程的不足"></a>用户线程的不足</h4><ul><li>线程发起系统调用而阻塞时，则整个进程进入等待</li><li>不支持基于线程的处理机抢占<ul><li>除非当前运行线程主动放弃，它所在进程的其他线程无法抢占CPU</li></ul></li><li>线程只能按进程分配CPU时间<ul><li>多个线程进程中，每个线程的时间片较少</li></ul></li></ul><h2 id="8、内核线程"><a href="#8、内核线程" class="headerlink" title="8、内核线程"></a>8、内核线程</h2><h4 id="内核线程"><a href="#内核线程" class="headerlink" title="内核线程"></a>内核线程</h4><p>由内核通过系统调用实现的线程机制，由内核完成线程的创建、终止和管理</p><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220904115513447.png" alt="image-20220904115513447" style="zoom: 50%;"><h4 id="内核线程的特征"><a href="#内核线程的特征" class="headerlink" title="内核线程的特征"></a>内核线程的特征</h4><ul><li>由内核维护PCB和TCB</li><li>线程执行系统调用而被阻塞不影响其他线程</li><li>线程的创建、终止和切换相对较大<ul><li>通过系统调用&#x2F;内核函数，在内核实现</li></ul></li><li>以线程为单位进行CPU时间分配<ul><li>多线程的进程可获得更多CPU时间</li></ul></li></ul><blockquote><p>在内核中维护线程的创建、终止和切换开销相对较大</p></blockquote><h4 id="轻权进程"><a href="#轻权进程" class="headerlink" title="轻权进程"></a>轻权进程</h4><p>内核支持的用户线程。一个进程可有一个或多个轻量级进程，每个轻权进程由一个单独的内核线程来支持。（Solaris&#x2F;Linux）</p><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220904115728161.png" alt="image-20220904115728161" style="zoom:50%;"><blockquote><p>是用户线程和内核线程的一种很好的结合，即有一个或多个的内核线程支持，它可为一个进程多个用户线程服务，可是在实际的系统中实现的不理想</p></blockquote><h4 id="用户线程和内核线程的对应关系"><a href="#用户线程和内核线程的对应关系" class="headerlink" title="用户线程和内核线程的对应关系"></a>用户线程和内核线程的对应关系</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220523172632051.png" alt="image-20220523172632051" style="zoom:50%;"><h1 id="八、进程控制"><a href="#八、进程控制" class="headerlink" title="八、进程控制"></a>八、进程控制</h1><h2 id="1、进程切换"><a href="#1、进程切换" class="headerlink" title="1、进程切换"></a>1、进程切换</h2><h4 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h4><p>进程切换（上下文切换）</p><ul><li>暂停当前运行进程，从运行状态变成其他状态</li><li>调度另一个进程从就绪状态变成运行状态</li></ul><p>进程切换的要求</p><ul><li><p>切换前，保存进程上下文</p></li><li><p>切换后，恢复进程上下文</p></li><li><p>快速切换</p></li></ul><p>进程生命周期的信息</p><ul><li>寄存器（PC,SP….）</li><li>CPU状态</li><li>内存地址空间</li></ul><blockquote><p>保存进程信息（现场）：寄存器信息，CPU状态，内存地址空间</p></blockquote><h4 id="上下文切换图示"><a href="#上下文切换图示" class="headerlink" title="上下文切换图示"></a>上下文切换图示</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220524103401438.png" alt="image-20220524103401438" style="zoom: 67%;"><h4 id="进程控制块PCB-内核的进程状态记录"><a href="#进程控制块PCB-内核的进程状态记录" class="headerlink" title="进程控制块PCB::内核的进程状态记录"></a>进程控制块PCB::内核的进程状态记录</h4><p>1）内核为每个进程维护了对应的进程控制块（PCB）</p><p>2）内核将相同状态的进程的PCB放置在同一队列</p><ul><li>就绪队列</li><li>I&#x2F;O等待队列<ul><li>每个设备一个队列</li></ul></li><li>I&#x2F;O等待队列</li></ul><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220905090449594.png" alt="image-20220905090449594" style="zoom:67%;"><h4 id="ucore的进程控制块结构proc-struct"><a href="#ucore的进程控制块结构proc-struct" class="headerlink" title="ucore的进程控制块结构proc_struct"></a>ucore的进程控制块结构proc_struct</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220524104825663.png" alt="image-20220524104825663" style="zoom:50%;"><h4 id="ucore的内存地址空间结构mm-struct"><a href="#ucore的内存地址空间结构mm-struct" class="headerlink" title="ucore的内存地址空间结构mm_struct"></a>ucore的内存地址空间结构mm_struct</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220524105318617.png" alt="image-20220524105318617" style="zoom: 50%;"><h4 id="ucore-的进程队列"><a href="#ucore-的进程队列" class="headerlink" title="ucore+的进程队列"></a>ucore+的进程队列</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220524105507567.png" alt="image-20220524105507567" style="zoom:50%;"><h4 id="ucore-进程-x2F-线程切换流程"><a href="#ucore-进程-x2F-线程切换流程" class="headerlink" title="ucore+进程&#x2F;线程切换流程"></a>ucore+进程&#x2F;线程切换流程</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220524105853681.png" alt="image-20220524105853681" style="zoom:50%;"><h4 id="ucore-的进程切换"><a href="#ucore-的进程切换" class="headerlink" title="ucore+的进程切换"></a>ucore+的进程切换</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220524110023449.png" alt="image-20220524110023449" style="zoom:50%;"><blockquote><p>由于各种事件如中断，信号量，CPU空闲等等，大致会经过schedule在去proc_run，然后到switch_to切换代码</p></blockquote><h4 id="switch-to-实现"><a href="#switch-to-实现" class="headerlink" title="switch_to 实现"></a>switch_to 实现</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220524110216643.png" alt="image-20220524110216643" style="zoom:50%;"><blockquote><p>切换代码和你的平台相关，每个CPU平台上所需要保存的寄存器是不一样的，而为了保存的速度比较快，代码使用汇编进进行编写的</p><p>大致过程是，前半段保存，后半段恢复</p></blockquote><h2 id="2、进程创建"><a href="#2、进程创建" class="headerlink" title="2、进程创建"></a>2、进程创建</h2><h4 id="创建进程的系统调用接口"><a href="#创建进程的系统调用接口" class="headerlink" title="创建进程的系统调用接口"></a>创建进程的系统调用接口</h4><p>系统调用接口操作系统提供给用户使用的系统调用，在不同的操作系统，系统调用的接口是不一样的</p><ul><li><p>Windows进程创建API：CreateProcess(fileliame）</p><ul><li><p>创建时关闭所有在子进程里的文件描述符<br>CreateProcess(filename，CLOSE FD）函数用于创建一个新进程，该进程独立于创建进程运行</p></li><li><p>创建时改变子进程的环境</p><p>CreateProcess(filename，CLOSE FD，new_envp）</p></li><li><p>等等</p></li></ul></li><li><p>Unix进程创建系统调用：fork&#x2F;exec</p><ul><li>forkO把一个进程复制成二个进程，parent (old PID)，child (new PID）</li><li>exec() 用新程序来重写当前进程，PID没有改变</li></ul></li></ul><h4 id="创建新进程"><a href="#创建新进程" class="headerlink" title="创建新进程"></a>创建新进程</h4><p>用fork和exec创建进程的示例</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> pid = fork()；<span class="comment">// 创建子进程</span></span><br><span class="line"><span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;<span class="comment">// 子进程在这里继续</span></span><br><span class="line">     <span class="comment">// Do anything (unmap memory, close net connections…)</span></span><br><span class="line"><span class="built_in">exec</span>(“program”, argc, argv0, argv1, …);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>fork() 创建一个继承的子进程</p><ul><li>复制父进程的所有变量和内存</li><li>复制父进程的所有CPU寄存器(有一个寄存器例外)</li></ul><p>fork()的返回值</p><ul><li>子进程的fork()返回0</li><li>父进程的fork()返回子进程标识符</li><li>fork() 返回值可方便后续使用，子进程可使用getpid()获取PID</li></ul><blockquote><p>fork复制一个完成一样的子进程，但是PID不同来区别于这两个进程，在用exec将程序加载到内存覆盖重写当前进程整个地址空间</p></blockquote><h4 id="fork-的地址空间复制"><a href="#fork-的地址空间复制" class="headerlink" title="fork()的地址空间复制"></a>fork()的地址空间复制</h4><p>fork（执行过程对于子进程而言是在调用时间灯交递程地址空间的一次复制</p><ul><li>对于父进程fork（）返回child PID，对于子进程返回值为0</li></ul><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220905092234655.png" alt="image-20220905092234655" style="zoom:67%;"><blockquote><p>复制完全一样的进程，但是PID不一样，导致后续的它就是一个不一样的进程</p></blockquote><h4 id="程序的加载和执行"><a href="#程序的加载和执行" class="headerlink" title="程序的加载和执行"></a>程序的加载和执行</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220524112723422.png" alt="image-20220524112723422" style="zoom:50%;"><h4 id="在shell中调用fork-后加载计算器的图示"><a href="#在shell中调用fork-后加载计算器的图示" class="headerlink" title="在shell中调用fork()后加载计算器的图示"></a>在shell中调用fork()后加载计算器的图示</h4><p>fork()复制完全一样的进程，地址空间的内容一样，即数据、代码和堆栈完全一样</p><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220524113245129.png" alt="image-20220524113245129" style="zoom:50%;"><p>exec()加载过程，将复制的进程重写，即将整个地址空间里的内容全部换掉，变成完全不一样的新进程</p><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220524113515537.png" alt="image-20220524113515537" style="zoom:50%;"><h4 id="空闲进程的创建"><a href="#空闲进程的创建" class="headerlink" title="空闲进程的创建"></a>空闲进程的创建</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220524123602410.png" alt="image-20220524123602410" style="zoom:50%;"><blockquote><p>在用户没有代码需要执行时，CPU也不会处于空闲状态，这时CPU会执行空闲进程中的指令</p><p>空闲进程的优先级最低，当没有其他进程时，它就会执行</p></blockquote><h4 id="创建第一个内核线程"><a href="#创建第一个内核线程" class="headerlink" title="创建第一个内核线程"></a>创建第一个内核线程</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220524124444783.png" alt="image-20220524124444783" style="zoom:50%;"><blockquote><p>进程创建与线程创建fork的参数信息不一样，线程只需要拷贝所需要的现场信息，初始化控制块，初始化堆栈，共享堆栈，将其放入就绪队列，当开始被调度执行，就可以创建第一个用户态的进程了</p></blockquote><h4 id="fork-的开销"><a href="#fork-的开销" class="headerlink" title="fork()的开销"></a>fork()的开销</h4><p>fork() 的实现开销</p><ul><li>对子进程分配内存</li><li>复制父进程的内存和CPU寄存器到子进程里</li><li>&#x3D;&#x3D;开销昂贵！！&#x3D;&#x3D;</li></ul><p>在99%的情况里，我们在调用fork() 之后调用exec()</p><ul><li>在fork() 操作中内存复制是没有作用的</li><li>子进程将可能关闭打开的文件和连接</li><li>为什么不能结合它们在一个调用中？</li></ul><p>vfork()</p><ul><li>创建进程时，不再创建一个同样的内存映像</li><li>一些时候称为轻量级fork()</li><li>子进程应该几乎立即调用exec()</li><li>现在使用Copy on Write（COW）技术</li></ul><h2 id="3、进程加载"><a href="#3、进程加载" class="headerlink" title="3、进程加载"></a>3、进程加载</h2><h4 id="程序加载和执行系统调用exec"><a href="#程序加载和执行系统调用exec" class="headerlink" title="程序加载和执行系统调用exec( )"></a>程序加载和执行系统调用exec( )</h4><ul><li>允许进程“加载一个完全不同的程序，并从main开始执行（即_start）</li><li>允许进程加载时指定启动参数（argc，argv）</li><li>exec调用成功时<ul><li>它是相同的进程….</li><li>但是运行了不同的程序</li></ul></li><li>代码段、堆栈和堆（heap）等完全重写</li></ul><h2 id="4、进程等待与退出"><a href="#4、进程等待与退出" class="headerlink" title="4、进程等待与退出"></a>4、进程等待与退出</h2><h4 id="父进程等待子进程wait"><a href="#父进程等待子进程wait" class="headerlink" title="父进程等待子进程wait()"></a>父进程等待子进程wait()</h4><ul><li>Wait（）系统调用用于父进程等待子进程的结束<ul><li>子进程结束时通过exit（）向父进程返回一个值</li><li>父进程通过wait（）接受并处理返回值</li></ul></li><li>wait（）系统调用的功能<ul><li>子进程存活时，父进程进入等待状态，等待子进程的返回结果</li><li>当某子进程调用exit（）时，唤醒父进程，将exit（）返回值作为父进程中wait的返回值</li><li>有僵尸子进程等待时，wait（）立即返回其中一个值</li><li>无子进程存活时，wait（）立刻返回</li></ul></li></ul><h4 id="进程的有序终止exit"><a href="#进程的有序终止exit" class="headerlink" title="进程的有序终止exit()"></a>进程的有序终止exit()</h4><ul><li>进程结束执行时调用&#x3D;&#x3D;exit（）&#x3D;&#x3D;，完成进程资源回收</li><li>exit（）系统调用的功能<ul><li>将调用参数作为进程的 “结果“</li><li>关闭所有打开的文件等占用资源</li><li>释放内存</li><li>释放大部分进程相关的内核数据结构</li><li>检查是否父进程是存活着的<ul><li>如存活，保留结果的值直到父进程需要它，进入僵尸（zombie&#x2F;defunct）状态</li><li>如果没有，它释放所有的数据结构，进程结果</li></ul></li><li>清理所有等待的僵尸进程</li></ul></li><li>进程终止是最终的垃圾收集（资源回收）</li></ul><h4 id="其他进程控制系统调用"><a href="#其他进程控制系统调用" class="headerlink" title="其他进程控制系统调用"></a>其他进程控制系统调用</h4><ul><li>优先级控制<ul><li>nice（）指定进程的初始优先级</li><li>Unix系统中进程优先级会随执行时间而衰减</li></ul></li><li>进程调试支持<ul><li>ptrace（）允许一个进程控制另一个进程的执行</li><li>设置断点和查看寄存器等</li></ul></li><li>定时<ul><li>sleep（）可以让进程在定时器的等待队列中等待指定</li></ul></li></ul><h4 id="进程控制和进程状态"><a href="#进程控制和进程状态" class="headerlink" title="进程控制和进程状态"></a>进程控制和进程状态</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220524161300142.png" alt="image-20220524161300142" style="zoom: 67%;"><blockquote><p>exec( ) : 在加载可执行文件过程中，它还会有相应的状态的变化</p></blockquote><h1 id="九、处理机调度"><a href="#九、处理机调度" class="headerlink" title="九、处理机调度"></a>九、处理机调度</h1><h2 id="1、处理机调度的概念"><a href="#1、处理机调度的概念" class="headerlink" title="1、处理机调度的概念"></a>1、处理机调度的概念</h2><h4 id="CPU资源的时分复用"><a href="#CPU资源的时分复用" class="headerlink" title="CPU资源的时分复用"></a>CPU资源的时分复用</h4><ul><li>进程切换：CPU资源的当前占用者切换<ul><li>保存当前进程在PCB中的执行上下文（CPU状态）</li><li>恢复下一个进程的执行上下文</li></ul></li><li>处理机调度<ul><li>从就绪队列中&#x3D;&#x3D;挑选&#x3D;&#x3D;下一个占用CPU运行的&#x3D;&#x3D;进程&#x3D;&#x3D;</li><li>从多个可用CPU中&#x3D;&#x3D;挑选&#x3D;&#x3D;就绪进程可使用的CPU&#x3D;&#x3D;资源&#x3D;&#x3D;</li></ul></li><li>调度程序：挑选就绪进程的内核函数<ul><li>调度策略<ul><li>依据什么原则挑选进程&#x2F;线程？</li></ul></li><li>调度时机<ul><li>什么时候进行调度？</li></ul></li></ul></li></ul><h4 id="调度时机"><a href="#调度时机" class="headerlink" title="调度时机"></a>调度时机</h4><p>内核运行调度程序的条件</p><ul><li>进程被终结了</li></ul><p>&#x3D;&#x3D;非抢占系统&#x3D;&#x3D;</p><ul><li>当前进程主动放弃CPU时</li></ul><p>&#x3D;&#x3D;可抢占系统&#x3D;&#x3D;</p><ul><li>中断请求被服务例程响应完成时</li><li>当前进程被抢占<ul><li>进程时间片用完</li><li>进程从等待切换到就绪</li></ul></li></ul><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220905095543111.png" alt="image-20220905095543111" style="zoom:50%;"><h2 id="2、调度准则"><a href="#2、调度准则" class="headerlink" title="2、调度准则"></a>2、调度准则</h2><h4 id="处理机资源的使用模式"><a href="#处理机资源的使用模式" class="headerlink" title="处理机资源的使用模式"></a>处理机资源的使用模式</h4><p>进程在CPU计算和I&#x2F;O操作间交替</p><ul><li>每次调度决定在下一个CPU计算时将哪个工作交给CPU</li><li>在时间片机制下，进程可能在结束当前CPU计算前被迫放弃CPU</li></ul><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220905095844146.png" alt="image-20220905095844146" style="zoom: 67%;"><blockquote><p>根据CPU计算频率与每次计算事件关系图，选择合适的时间片分配使用CPU资源</p></blockquote><h4 id="比较调度算法的准则"><a href="#比较调度算法的准则" class="headerlink" title="比较调度算法的准则"></a>比较调度算法的准则</h4><ul><li>CPU使用率<ul><li>CPU处于忙状态的&#x3D;&#x3D;时间百分比&#x3D;&#x3D;</li></ul></li><li>吞吐量<ul><li>单位时间内完成的&#x3D;&#x3D;进程数量&#x3D;&#x3D;</li></ul></li><li>周转时间<ul><li>进程从初始化到结束（包括等待）的&#x3D;&#x3D;总时间&#x3D;&#x3D;</li></ul></li><li>等待时间<ul><li>进程在就绪队列中的&#x3D;&#x3D;总时间&#x3D;&#x3D;</li></ul></li><li>响应时间<ul><li>从提交请求到产生响应所花费的&#x3D;&#x3D;总时间&#x3D;&#x3D;</li></ul></li></ul><h4 id="吞吐量与响应延迟"><a href="#吞吐量与响应延迟" class="headerlink" title="吞吐量与响应延迟"></a>吞吐量与响应延迟</h4><p>调度算法的要求</p><ul><li>希望 &#x3D;&#x3D;“更快”&#x3D;&#x3D; 的服务</li></ul><p>什么是更快？</p><ul><li>传输文件时的&#x3D;&#x3D;高带宽&#x3D;&#x3D;，调度算法的&#x3D;&#x3D;高吞吐量&#x3D;&#x3D;</li><li>玩游戏时的&#x3D;&#x3D;低延迟&#x3D;&#x3D;，调度算法的&#x3D;&#x3D;低响应延迟&#x3D;&#x3D;</li><li>这两个因素是独立的</li></ul><p>与&#x3D;&#x3D;水管&#x3D;&#x3D;的类比</p><ul><li>低延迟：&#x3D;&#x3D;喝水&#x3D;&#x3D;的时候想要一打开水龙头水就流出来</li><li>高带宽：&#x3D;&#x3D;给游泳池充水&#x3D;&#x3D;时希望从水龙头里同时流出大量的水，并且不介意是否存在延</li></ul><h4 id="处理机调度策略的响应时间目标"><a href="#处理机调度策略的响应时间目标" class="headerlink" title="处理机调度策略的响应时间目标"></a>处理机调度策略的响应时间目标</h4><p>&#x3D;&#x3D;减少响应时间&#x3D;&#x3D;</p><ul><li>及时处理用户的输入请求，尽快将输出反馈给用户</li></ul><p>&#x3D;&#x3D;减少平均响应时间的波动&#x3D;&#x3D;</p><ul><li>在交互系统中，可预测性比高差异低平均更重要</li></ul><p>低延退调度改善了用户的交互体验</p><ul><li>如果移动鼠标时，屏幕中的光标没动，用户可能会重启电脑</li></ul><p>响应时间是操作系统的计算延迟</p><h4 id="处理调度策略的吞吐量目标"><a href="#处理调度策略的吞吐量目标" class="headerlink" title="处理调度策略的吞吐量目标"></a>处理调度策略的吞吐量目标</h4><p>&#x3D;&#x3D;增加吞吐量&#x3D;&#x3D;</p><ul><li>减少开销（操作系统开销，上下文切换）</li><li>系统资源的高效利用（CPU，0设备）</li></ul><p>&#x3D;&#x3D;减少等待时间&#x3D;&#x3D;</p><ul><li>减少每个进程的等待时间</li></ul><p>操作系统需要保证吞吐量不受用户交互的影响</p><ul><li>操作系统必须不时进行调度，即使存在许多交互任务</li></ul><p>吞吐量是操作系统的计算带宽</p><blockquote><p>吞吐量目标：希望在单位时间内尽可能能够执行更多的进程</p></blockquote><h4 id="处理机调度的公平性目标"><a href="#处理机调度的公平性目标" class="headerlink" title="处理机调度的公平性目标"></a>处理机调度的公平性目标</h4><p>公平的定义</p><ul><li>保证每个进程占用相同的CPU时间</li><li>保证每个进程的等待时间相同</li></ul><p>公平通常会增加平均响应时间</p><h2 id="3、先来先服务、短进程优先和最高响应比优先调度算法"><a href="#3、先来先服务、短进程优先和最高响应比优先调度算法" class="headerlink" title="3、先来先服务、短进程优先和最高响应比优先调度算法"></a>3、先来先服务、短进程优先和最高响应比优先调度算法</h2><h4 id="先来先服务算法FCFS"><a href="#先来先服务算法FCFS" class="headerlink" title="先来先服务算法FCFS"></a>先来先服务算法FCFS</h4><p><code>First Come First Served</code></p><p>依据进程进入就绪状态的先后顺序排列</p><ul><li>进程进入等待或结束状态时，就绪队列中的下一个进程占用CPU</li></ul><p>FCFS算法的周转时间</p><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220905101256452.png" alt="image-20220905101256452" style="zoom:67%;"><blockquote><p>计算周转时间，假设进程几乎同时到达，这里忽略了到达时间</p><p>如果大作业先到了，周转时间会变得更长，不利于小作业，作业等待时间会长</p></blockquote><h4 id="先来先服务算法特征"><a href="#先来先服务算法特征" class="headerlink" title="先来先服务算法特征"></a>先来先服务算法特征</h4><p>优点</p><ul><li>简单</li></ul><p>缺点</p><ul><li>平均等待时间波动较大<ul><li>短进程可能排在长进程后面</li></ul></li><li>I&#x2F;O资源和CPU资源的利用率较低<ul><li>CPU密集型进程会导致I&#x2F;O设备闲置时，I&#x2F;O密集型进程也等待</li></ul></li></ul><h4 id="短进程优先算法SPN"><a href="#短进程优先算法SPN" class="headerlink" title="短进程优先算法SPN"></a>短进程优先算法SPN</h4><p>选择就绪队列中执行时间最短进程占用CPU进入运行状态</p><ul><li>就绪队列按预期的执行时间来排序</li></ul><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220905102016758.png" alt="image-20220905102016758" style="zoom:50%;"><p>短剩余时间优先算法&#x3D;&#x3D;（SRT）&#x3D;&#x3D;</p><ul><li>DSPN算法的可抢占改进</li></ul><blockquote><p>短剩余时间优先算法，即当前进程已经执行了一段时间，新来了个进程，执行时间比当前进程剩余的执行时间短，那么它可以抢占当前进程</p></blockquote><h4 id="短进程优先算法具有最优平均周转时间"><a href="#短进程优先算法具有最优平均周转时间" class="headerlink" title="短进程优先算法具有最优平均周转时间"></a>短进程优先算法具有最优平均周转时间</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220525173950667.png" alt="image-20220525173950667" style="zoom:50%;"><h4 id="短进程优先算法的特征：缺点"><a href="#短进程优先算法的特征：缺点" class="headerlink" title="短进程优先算法的特征：缺点"></a>短进程优先算法的特征：缺点</h4><p>可能导致机饿</p><ul><li>连续的短进程流会使长进程无法获得CPU资源</li></ul><p>&#x3D;&#x3D;需要预知未来&#x3D;&#x3D;</p><ul><li>如何预估下一个CPU计算的持续时间？</li><li>简单的解决办法：询问用户<ul><li>用户欺骗就杀死相应进程</li><li>用户不知道怎么办？</li></ul></li></ul><h4 id="短进程优先算法执行时间预估"><a href="#短进程优先算法执行时间预估" class="headerlink" title="短进程优先算法执行时间预估"></a>短进程优先算法执行时间预估</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220525174709991.png" alt="image-20220525174709991" style="zoom:50%;"><p>加权计算，最近一次的计算时间权重最大，越久远的计算时间权重越小</p><h4 id="预估执行时间"><a href="#预估执行时间" class="headerlink" title="预估执行时间"></a>预估执行时间</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220525174951615.png" alt="image-20220525174951615" style="zoom:50%;"><p>实际和预估能够有一个比较好的拟合效果</p><h4 id="最高响应比优先算法HRRN"><a href="#最高响应比优先算法HRRN" class="headerlink" title="最高响应比优先算法HRRN"></a>最高响应比优先算法HRRN</h4><p>选择就绪队列中响应比R值最高的进程</p><table><thead><tr><th>R&#x3D;（w+s)&#x2F;s</th></tr></thead><tbody><tr><td>w：等待时间（waiting time）</td></tr><tr><td>S：执行时间（service time）</td></tr></tbody></table><ul><li>在短进程优先算法的基础上改进</li><li>不可抢占</li><li>关注进程的等待时间</li><li>防止无限期推</li></ul><h2 id="4、时间片轮转、多级反馈队列、公平共享调度算法和ucore调度框架"><a href="#4、时间片轮转、多级反馈队列、公平共享调度算法和ucore调度框架" class="headerlink" title="4、时间片轮转、多级反馈队列、公平共享调度算法和ucore调度框架"></a>4、时间片轮转、多级反馈队列、公平共享调度算法和ucore调度框架</h2><h4 id="时间片轮转算法RR"><a href="#时间片轮转算法RR" class="headerlink" title="时间片轮转算法RR"></a>时间片轮转算法RR</h4><p>时间片</p><ul><li>分配处理机资源的基本时间单元</li></ul><p>算法思路</p><ul><li>时间片结束时，按FCFS算法切换到下一个就绪进程</li><li>每隔（n-1）个时间片进程执行一个时间片q</li></ul><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220906125705199.png" alt="image-20220906125705199" style="zoom: 67%;"><blockquote><p>采用先来先服务算法  +  时间片。</p><p>执行完一个时间片后，如未完成则加入到就绪队列末尾，执行下一个就绪队列的头进程</p></blockquote><h4 id="时间片为20的RR算法示例"><a href="#时间片为20的RR算法示例" class="headerlink" title="时间片为20的RR算法示例"></a>时间片为20的RR算法示例</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220604134104994.png" alt="image-20220604134104994" style="zoom: 67%;"><h4 id="时间片轮转算法中的时间片长度"><a href="#时间片轮转算法中的时间片长度" class="headerlink" title="时间片轮转算法中的时间片长度"></a>时间片轮转算法中的时间片长度</h4><p>RR算法开销</p><ul><li>额外的上下文切换</li></ul><p>时间片太大</p><ul><li>等待时间过长</li><li>极限情况退化成FCFS</li></ul><p>时间片太小</p><ul><li>反应迅速，但产生大量上下文切换</li><li>大量上下文切换开销影响到系统吞吐量</li></ul><p>时间片长度选择目标</p><ul><li>选择一个合适的时间片长度</li><li>经验规则：维持上下文切换开销处于1%以内</li></ul><h4 id="比较FCFS和RR"><a href="#比较FCFS和RR" class="headerlink" title="比较FCFS和RR"></a>比较FCFS和RR</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220604134807497.png" alt="image-20220604134807497" style="zoom: 67%;"><blockquote><p>先来先服务算法有两种极端，长进程优先和短进程优先，进程如果以从小到大的顺序到达，则出现最好情况，否则就是最差情况，而时间片轮转算法的平均等待时间是在则两者的平均等待时间之间</p></blockquote><h4 id="多级队列调度算法（MQ）"><a href="#多级队列调度算法（MQ）" class="headerlink" title="多级队列调度算法（MQ）"></a>多级队列调度算法（MQ）</h4><p>就绪队列被划分成多个独立的子队列</p><ul><li>如：前台（交互）、后台（批处理）</li></ul><p>每个队列拥有自己的调度策略</p><ul><li>如：前台-RR、后台-FCFS</li></ul><p>队列间的调度</p><ul><li>固定优先级<ul><li>先处理前台，然后处理后台</li><li>可能导致饥饿</li></ul></li><li>时间片轮转<ul><li>每个队列都能得到一个确定的能够调度其进程的CPU总时间</li><li>如：80%CPU时间用于前台，20%CPU时间用于后台</li></ul></li></ul><blockquote><p><strong>此算法，不同队列间没有交互，即进程不能在不同队列间移动</strong></p></blockquote><h4 id="多级反馈队列算法（MLFQ）"><a href="#多级反馈队列算法（MLFQ）" class="headerlink" title="多级反馈队列算法（MLFQ）"></a>多级反馈队列算法（MLFQ）</h4><p>进程可在不同队列间&#x3D;&#x3D;移动&#x3D;&#x3D;的多级队列算法</p><ul><li>时间片大小随优先级级别增加而增加</li><li>如进程在当前的时间片没有完成，则降到下一个优先级</li></ul><p>MLFQ算法的特征</p><ul><li>CPU密集型进程的优先级下降很快</li><li>I&#x2F;O密集型进程停留在高优先级</li></ul><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220604140648217.png" alt="image-20220604140648217" style="zoom: 67%;"><h4 id="公平共享调度算法FSS"><a href="#公平共享调度算法FSS" class="headerlink" title="公平共享调度算法FSS"></a>公平共享调度算法FSS</h4><p>FSS控制用户对系统资源的访问</p><ul><li>一些用户组比其他用户组更重要</li><li>保证不重要的组无法垄断资源<br>未使用的资源按比例分配<br>没有达到资源使用率目标的组获得更高的优先级</li></ul><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220906130411629.png" alt="image-20220906130411629" style="zoom:67%;"><h4 id="传统调度算法的总结"><a href="#传统调度算法的总结" class="headerlink" title="传统调度算法的总结"></a>传统调度算法的总结</h4><p>先来先服务算法</p><ul><li>不公平，平均等待时间较差</li></ul><p>短进程优先算法</p><ul><li>不公平，平均周转时间最小</li><li>需要精确的预测计算时间</li><li>可能导致饥饿</li></ul><p>最高响应比优先算法（看重进程等段时间）</p><ul><li>基于短进程优先算法SPN调度</li><li>不可抢占</li></ul><p>时间片轮转算法</p><ul><li>公平，但是平均等待时间较差</li></ul><p>多级反馈队列</p><ul><li>多种算法的集成</li></ul><p>公平共享调度</p><ul><li>公平是第一要素</li></ul><h4 id="ucore的调度时机和进程切换"><a href="#ucore的调度时机和进程切换" class="headerlink" title="ucore的调度时机和进程切换"></a>ucore的调度时机和进程切换</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220604143050363.png" alt="image-20220604143050363" style="zoom:50%;"><p>进程遇到中断，从用户态进入到内核态进行中断处理，完成后根据调度算法调度另外的进程或本进程</p><p>调度时机是在内核态切换回用户态之前就调度了</p><h2 id="5、实时调度和多处理机调度"><a href="#5、实时调度和多处理机调度" class="headerlink" title="5、实时调度和多处理机调度"></a>5、实时调度和多处理机调度</h2><h4 id="实时操作系统"><a href="#实时操作系统" class="headerlink" title="实时操作系统"></a>实时操作系统</h4><p>实时操作系统的定义</p><ul><li>正确性依赖于其&#x3D;&#x3D;时间&#x3D;&#x3D;和&#x3D;&#x3D;功能&#x3D;&#x3D;两方面的操作系统</li></ul><p>实时操作系统的性能指标</p><ul><li>&#x3D;&#x3D;时间约束的及时性（deadlines）&#x3D;&#x3D;</li><li>速度和平均性能相对不重要</li></ul><p>实时操作系统的特性</p><ul><li>时间约束的&#x3D;&#x3D;可预测性&#x3D;&#x3D;</li></ul><h4 id="实时任务"><a href="#实时任务" class="headerlink" title="实时任务"></a>实时任务</h4><p>任务（工作单元）</p><ul><li>一次计算，一次文件读取，一次信息传递等等</li></ul><p>任务属性</p><ul><li>完成任务所需要的资源</li><li>定时参数</li></ul><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220906130704508.png" alt="image-20220906130704508" style="zoom: 67%;"><h4 id="周期实时任务"><a href="#周期实时任务" class="headerlink" title="周期实时任务"></a>周期实时任务</h4><p>周期实时任务：一系列相似的任务</p><ul><li>任务有规律地重复</li><li>周期 p &#x3D; 任务请求时间间隔（0 &lt; p）</li><li>执行时间 e &#x3D; 最大执行时间（0 &lt; e &lt; p）</li><li>使用率U&#x3D;e &#x2F; p</li></ul><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220906130755301.png" alt="image-20220906130755301" style="zoom:67%;"><h4 id="硬时限和软时限"><a href="#硬时限和软时限" class="headerlink" title="硬时限和软时限"></a>硬时限和软时限</h4><p>硬时限（Hard deadline）</p><ul><li>错过任务时限会导致灾难性或非常严重的后果</li><li>必须验证，在最坏情况下能够满足时限</li></ul><p>软时限（Soft deadline）</p><ul><li>通常能满足任务时限<ul><li>如有时不能满足，则降低要求</li></ul></li><li>尽力保证满足任务时限</li></ul><h4 id="可调度性"><a href="#可调度性" class="headerlink" title="可调度性"></a>可调度性</h4><p>可调度表示一个实时操作系统能够满足任务时限要求</p><ul><li>需要确定实时任务的执行顺序</li><li>静态优先级调度</li><li>动态优先级调度</li></ul><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220907105051196.png" alt="image-20220907105051196" style="zoom:50%;"><h4 id="实时调度"><a href="#实时调度" class="headerlink" title="实时调度"></a>实时调度</h4><p>速率单调调度算法（RM，Rate Monotonic）</p><ul><li>通过&#x3D;&#x3D;周期&#x3D;&#x3D;安排优先级</li><li>周期越短优先级越高</li><li>执行周期最短的任务</li></ul><p>最早截止时间优先算法（EDF，Earliest Deadline First）</p><ul><li>截止时间越早优先级越高</li><li>执行截止时间最早的任务</li></ul><blockquote><p>这两种算法在一定条件下，满足可调度性</p></blockquote><h4 id="多处理机调度"><a href="#多处理机调度" class="headerlink" title="多处理机调度"></a>多处理机调度</h4><p>多处理机调度的特征</p><ul><li>多个处理机组成一个多处理机系统</li><li>处理机间可负载共享</li></ul><p>对称多处理器（SMP，Symmetric multiprocessing）调度</p><ul><li>截止时间越早优先级越高，每个处理器运行自己的调度程序</li><li>调度程序对共享资源的访问需要进行同步</li></ul><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220907105304753.png" alt="image-20220907105304753" style="zoom: 67%;"><blockquote><p>共享资源同步是多处理机调度最大的问题</p></blockquote><h4 id="对称多处理器的进程分配"><a href="#对称多处理器的进程分配" class="headerlink" title="对称多处理器的进程分配"></a>对称多处理器的进程分配</h4><p>静态进程分配</p><ul><li>进程从开始到结束都被分配到一个固定的处理机上执行</li><li>每个处理机有自己的就绪队列</li><li>调度开销小</li><li>各处理机可能忙闲不均</li></ul><p>动态进程分配</p><ul><li>进程在执行中可分配到任意空闲处理机执行</li><li>所有处理机共享一个公共的就绪队列</li><li>调度开销大</li><li>各处理机的负载是均衡的</li></ul><h2 id="6、优先级反置"><a href="#6、优先级反置" class="headerlink" title="6、优先级反置"></a>6、优先级反置</h2><h4 id="优先级反置"><a href="#优先级反置" class="headerlink" title="优先级反置"></a>优先级反置</h4><p>操作系统中出现高优先级进程长时间等待低优先级进程所占用资源的现象</p><p>基于优先级的可抢占调度算法存在优先级反置</p><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220907105613987.png" alt="image-20220907105613987" style="zoom:67%;"><blockquote><p>优先级反置：在优先级可抢占调度算法下，高优先级T2由于T1占用L1资源，没有进行抢占CPU，而是申请L1资源后进入阻塞状态，之后T3高优先级资源满足，进行抢占CPU，导致T1进入阻塞状态无法执行，T1不释放资源导致更高的优先级T2长时间的等待</p></blockquote><h4 id="优先级继承"><a href="#优先级继承" class="headerlink" title="优先级继承"></a>优先级继承</h4><p>占用资源的低优先级进程继承申请资源的高优先级进程的优先级</p><ul><li>只在占有资源的低优先级进程被阻塞时，才提高占有资源进程的优先级</li></ul><blockquote><p>你优先级高，我被阻塞了，借你的优先级给我用用，一会儿释放资源给你</p></blockquote><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220907110140370.png" alt="image-20220907110140370" style="zoom: 67%;"><p>首先T3执行占用资源s，T1抢占CPU执行而T3被阻塞，之后T1需要资源s，所以T3继承T1优先级，T1等待T3执行完后释放资源，T1才能获得资源s进行执行</p><h4 id="优先级天花板协议"><a href="#优先级天花板协议" class="headerlink" title="优先级天花板协议"></a>优先级天花板协议</h4><p>占用资源进程的优先级和所有可能申请该资源的进程的最高优先级相同</p><ul><li>不管是否发生等待，都提升占用资源进程的优先级</li><li>优先级高于系统中所有被锁定的资源的优先级上限，任务执行临界区时就不会被阻塞</li></ul><blockquote><p>你的优先级那么高，你赶紧先吃，一会儿我们在吃</p></blockquote><h1 id="十、同步互斥"><a href="#十、同步互斥" class="headerlink" title="十、同步互斥"></a>十、同步互斥</h1><h2 id="1、背景"><a href="#1、背景" class="headerlink" title="1、背景"></a>1、背景</h2><h4 id="并发进程的正确性"><a href="#并发进程的正确性" class="headerlink" title="并发进程的正确性"></a>并发进程的正确性</h4><p>独立进程</p><ul><li>不和其他进程共享资源或状态</li><li>&#x3D;&#x3D;确定性&#x3D;&#x3D;  –&gt; 输入状态决定结果</li><li>&#x3D;&#x3D;可重现&#x3D;&#x3D;  –&gt; 能够重现起始条件</li><li>调度顺序不重要</li></ul><p>并发进程</p><ul><li>在多个进程间有资源共享</li><li>不确定性</li><li>不可重现</li></ul><p>并发进程的正确性</p><ul><li>执行过程是不确定性和不可重现的</li><li>程序错误可能是间歇性发生的</li></ul><h4 id="进程并发执行的好处"><a href="#进程并发执行的好处" class="headerlink" title="进程并发执行的好处"></a>进程并发执行的好处</h4><p>进程需要与计算机中的其他进程和设备进行协作</p><ul><li>好处1：共享资源<ul><li>多个用户使用同一台计算机</li><li>银行账号存款余额在多台ATM机操作</li><li>机器人上的嵌入式系统协调手臂和手的动作</li></ul></li><li>好处2：加速<ul><li>I&#x2F;O 操作和CPU计算可在重叠（并行）</li><li>程序可划分成多个模块放在多个处理器上并行执行</li></ul></li><li>好处3：模块化<ul><li>将大程序分解成小程序<ul><li>以编译为例，gcc会调用cpp、cc1、cc2、as、ld等编译链接函数</li></ul></li><li>使系统易于复用和扩展</li></ul></li></ul><h4 id="并发创建新进程时的标识分配"><a href="#并发创建新进程时的标识分配" class="headerlink" title="并发创建新进程时的标识分配"></a>并发创建新进程时的标识分配</h4><p>程序可以调用函数fork（）来创建一个新的进程</p><ul><li>操作系统需要分配一个新的并且&#x3D;&#x3D;唯一的进程ID&#x3D;&#x3D;</li><li>在内核中，这个系统调用会运行</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new_pid = next_pid ++</span><br></pre></td></tr></table></figure><ul><li>翻译成机器指令</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LOAD next_pid Reg1</span><br><span class="line">STORE Reg1 new_pid</span><br><span class="line">INC Reg1</span><br><span class="line">STORE  Reg1 next_pid</span><br></pre></td></tr></table></figure><p>两个进程并发执行时的预期结果（假定next_pid &#x3D;100）</p><ul><li>一个进程得到的ID应该是100</li><li>另一个进程的ID应该是101</li><li>next_pid 应该增加到102</li></ul><h4 id="新进程分配标识的可能错误"><a href="#新进程分配标识的可能错误" class="headerlink" title="新进程分配标识的可能错误"></a>新进程分配标识的可能错误</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220605115703062.png" alt="image-20220605115703062" style="zoom:50%;"><blockquote><p>为新进程分配标识，四条汇编代码应该一块执行，即赋值id，之后加1写回去，但是这里执行赋值之后被中断了，导致出现两个相同的id</p></blockquote><h4 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h4><p>原子操作是指一次不存在任何中断或失败的操作</p><ul><li>要么操作成功完成</li><li>或者操作没有执行</li><li>不会出现部分执行的状态</li></ul><p>操作系统需要利用同步机制在并发执行的同时保证一些操作是原子操作</p><h2 id="2、现实生活中的同步问题"><a href="#2、现实生活中的同步问题" class="headerlink" title="2、现实生活中的同步问题"></a>2、现实生活中的同步问题</h2><h4 id="现实生活中的同步问题"><a href="#现实生活中的同步问题" class="headerlink" title="现实生活中的同步问题"></a>现实生活中的同步问题</h4><p>操作系统和现实生活的问题类比</p><ul><li>利用现实生活问题帮助理解操作系统同步问题</li><li>同时注意，计算机与人的差异</li></ul><p>例如：家庭采购协调</p><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220907111604848.png" alt="image-20220907111604848" style="zoom:67%;"><h4 id="家庭采购协调问题分析"><a href="#家庭采购协调问题分析" class="headerlink" title="家庭采购协调问题分析"></a>家庭采购协调问题分析</h4><p>如何保证家庭采购协调的成功和高效</p><ul><li><p>有人去买</p><p>需要采购时，有人去买面包</p></li><li><p>最多只有一个人去买面包</p></li></ul><p>可能的解决方法</p><ul><li>在冰箱上设置一个&#x3D;&#x3D;锁和钥匙（lock&amp;key）&#x3D;&#x3D;</li><li>去买面包之前锁住冰箱并且拿走钥匙</li></ul><p>加锁导致的新问题</p><ul><li>冰箱中还有其他食品时，别人无法取到</li></ul><h4 id="解决方案一"><a href="#解决方案一" class="headerlink" title="解决方案一"></a>解决方案一</h4><p>使用&#x3D;&#x3D;便签&#x3D;&#x3D;来避免购买太多面包</p><ul><li>购买之前留下一张便签</li><li>买完后移除该便签</li><li>别人看到便签时，就不去购买面包</li></ul><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220907111937734.png" alt="image-20220907111937734" style="zoom:50%;"><p><strong>方案一分析</strong></p><p>偶尔会购买太多面包</p><ul><li>检查面包和便签后帖便签前，有其他人检查面包和便签</li></ul><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220907112038696.png" alt="image-20220907112038696" style="zoom: 67%;"><p>对于生活中两人几乎同时来检查有没有面包和有没有便签，之后不可能发生买重的问题，但是在计算机中就会出现此问题</p><p>解决方案只是间歇性地失败</p><ul><li>问题难以调试</li><li>必须考虑调度器所做的事情</li></ul><h4 id="解决方案2"><a href="#解决方案2" class="headerlink" title="解决方案2"></a>解决方案2</h4><p>&#x3D;&#x3D;先留便签，后检查面包和便签&#x3D;&#x3D;</p><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220907112148209.png" alt="image-20220907112148209" style="zoom:50%;"><p>不会有人买面包</p><h4 id="解决方案3"><a href="#解决方案3" class="headerlink" title="解决方案3"></a>解决方案3</h4><p>&#x3D;&#x3D;为便签增加标记，以区别不同人的便签&#x3D;&#x3D;</p><ul><li>现在可在检查之前留便签</li></ul><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220907112305482.png" alt="image-20220907112305482" style="zoom: 50%;"><blockquote><p>最后导致谁都没有检查有没有面包，都以为另外一个人会去买</p></blockquote><h4 id="解决方案4"><a href="#解决方案4" class="headerlink" title="解决方案4"></a>解决方案4</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220605122616182.png" alt="image-20220605122616182" style="zoom:50%;"><p><strong>方案4分析</strong></p><p>它有效，但太复杂</p><ul><li>很难验证它的有效性</li></ul><p>A和B的代码不同</p><ul><li>每个进程的代码也会略有不同</li><li>如果进程更多，怎么办？</li></ul><p>&#x3D;&#x3D;当A在等待时，它不能做其他事&#x3D;&#x3D;</p><ul><li>忙等待（busy-waiting）</li></ul><h4 id="解决方案5"><a href="#解决方案5" class="headerlink" title="解决方案5"></a>解决方案5</h4><p>&#x3D;&#x3D;利用两个原子操作实现一个锁（lock）&#x3D;&#x3D;</p><ul><li>Lock.Acquire( )<ul><li>在锁被释放前一直等待，然后获得锁</li><li>如果两个线程都在等待同一个锁，并且同时发现锁被释放了，那么只有一个能够获得锁</li></ul></li><li>Lock.Release( )<ul><li>解锁并唤醒任何等待中的进程</li></ul></li></ul><p>基于原子锁的解决方案：</p><p><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220605122939306.png" alt="image-20220605122939306"></p><h4 id="进程的交互关系：相互感知程度"><a href="#进程的交互关系：相互感知程度" class="headerlink" title="进程的交互关系：相互感知程度"></a>进程的交互关系：相互感知程度</h4><table><thead><tr><th>相互感知的程度</th><th>交互关系</th><th>进程间的影响</th></tr></thead><tbody><tr><td>相互不感知（完全不了解其它进程的存在）</td><td>独立</td><td>一个进程的操作对其他进程的结果无影响</td></tr><tr><td>&#x3D;&#x3D;间接感知（双方都与第三方交互，如共享资源）&#x3D;&#x3D;</td><td>&#x3D;&#x3D;通过共享进行协作&#x3D;&#x3D;</td><td>&#x3D;&#x3D;一个进程的结果依赖于共享资源的状态&#x3D;&#x3D;</td></tr><tr><td>直接感知（双方直接交互，如通信）</td><td>通过通信进行协作</td><td>一个进程的结果依赖于从其他进程获得的信息</td></tr></tbody></table><p>互斥</p><ul><li>一个进程占用资源，其他进程不能使用</li></ul><p>死锁</p><ul><li>多个进程各占用部分资源，形成循环等待</li></ul><p>饥饿</p><ul><li>其他进程可能轮流占用资源，一个进程一直得不到资源</li></ul><h2 id="3、临界区"><a href="#3、临界区" class="headerlink" title="3、临界区"></a>3、临界区</h2><h4 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">entry section</span><br><span class="line">critical section</span><br><span class="line">exit section</span><br><span class="line">remainder section</span><br></pre></td></tr></table></figure><p>进入区</p><ul><li>检查可否进入临界区的一段代码</li><li>如可进入，设置相应“正在访问临界区”标志</li></ul><p>临界区</p><ul><li>进程中访问临界资源的一段需要互斥执行的代码</li></ul><p>退出区</p><ul><li>清除”正在访问临界区“标志</li></ul><p>剩余区</p><ul><li>代码中的其余部分（如执行一些返回地址或跳转等）</li></ul><h4 id="临界区的访问规则"><a href="#临界区的访问规则" class="headerlink" title="临界区的访问规则"></a>临界区的访问规则</h4><p>空闲则入</p><ul><li>没有进程在临界区时，任何进程可进入</li></ul><p>忙则等待</p><ul><li>有进程在临界区时，其他进程均不能进入临界区</li></ul><p>优先等待</p><ul><li>等待进入临界区的进程不能无限期等待</li></ul><p>让权等待（可选）</p><ul><li>不能进入临界区的进程，应释放CPU（如转换到阻塞状态）</li></ul><h4 id="临界区的实现方法"><a href="#临界区的实现方法" class="headerlink" title="临界区的实现方法"></a>临界区的实现方法</h4><ul><li>禁用中断</li><li>软件方法</li><li>更高级的抽象方法</li><li>不同的临界区实现机制的比较<ul><li>性能：并发级别</li></ul></li></ul><h2 id="4、禁用硬件中断同步方法"><a href="#4、禁用硬件中断同步方法" class="headerlink" title="4、禁用硬件中断同步方法"></a>4、禁用硬件中断同步方法</h2><h4 id="禁用硬件中断"><a href="#禁用硬件中断" class="headerlink" title="禁用硬件中断"></a>禁用硬件中断</h4><p>没有中断，没有上下文切换，因此没有并发</p><ul><li>硬件将中断处理延迟到中断被启用之后</li><li>现代计算机体系结构都提供指令来实现禁用中断</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">local_irg_save(<span class="type">unsigned</span> <span class="type">long</span> flags);</span><br><span class="line">critical section</span><br><span class="line"><span class="title function_">local_irq_restore</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> flags)</span>;</span><br></pre></td></tr></table></figure><p>进入临界区</p><ul><li>禁止所有中断，并保存标志</li></ul><p>离开临界区</p><ul><li>使能所有中断，并恢复标志</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li><p>禁用中断后，进程无法被停止</p><ul><li>整个系统都会为此停下来</li><li>可能导致其他进程处于机饿状态</li></ul></li><li><p>临界区可能很长</p><ul><li>无法确定响应中断所需的时间（可能存在硬件影响）</li></ul></li><li><p>要小心使用</p></li></ul><h2 id="5、基于软件的同步方法"><a href="#5、基于软件的同步方法" class="headerlink" title="5、基于软件的同步方法"></a>5、基于软件的同步方法</h2><h4 id="基于软件的同步解决方法"><a href="#基于软件的同步解决方法" class="headerlink" title="基于软件的同步解决方法"></a>基于软件的同步解决方法</h4><p>两个线程，T0和T1 </p><ul><li>线程Ti的代码</li></ul><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220907114142843.png" alt="image-20220907114142843" style="zoom:67%;"><p>线程可通过共享一些共有变量来同步它们的行为</p><h4 id="第一次尝试"><a href="#第一次尝试" class="headerlink" title="第一次尝试"></a>第一次尝试</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220907114632391.png" alt="image-20220907114632391" style="zoom: 67%;"><p>满足“忙则等待”，但是有时不满足“空闲则入</p><ul><li>Ti 不在临界区，Ti 想要继续运行，但是必须等待Ti 进入过临界区后</li></ul><h4 id="第二种尝试"><a href="#第二种尝试" class="headerlink" title="第二种尝试"></a>第二种尝试</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220907114701720.png" alt="image-20220907114701720" style="zoom: 67%;"><p>不满足 “忙则等待“</p><h4 id="第三种尝试"><a href="#第三种尝试" class="headerlink" title="第三种尝试"></a>第三种尝试</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220907114817566.png" alt="image-20220907114817566" style="zoom: 67%;"><p>满足 “忙则等待”，但是不满足 “空闲则入“</p><h4 id="Peterson算法"><a href="#Peterson算法" class="headerlink" title="Peterson算法"></a>Peterson算法</h4><p>满足线程Ti 和 Tj 之间互斥的经典的基于软件的解决方法</p><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220907114921534.png" alt="image-20220907114921534" style="zoom: 67%;"><h4 id="Peterson算法实现"><a href="#Peterson算法实现" class="headerlink" title="Peterson算法实现"></a>Peterson算法实现</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220606104800654.png" alt="image-20220606104800654" style="zoom: 67%;"><h4 id="Dekkers算法"><a href="#Dekkers算法" class="headerlink" title="Dekkers算法"></a>Dekkers算法</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220828101840870.png" alt="image-20220828101840870" style="zoom:67%;"><h4 id="N线程的软件方法（Eisenberg和McGuire）"><a href="#N线程的软件方法（Eisenberg和McGuire）" class="headerlink" title="N线程的软件方法（Eisenberg和McGuire）"></a>N线程的软件方法（Eisenberg和McGuire）</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220828114647192.png" alt="image-20220828114647192" style="zoom:67%;"><h4 id="基于软件的解决方法的分析"><a href="#基于软件的解决方法的分析" class="headerlink" title="基于软件的解决方法的分析"></a>基于软件的解决方法的分析</h4><p>复杂</p><ul><li>需要两个进程间的共享数据项</li></ul><p>需要忙等待</p><ul><li>浪费CPU时间</li></ul><h2 id="6、高级抽象的同步方法"><a href="#6、高级抽象的同步方法" class="headerlink" title="6、高级抽象的同步方法"></a>6、高级抽象的同步方法</h2><h4 id="高级抽象的同步方法"><a href="#高级抽象的同步方法" class="headerlink" title="高级抽象的同步方法"></a>高级抽象的同步方法</h4><p>硬件提供了一些同步原语</p><ul><li>中断禁用，原子操作指令等</li></ul><p>操作系统提供更高级的编程抽象来简化进程同步</p><ul><li>例如：锁、信号量</li><li>用硬件原语来构建</li></ul><h4 id="锁（Lock）"><a href="#锁（Lock）" class="headerlink" title="锁（Lock）"></a>锁（Lock）</h4><p>锁是一个抽象的数据结构</p><ul><li>一个二进制变量（锁定&#x2F;&#x2F;解锁）</li><li>Lock :: Acquire()<ul><li>锁被释放前一直等待，然后得到锁</li></ul></li><li>Lock :: Release()<ul><li>释放锁，唤醒任何等待的进程</li></ul></li></ul><p>使用锁来控制临界区访问</p><p><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220828115632639.png" alt="image-20220828115632639"></p><h4 id="原子操作指令"><a href="#原子操作指令" class="headerlink" title="原子操作指令"></a>原子操作指令</h4><ul><li>现代CPU体系结构都提供一些特殊的原子操作指令</li><li>测试和置位（Test-and-Set）指令<ul><li>从内存单元中读取值</li><li>测试该值是否为1（然后返回真或假）</li><li>内存单元值设置为1</li></ul></li></ul><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220907115409189.png" alt="image-20220907115409189" style="zoom: 67%;"><ul><li>交换指令（exchange）<ul><li>交换内存中的两个值</li></ul></li></ul><p><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220907115459925.png" alt="image-20220907115459925"></p><h4 id="使用TS指令实现自旋锁（spinlock）"><a href="#使用TS指令实现自旋锁（spinlock）" class="headerlink" title="使用TS指令实现自旋锁（spinlock）"></a>使用TS指令实现自旋锁（spinlock）</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220828120418593.png" alt="image-20220828120418593" style="zoom: 67%;"><blockquote><p>特点：线程在等待的时候消耗CPU时间</p></blockquote><h4 id="无忙等待锁"><a href="#无忙等待锁" class="headerlink" title="无忙等待锁"></a>无忙等待锁</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220828120731407.png" alt="image-20220828120731407" style="zoom:67%;"><blockquote><p>如锁是关时，当前进程加入等待队列，schedule()CPU执行调度程序，如果该锁释放，唤醒等待队列，队列中的进程在去查看锁的状态</p></blockquote><h4 id="原子操作指令特征锁"><a href="#原子操作指令特征锁" class="headerlink" title="原子操作指令特征锁"></a>原子操作指令特征锁</h4><p>优点</p><ul><li>适用于单处理器或者共享主存的&#x3D;&#x3D;多处理器&#x3D;&#x3D;中&#x3D;&#x3D;任意数量的进程同步&#x3D;&#x3D;</li><li>简单并且容易证明</li><li>支持多临界区</li></ul><p>缺点</p><ul><li>忙等待消耗处理器时间</li><li>可能导致机饿</li><li>进程离开临界区时有多个等待进程的情况</li><li>死锁<ul><li>拥有临界区的低优先级进程</li><li>请求访问临界区的高优先级进程获得处理器并等待临界区</li></ul></li></ul><h4 id="同步方法总结"><a href="#同步方法总结" class="headerlink" title="同步方法总结"></a>同步方法总结</h4><p>锁是一种高级的同步抽象方法</p><ul><li>互斥可以使用锁来实现</li><li>需要硬件支持</li></ul><p>常用的三种同步实现方法</p><ul><li>禁用中断（仅限于单处理器）</li><li>软件方法（复杂）</li><li>原子操作指令（单处理器或多处理器均可）</li></ul><h2 id="7、信号量（semaphore）"><a href="#7、信号量（semaphore）" class="headerlink" title="7、信号量（semaphore）"></a>7、信号量（semaphore）</h2><h4 id="回顾并发和同步"><a href="#回顾并发和同步" class="headerlink" title="回顾并发和同步"></a>回顾并发和同步</h4><p>并发问题</p><ul><li>多线程并发导致资源竞争</li></ul><p>同步概念</p><ul><li>协调多线程对共享数据的访问</li><li>任何时刻只能有一个线程执行临界区代码</li></ul><p>确保同步正确的方法</p><ul><li>底层硬件支持</li><li>高层次的编程抽象</li></ul><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220908083815091.png" alt="image-20220908083815091" style="zoom: 67%;"><h4 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h4><ul><li>信号量是操作系统提供的一种协调共享资源访问的方法<ul><li>软件同步是平等线程间的一种同步协商机制</li><li>OS是管理者，地位高于进程</li><li>用信号量表示&#x3D;&#x3D;系统资源的数量&#x3D;&#x3D;</li></ul></li><li>由Dijkstra在20世纪60年代提出</li><li>早期的操作系统的主要同步机制<ul><li>现在很少用（但还是非常重要在计算机科学研究）</li></ul></li></ul><h4 id="信号量的类比示例"><a href="#信号量的类比示例" class="headerlink" title="信号量的类比示例"></a>信号量的类比示例</h4><p>信号是一种抽象数据类型</p><ul><li>由一个整型（sem）变量和两个原子操作组成</li><li>P( ) （Prolaag）荷兰语尝试减少<ul><li>sem减少1</li><li>如 sem&lt; 0 ，进入等待，否则继续</li></ul></li><li>V( ) <ul><li>sem加1</li><li>如sem&lt;&#x3D;0，唤醒一个等待进程</li></ul></li><li>信号量与铁路的类比<ul><li>2个站台的车站</li><li>2个资源的信号量</li></ul></li></ul><p><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220828221403975.png" alt="image-20220828221403975"></p><h4 id="信号量的特性"><a href="#信号量的特性" class="headerlink" title="信号量的特性"></a>信号量的特性</h4><ul><li>信号量是&#x3D;&#x3D;被保护&#x3D;&#x3D;的&#x3D;&#x3D;整数&#x3D;&#x3D;变量<ul><li>初始化完成后，只能通过P（）和V（）操作修改</li><li>由操作系统保证，PV操作是原子操作</li></ul></li><li>&#x3D;&#x3D;P（）可能阻塞&#x3D;&#x3D;，V（）不会阻塞</li><li>通常假定信号量是“公平的“<ul><li>线程不会被无限期阻塞在P（）操作</li><li>假定信号量等待按先进先出排队</li></ul></li></ul><blockquote><p>自旋锁能否实现先进先出？</p><p>不能实现先进先出，当释放锁时，各个等待的进程需要抢占CPU去检查锁开关状态</p></blockquote><h4 id="信号量的发展"><a href="#信号量的发展" class="headerlink" title="信号量的发展"></a>信号量的发展</h4><ul><li>整型信号量（重点了解）<ul><li>在整型信号量机制中的wait操作，只要是信号量S≤0般会&#x3D;&#x3D;不断地测试&#x3D;&#x3D;</li></ul></li><li>记录型信号量（重点了解）<ul><li>整型信号量并未遵循“让权等待”的准则，而是使进程处于“忙等”的状态</li><li>记录型信号量机制则是一种不存在“忙等”现象的进程同步机制。但在采取了“让权等待”的策略后，又会出现多个进程等待访问同一临界资源的情况。为此，在信号量机制中，除了需要一个用于代表&#x3D;&#x3D;资源数目的整型变量value&#x3D;&#x3D;外，还应增加一个&#x3D;&#x3D;进程链表指针list&#x3D;&#x3D;，用于&#x3D;&#x3D;链接上述的所有等待进程&#x3D;&#x3D;。</li></ul></li><li>AND信号量</li><li>信号量集</li></ul><h4 id="记录型信号量的实现"><a href="#记录型信号量的实现" class="headerlink" title="记录型信号量的实现"></a>记录型信号量的实现</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220829091238213.png" alt="image-20220829091238213" style="zoom: 67%;"><blockquote><p>这段代码由操作系统内核执行，保证其原子性，避免以往中断带来的同步问题</p></blockquote><h4 id="信号量的分类和使用"><a href="#信号量的分类和使用" class="headerlink" title="信号量的分类和使用"></a>信号量的分类和使用</h4><p>可分为两种信号量</p><ul><li>&#x3D;&#x3D;二进制信号量&#x3D;&#x3D;：资源数目为0或1</li><li>&#x3D;&#x3D;资源信号量&#x3D;&#x3D;：资源数目为任何非负值</li><li>两者等价<ul><li>基于一个可以实现另一个</li></ul></li></ul><p>信号量的使用</p><ul><li>互斥访问<ul><li>临界区的互斤访问控制</li></ul></li><li>条件同步<ul><li>线程间的事件等待</li></ul></li></ul><h4 id="信号量实现临界区的互斥访问"><a href="#信号量实现临界区的互斥访问" class="headerlink" title="信号量实现临界区的互斥访问"></a>信号量实现临界区的互斥访问</h4><p>每类资源设置一个信号量，其初值为1</p><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220908085239025.png" alt="image-20220908085239025" style="zoom: 67%;"><p>必须&#x3D;&#x3D;成对使用&#x3D;&#x3D;P（）操作和V（）操作</p><ul><li>P（）操作保证互后访问临界资源</li><li>V（）操作在使用后释放临界资源</li><li>PV操作&#x3D;&#x3D;不能次序错误、重复或遗漏&#x3D;&#x3D;</li></ul><h4 id="信号量实现条件同步"><a href="#信号量实现条件同步" class="headerlink" title="信号量实现条件同步"></a>信号量实现条件同步</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220829092314216.png" alt="image-20220829092314216" style="zoom: 80%;"><blockquote><p>假设线程A要实现N，要等待线程B实现完X，使用信号量实现这种条件同步，即线程A实现完M将信号量减一，线程B实现完X将信号量加一,线程A发现信号量恢复0，可执行N,线程B也继续执行Y。</p></blockquote><h4 id="生产者-消费者问题"><a href="#生产者-消费者问题" class="headerlink" title="生产者-消费者问题"></a>生产者-消费者问题</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220908085653163.png" alt="image-20220908085653163" style="zoom:80%;"><p>有界缓冲区的生产者-消费者问题描述</p><ul><li>一个或多个&#x3D;&#x3D;生产者&#x3D;&#x3D;在生成数据后放在一个缓冲区里</li><li>单个&#x3D;&#x3D;消费者&#x3D;&#x3D;从缓冲区取出数据处理</li><li>任何时刻&#x3D;&#x3D;只能有一个&#x3D;&#x3D;生产者或消费者可访问缓冲区</li></ul><h4 id="信号量解决生产者-消费者问题"><a href="#信号量解决生产者-消费者问题" class="headerlink" title="信号量解决生产者-消费者问题"></a>信号量解决生产者-消费者问题</h4><p>问题分析</p><ul><li>任何时刻只能有一个线程操作缓冲区（互兵访问）</li><li>缓冲区空时，消费者必须等待生产者（条件同步</li><li>缓冲区满时，生产者必须等待消费者（条件同步）</li></ul><p>用信号量描述每个约束</p><ul><li>二进制信号量mutex</li><li>资源信号量fullBuffers</li><li>资源信号量emptyBuffers</li></ul><p><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220829093616763.png" alt="image-20220829093616763"></p><h4 id="信号量的缺点"><a href="#信号量的缺点" class="headerlink" title="信号量的缺点"></a>信号量的缺点</h4><p>读&#x2F;开发代码比较困难</p><ul><li>程序员需要能运用信号量机制</li></ul><p>容易出错</p><ul><li>使用的信号量已经被另一个线程占用</li><li>忘记释放信号量</li></ul><p>不能够处理死锁问题</p><blockquote><p>不能解决死锁：因为一个线程进入到临界区后，如果执行的所需资源被占用，该线程不会自动放弃临界区资源，对方如果也想用临界区，这将导致严重的死锁问题</p></blockquote><h2 id="8、管程"><a href="#8、管程" class="headerlink" title="8、管程"></a>8、管程</h2><h4 id="基本同步方法"><a href="#基本同步方法" class="headerlink" title="基本同步方法"></a>基本同步方法</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220829100524485.png" alt="image-20220829100524485" style="zoom: 67%;"><h4 id="管程（Moniter）"><a href="#管程（Moniter）" class="headerlink" title="管程（Moniter）"></a>管程（Moniter）</h4><p>管程是一种用于多线程互斥访问共享资源的程序结构</p><ul><li>采用面向对象方法，简化了线程间的同步控制</li><li>任一时刻最多只有一个线程执行管程代码</li><li>正在管程中的线程可临时放弃管程的互斥访问，等待事件出现时恢复</li></ul><p>管程的使用</p><ul><li>在对象&#x2F;模块中，收集相关共享数据</li><li>定义访问共享数据的方法</li></ul><h4 id="管程的组成"><a href="#管程的组成" class="headerlink" title="管程的组成"></a>管程的组成</h4><p>一个锁</p><ul><li>控制管程代码的互斥访问</li></ul><p>0或者多个条件变量</p><ul><li>管理共享数据的并发访问</li></ul><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220908090630331.png" alt="image-20220908090630331" style="zoom:80%;"><blockquote><p>管程临界区每次只能进一个，如果进入到的管程临界区或执行管程代码时，某一条件被占用，不满足条件变量，则会被放入管程内的等待队列，此时管程可由下一个线程接管，当再次满足条件时，唤醒等待队列一个线程抢占执行</p></blockquote><h4 id="条件变量（Condition-Variable）"><a href="#条件变量（Condition-Variable）" class="headerlink" title="条件变量（Condition Variable）"></a>条件变量（Condition Variable）</h4><p>条件变量是管程内的等待机制</p><ul><li>进入管程的线程因资源被占用而进入等待状态</li><li>每个条件变量表示一种等待原因，对应一个等待队列</li></ul><p>Wait（）操作</p><ul><li>将自己阻塞在等待队列中</li><li>唤醒一个等待者或释放管程的互后访问</li></ul><p>Signal（）操作</p><ul><li>将等待队列中的一个线程唤醒</li><li>如果等待队列为空，则等同空操作</li></ul><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220829102639849.png" alt="image-20220829102639849"><h4 id="管程解决生产者-消费者问题"><a href="#管程解决生产者-消费者问题" class="headerlink" title="管程解决生产者-消费者问题"></a>管程解决生产者-消费者问题</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220829103622921.png" alt="image-20220829103622921" style="zoom: 67%;"><h4 id="管程条件变量的释放处理方式"><a href="#管程条件变量的释放处理方式" class="headerlink" title="管程条件变量的释放处理方式"></a>管程条件变量的释放处理方式</h4><p>Hansen管程：</p><ul><li>T2唤醒唤醒T1，仍继续执行，直到结束退出管程，T1才开始执行</li><li>主要用于真实的OS和Java中</li></ul><p>Hoare管程：</p><ul><li>T2唤醒T1后，T1立马恢复管程执行，执行结束后，才到T2执行</li><li>主要见于教材中</li></ul><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220829110812498.png" alt="image-20220829110812498" style="zoom: 67%;"><h4 id="Hansen管程与Hoare管程"><a href="#Hansen管程与Hoare管程" class="headerlink" title="Hansen管程与Hoare管程"></a>Hansen管程与Hoare管程</h4><p>Hansen管程</p><ul><li>条件变量释放仅是一个提示</li><li>需要重新检查条件</li><li>特点：高效</li></ul><p>Hoare管程</p><ul><li>条件变量释放同时表示放弃管程访问</li><li>释放后条件变量的状态可用</li><li>特点：低效</li></ul><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220908091731330.png" alt="image-20220908091731330" style="zoom:80%;"><h2 id="9、哲学家就餐问题"><a href="#9、哲学家就餐问题" class="headerlink" title="9、哲学家就餐问题"></a>9、哲学家就餐问题</h2><h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><ul><li>5个哲学家围绕一张圆桌而坐<ul><li>桌子上放着5支叉子</li><li>每两个哲学家之间放一支</li></ul></li><li>哲学家的动作包括思考和进餐<ul><li>进餐时需同时拿到左右两边的叉子</li><li>思考时将两支叉子放回原处</li></ul></li><li>如何保证哲学家们的动作有序进行？<ul><li>如：不出现有人永远拿不到叉子</li></ul></li></ul><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220908092455212.png" alt="image-20220908092455212" style="zoom:67%;"><h4 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220829211820678.png" alt="image-20220829211820678" style="zoom:67%;"><blockquote><p>不正确，可能导致死锁</p></blockquote><h4 id="方案二-信号量互斥访问"><a href="#方案二-信号量互斥访问" class="headerlink" title="方案二::信号量互斥访问"></a>方案二::信号量互斥访问</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220829211901768.png" alt="image-20220829211901768" style="zoom: 80%;"><blockquote><p>互斥访问正确，但每次只允许一人进餐</p></blockquote><h4 id="方案三"><a href="#方案三" class="headerlink" title="方案三"></a>方案三</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220829212022640.png" alt="image-20220829212022640" style="zoom:80%;"><blockquote><p>加变量i，2号哲学家来先拿左边筷子，3号哲学家来先拿右边筷子，中间的筷子二者谁抢先算谁的</p><p>没有死锁，可以多人同时进餐</p></blockquote><h2 id="10、读者-写者问题"><a href="#10、读者-写者问题" class="headerlink" title="10、读者-写者问题"></a>10、读者-写者问题</h2><h4 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h4><p>共享数据的两类使用者</p><ul><li>读者：只读取数据不修改</li><li>写者：读取和修改数据</li></ul><p>读者-写者问题描述：对共享数据的读写</p><ul><li>“读 - 读”允许<ul><li>同一时刻，允许有多个读者同时读</li></ul></li><li>“读－写”互斥<ul><li>没有写者时读者才能读</li><li>没有读者时写者才能写</li></ul></li><li>“写 - 写”互斥<ul><li>没有其他写者时写者才能写</li></ul></li></ul><h4 id="信号量解决读者-写者问题"><a href="#信号量解决读者-写者问题" class="headerlink" title="信号量解决读者-写者问题"></a>信号量解决读者-写者问题</h4><p>用信号量描述每个约束</p><ul><li>信号量WriteMutex<ul><li>控制读写操作的互斥</li><li>初始化为1</li></ul></li><li>读者计数Rcount<ul><li>正在进行读操作的读者数目</li><li>初始化为0</li></ul></li><li>信号量CountMutex<ul><li>控制对读者计数的互斥修改</li><li>初始化为1</li></ul></li></ul><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220829215248958.png" alt="image-20220829215248958" style="zoom: 80%;"><h4 id="优先策略"><a href="#优先策略" class="headerlink" title="优先策略"></a>优先策略</h4><p>读者优先策略</p><ul><li>只要有读者正在读状态，后来的读者都能直接进入</li><li>如读者持续不断进入，则写者就处于饥饿</li></ul><p>写者优先策略</p><ul><li>只要有写者就绪，写者应尽快执行写操作</li><li>如写者持续不断就绪，则读者就处于饥饿</li></ul><h4 id="用管程解决读者-写者问题"><a href="#用管程解决读者-写者问题" class="headerlink" title="用管程解决读者-写者问题"></a>用管程解决读者-写者问题</h4><p><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220829215500272.png" alt="image-20220829215500272"></p><h4 id="解决方案详细：读者"><a href="#解决方案详细：读者" class="headerlink" title="解决方案详细：读者"></a>解决方案详细：读者</h4><p><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220829215547076.png" alt="image-20220829215547076"></p><h4 id="解决方案详细：写者"><a href="#解决方案详细：写者" class="headerlink" title="解决方案详细：写者"></a>解决方案详细：写者</h4><p><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220829215625842.png" alt="image-20220829215625842"></p><blockquote><p>管程实现主要以写者优先</p></blockquote><h1 id="十一、死锁"><a href="#十一、死锁" class="headerlink" title="十一、死锁"></a>十一、死锁</h1><h2 id="1、死锁的概念"><a href="#1、死锁的概念" class="headerlink" title="1、死锁的概念"></a>1、死锁的概念</h2><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>由于竞争资源或通信关系，两个或更多线程在执行中出现，永远相互等待只能由其他进程引发的事件</p><h4 id="死锁实例：单向通行桥梁"><a href="#死锁实例：单向通行桥梁" class="headerlink" title="死锁实例：单向通行桥梁"></a>死锁实例：单向通行桥梁</h4><p>桥梁只能单向通行</p><p>桥的每个部分可视为一个资源</p><p>可能出现死锁</p><ul><li>对向行驶车辆在桥上相遇</li><li>解决方法：一个方向的车辆倒退（资源抢占和回退）</li></ul><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220829231026688.png" alt="image-20220829231026688" style="zoom: 67%;"><p>可能发生饥饿</p><ul><li>由于一个方向的持续车流，另一个方向的车辆无法通过桥梁</li></ul><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220829231316404.png" alt="image-20220829231316404" style="zoom:67%;"><h4 id="进程访问资源的流程"><a href="#进程访问资源的流程" class="headerlink" title="进程访问资源的流程"></a>进程访问资源的流程</h4><ul><li>资源类型R1，R2…..Rm<ul><li>CPU执行时间、内存空间、I&#x2F;O设备等</li></ul></li><li>每类资源Ri 有Wi 个实例</li><li>进程访问资源的流程<ul><li>请求&#x2F;获取<ul><li>申请空闲资源</li></ul></li><li>使用&#x2F;占用<ul><li>进程占用资源</li></ul></li><li>释放<ul><li>资源状态由占用变成空闲</li></ul></li></ul></li></ul><h4 id="资源分类"><a href="#资源分类" class="headerlink" title="资源分类"></a>资源分类</h4><p>可重用资源（Reusable Resource）</p><ul><li>资源不能被删除且在任何时刻只能有一个进程使用</li><li>进程释放资源后，其他进程可重用</li><li>可重用资源示例<ul><li>硬件：处理器、I &#x2F; O通道、主和副存储器、设备等</li><li>软件：文件、数据库和信号量等数据结构</li></ul></li><li>可能出现死锁<ul><li>每个进程占用一部分资源并请求其他资源</li></ul></li></ul><p>消耗资源（Consumable Resource）</p><ul><li>资源创建和销毁</li><li>消耗资源示例<ul><li>在I &#x2F; O 缓冲区的中断、信号、消息等</li></ul></li></ul><h4 id="资源分配图"><a href="#资源分配图" class="headerlink" title="资源分配图"></a>资源分配图</h4><p>&#x3D;&#x3D;描述资源和进程间的分配和占用关系的有向图&#x3D;&#x3D;<br>两类顶点</p><ul><li>系统中的所有进程<br>P&#x3D;(Pi, P2.. Pn）</li><li>系统中的所有资源<br>R&#x3D; (Ri, R2..Pm）</li></ul><p>两类有向边</p><ul><li>资源请求边<br>进程Pi请求资源Rj：Pi→Rj</li><li>资源分配边<br>资源Rj已分配给进程Pi：Rj→Pi</li></ul><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220908101632240.png" alt="image-20220908101632240" style="zoom:67%;"><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220829232241311.png" alt="image-20220829232241311" style="zoom:67%;"><h4 id="出现死锁的必要条件"><a href="#出现死锁的必要条件" class="headerlink" title="出现死锁的必要条件"></a>出现死锁的必要条件</h4><p>互斥</p><ul><li>任何时刻只能由一个进程使用一个资源实例</li></ul><p>非抢占</p><ul><li>资源只能在进程使用后资源释放</li></ul><p>持有并等待</p><ul><li>进程保持至少一个资源，并正在等待获取其他进程持有的资源</li></ul><p>循环等待</p><ul><li><p>存在等待进程集合{ P0，P1，…..，PN }，</p><p>P0正在等待P1所占用的资源，</p><p>P1正在等待P2所占用的资源，</p><p>PN-1正在等待PN所占用的资源，</p><p>PN正在等待P0所占用的资源。</p></li></ul><h2 id="2、死锁处理的方法"><a href="#2、死锁处理的方法" class="headerlink" title="2、死锁处理的方法"></a>2、死锁处理的方法</h2><h4 id="死锁处理的方法"><a href="#死锁处理的方法" class="headerlink" title="死锁处理的方法"></a>死锁处理的方法</h4><p>&#x3D;&#x3D;死锁预防（Deadlock Prevention）&#x3D;&#x3D;</p><ul><li>确保系统永远不会进入死锁状态</li></ul><p>&#x3D;&#x3D;死锁避免（Deadlock Avoidance）&#x3D;&#x3D;</p><ul><li>在使用前进行判断，只允许不会出现死锁的进程请求资源</li></ul><p>&#x3D;&#x3D;死锁检测和恢复（Deadlock Detection &amp; Recovery）&#x3D;&#x3D;</p><ul><li>在检测到运行系统进入死锁状态后，进行恢复</li></ul><p>由应用进程处理死锁</p><ul><li>通常操作系统忽略死锁<ul><li>大多数操作系统（包括UNIX）的做法</li></ul></li></ul><h4 id="死锁预防：限制申请方式"><a href="#死锁预防：限制申请方式" class="headerlink" title="死锁预防：限制申请方式"></a>死锁预防：限制申请方式</h4><p>预防是采用某种策略，限制并发进程对资源的请求，使系统在任何时刻都不满足死锁的必要要求</p><ul><li>互斥<ul><li>把互斥的共享资源封装成可同时访问的资源，如将其拷贝出来</li></ul></li><li>持有并等待<ul><li>进程请求资源时，要求它不持有任何资源</li><li>仅允许进程在开始执行时，一次请求所有需要的资源</li><li>资源利用率低</li></ul></li><li>非抢占<ul><li>如进程请求不能立即分配的资源，则释放已占有资源</li><li>只在能够同时获取所有需要资源时，才执行分配操作</li></ul></li><li>循环等待<ul><li>对资源排序，要求进程按顺序请求资源</li></ul></li></ul><h4 id="死锁避免"><a href="#死锁避免" class="headerlink" title="死锁避免"></a>死锁避免</h4><p>利用额外的先验信息，在分配资源时判断是否会出现死锁，只在不会死锁时分配资源</p><ul><li>要求进程声明需要资源的&#x3D;&#x3D;最大数目&#x3D;&#x3D;</li><li>限定&#x3D;&#x3D;提供&#x3D;&#x3D;与&#x3D;&#x3D;分配&#x3D;&#x3D;的资源数量，确保满足进程的&#x3D;&#x3D;最大&#x3D;&#x3D;需求</li><li>&#x3D;&#x3D;动态检查&#x3D;&#x3D;资源分配状态，确保不会出现环形等待</li></ul><h4 id="资源分配资源的安全状态"><a href="#资源分配资源的安全状态" class="headerlink" title="资源分配资源的安全状态"></a>资源分配资源的安全状态</h4><ul><li>当进程请求资源时，系统判断分配后是否处于安全状态</li><li>系统处于安全状态<ul><li>针对所有已占用进程，存在安全序列</li></ul></li><li>序列&lt;P1，P2….，PN&gt;是安全的<ul><li>Pi 要求的资源 ≤ 当前可用资源 + 所有 Pi 持有资源，其中j&lt;i</li><li>如Pi 的资源请求不能立即分配，则P等待所有Pj（j&lt;i）完成</li><li>Pi 完成后，Pi+1可得到所需资源，执行并释放所分配的资源</li><li>最终整个序列的所有Pi 都能获得所需资源</li></ul></li></ul><h4 id="安全状态与死锁的关系"><a href="#安全状态与死锁的关系" class="headerlink" title="安全状态与死锁的关系"></a>安全状态与死锁的关系</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220909090613482.png" alt="image-20220909090613482" style="zoom:67%;"><ul><li>系统处于安全状态，一定没有死锁</li><li>系统处于不安全状态，可能出现死锁<ul><li>避免死锁就是确保系统不会进入不安全状态</li></ul></li></ul><h2 id="3、银行家算法（Banker-96-s-Alogrithm）"><a href="#3、银行家算法（Banker-96-s-Alogrithm）" class="headerlink" title="3、银行家算法（Banker&#96;s  Alogrithm）"></a>3、银行家算法（Banker&#96;s  Alogrithm）</h2><h4 id="银行家算法概述"><a href="#银行家算法概述" class="headerlink" title="银行家算法概述"></a>银行家算法概述</h4><p>银行家算法是一个避免死锁产生的算法。以银行借贷分配策略为基础，判断并保证系统处于安全状态</p><ul><li>客户在第一次申请贷款时，声明所需最大资金量，在满足所有贷款要求并完成项目时，及时归还</li><li>在客户贷款数量不超过银行拥有的最大值时，银行家尽量满足客户需要</li><li>类比<ul><li>银行家 —-&gt; 操作系统</li><li>资金 —-&gt; 资源</li><li>客户 —-&gt; 申请资源的线程</li></ul></li></ul><h4 id="银行家算法：数据结构"><a href="#银行家算法：数据结构" class="headerlink" title="银行家算法：数据结构"></a>银行家算法：数据结构</h4><p>&#x3D;&#x3D;n&#x3D;&#x3D; &#x3D; 线程数量，&#x3D;&#x3D;m&#x3D;&#x3D; &#x3D;资源类型数量</p><ul><li>&#x3D;&#x3D;Max（总需求量）&#x3D;&#x3D;：n x m 矩阵<br>线程 Ti 最多请求类型 R 的资源Max[ i , j ]个实例</li><li>&#x3D;&#x3D;Available（剩余空闲量）&#x3D;&#x3D;：长度为m的向量<br>当前有Available[ i ] 个类型Rj的资源实例可用</li><li>&#x3D;&#x3D;Allocation（已分配量）&#x3D;&#x3D;：n x m矩阵<br>线程T当前分配了Allocation[ i , j ]个R的实例</li><li>&#x3D;&#x3D;Need（未来需要量）&#x3D;&#x3D;：n x m 矩阵<br>线程 Ti 未来需要Need[ i , j ]个 Rj 资源实例</li><li>&#x3D;&#x3D;Need[ i , j ] &#x3D; Max[ i , j ] - Allocation[ i , j ]&#x3D;&#x3D;</li></ul><h4 id="银行家算法：安全状态判断"><a href="#银行家算法：安全状态判断" class="headerlink" title="银行家算法：安全状态判断"></a>银行家算法：安全状态判断</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220830001152909.png" alt="image-20220830001152909" style="zoom:67%;"><h4 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h4><p>初始化：</p><ul><li>Request i 线程 Ti 的资源请求向量</li><li>Request i [ j ]线程 Ti 请求资源 Rj 的实例</li></ul><p>循环：</p><ol><li>如果 Request i ≤ Need[ i ]，转到步骤2。否则，拒绝资源申请，因为线程已经超过了其最大要求</li><li>如果Request i ≤ Available，转到步骤3。否则，Ti 必须等待，因为资源不可用</li><li>通过安全状态判断来确定是否分配资源给Ti：<ul><li>生成一个需要判断状态是否安全的资源分配环境</li></ul></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Available = Available - Request i:</span><br><span class="line">Allocation[i]= Allocationt[i]+Request i</span><br><span class="line">Needt[i]= Needt[i]-Request i</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;调用安全状态判断&#x3D;&#x3D;<br>如果返回结果是&#x3D;&#x3D;安全&#x3D;&#x3D;，将资源分配给Ti<br>如果返回结果是&#x3D;&#x3D;不安全&#x3D;&#x3D;，系统会拒绝Ti的资源请求</p><h4 id="银行家算法安全状态判断示例"><a href="#银行家算法安全状态判断示例" class="headerlink" title="银行家算法安全状态判断示例"></a>银行家算法安全状态判断示例</h4><p>&#x3D;&#x3D;初始状态&#x3D;&#x3D;</p><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220830001345403.png" alt="image-20220830001345403" style="zoom: 80%;"><p>&#x3D;&#x3D;T2线程完成运行&#x3D;&#x3D;</p><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220830001445186.png" alt="image-20220830001445186" style="zoom: 80%;"><p>&#x3D;&#x3D;T3线程完成运行&#x3D;&#x3D;</p><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220830001540615.png" alt="image-20220830001540615" style="zoom: 80%;"><p>&#x3D;&#x3D;这样就都可以完成了&#x3D;&#x3D;</p><h4 id="银行家算法安全状态判断示例2"><a href="#银行家算法安全状态判断示例2" class="headerlink" title="银行家算法安全状态判断示例2"></a>银行家算法安全状态判断示例2</h4><p>初始状态</p><p><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220830001620746.png" alt="image-20220830001620746"></p><p>可用资源不满足任何线程的当前请求资源数量，这是不安全</p><h2 id="4、死锁检测"><a href="#4、死锁检测" class="headerlink" title="4、死锁检测"></a>4、死锁检测</h2><h4 id="死锁检测"><a href="#死锁检测" class="headerlink" title="死锁检测"></a>死锁检测</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220909093025399.png" alt="image-20220909093025399" style="zoom: 67%;"><ul><li>允许系统进入死锁状态</li><li>维护系统的资源分配图</li><li>定期调用死锁检测算法来搜索图中是否存在死锁</li><li>出现死锁时，用死锁恢复机制进行恢复</li></ul><h4 id="死锁检测算法：数据结构"><a href="#死锁检测算法：数据结构" class="headerlink" title="死锁检测算法：数据结构"></a>死锁检测算法：数据结构</h4><p>&#x3D;&#x3D;Available&#x3D;&#x3D;:长度为m的向量</p><ul><li>每种类型可用资源的数量</li></ul><p>&#x3D;&#x3D;Allocation&#x3D;&#x3D;:一个n×m矩阵</p><ul><li>当前分配给各个进程每种类型资源的数量</li><li>进程Pi：拥有资源Rj 的Allocation[i，j]个实例</li></ul><h4 id="死锁检测算法"><a href="#死锁检测算法" class="headerlink" title="死锁检测算法"></a>死锁检测算法</h4><p><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220830141257516.png" alt="image-20220830141257516"></p><blockquote><p>算法需要O(m x n)^2 操作检测是否系统处于死锁状态</p></blockquote><h4 id="死锁检测示例1"><a href="#死锁检测示例1" class="headerlink" title="死锁检测示例1"></a>死锁检测示例1</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220830141645737.png" alt="image-20220830141645737" style="zoom:67%;"><h4 id="死锁检测示例2"><a href="#死锁检测示例2" class="headerlink" title="死锁检测示例2"></a>死锁检测示例2</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220830141711908.png" alt="image-20220830141711908" style="zoom:67%;"><h4 id="死锁检测算法的使用"><a href="#死锁检测算法的使用" class="headerlink" title="死锁检测算法的使用"></a>死锁检测算法的使用</h4><p>死锁检测的时间和周期选择依据</p><ul><li>死锁多久可能会发生</li><li>多少进程需要被回滚</li></ul><p>资源图可能有多个循环</p><ul><li>难于分辨“造成”死锁的关键进程</li></ul><h4 id="死锁恢复：进程终止"><a href="#死锁恢复：进程终止" class="headerlink" title="死锁恢复：进程终止"></a>死锁恢复：进程终止</h4><ul><li>终止所有的死锁进程</li><li>一次只终止一个进程直到死锁消除</li><li>终止进程的顺序应该是<ul><li>进程的优先级</li><li>进程已运行时间以及还需运行时间</li><li>进程已占用资源</li><li>进程完成需要的资源</li><li>终止进程数目</li><li>进程是交互还是批处理</li></ul></li></ul><h4 id="死锁恢复：资源抢占"><a href="#死锁恢复：资源抢占" class="headerlink" title="死锁恢复：资源抢占"></a>死锁恢复：资源抢占</h4><p>选择被抢占进程</p><ul><li>最小成本目标</li></ul><p>进程回退</p><ul><li>返回到一些安全状态，重启进程到安全状态</li></ul><p>可能出现饥饿</p><ul><li>同一进程可能一直被选作被抢占者</li></ul><h2 id="5、进程通信概念"><a href="#5、进程通信概念" class="headerlink" title="5、进程通信概念"></a>5、进程通信概念</h2><h4 id="进程通信（IPC-Inter-Process-Communication）"><a href="#进程通信（IPC-Inter-Process-Communication）" class="headerlink" title="进程通信（IPC,Inter-Process Communication）"></a>进程通信（IPC,Inter-Process Communication）</h4><ul><li>进程通信是进程进行通信和同步的机制</li><li>IPC提供2个基本操作<ul><li>发送操作：send（message）</li><li>接收操作：receive(message）</li></ul></li><li>进程通信流程<ul><li>在通信进程间建立通信链路</li><li>通过send&#x2F;receive交换消息</li></ul></li><li>进程链路特征<ul><li>物理（如，共享内存，硬件总线）</li><li>逻辑（如，逻辑属性）</li></ul></li></ul><h4 id="通信方式"><a href="#通信方式" class="headerlink" title="通信方式"></a>通信方式</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220830143029359.png" alt="image-20220830143029359" style="zoom:67%;"><h4 id="直接通信"><a href="#直接通信" class="headerlink" title="直接通信"></a>直接通信</h4><p>进程必须正确的命名对方</p><ul><li>send（P，message）-发送信息到进程P</li><li>receive（Q，message）－从进程Q接受消息</li></ul><p>通信链路的属性</p><ul><li>自动建立链路</li><li>一条链路恰好对应一对通信进程</li><li>每对进程之间只有一个链接存在</li><li>链接可以是单向的，但通常为双向的</li></ul><h4 id="间接通信"><a href="#间接通信" class="headerlink" title="间接通信"></a>间接通信</h4><p>通过操作系统维护的消息队列实现进程间的消息接收和发送</p><ul><li>每个消息队列都有一个唯一的标识</li><li>只有共享了相同消息队列的进程，才能够通信</li></ul><p>通信链路的属性</p><ul><li>只有共享了相同消息队列的进程，才建立连接</li><li>连接可以是单向或双向</li><li>消息队列可以与多个进程相关联</li><li>每对进程可以共享多个消息队列</li></ul><p>通信流程</p><ul><li>创建一个新的消息队列</li><li>通过消息队列发送和接收消息</li><li>销毁消息队列</li></ul><p>基本通信操作</p><ul><li>send（A，message）- 发送消息到队列A</li><li>receive（A，message）- 从队列A接受消息</li></ul><h4 id="阻塞和非阻塞通信"><a href="#阻塞和非阻塞通信" class="headerlink" title="阻塞和非阻塞通信"></a>阻塞和非阻塞通信</h4><ul><li>进程通信可划分为阻塞（同步）或非阻塞（异步）</li><li>阻塞通信<ul><li>阻塞发送</li><li>阻塞接收</li></ul></li><li>非阻塞通信<ul><li>非阻塞发送</li><li>非阻塞接收<br>没有消息发送时，接收者在请求接收消息后，接收不到任何消息</li></ul></li></ul><blockquote><p>阻塞：同步，一个完成下一个在继续</p><ul><li>如前面有进程正在通信（发送或接收），则需要此进程需要等待</li></ul><p>非阻塞：为所欲为，异步，想继续就继续，无需等待</p><ul><li>如不管有没有进程正在通信（发送或接收），此进程都可以直接通信</li></ul></blockquote><h4 id="通信链路缓冲"><a href="#通信链路缓冲" class="headerlink" title="通信链路缓冲"></a>通信链路缓冲</h4><p>进程发送的消息在链路上可能有3种缓冲方式</p><ul><li>0容量<br>发送方必须等待接收方</li><li>有限容量<br>通信链路缓冲队列满时，发送方必须等待</li><li>无限容量<br>发送方不需要等待</li></ul><h2 id="6、信号和管道"><a href="#6、信号和管道" class="headerlink" title="6、信号和管道"></a>6、信号和管道</h2><h4 id="信号（Signal）"><a href="#信号（Signal）" class="headerlink" title="信号（Signal）"></a>信号（Signal）</h4><p>信号</p><ul><li>进程间的软件中断通知和处理机制</li><li>如：SIGKILL，SIGSTOP，SIGCONT等</li></ul><p>信号的接收处理</p><ul><li><p>捕获（catch）：执行进程指定的信号处理函数被调用</p></li><li><p>忽略（Ignore）：执行操作系统指定的缺省处理</p><ul><li>例如：进程终止、进程挂起等</li></ul></li><li><p>屏蔽（Mask）：禁止进程接收和处理信号</p><ul><li>可能是暂时的（当处理同样类型的信号）</li></ul></li></ul><p>不足</p><ul><li>传送的信息量小，只有一个信号类型</li></ul><h4 id="信号的实现"><a href="#信号的实现" class="headerlink" title="信号的实现"></a>信号的实现</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220830145229429.png" alt="image-20220830145229429" style="zoom: 80%;"><h4 id="管道（pip）"><a href="#管道（pip）" class="headerlink" title="管道（pip）"></a>管道（pip）</h4><p>进程间基于内存文件的通信机制</p><ul><li>子进程从父进程继承文件描述符</li><li>缺省文件描述符：0stdin，1stdout，2stderr</li></ul><p>进程不知道（或不关心！）的另一端</p><ul><li>可能从键盘、文件、程序读取</li><li>可能写入到终端、文件、程序</li></ul><h4 id="与管道相关的系统调用"><a href="#与管道相关的系统调用" class="headerlink" title="与管道相关的系统调用"></a>与管道相关的系统调用</h4><p>读管道：read（fd.buffer，nbytes）</p><ul><li>scanf（）是基于它实现的</li></ul><p>写管道：write(fd，buffer，nbytes）</p><ul><li>printf（）是基于它实现的</li></ul><p>创建管道：pipe（rgfd）</p><ul><li>rgfd是2个文件描述符组成的数组</li><li>rgfd[0]是读文件描述符</li><li>rgfd[1]是写文件描述符</li></ul><h4 id="管道示例"><a href="#管道示例" class="headerlink" title="管道示例"></a>管道示例</h4><p><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220909095421017.png" alt="image-20220909095421017"></p><p>shell</p><ul><li>创建管道<br>为ls创建一个进程，设置stdout为管道写端<br>为more创建一个进程，设置stdin为管道读端</li></ul><blockquote><p>这是管道在Linux 和Unix系统中常见的用法</p></blockquote><h2 id="7、消息队列和共享内存"><a href="#7、消息队列和共享内存" class="headerlink" title="7、消息队列和共享内存"></a>7、消息队列和共享内存</h2><h4 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h4><p>消息队列是由操作系统维护的以字节序列为基本单位的间接通信机制</p><ul><li>每个消息（Message）是一个字节序列</li><li>相同标识的消息组成按先进先出顺序组成一个消息队列（Message Queues）</li></ul><p><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220909095611112.png" alt="image-20220909095611112"></p><h4 id="消息队列的系统调用"><a href="#消息队列的系统调用" class="headerlink" title="消息队列的系统调用"></a>消息队列的系统调用</h4><p>msgget(key，flags）</p><ul><li>获取消息队列标识</li></ul><p>msgsnd (QID，buf，size，flags）</p><ul><li>发送消息</li></ul><p>msgrcv(QID，buf，size，type，flags）</p><ul><li>接收消息</li></ul><p>msgctl(…）</p><ul><li>消息队列控制</li></ul><h4 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h4><ul><li>共享内存是把同&#x3D;&#x3D;一个&#x3D;&#x3D;物理内存区域同时映射到&#x3D;&#x3D;多个&#x3D;&#x3D;进程的内存地址空间的通信机制</li><li>进程<ul><li>每个进程都有私有内存地址空间</li><li>每个进程的内存地址空间需明确设置共享内存段</li></ul></li><li>线程<ul><li>同一进程中的线程总是共享相同的内存地址空间</li></ul></li><li>优点<ul><li>快速、方便地共享数据</li></ul></li><li>不足<ul><li>必须用额外的同步机制来协调数据访问</li></ul></li></ul><h4 id="共享内存示例"><a href="#共享内存示例" class="headerlink" title="共享内存示例"></a>共享内存示例</h4><ul><li>最快的方法</li><li>一个进程写另外一个进程立即可见</li><li>没有系统调用干预</li><li>没有数据复制</li><li>不提供同步<ul><li>由程序员提供同步</li></ul></li></ul><p><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220909100118135.png" alt="image-20220909100118135"></p><h4 id="共享内存系统调用"><a href="#共享内存系统调用" class="headerlink" title="共享内存系统调用"></a>共享内存系统调用</h4><p>shmget( key,size，flags）</p><ul><li>创建共享段</li></ul><p>shmat( shmid,* shmaddr flags）</p><ul><li>把共享段映射到进程地址空间</li></ul><p>shmdt(* shmaddr）</p><ul><li>取消共享段到进程地址空间的映射</li></ul><p>shmctl(…）</p><ul><li>共享段控制</li></ul><p>需要信号量等机制协调共享内存的访问冲突</p><h2 id="8、消息传递系统（Message-passing-system）（了解）"><a href="#8、消息传递系统（Message-passing-system）（了解）" class="headerlink" title="8、消息传递系统（Message passing system）（了解）"></a>8、消息传递系统（Message passing system）（了解）</h2><ul><li>在该机制中，进程不必借助任何共享存储区或数据结构，而是以格式化的消息（message）为单位，将通信的数据封装在消息中，并利用操作系统提供的一组通信命令（原语），在进程间进行消息传递，完成进程间的数据交换。</li><li>由于该机制能很好地支持多处理机系统、分布式系统和计算机网络，因此也成为这些领域最主要的通信工具。</li><li>基于消息传递系统的通信方式属于高级通信方式，因其实现方式的不同，可进一步分成两类<ul><li>直接通信方式，是指发送进程利用OS所提供的发送原语，直接把消息发送给目标进程；</li><li>间接通信方式，是指发送和接收进程，都通过共享中间实体（称为邮箱）的方式进行消息的发送和接收，完成进程间的通信。</li></ul></li></ul><h1 id="十二、文件系统"><a href="#十二、文件系统" class="headerlink" title="十二、文件系统"></a>十二、文件系统</h1><h2 id="1、文件系统的概念"><a href="#1、文件系统的概念" class="headerlink" title="1、文件系统的概念"></a>1、文件系统的概念</h2><h4 id="文件系统和文件"><a href="#文件系统和文件" class="headerlink" title="文件系统和文件"></a>文件系统和文件</h4><p>文件系统是操作系统中管理持久性数据的子系统，提供数据存储和访问功能</p><ul><li>组织、检索、读写访问数据</li><li>大多数计算机系统都有文件系统</li><li>Google也是一个文件系统</li></ul><p>文件是具有符号名，由字节序列构成的数据项集合</p><ul><li>文件系统的基本数据单位</li><li>文件名是文件的标识符号</li></ul><h4 id="文件系统的功能"><a href="#文件系统的功能" class="headerlink" title="文件系统的功能"></a>文件系统的功能</h4><p>分配文件磁盘空间</p><ul><li>管理文件块（位置和顺序）</li><li>管理空闲空间（位置）</li><li>分配算法（策略）</li></ul><p>管理文件集合</p><ul><li>定位：文件及其内容</li><li>命名：通过名字找到文件</li><li>文件系统结构：文件组织方式</li></ul><p>数据可靠和安全</p><ul><li>安全：多层次保护数据安全</li><li>可靠<ul><li>持久保存文件</li><li>避免系统崩溃、媒体错误、攻击等</li></ul></li></ul><h4 id="文件属性"><a href="#文件属性" class="headerlink" title="文件属性"></a>文件属性</h4><p>文件属性</p><ul><li>名称、类型、位置、大小、保护、创建者、创建时间、最近修改时间、…</li></ul><p>文件头：文件系统元数据中的文件信息</p><ul><li>文件属性</li><li>文件存储位置和顺序</li></ul><h4 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h4><p>文件访问模式</p><ul><li>进程访问文件数据前必须先“打开”文件</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">f=open(name，flag）;</span><br><span class="line">....</span><br><span class="line">read(f，...）；</span><br><span class="line">....</span><br><span class="line">close(f);</span><br></pre></td></tr></table></figure><p>内核跟踪进程打开的所有文件</p><ul><li>操作系统为每个进程维护一个打开文件表</li><li>文件描述符是打开文件的标识</li></ul><p><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220912091011406.png" alt="image-20220912091011406"></p><h4 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h4><p>操作系统在打开文件表中维护的打开文件状态和信息</p><ul><li>文件指针<ul><li>最近一次读写位置</li><li>每个进程分别维护自己的打开文件指针</li></ul></li><li>文件打开计数<ul><li>当前打开文件的次数</li><li>最后一个进程关闭文件时，将其从打开文件表中移除</li></ul></li><li>文件的磁盘位置<ul><li>缓存数据访问信息</li></ul></li><li>访问权限<ul><li>每个进程的文件访问模式信息</li></ul></li></ul><h4 id="文件的用户视图和系统视图"><a href="#文件的用户视图和系统视图" class="headerlink" title="文件的用户视图和系统视图"></a>文件的用户视图和系统视图</h4><p>文件的用户视图</p><ul><li>持久的&#x3D;&#x3D;数据结构&#x3D;&#x3D;</li></ul><p>系统访问接口</p><ul><li>&#x3D;&#x3D;字节序列&#x3D;&#x3D;的集合（UNIX）</li><li>系统不关心存储在磁盘上的数据结构</li></ul><p>操作系统的文件视图</p><ul><li>数据块的集合</li><li>数据块是逻辑存储单元，而扇区是物理存储单元</li><li>块大小&lt;&gt;扇区大小</li></ul><blockquote><p>通常几个扇区构成一个块</p></blockquote><h4 id="用户视图到系统视图的转换"><a href="#用户视图到系统视图的转换" class="headerlink" title="用户视图到系统视图的转换"></a>用户视图到系统视图的转换</h4><p>进程读文件</p><ul><li>获取字节所在的数据块</li><li>返回数据块内对应部分</li></ul><p>进程写文件</p><ul><li>获取数据块</li><li>修改数据块中对应部分 </li><li>写回数据块</li></ul><p>&#x3D;&#x3D;文件系统中的基本操作单位是数据块&#x3D;&#x3D;</p><ul><li>例如，getc（）和putc（）即使每次只访问1字节的数据，也需要缓存目标数据4096字节</li></ul><h4 id="访问模式"><a href="#访问模式" class="headerlink" title="访问模式"></a>访问模式</h4><ul><li>操作系统需要了解进程如何访问文件</li><li>&#x3D;&#x3D;顺序访问&#x3D;&#x3D;：按字节依次读取<ul><li>大多数的文件访问都是顺序访问</li></ul></li><li>&#x3D;&#x3D;随机访问&#x3D;&#x3D;：从中间读写<ul><li>不常用，但仍然重要<br>例如，虚拟内存中把内存页存储在文件</li></ul></li><li>&#x3D;&#x3D;索引访问&#x3D;&#x3D;：依据数据特征索引<ul><li>通常操作系统不完整提供索引访问</li><li>数据库是建立在索引内容的磁盘访问上</li></ul></li></ul><h4 id="索引文件示例"><a href="#索引文件示例" class="headerlink" title="索引文件示例"></a>索引文件示例</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220830161845875.png" alt="image-20220830161845875" style="zoom:67%;"><h4 id="文件的内部结构"><a href="#文件的内部结构" class="headerlink" title="文件的内部结构"></a>文件的内部结构</h4><p>无结构</p><ul><li>单词、字节序列</li></ul><p>简单记录结构</p><ul><li>分列</li><li>固定长度</li><li>可变长度</li></ul><p>复杂结构</p><ul><li>格式化的文档（如，MS Word，PDF）</li><li>可执行文件</li><li>……</li></ul><h4 id="文件共享和访问控制"><a href="#文件共享和访问控制" class="headerlink" title="文件共享和访问控制"></a>文件共享和访问控制</h4><ul><li>&#x3D;&#x3D;多用户系统&#x3D;&#x3D;中的文件共享是很必要的</li><li>访问控制<ul><li>每个用户能够获得哪些文件的哪些访问权限</li><li>访问模式：读、写、执行、删除、列表等</li></ul></li><li>文件访问控制列表（ACL）<ul><li>&lt;文件实体，权限&gt;</li></ul></li><li>Unix模式<ul><li>&lt;用户组|所有人，读写可执行&gt;</li><li>&#x3D;&#x3D;用户标识ID&#x3D;&#x3D;<br>识别用户，表明每个用户所允许的权限及保护模式</li><li>&#x3D;&#x3D;组标识ID&#x3D;&#x3D;<br>允许用户组成组，并指定了组访问权限</li></ul></li></ul><h4 id="语义一致性"><a href="#语义一致性" class="headerlink" title="语义一致性"></a>语义一致性</h4><p>规定多进程如何同时访问共享文件</p><ul><li>与同步算法相似</li><li>因磁盘I&#x2F;O和网络延迟而设计简单</li></ul><p>Unix文件系统（UFS）语义</p><ul><li>对打开文件的写入内容立即对其他打开同一文件的其他用户可见</li><li>共享文件指针允许多用户同时读取和写入文件</li></ul><p>会话语义</p><ul><li>写入内容只有当文件关闭时可见</li></ul><p>读写锁</p><ul><li>一些操作系统和文件系统提供该功能</li></ul><h2 id="2、目录"><a href="#2、目录" class="headerlink" title="2、目录"></a>2、目录</h2><h4 id="分层文件系统"><a href="#分层文件系统" class="headerlink" title="分层文件系统"></a>分层文件系统</h4><ul><li>文件以目录的方式组织起来</li><li>目录是一类特殊的文件<ul><li>目录的内容是文件索引表&lt;文件名，指向文件的指针&gt;</li></ul></li><li>目录和文件的树型结构<ul><li>（早期的文件系统是扁平的（只有一层目录）</li></ul></li></ul><p><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220912091804249.png" alt="image-20220912091804249"></p><h4 id="目录操作"><a href="#目录操作" class="headerlink" title="目录操作"></a>目录操作</h4><p>典型目录操作</p><ul><li>搜索文件</li><li>创建文件</li><li>删除文件</li><li>列目录</li><li>重命名文件</li><li>遍历路径</li></ul><p>操作系统应该只允许内核修改目录</p><ul><li>确保映射的完整性</li><li>应用程序通过系统调用访问目录</li></ul><h4 id="目录实现"><a href="#目录实现" class="headerlink" title="目录实现"></a>目录实现</h4><p>文件名的线性列表，包涵了指向数据块的指针</p><ul><li>编程简单</li><li>执行耗时</li></ul><p>&#x3D;&#x3D;哈希表&#x3D;&#x3D;一哈希数据结构的线性表</p><ul><li>减少目录搜索时间</li><li>冲突 – 两个文件名的哈希值相同</li><li>固定大小</li></ul><h2 id="3、文件别名"><a href="#3、文件别名" class="headerlink" title="3、文件别名"></a>3、文件别名</h2><p>两个或多个文件名关联同一个文件</p><ul><li>&#x3D;&#x3D;硬链接&#x3D;&#x3D;：多个文件项指向一个文件</li><li>&#x3D;&#x3D;软链接&#x3D;&#x3D;：以“快捷方式”指向其他文件<ul><li>通过存储真实文件的逻辑名称来实现</li></ul></li></ul><p><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220912092105833.png" alt="image-20220912092105833"></p><h4 id="文件目录中的循环"><a href="#文件目录中的循环" class="headerlink" title="文件目录中的循环"></a>文件目录中的循环</h4><p><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220912092209992.png" alt="image-20220912092209992"></p><p>如何保证没有循环？</p><ul><li>只允许到文件的链接，不允许在子目录的链接</li><li>增加链接时，用循环检测算法确定是否合理</li></ul><p>更多实践</p><ul><li>限制路径可遍历文件目录的数量</li></ul><h4 id="名字解析（路径遍历）"><a href="#名字解析（路径遍历）" class="headerlink" title="名字解析（路径遍历）"></a>名字解析（路径遍历）</h4><p>名字解析：把逻辑名字转换成物理资源（如文件）</p><ul><li>依据路径名，在文件系统中找到实际文件位置</li><li>遍历文件目录直到找到目标文件</li></ul><p>举例：解析“&#x2F;bin&#x2F;ls”</p><ul><li>读取根目录的文件头（在磁盘固定位置）</li><li>读取根目录的数据块，搜索“bin”项</li><li>读取bin的文件头</li><li>读取bin的数据块；搜索“Is”顶</li><li>读取Is的文件头</li></ul><p>当前工作目录（PWD）</p><ul><li>每个进程都会指向一个文件目录用于解析文件名</li><li>允许用户指定相对路径来代替绝对路径</li><li>如，用PWD&#x3D;“&#x2F;bin” 能够解析 “ls“</li></ul><h4 id="文件系统挂载"><a href="#文件系统挂载" class="headerlink" title="文件系统挂载"></a>文件系统挂载</h4><ul><li>文件系统需要先挂载才能被访问</li><li>未挂载的文件系统被挂载在挂载点上</li></ul><p><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220912092424655.png" alt="image-20220912092424655"></p><h4 id="文件系统种类"><a href="#文件系统种类" class="headerlink" title="文件系统种类"></a>文件系统种类</h4><p>磁盘文件系统</p><ul><li>文件存储在数据存储设备上，如磁盘</li><li>例如：FAT,NTFS，ext2&#x2F;3，ISO9660，等</li></ul><p>数据库文件系统</p><ul><li>文件特征是可被寻址（辨识）的</li><li>例如：WinFS</li></ul><p>日志文件系统</p><ul><li>记录文件系统的修改&#x2F;事件</li></ul><p>网络&#x2F;分布式文件系统</p><ul><li>例如：NFS，SMB，AFS，GFS</li></ul><p>特殊&#x2F;虚拟文件系统</p><h4 id="网络-x2F-分布式文件系统"><a href="#网络-x2F-分布式文件系统" class="headerlink" title="网络 &#x2F; 分布式文件系统"></a>网络 &#x2F; 分布式文件系统</h4><p>文件可以通过网络被共享</p><ul><li>文件位于远程服务器</li><li>客户端远程挂载服务器文件系统</li><li>标准系统文件访问被转换成远程访问</li><li>标准文件共享协议<br>NFS for Unix，CIFS for Windows</li></ul><p>分布式文件系统的挑战</p><ul><li>客户端和客户端上的用户辨别起来很复杂</li><li>例如，NFS是不安全的</li><li>&#x3D;&#x3D;一致性&#x3D;&#x3D;问题</li><li>错误处理模式</li></ul><h2 id="3、虚拟文件系统"><a href="#3、虚拟文件系统" class="headerlink" title="3、虚拟文件系统"></a>3、虚拟文件系统</h2><h4 id="文件系统的实现"><a href="#文件系统的实现" class="headerlink" title="文件系统的实现"></a>文件系统的实现</h4><p>分层结构</p><ul><li>虚拟（逻辑）文件系统（VFS，Virtual File System）</li><li>特定文件系统模块</li></ul><p><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220912092650383.png" alt="image-20220912092650383"></p><h4 id="虚拟文件系统（VFS）"><a href="#虚拟文件系统（VFS）" class="headerlink" title="虚拟文件系统（VFS）"></a>虚拟文件系统（VFS）</h4><p>目的</p><ul><li>对所有不同文件系统的抽象</li></ul><p>功能</p><ul><li>提供相同的文件和文件系统&#x3D;&#x3D;接口&#x3D;&#x3D;</li><li>管理所有文件和文件系统关联的&#x3D;&#x3D;数据结构&#x3D;&#x3D;</li><li>高效查询&#x3D;&#x3D;例程&#x3D;&#x3D;，遍历文件系统</li></ul><h4 id="文件系统的基本数据结构"><a href="#文件系统的基本数据结构" class="headerlink" title="文件系统的基本数据结构"></a>文件系统的基本数据结构</h4><p>文件卷控制块（Unix：“superblock”）</p><ul><li>每个文件系统都有一个</li><li>文件系统详细信息</li><li>块、块大小、空余块、计数&#x2F;指针等</li></ul><p>文件控制块（Unix：“vnode”  or  “inode” )</p><ul><li>每个文件都有一个</li><li>文件详细信息</li><li>访问权限、拥有者、大小、数据块位置等</li></ul><p>目录项（Linux：“dentry”）</p><ul><li>每个目录项都有一个（目录和文件）</li><li>将目录项数据结构及树型布局编码成树型数据结构</li><li>指向文件控制块、父目录、子目录等</li></ul><h4 id="文件系统的组织视图"><a href="#文件系统的组织视图" class="headerlink" title="文件系统的组织视图"></a>文件系统的组织视图</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220830180930676.png" alt="image-20220830180930676" style="zoom:67%;"><h4 id="文件系统的存储结构"><a href="#文件系统的存储结构" class="headerlink" title="文件系统的存储结构"></a>文件系统的存储结构</h4><p>文件系统数据结构</p><ul><li>卷控制块（每个文件系统一个）</li><li>文件控制块（每个文件一个）</li><li>目录节点（每个目录项一个）</li></ul><p>持久存储在外存中</p><ul><li>存储设备的数据块中</li></ul><p>当需要时加载进内存</p><ul><li>卷控制模块：当文件系统挂载时进入内存</li><li>文件控制块：当文件被访问时进入每次</li></ul><h4 id="文件系统的存储视图"><a href="#文件系统的存储视图" class="headerlink" title="文件系统的存储视图"></a>文件系统的存储视图</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220830181037861.png" alt="image-20220830181037861" style="zoom: 67%;"><h2 id="4、文件缓存和打开文件"><a href="#4、文件缓存和打开文件" class="headerlink" title="4、文件缓存和打开文件"></a>4、文件缓存和打开文件</h2><h4 id="多种磁盘缓存的位置"><a href="#多种磁盘缓存的位置" class="headerlink" title="多种磁盘缓存的位置"></a>多种磁盘缓存的位置</h4><p><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220830223531993.png" alt="image-20220830223531993"></p><h4 id="数据块缓存"><a href="#数据块缓存" class="headerlink" title="数据块缓存"></a>数据块缓存</h4><p>数据块按需读入内存</p><ul><li>提供read()操作</li><li>预读：预先读取后面的数据块</li></ul><p>数据块使用后被缓存</p><ul><li>假设数据将会再次用到</li><li>写操作可能被缓存和延迟写入</li></ul><p>两种数据块缓存方式</p><ul><li>数据块缓存</li><li>页缓存：统一缓存数据块和内存页</li></ul><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220830223821939.png" alt="image-20220830223821939" style="zoom:50%;"><h4 id="页缓存"><a href="#页缓存" class="headerlink" title="页缓存"></a>页缓存</h4><p>虚拟页式存储</p><ul><li>在虚拟地址空间中虚拟页面可映射到本地外存文件中</li></ul><p>文件数据块的页缓存</p><ul><li>在虚拟内存中文件数据块被映射成页</li><li>文件的读&#x2F;写操作被转换成对内存的访问</li><li>可能导致缺页和&#x2F;或设置为脏页</li><li>问题：页置换算法需要协调虚拟存储和页缓存间的页面数</li></ul><p><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220912093337284.png" alt="image-20220912093337284"></p><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220830224053343.png" alt="image-20220830224053343" style="zoom:67%;"><h4 id="文件系统中打开文件的数据结构"><a href="#文件系统中打开文件的数据结构" class="headerlink" title="文件系统中打开文件的数据结构"></a>文件系统中打开文件的数据结构</h4><p>文件描述符</p><ul><li>每个被打开的文件都有一个文件描述符</li><li>文件状态信息<ul><li>目录项、当前文件指针、文件操作设置等</li></ul></li></ul><p>打开文件表</p><ul><li>每个进程一个进程打开文件表</li><li>一个系统级的打开文件表</li><li>有文件被打开时，文件卷就不能被卸载</li></ul><h4 id="打开文件表"><a href="#打开文件表" class="headerlink" title="打开文件表"></a>打开文件表</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220830224258512.png" alt="image-20220830224258512" style="zoom:67%;"><h4 id="打开文件锁"><a href="#打开文件锁" class="headerlink" title="打开文件锁"></a>打开文件锁</h4><p>一些文件系统提供文件锁，用于协调多进程的文件访问</p><ul><li>&#x3D;&#x3D;强制&#x3D;&#x3D;－根据锁保持情况和访问需求确定是否拒绝访问</li><li>&#x3D;&#x3D;劝告&#x3D;&#x3D;－进程可以查找锁的状态来决定怎么做</li></ul><h2 id="5、文件分配"><a href="#5、文件分配" class="headerlink" title="5、文件分配"></a>5、文件分配</h2><h4 id="文件大小"><a href="#文件大小" class="headerlink" title="文件大小"></a>文件大小</h4><p>大多数文件都很小</p><ul><li>需要对小文件提供很好的支持</li><li>块空间不能太大</li></ul><p>一些文件非常大</p><ul><li>必须支持大文件（64位文件偏移）</li><li>大文件访问需要高效</li></ul><h4 id="文件分配"><a href="#文件分配" class="headerlink" title="文件分配"></a>文件分配</h4><ul><li><p>如何表示分配给一个文件数据块的位置和顺序</p></li><li><p>分配方式</p><ul><li>连续分配</li><li>链式分配</li><li>索引分配</li></ul></li><li><p>指标</p><ul><li>存储效率：外部碎片等</li><li>读写性能：访问速度</li></ul></li></ul><h4 id="连续分配"><a href="#连续分配" class="headerlink" title="连续分配"></a>连续分配</h4><p>文件头指定起始块和长度</p><p><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220912101220329.png" alt="image-20220912101220329"></p><p>分配策略</p><ul><li>最先匹配，最佳匹配，….</li></ul><p>优点</p><ul><li>文件读取表现好</li><li>高效的顺序和随机访问</li></ul><p>缺点</p><ul><li>碎片！</li><li>文件增长问题<ul><li>预分配？</li><li>按需分配？</li></ul></li></ul><h4 id="链式分配"><a href="#链式分配" class="headerlink" title="链式分配"></a>链式分配</h4><ul><li>文件以数据块链表方式存储</li><li>文件头包含了到第一块和最后一块的指针</li></ul><p><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220912101247239.png" alt="image-20220912101247239"></p><ul><li><p>优点</p><ul><li>创建、增大、缩小很容易</li><li>没有碎片</li></ul></li><li><p>缺点</p><ul><li>无法实现真正的随机访问</li><li>可靠性差<br>破坏一个链，后面的数据块就丢了</li></ul></li></ul><h4 id="索引分配"><a href="#索引分配" class="headerlink" title="索引分配"></a>索引分配</h4><ul><li>为每个文件创建一个&#x3D;&#x3D;索引数据块&#x3D;&#x3D;<ul><li>指向文件数据块的指针列表</li></ul></li><li>文件头包含了索引数据块指针</li></ul><p><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220912101445737.png" alt="image-20220912101445737"></p><ul><li><p>优点</p><ul><li>创建、增大、缩小很容易</li><li>没有碎片</li><li>支持直接访问</li></ul></li><li><p>缺点</p><ul><li>当文件很小时，存储索引的&#x3D;&#x3D;开销&#x3D;&#x3D;</li><li>如何处理大文件？</li></ul></li></ul><h4 id="大文件的索引分配"><a href="#大文件的索引分配" class="headerlink" title="大文件的索引分配"></a>大文件的索引分配</h4><p>链式索引块（IB+IB+…）</p><p><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220912101612326.png" alt="image-20220912101612326"></p><p>多级索引块（IB * IB *..）</p><p><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220912101626681.png" alt="image-20220912101626681"></p><h4 id="UFS-Unix-File-System-多级索引分配"><a href="#UFS-Unix-File-System-多级索引分配" class="headerlink" title="UFS(Unix File System)多级索引分配"></a>UFS(Unix File System)多级索引分配</h4><p>文件头包含13个指针</p><ul><li>10个指针指向数据块</li><li>第11个指针指向索引块</li><li>第12个指针指向二级索引块</li><li>第13个指针指向三级索引块</li></ul><p>效果</p><ul><li>提高了文件大小限制阀值</li><li>动态分配数据块，文件扩展很容易</li><li>小文件开销小</li><li>只为大文件分配间接数据块，大文件在访问数据块时需要大量查询</li></ul><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220830230543243.png" alt="image-20220830230543243" style="zoom: 80%;"><h2 id="6、空闲空间管理"><a href="#6、空闲空间管理" class="headerlink" title="6、空闲空间管理"></a>6、空闲空间管理</h2><p>跟踪记录文件卷未分配的数据块</p><ul><li>采用什么数据结构表示空闲空间列表</li></ul><h4 id="空闲空间组织：位图"><a href="#空闲空间组织：位图" class="headerlink" title="空闲空间组织：位图"></a>空闲空间组织：位图</h4><p>用位图代表空闲数据块列表</p><ul><li>111111111111111001110101011101111..</li><li>Di&#x3D;0表明数据块i是空闲，否则，表示已分配</li></ul><p>使用简单但是可能会是一个大的很大向量表</p><ul><li>160GB磁盘-&gt;40M数据块-&gt;5MB位图</li><li>假定空闲空间在磁盘中均匀分布，则找到“0”之前要扫描n&#x2F;r<br>n&#x3D;磁盘上数据块的总数<br>r&#x3D;空闲块的数目</li></ul><h4 id="其他空闲空间组织方式"><a href="#其他空闲空间组织方式" class="headerlink" title="其他空闲空间组织方式"></a>其他空闲空间组织方式</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220831124735352.png" alt="image-20220831124735352" style="zoom:67%;"><h2 id="7、冗余磁盘阵列RAID"><a href="#7、冗余磁盘阵列RAID" class="headerlink" title="7、冗余磁盘阵列RAID"></a>7、冗余磁盘阵列RAID</h2><h4 id="磁盘分区"><a href="#磁盘分区" class="headerlink" title="磁盘分区"></a>磁盘分区</h4><p>通常磁盘通过分区来最大限度减小寻道时间</p><ul><li>分区是一组柱面的集合</li><li>每个分区都可视为逻辑上独立的磁盘</li></ul><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220912102528428.png" alt="image-20220912102528428" style="zoom:67%;"><h4 id="典型的磁盘文件系统组织"><a href="#典型的磁盘文件系统组织" class="headerlink" title="典型的磁盘文件系统组织"></a>典型的磁盘文件系统组织</h4><p>文件卷：</p><ul><li>一个拥有完整文件系统实例的外存空间</li><li>通常常驻在磁盘的单个分区上</li></ul><p><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220912102636179.png" alt="image-20220912102636179"></p><blockquote><p>windows下的C盘、D盘</p></blockquote><h4 id="多磁盘管理"><a href="#多磁盘管理" class="headerlink" title="多磁盘管理"></a>多磁盘管理</h4><p>使用多磁盘可改善</p><ul><li>吞吐量（通过并行）</li><li>可靠性和可用性（通过冗余）</li></ul><p>冗余磁盘阵列（RAID，Redundant Array of Inexpensive Disks）</p><ul><li>多种磁盘管理技术</li><li>RAID分类<br>如，RAID-O，RAID-1，RAID-5</li></ul><p>冗余磁盘阵列的实现</p><ul><li>软件：操作系统内核的文件卷管理</li><li>硬件：RAID硬件控制器（I&#x2F;O）</li></ul><h4 id="RAID-0：磁盘条带化"><a href="#RAID-0：磁盘条带化" class="headerlink" title="RAID-0：磁盘条带化"></a>RAID-0：磁盘条带化</h4><p>把数据块分成多个子块，存储在独立的磁盘中</p><ul><li>通过独立磁盘上并行数据块访问提供更大的磁盘带宽</li></ul><p><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220912102819051.png" alt="image-20220912102819051"></p><h4 id="RAID-1：磁盘镜像"><a href="#RAID-1：磁盘镜像" class="headerlink" title="RAID-1：磁盘镜像"></a>RAID-1：磁盘镜像</h4><p>向两个磁盘写入，从任何一个读取</p><ul><li>可靠性成倍增长</li><li>读取性能线性增加</li></ul><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220912102846403.png" alt="image-20220912102846403" style="zoom:67%;"><h4 id="RAID-4：带校验的磁盘条带化"><a href="#RAID-4：带校验的磁盘条带化" class="headerlink" title="RAID-4：带校验的磁盘条带化"></a>RAID-4：带校验的磁盘条带化</h4><p>数据块级的磁盘条带化加专用奇偶校验磁盘</p><ul><li>允许从任意一个故障磁盘中恢复</li></ul><p><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220912102953021.png" alt="image-20220912102953021"></p><blockquote><p>检验磁盘存储着每个数据块的校验和，会验证磁盘取出的数据的正确性，如果有一个磁盘发生故障，读取数据有误，那么校验磁盘能够使它的数据恢复正确</p><p>大大提升了可靠性，和读取效率</p></blockquote><h3 id="RAID-5：带分布式校验的磁盘条带化"><a href="#RAID-5：带分布式校验的磁盘条带化" class="headerlink" title="RAID-5：带分布式校验的磁盘条带化"></a>RAID-5：带分布式校验的磁盘条带化</h3><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220831130204018.png" alt="image-20220831130204018" style="zoom: 80%;"><blockquote><p>数据块校验和分布在不同的磁盘，减少了校验磁盘的读取压力</p></blockquote><h4 id="基于位和基于块的磁盘条带化"><a href="#基于位和基于块的磁盘条带化" class="headerlink" title="基于位和基于块的磁盘条带化"></a>基于位和基于块的磁盘条带化</h4><p>条带化和奇偶校验按“&#x3D;&#x3D;字节&#x3D;&#x3D;”或者“&#x3D;&#x3D;位&#x3D;&#x3D;“</p><ul><li>RAID-0&#x2F;4&#x2F;5:基于数据块</li><li>RAID-3:基于位</li></ul><p><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220912103103137.png" alt="image-20220912103103137"></p><blockquote><p>基于数据块的常用</p></blockquote><h4 id="可纠正多个磁盘错误的冗余磁盘阵列"><a href="#可纠正多个磁盘错误的冗余磁盘阵列" class="headerlink" title="可纠正多个磁盘错误的冗余磁盘阵列"></a>可纠正多个磁盘错误的冗余磁盘阵列</h4><p>RAID-5：每组条带块有一个奇偶校验块</p><ul><li>允许一个磁盘错误</li></ul><p>RAID-6:每组条带块有两个冗余块</p><ul><li>允许两个磁盘错误</li></ul><h4 id="RAID嵌套"><a href="#RAID嵌套" class="headerlink" title="RAID嵌套"></a>RAID嵌套</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220831130849991.png" alt="image-20220831130849991" style="zoom: 67%;"><h1 id="十三、I-x2F-O系统"><a href="#十三、I-x2F-O系统" class="headerlink" title="十三、I&#x2F;O系统"></a>十三、I&#x2F;O系统</h1><h2 id="1、I-x2F-O特点"><a href="#1、I-x2F-O特点" class="headerlink" title="1、I&#x2F;O特点"></a>1、I&#x2F;O特点</h2><h4 id="三种常见的设备接口类型"><a href="#三种常见的设备接口类型" class="headerlink" title="三种常见的设备接口类型"></a>三种常见的设备接口类型</h4><p>字符设备</p><ul><li>如：键盘&#x2F;鼠标，串口等</li></ul><p>块设备</p><ul><li>如：磁盘驱动器、磁带驱动器、光驱等</li></ul><p>网络设备</p><ul><li>如：以太网、无线、蓝牙等</li></ul><h4 id="设备访问特征"><a href="#设备访问特征" class="headerlink" title="设备访问特征"></a>设备访问特征</h4><p>字符设备</p><ul><li>访问特征<ul><li>以字节为单位顺序访问</li></ul></li><li>I&#x2F;O命令<ul><li>get()、put() 等</li><li>通常使用文件访问接口和语义</li></ul></li></ul><p>块设备</p><ul><li>访问特征<ul><li>均匀的数据块访问</li></ul></li><li>I&#x2F;O命令<ul><li>原始I&#x2F;O或文件系统接口</li><li>内存映射文件访问</li></ul></li></ul><p>网络设备</p><ul><li>访问特征<ul><li>格式化报文交换</li></ul></li><li>I&#x2F;O命令<ul><li>send&#x2F;receive网络报文</li><li>通过网络接口支持多种网络协议</li></ul></li></ul><h4 id="阻塞I-x2F-O：Wait"><a href="#阻塞I-x2F-O：Wait" class="headerlink" title="阻塞I&#x2F;O：Wait"></a>阻塞I&#x2F;O：Wait</h4><ul><li>读数据（read）时，进程将进入等待状态，直到完成数据读出</li><li>写数据（write）时，进程将进入等待状态，直到设备完成数据写入处理</li></ul><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220912103456442.png" alt="image-20220912103456442" style="zoom:67%;"><blockquote><p>用户调用系统调用后，进入内核执行相应设备驱动，控制硬件进行数据传送，完成后发出中断请求，设备驱动处理，返回用户态告诉进程，在这期间进程一直处于等待</p></blockquote><h4 id="非阻塞I-x2F-O：Dont-Wait"><a href="#非阻塞I-x2F-O：Dont-Wait" class="headerlink" title="非阻塞I&#x2F;O：Dont Wait"></a>非阻塞I&#x2F;O：Dont Wait</h4><ul><li>立即从read或write系统调返回，返回值为成功传输字节数</li><li>read或write的传输字节数可能为零</li></ul><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220912103608697.png" alt="image-20220912103608697" style="zoom: 67%;"><blockquote><p>传输的数据比较小</p></blockquote><h4 id="异步I-x2F-O-“Tell-Me-Later“"><a href="#异步I-x2F-O-“Tell-Me-Later“" class="headerlink" title="异步I&#x2F;O:“Tell Me Later“"></a>异步I&#x2F;O:“Tell Me Later“</h4><ul><li>读数据时，使用指针标记好用户缓冲区，立即返回；稍后内核将填充缓冲区并通知用户</li><li>写数据时，使用指针标记好用户缓冲区，立即返回；稍后内核将处理数据并通知用户</li></ul><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220912103707801.png" alt="image-20220912103707801" style="zoom: 67%;"><blockquote><p>设备驱动是等待的，而用户态进程是不需要等待的，可以干别的事</p></blockquote><h2 id="2、I-x2F-O结构"><a href="#2、I-x2F-O结构" class="headerlink" title="2、I&#x2F;O结构"></a>2、I&#x2F;O结构</h2><h4 id="一个实际例子"><a href="#一个实际例子" class="headerlink" title="一个实际例子"></a>一个实际例子</h4><p>北桥</p><ul><li>内存</li><li>AGP&#x2F;PCI-Express</li><li>Built-in display</li></ul><p>南桥</p><ul><li>ATA&#x2F;IDE</li><li>PCI总线</li><li>USB&#x2F;Firewire总线</li><li>Serial&#x2F;Parallel接口</li><li>DMA控制器</li><li>Interrupt控制器</li><li>RTC，ACPI，BIOS，…</li></ul><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220912103844955.png" alt="image-20220912103844955" style="zoom:67%;"><h4 id="CPU与设备连接"><a href="#CPU与设备连接" class="headerlink" title="CPU与设备连接"></a>CPU与设备连接</h4><p>CPU与设备的通信方式</p><ul><li>轮询、设备中断和DMA</li></ul><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220912104429433.png" alt="image-20220912104429433" style="zoom:67%;"><p>设备控制器</p><ul><li>CPU和I&#x2F;O设备间的接口</li><li>向CPU提供特殊指令和寄存器</li></ul><p>I&#x2F;O地址</p><ul><li>CPU用来控制I&#x2F;O硬件</li><li>内存地址或端口号<ul><li>I&#x2F;O指令</li><li>内存映射I&#x2F;O</li></ul></li></ul><h4 id="I-x2F-O指令"><a href="#I-x2F-O指令" class="headerlink" title="I&#x2F;O指令"></a>I&#x2F;O指令</h4><ul><li>通过I&#x2F;O端口号访问设备寄存器</li><li>特殊的CPU指令<br>out 0x21，AL</li></ul><h4 id="内存映射I-x2F-O"><a href="#内存映射I-x2F-O" class="headerlink" title="内存映射I&#x2F;O"></a>内存映射I&#x2F;O</h4><ul><li>设备的寄存器&#x2F;存储被映射到内存物理地址空间中</li><li>通过内存load&#x2F;store指令完成I&#x2F;O操作</li><li>MMU设置映射，硬件跳线或程序在启动时设置地址</li></ul><h4 id="内核I-x2F-O结构"><a href="#内核I-x2F-O结构" class="headerlink" title="内核I&#x2F;O结构"></a>内核I&#x2F;O结构</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220831173014014.png" alt="image-20220831173014014" style="zoom:67%;"><h4 id="I-x2F-O请求的生存周期"><a href="#I-x2F-O请求的生存周期" class="headerlink" title="I&#x2F;O请求的生存周期"></a>I&#x2F;O请求的生存周期</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220831173052945.png" alt="image-20220831173052945" style="zoom: 80%;"><h2 id="3、I-x2F-O数据传输"><a href="#3、I-x2F-O数据传输" class="headerlink" title="3、I&#x2F;O数据传输"></a>3、I&#x2F;O数据传输</h2><h4 id="CPU与设备控制器的设备传输"><a href="#CPU与设备控制器的设备传输" class="headerlink" title="CPU与设备控制器的设备传输"></a>CPU与设备控制器的设备传输</h4><p>程序控制I&#x2F;O（PIO，Programmed I&#x2F;O）</p><ul><li>通过CPU的in&#x2F;out或者load&#x2F;store传输所有数据</li><li>特点<ul><li>硬件简单，编程容易</li><li>消耗的CPU时间和数据量成正比</li></ul></li><li>适用于简单的、小型的设备I&#x2F;O</li></ul><p>直接内存访问（DMA）</p><ul><li>设备控制器可直接访问系统总线</li><li>控制器直接与内存互相传输数据</li><li>特点<ul><li>设备传输数据不影响CPU</li><li>需要CPU参与设置</li></ul></li><li>适用于高吞吐量I&#x2F;O</li></ul><h4 id="通过直接I-x2F-O寻址读取磁盘数据的步骤"><a href="#通过直接I-x2F-O寻址读取磁盘数据的步骤" class="headerlink" title="通过直接I&#x2F;O寻址读取磁盘数据的步骤"></a>通过直接I&#x2F;O寻址读取磁盘数据的步骤</h4><p><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220831174236831.png" alt="image-20220831174236831"></p><h4 id="I-x2F-O设备通知操作系统的机制"><a href="#I-x2F-O设备通知操作系统的机制" class="headerlink" title="I&#x2F;O设备通知操作系统的机制"></a>I&#x2F;O设备通知操作系统的机制</h4><p>操作系统需要了解设备状态</p><ul><li>I&#x2F;O操作完成时间</li><li>I&#x2F;O操作遇到错误</li></ul><p>两种方式</p><ul><li>CPU主动轮询</li><li>设备中断</li></ul><h4 id="轮询"><a href="#轮询" class="headerlink" title="轮询"></a>轮询</h4><ul><li>I&#x2F;O设备在特定的&#x3D;&#x3D;状态寄存器&#x3D;&#x3D;中放置状态和错误信息</li><li>操作系统&#x3D;&#x3D;定期检测&#x3D;&#x3D;状态寄存器</li><li>特点<ul><li>简单</li><li>I&#x2F;O操作频繁或不可预测时，开销大和延时长</li></ul></li></ul><h4 id="设备中断"><a href="#设备中断" class="headerlink" title="设备中断"></a>设备中断</h4><p>设备中断处理流程</p><ul><li>CPU在I&#x2F;O之前设置任务参数</li><li>CPU发出I&#x2F;O请求后，继续执行其他任务</li><li>I&#x2F;O设备处理I&#x2F;O请求</li><li>I&#x2F;O设备处理完成时，触发CPU中断请求</li><li>CPU接收中断，分发到相应中断处理例程</li></ul><p>特点</p><ul><li>处理不可预测事件效果好</li><li>开销相对较高</li></ul><p>一些设备可能结合了轮询和设备中断</p><ul><li>如：高带宽网络设备<ul><li>第一个传入数据包到达前采用中断</li><li>轮询后面的数据包直到硬件缓存为空</li></ul></li></ul><h3 id="设备中断I-x2F-O处理流程"><a href="#设备中断I-x2F-O处理流程" class="headerlink" title="设备中断I&#x2F;O处理流程"></a>设备中断I&#x2F;O处理流程</h3><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220831174740052.png" alt="image-20220831174740052" style="zoom:67%;"><h2 id="4、磁盘调度"><a href="#4、磁盘调度" class="headerlink" title="4、磁盘调度"></a>4、磁盘调度</h2><h4 id="磁盘工作机制和性能参数"><a href="#磁盘工作机制和性能参数" class="headerlink" title="磁盘工作机制和性能参数"></a>磁盘工作机制和性能参数</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220912105405940.png" alt="image-20220912105405940" style="zoom:67%;"><ul><li>读取或写入时，磁头必须被定位在&#x3D;&#x3D;期望的磁道&#x3D;&#x3D;，并从所&#x3D;&#x3D;期望的柱面和扇区&#x3D;&#x3D;的开始</li><li>寻道时间<ul><li>定位到期望的磁道所花费的时间</li></ul></li><li>旋转延迟<ul><li>从零扇区开始处到达目的地花费的时间</li></ul></li><li>&#x3D;&#x3D;平均旋转延迟时间&#x3D;磁盘旋转一周时间的一半&#x3D;&#x3D;</li></ul><h4 id="磁盘I-x2F-O传输时间"><a href="#磁盘I-x2F-O传输时间" class="headerlink" title="磁盘I&#x2F;O传输时间"></a>磁盘I&#x2F;O传输时间</h4><p><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220901083451945.png" alt="image-20220901083451945"></p><h4 id="磁盘调度算法"><a href="#磁盘调度算法" class="headerlink" title="磁盘调度算法"></a>磁盘调度算法</h4><p>通过优化磁盘访问请求顺序来提高磁盘访问性能</p><ul><li>寻道时间是磁盘访问最耗时的部分</li><li>同时会有多个在同一磁盘上的I&#x2F;O请求</li><li>随机处理磁盘访问请求的性能表现很差</li></ul><h4 id="先进先出（FIFO）算法"><a href="#先进先出（FIFO）算法" class="headerlink" title="先进先出（FIFO）算法"></a>先进先出（FIFO）算法</h4><ul><li>按顺序处理请求</li><li>公平对待所有进程</li><li>在有很多进程的情况下，接近随机调度的性能</li></ul><h4 id="FIFO算法示例-1"><a href="#FIFO算法示例-1" class="headerlink" title="FIFO算法示例"></a>FIFO算法示例</h4><p><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220901083644552.png" alt="image-20220901083644552"></p><h4 id="最短服务时间优先（SSTF）"><a href="#最短服务时间优先（SSTF）" class="headerlink" title="最短服务时间优先（SSTF）"></a>最短服务时间优先（SSTF）</h4><ul><li>选择从磁臂当前位置需要移动最少的I&#x2F;O请求</li><li>总是选择最短寻道时间</li></ul><h4 id="SSTF算法示例"><a href="#SSTF算法示例" class="headerlink" title="SSTF算法示例"></a>SSTF算法示例</h4><p><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220901083751024.png" alt="image-20220901083751024"></p><h4 id="扫面算法（SCAN）"><a href="#扫面算法（SCAN）" class="headerlink" title="扫面算法（SCAN）"></a>扫面算法（SCAN）</h4><ul><li>磁臂在一个方向上移动，访问所有未完成的请求，直到磁臂到达该方向上最后的磁道</li><li>调换方向</li><li>也称为电梯算法（elevator algorithm）</li></ul><h4 id="SCAN算法示例"><a href="#SCAN算法示例" class="headerlink" title="SCAN算法示例"></a>SCAN算法示例</h4><p><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220901083857941.png" alt="image-20220901083857941"></p><h4 id="循环扫描算法（C-SCAN）"><a href="#循环扫描算法（C-SCAN）" class="headerlink" title="循环扫描算法（C-SCAN）"></a>循环扫描算法（C-SCAN）</h4><ul><li>限制了仅在一个方向上扫描</li><li>当最后一个磁道也被访问过了后，磁臂返回到磁盘的另外一端再次进行</li></ul><h4 id="C-LOOK算法"><a href="#C-LOOK算法" class="headerlink" title="C-LOOK算法"></a>C-LOOK算法</h4><ul><li>磁臂先到达该方向上最后一个请求处，然后立即反转，而不是先到最后点路径上的所有请求</li></ul><blockquote><p>避免到达该方向上末端点这段路径没有请求的扫描过程</p></blockquote><h4 id="N步扫描算法（N-Step-SCAN"><a href="#N步扫描算法（N-Step-SCAN" class="headerlink" title="N步扫描算法（N-Step-SCAN)"></a>N步扫描算法（N-Step-SCAN)</h4><p>磁头粘着（Arm Stickiness）现象</p><ul><li>SSTF、SCAN及CSCAN等算法中，可能出现磁头停留在某处不动的情况</li><li>如：进程反复请求对某一磁道的I&#x2F;O操作</li></ul><p>N步扫描算法</p><ul><li>将磁盘请求队列分成长度为N的子队列</li><li>按FIFO算法依次处理所有子队列</li><li>扫描算法处理每个队列</li></ul><h4 id="双队列扫描算法（FSCAN）"><a href="#双队列扫描算法（FSCAN）" class="headerlink" title="双队列扫描算法（FSCAN）"></a>双队列扫描算法（FSCAN）</h4><p>FSCAN算法是N步扫描算法的简化</p><ul><li>FSCAN只将磁盘请求队列分成两个子队列</li></ul><p>FSCAN算法</p><ul><li>把磁盘I&#x2F;0请求分成两个队列</li><li>交替使用扫描算法处理一个队列</li><li>新生成的磁盘I&#x2F;0请求放入另一队列中所有的新请求都将被推退到下一次扫描时处理</li></ul><h4 id="磁盘缓存"><a href="#磁盘缓存" class="headerlink" title="磁盘缓存"></a>磁盘缓存</h4><p>缓存</p><ul><li>数据传输双方访问速度差异较大时，引入的速度匹配中间层</li></ul><p>磁盘缓存是磁盘扇区在内存中的缓存区</p><ul><li>磁盘缓存的调度算法很类似虚拟存储调度算法</li><li>磁盘的访问频率远低于虚拟存储中的内存访问频率</li><li>通常磁盘缓存调度算法会比虚拟存储复杂</li></ul><h4 id="单缓存和双缓存"><a href="#单缓存和双缓存" class="headerlink" title="单缓存和双缓存"></a>单缓存和双缓存</h4><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220901091753725.png" alt="image-20220901091753725" style="zoom:67%;"><h4 id="访问频率置换算法（Frequency-based-Replacement）"><a href="#访问频率置换算法（Frequency-based-Replacement）" class="headerlink" title="访问频率置换算法（Frequency-based-Replacement）"></a>访问频率置换算法（Frequency-based-Replacement）</h4><p>问题</p><ul><li>在一段密集磁盘访问后，LFU算法的引用计数变化无法反映当前的引用情况</li></ul><p>算法思路</p><ul><li>考虑磁盘访问的密集特征，对密集引用不计数</li><li>在短周期中使用LRU算法，而在长周期中使用LFU算法</li></ul><p><img src="/2022/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/image-20220901091953802.png" alt="image-20220901091953802"></p><p>栈中缓存被访问时移到栈顶；如果该块在新区域，引用计数不变；否则，引用计数加1</p><ul><li>在新区域中引用计数不变的目的是避免密集访问对引用计数不利影响</li><li>在中间区域和旧区域中引用计数加1是为了使用LFU算法</li></ul><p>未缓存数据块读入后放在栈顶，引用计数为1</p><p>在旧区域中引用计数最小的缓存块被置换</p><ul><li>中间区域的定义是为了避免读入的缓存块在第一次出新区域时马上被置换，有一个过渡期</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、操作系统概述&quot;&gt;&lt;a href=&quot;#一、操作系统概述&quot; class=&quot;headerlink&quot; title=&quot;一、操作系统概述&quot;&gt;&lt;/a&gt;一、操作系统概述&lt;/h1&gt;&lt;h2 id=&quot;1、课程导读&quot;&gt;&lt;a href=&quot;#1、课程导读&quot; class=&quot;headerli</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>关于hexo博客插入图片内容解决方法</title>
    <link href="http://example.com/2022/08/27/%E5%8D%9A%E5%AE%A2%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87/"/>
    <id>http://example.com/2022/08/27/%E5%8D%9A%E5%AE%A2%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87/</id>
    <published>2022-08-26T16:00:00.000Z</published>
    <updated>2022-08-29T03:53:23.073Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、插入图片要求："><a href="#一、插入图片要求：" class="headerlink" title="一、插入图片要求："></a>一、插入图片要求：</h3><ul><li><p>md文件名和存放其图片文件夹一致</p></li><li><p>md图片访问路径的分割符使用 &#x2F;</p></li><li><p>图片访问路径中不能有空格</p></li><li><p>md中图片使用相对路径访问，如 .&#x2F;xxx&#x2F;yyy.jpg 或 xxx&#x2F;yyy.jpg</p></li><li><p>下载hexo-asset-image图片访问插件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save hexo-asset-image </span><br></pre></td></tr></table></figure></li></ul><h3 id="二、具体步骤"><a href="#二、具体步骤" class="headerlink" title="二、具体步骤"></a>二、具体步骤</h3><h5 id="步骤一：博客根目录下的source-x2F-post下，创建同名md文件和存图文件夹"><a href="#步骤一：博客根目录下的source-x2F-post下，创建同名md文件和存图文件夹" class="headerlink" title="步骤一：博客根目录下的source&#x2F;_post下，创建同名md文件和存图文件夹"></a>步骤一：博客根目录下的source&#x2F;_post下，创建同名md文件和存图文件夹</h5><p>![image-20220827104613441](博客插入图片 &#x2F;image-20220827104613441.png)</p><h5 id="步骤二：以相对路径的方式引入一张图片"><a href="#步骤二：以相对路径的方式引入一张图片" class="headerlink" title="步骤二：以相对路径的方式引入一张图片"></a>步骤二：以相对路径的方式引入一张图片</h5><img src="/2022/08/27/%E5%8D%9A%E5%AE%A2%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87/image-20220827104843261.png" alt="image-20220827104843261" style="zoom: 67%;"><h4 id="步骤三：下载图片访问插件"><a href="#步骤三：下载图片访问插件" class="headerlink" title="步骤三：下载图片访问插件"></a>步骤三：下载图片访问插件</h4><p><img src="/2022/08/27/%E5%8D%9A%E5%AE%A2%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87/image-20220827104959034.png"></p><h4 id="步骤四：生成网站静态文件和进行本地预览"><a href="#步骤四：生成网站静态文件和进行本地预览" class="headerlink" title="步骤四：生成网站静态文件和进行本地预览"></a>步骤四：生成网站静态文件和进行本地预览</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo g </span><br><span class="line"></span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><h5 id="预览结果："><a href="#预览结果：" class="headerlink" title="预览结果："></a>预览结果：</h5><img src="/2022/08/27/%E5%8D%9A%E5%AE%A2%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87/image-20220827105405180.png" alt="image-20220827105405180" style="zoom:50%;"><h5 id="该图片路径："><a href="#该图片路径：" class="headerlink" title="该图片路径："></a>该图片路径：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cannot GET /.com//%E9%95%87%E5%BA%97%E4%B9%8B%E5%AE%9D%5C%E5%8F%A4%E9%A3%8E%E7%BE%8E%E5%A5%B3.jpg</span><br></pre></td></tr></table></figure><h2 id="三、图片还是无法显示，经过网上的一番查找，得以解决"><a href="#三、图片还是无法显示，经过网上的一番查找，得以解决" class="headerlink" title="三、图片还是无法显示，经过网上的一番查找，得以解决:"></a>三、图片还是无法显示，经过网上的一番查找，得以解决:</h2><h4 id="首先：删除原来的插件"><a href="#首先：删除原来的插件" class="headerlink" title="首先：删除原来的插件"></a>首先：删除原来的插件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm remove hexo-asset-image</span><br></pre></td></tr></table></figure><h4 id="其次：下载修改版的插件修改版的hexo-asset-image"><a href="#其次：下载修改版的插件修改版的hexo-asset-image" class="headerlink" title="其次：下载修改版的插件修改版的hexo-asset-image"></a>其次：下载修改版的插件<a href="https://github.com/CodeFalling/hexo-asset-image">修改版的hexo-asset-image</a></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save https://github.com/CodeFalling/hexo-asset-image</span><br></pre></td></tr></table></figure><h4 id="再次：重新操作一波"><a href="#再次：重新操作一波" class="headerlink" title="再次：重新操作一波"></a>再次：重新操作一波</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hexo cl</span><br><span class="line"></span><br><span class="line">hexo g</span><br><span class="line"></span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><h4 id="效果显著："><a href="#效果显著：" class="headerlink" title="效果显著："></a>效果显著：</h4><img src="/2022/08/27/%E5%8D%9A%E5%AE%A2%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87/image-20220827110447646.png" alt="image-20220827110447646" style="zoom:50%;">]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;一、插入图片要求：&quot;&gt;&lt;a href=&quot;#一、插入图片要求：&quot; class=&quot;headerlink&quot; title=&quot;一、插入图片要求：&quot;&gt;&lt;/a&gt;一、插入图片要求：&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;md文件名和存放其图片文件夹一致&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>GitHub + Hexo + Node.js + Git搭建个人博客</title>
    <link href="http://example.com/2022/08/25/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    <id>http://example.com/2022/08/25/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</id>
    <published>2022-08-25T09:45:41.000Z</published>
    <updated>2022-08-29T03:58:02.665Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、搭建环境"><a href="#1、搭建环境" class="headerlink" title="1、搭建环境"></a>1、搭建环境</h3><p>操作系统系统：Windows10</p><p>Node.js：v14.18.2</p><p>Git：2.37.2.windows.2 </p><h3 id="2、Node-js安装及配置"><a href="#2、Node-js安装及配置" class="headerlink" title="2、Node.js安装及配置"></a>2、Node.js安装及配置</h3><p><a href="https://nodejs.org/zh-cn/download/releases/">node.js以往的版本</a></p><h4 id="步骤一：下载并安装"><a href="#步骤一：下载并安装" class="headerlink" title="步骤一：下载并安装"></a>步骤一：下载并安装</h4><p>下载完成后进行安装，node.js安装一路next直至完成</p><h4 id="步骤二：检查是否安装成功"><a href="#步骤二：检查是否安装成功" class="headerlink" title="步骤二：检查是否安装成功"></a>步骤二：检查是否安装成功</h4><p>【win+R】键，输入cmd，然后回车，打开cmd窗口</p><ul><li><p>检查其是否安装成功，输入 node -v</p></li><li><p>检查npm是否也安装成功 ，输入 npm -v</p><blockquote><p>新版的Node.js已自带npm，安装Node.js时会一起安装，npm的作用就是对Node.js依赖的包进行管理，也可以理解为用来安装&#x2F;卸载Node.js需要装的东西</p></blockquote></li></ul><h4 id="步骤三：配置默认安装目录和缓存日志目录"><a href="#步骤三：配置默认安装目录和缓存日志目录" class="headerlink" title="步骤三：配置默认安装目录和缓存日志目录"></a>步骤三：配置默认安装目录和缓存日志目录</h4><p>为了不占用C盘空间，修改node.js的全局模块module的下载路径和cache缓存路径，其默认位置在<code>C:\Users\用户名\AppData\Roaming\npm</code></p><ul><li><p>在我们安装node.js目录下创建两个文件夹，名分别为<code>node_global</code>和<code>node_cache</code>，且在这<code>node_global</code>文件夹下在创建一个名为<code>node_modules</code>的文件夹</p></li><li><p>win+R，cmd打开控制台，输入以下命令修改其默认路径</p><p>npm config set prefix “F:\Develop_tools\node_js\node_global” </p><p>npm config set cache “F:\Develop_tools\node_js\node_cache”</p></li></ul><h4 id="步骤四：配置nodejs环境变量"><a href="#步骤四：配置nodejs环境变量" class="headerlink" title="步骤四：配置nodejs环境变量"></a>步骤四：配置nodejs环境变量</h4><p>将默认配置的nmp路径<code>C:\Users\用户名\AppData\Roaming\npm</code>删除，添加一个你新建的global路径</p><img src="/2022/08/25/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/image-20220825154829124.png" alt="image-20220825154829124" style="zoom:67%;"><p>在系统变量（环境变量）添加NODE_PATH，用来告诉系统， 下载的模块或者包都在这里了</p><img src="/2022/08/25/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/image-20220825143044875.png" alt="image-20220825143044875" style="zoom: 67%;"><p>在系统变量（环境变量）PATH中添加NODE_PATH</p><img src="/2022/08/25/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/image-20220825144710580.png" alt="image-20220825144710580" style="zoom:67%;"><h4 id="步骤五：设置npm淘宝镜像"><a href="#步骤五：设置npm淘宝镜像" class="headerlink" title="步骤五：设置npm淘宝镜像"></a>步骤五：设置npm淘宝镜像</h4><p>使用阿里定制的cnpm命令行工具代替默认的npm，输入以下代码</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><p>检查是否安装成功：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cnpm -v</span><br></pre></td></tr></table></figure><p>安装成功之后，以后安装依赖包的方式和npm的是一样的，只是npm的命令换成是cnpm就可以了。</p><h3 id="3、Git安装"><a href="#3、Git安装" class="headerlink" title="3、Git安装"></a>3、Git安装</h3><p><a href="https://git-scm.com/">Git 官网下载</a></p><p>Git安装比较简单，下载后一路next直至完成即可，无需多余配置</p><h3 id="4、Github建立仓库"><a href="#4、Github建立仓库" class="headerlink" title="4、Github建立仓库"></a>4、Github建立仓库</h3><ul><li><p>仓库名：用户名.github.io</p></li><li><p>branch：默认名为main，这里可以修改，一旦创建就无法修改了</p></li></ul><h3 id="5、下载hexo-script-的安装脚本"><a href="#5、下载hexo-script-的安装脚本" class="headerlink" title="5、下载hexo-script]的安装脚本"></a>5、下载hexo-script]的安装脚本</h3><ul><li><p>选择最新版本,只需下载install.sh即可，<a href="https://github.com/kjhuanhao/hexo-script/releases"><strong>下载install.sh</strong></a></p></li><li><p>选择一个你想存放博客文件的位置，创建一个文件夹，名字随意，将下载好的install.sh放到其中</p></li><li><p>我创建了一个[myblog]文件夹，然后在此文件夹下，<strong>右键打开git bash</strong></p></li></ul><hr><h3 id="6、检测node-js和git环境"><a href="#6、检测node-js和git环境" class="headerlink" title="6、检测node.js和git环境"></a>6、检测node.js和git环境</h3><h4 id="检测node-js环境"><a href="#检测node-js环境" class="headerlink" title="检测node.js环境"></a>检测node.js环境</h4><p>在存放install.sh脚本的目录中,右键打开git bash然后运行以下命令:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source install.sh test_node</span><br></pre></td></tr></table></figure><p>如果出现了如图的情况证明环境变量是配置成功的</p><p>(出现了版本号和成功的提示信息代表配置成功)</p><p><img src="/2022/08/25/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/image-20220825151430500.png" alt="image-20220825151430500"></p><p>如果你并发现有版本号的出现,而是红色的错误信息,你可能需要手动配置node.js的环境变量,或者重新安装node.js并注意勾选<strong>Add to PATH</strong></p><hr><h4 id="检测git环境"><a href="#检测git环境" class="headerlink" title="检测git环境"></a>检测git环境</h4><p>如果你想要检测git环境或者查看当前git的版本号,您可以在存放install.sh脚本的目录中,右键打开git bash运行以下命令:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source install.sh test_git</span><br></pre></td></tr></table></figure><p>一般情况下安装git工具后git环境是会自动配置的,可以无需检测git环境.此脚本可以用于linux系统,出现版本号信息则配置为成功.</p><p><img src="/2022/08/25/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/image-20220825151534207.png" alt="image-20220825151534207"></p><hr><h3 id="7、一键安装hexo博客"><a href="#7、一键安装hexo博客" class="headerlink" title="7、一键安装hexo博客"></a>7、一键安装hexo博客</h3><p>您需要在存放install.sh脚本的目录中,右键打开git bash运行以下命令:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source install.sh hexo_win</span><br></pre></td></tr></table></figure><p>提示:此时你可以去来一杯卡布奇诺,大约两分钟的时间,博客即可自动安装完成,如图:</p><img src="/2022/08/25/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/image-20220825152443388.png" alt="image-20220825152443388" style="zoom:50%;"><p>当您看到出现<code>Please run hexo s to check it out!</code>的提示,证明您已经安装成功,此时你可以运行hexo s 然后查看你的博客</p><p>自动完成全部安装过程并生成博客文件</p><img src="/2022/08/25/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/image-20220825152153353.png" alt="image-20220825152153353" style="zoom: 67%;"><p>进入hexblog目录，输入命令 hexo  s ，开启本地预览</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd hexoblog</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>注意:要先cd到hexoblog目录哦!执行以上命令即可</p><img src="/2022/08/25/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/image-20220825152528941.png" alt="image-20220825152528941" style="zoom:67%;"><blockquote><p>在浏览器访问:<a href="http://localhost:4000/">http://localhost:4000 </a>,你就可以在本地预览了,浏览情况如图:</p></blockquote><img src="/2022/08/25/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/image-20220825152718571.png" alt="image-20220825152718571" style="zoom:67%;"><h3 id="8、生成SSH秘钥并配置GitHub"><a href="#8、生成SSH秘钥并配置GitHub" class="headerlink" title="8、生成SSH秘钥并配置GitHub"></a>8、生成SSH秘钥并配置GitHub</h3><p>这是你的github与本地传输数据时需要使用的密钥</p><p>您需要在存放install.sh脚本的目录中,右键打开git bash运行以下命令:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./install.sh git_ssh</span><br></pre></td></tr></table></figure><img src="/2022/08/25/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/image-20220825162832088.png" alt="image-20220825162832088" style="zoom:67%;"><p>可以看到会有四条可执行命令，输入对应数字可以执行对应的命令</p><ul><li><p>执行1后，一直按回车，直至结束，输入yes，可以一键生成秘钥</p><ul><li>生成密钥位置：C:\Users\用户名\ .ssh\id_rsa.pub</li><li>如果你的电脑已经存在秘钥,程序将会自动退出</li></ul></li><li><p>执行2后，可以查看你电脑中已生成的秘钥</p><ul><li><p>将上述生成密钥与github中进行配置</p></li><li><p>进入Github —&gt; 头像 —&gt; Setting —&gt; SSH and GPG keys —&gt; New SSH key</p></li></ul></li><li><p>执行3后，可以检查秘钥是否配置github成功</p></li><li><p>执行4后，可以检查秘钥是否配置coding成功 </p><ul><li>coding是腾讯云的，咱们是与github对接，不用管这个</li></ul></li></ul><hr><h3 id="9、配置博客部署GitHub"><a href="#9、配置博客部署GitHub" class="headerlink" title="9、配置博客部署GitHub"></a>9、配置博客部署GitHub</h3><p>在_config.yml文件中修改，注意冒号后面有空格</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repository:</span> <span class="string">git@github.com:用户名/用户名.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">main</span>  <span class="comment">#创建仓库时默认使用的branch</span></span><br></pre></td></tr></table></figure><h3 id="10、更换博客主题"><a href="#10、更换博客主题" class="headerlink" title="10、更换博客主题"></a>10、更换博客主题</h3><p><a href="https://hexo.io/themes/">hexo提供多种多样的主题：Themes | Hexo</a></p><ul><li>只要知道主题的github地址，使用git clone 下载到themes文件中</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/Shen-Yu/hexo-theme-ayer themes/ayer</span><br></pre></td></tr></table></figure><ul><li>修改_config.yml文件</li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">ayer</span></span><br></pre></td></tr></table></figure><ul><li>如果更换主题后无法打开网站，则下载渲染插件</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-renderer-pug hexo-renderer-stylus</span><br></pre></td></tr></table></figure><h3 id="11、发布第一篇博客"><a href="#11、发布第一篇博客" class="headerlink" title="11、发布第一篇博客"></a>11、发布第一篇博客</h3><p>hexo博客可以使用markdown编写，它会将markdown文件进行解析成网页，之后将它们发布到github上，就可以通过<code>http://用户名.github.io/</code></p><p>使用hexo自动创建md文件，会在source下的_post中创建</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new &quot;文件名&quot;</span><br></pre></td></tr></table></figure><p>也可以自己引入md文件到_post，md中的图片文件夹也引入进来，md文件中引用的图片应以相对路径引入</p><img src="/2022/08/25/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/image-20220825182617976.png" alt="image-20220825182617976" style="zoom:67%;"><blockquote><p>注意：md文章开头必须得有 Front Matter格式的信息，其中至少填写title和date</p><p><img src="/2022/08/25/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/image-20220825183120172.png" alt="image-20220825183120172"></p><p><a href="https://blog.csdn.net/qq_42549254/article/details/102721177">Front Matter其他参数</a></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo cl 或 hexo clean </span><br></pre></td></tr></table></figure><p>清除缓存文件 db.json 和已生成的静态文件 public 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure><p>生成网站静态文件到默认设置的 public 文件夹。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>启动本地服务器，用于预览主题。默认地址： <a href="http://localhost:4000/">http://localhost:4000/</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>自动生成网站静态文件，并部署到GitHub设定的仓库。</p><p>访问地址：http:&#x2F;&#x2F;用户名.github.io&#x2F;即可访问你的网站啦！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1、搭建环境&quot;&gt;&lt;a href=&quot;#1、搭建环境&quot; class=&quot;headerlink&quot; title=&quot;1、搭建环境&quot;&gt;&lt;/a&gt;1、搭建环境&lt;/h3&gt;&lt;p&gt;操作系统系统：Windows10&lt;/p&gt;
&lt;p&gt;Node.js：v14.18.2&lt;/p&gt;
&lt;p&gt;Git：2.</summary>
      
    
    
    
    
  </entry>
  
</feed>
