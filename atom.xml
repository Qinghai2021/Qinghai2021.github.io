<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Qinghai2021·博客</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-09-28T08:10:52.405Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Qinghai2021</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java基础</title>
    <link href="http://example.com/2022/09/28/%E5%B0%9A%E7%A1%85%E8%B0%B7java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    <id>http://example.com/2022/09/28/%E5%B0%9A%E7%A1%85%E8%B0%B7java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/</id>
    <published>2022-09-28T09:45:41.000Z</published>
    <updated>2022-09-28T08:10:52.405Z</updated>
    
    <content type="html"><![CDATA[<h1 id="项目及工具"><a href="#项目及工具" class="headerlink" title="项目及工具"></a>项目及工具</h1><h2 id="1-eclipse"><a href="#1-eclipse" class="headerlink" title="1.eclipse"></a>1.eclipse</h2><h3 id="1-eclipse-1"><a href="#1-eclipse-1" class="headerlink" title="1.eclipse"></a>1.eclipse</h3><p>安装配置见—文档</p><h3 id="2-eclipse快捷键"><a href="#2-eclipse快捷键" class="headerlink" title="2.eclipse快捷键"></a>2.eclipse快捷键</h3><ul><li><strong>1.补全代码的声明：alt + &#x2F;</strong></li><li>2.快速修复: ctrl + 1 </li><li><strong>3.批量导包：ctrl + shift + o</strong></li><li><strong>4.使用单行注释：ctrl + &#x2F;</strong></li><li><strong>5.使用多行注释： ctrl + shift + &#x2F;</strong> </li><li>6.取消多行注释：ctrl + shift + \</li><li><strong>7.复制指定行的代码：ctrl + alt + down 或 ctrl + alt + up</strong></li><li><strong>8.删除指定行的代码：ctrl + d</strong></li><li>9.上下移动代码：alt + up 或 alt + down</li><li>10.切换到下一行代码空位：shift + enter</li><li>11.切换到上一行代码空位：ctrl + shift + enter</li><li><strong>12.如何查看源码：ctrl + 选中指定的结构 或 ctrl + shift + t</strong></li><li>13.退回到前一个编辑的页面：alt + left </li><li>14.进入到下一个编辑的页面(针对于上面那条来说的)：alt + right</li><li><strong>15.光标选中指定的类，查看继承树结构：ctrl + t</strong></li><li>16.复制代码： ctrl + c</li><li><strong>17.撤销： ctrl + z</strong></li><li><strong>18.反撤销： ctrl + y</strong></li><li>19.剪切：ctrl + x </li><li>20.粘贴：ctrl + v</li><li><strong>21.保存： ctrl + s</strong></li><li><strong>22.全选：ctrl + a</strong></li><li><strong>23.格式化代码： ctrl + shift + f</strong> (使代码格式整洁)</li><li><strong>24.选中数行，整体往后移动：tab</strong></li><li><strong>25.选中数行，整体往前移动：shift + tab</strong></li><li><strong>26.在当前类中，显示类结构，并支持搜索指定的方法、属性等：ctrl + o</strong></li><li>27.批量修改指定的变量名、方法名、类名等：alt + shift + r</li><li>28.选中的结构的大小写的切换：变成大写： ctrl + shift + x</li><li>29.选中的结构的大小写的切换：变成小写：ctrl + shift + y</li><li><strong>30.调出生成 getter&#x2F;setter&#x2F;构造器等结构： alt + shift + s</strong></li><li>31.显示当前选择资源(工程 or 文件)的属性：alt + enter</li><li>32**.快速查找：参照选中的 Word 快速定位到下一个 ：ctrl + k** </li><li>33.关闭当前窗口：ctrl + w</li><li>34.关闭所有的窗口：ctrl + shift + w</li><li>35.查看指定的结构使用过的地方：ctrl + alt + g</li><li>36.查找与替换：ctrl + f</li><li>37.最大化当前的 View：ctrl + m</li><li>38.<strong>直接定位到当前行的首位：home</strong></li><li><strong>39.直接定位到当前行的末位：end</strong></li></ul><h3 id="3-Debug-调试"><a href="#3-Debug-调试" class="headerlink" title="3.Debug  调试"></a>3.Debug  调试</h3><p>调试代码，查找bug所需，见网上教程</p><h2 id="2-项目要求"><a href="#2-项目要求" class="headerlink" title="2.项目要求"></a>2.项目要求</h2><ol><li><p>至少独立完成一遍以上的项目代码</p></li><li><p>积累完成项目的过程中常见的bug的调试</p><p>方式一: “硬看”，必要时，添加一些输出语句</p><p>方式二：Debug</p></li><li><p>最重要的：捋顺思路，强化逻辑</p></li><li><p>对象、数组等内存结构的解析</p></li><li><p>遵守编码的规范，标识符的命名规范</p></li><li><p>在类前，方法前，方法内具体逻辑的实现步骤等添加必要的注释</p><p>单行、多行、以及文档（项目大时十分重要）</p><p>类前、方法前、属性前：文档注释</p><p>逻辑步骤：单行、多行注释。</p></li></ol><h2 id="3-客户信息管理软件"><a href="#3-客户信息管理软件" class="headerlink" title="3.客户信息管理软件"></a>3.客户信息管理软件</h2><p>项目二：</p><h3 id="1-分为三大类"><a href="#1-分为三大类" class="headerlink" title="1.分为三大类"></a>1.分为三大类</h3><p>CustomerView为主模块，负责菜单的显示和处理用户操作</p><p>CustomerList为Customer对象的管理模块，内部用数组管理一组Customer对象，并提供相应的添加、修改、删除和遍历方法，供CustomerView调用</p><p>Customer为实体对象，用来封装客户信息</p><h3 id="2-Customer类的设计"><a href="#2-Customer类的设计" class="headerlink" title="2.Customer类的设计"></a>2.Customer类的设计</h3><p>Customer为实体类，用来封装客户信息 该类封装客户的以下信息：</p><p>String name ：客户姓名</p><p>char gender  ：性别</p><p>int age          ：年龄</p><p>String phone：电话号码</p><p>String email ：电子邮箱 </p><p>提供各属性的get&#x2F;set方法   (以上都是private)</p><p>提供所需的构造器（可自行确定）</p><h3 id="3-CustomerList类的设计"><a href="#3-CustomerList类的设计" class="headerlink" title="3.CustomerList类的设计"></a>3.CustomerList类的设计</h3><p>CustomerList为Customer对象的管理模块，内部使用数组管理一组Customer对象本类封装以下信息：</p><p>Customer[] customers：用来保存客户对象的数组</p><p>int total &#x3D; 0                 ：记录已保存客户对象的数量该类至少提供以下构造器和方法：</p><p>public CustomerList(int totalCustomer) &#x2F;&#x2F;构造器</p><p>public boolean addCustomer(Customer customer)&#x2F;&#x2F;将指定用户添加到数组中</p><p> public boolean replaceCustomer(int index, Customer cust)&#x2F;&#x2F;修改指定索引的值</p><p>public boolean deleteCustomer(int index)&#x2F;&#x2F;删除指定索引值，元素前移补位</p><p>public Customer[] getAllCustomers()&#x2F;&#x2F;获取所有客户信息</p><p> public Customer getCustomer(int index) &#x2F;&#x2F;索引指定位置的客户</p><p>public int getTotal()&#x2F;&#x2F;获取存储客户的数量</p><h3 id="4-CustomerView类的设计"><a href="#4-CustomerView类的设计" class="headerlink" title="4.CustomerView类的设计"></a>4.CustomerView类的设计</h3><p>本类封装以下信息：</p><p>CustomerList customerList &#x3D; new CustomerList(10);</p><p>创建最大包含10个客户对象的CustomerList 对象，供以下各成员方法使用。该类至少提供以下方法：</p><p>public void enterMainMenu() &#x2F;&#x2F;进入主目录</p><p>private void addNewCustomer() &#x2F;&#x2F;添加新客户</p><p>private void modifyCustomer()&#x2F;&#x2F;修改客户</p><p>private void deleteCustomer()&#x2F;&#x2F;删除客户信息</p><p>private void listAllCustomers()&#x2F;&#x2F;获取所有客户信息</p><p>public static void main(String[] args)&#x2F;&#x2F;main方法</p><h2 id="4-错题事件"><a href="#4-错题事件" class="headerlink" title="4.错题事件"></a>4.错题事件</h2><h3 id="1-三元运算符"><a href="#1-三元运算符" class="headerlink" title="1.三元运算符"></a>1.三元运算符</h3><p><img src="/2022/09/28/%E5%B0%9A%E7%A1%85%E8%B0%B7java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/Snipaste_2022-01-14_21-02-00.png" alt="Snipaste_2022-01-14_21-02-00"></p><h2 id="5-面试题："><a href="#5-面试题：" class="headerlink" title="5.面试题："></a>5.面试题：</h2><h4 id="1-多态性"><a href="#1-多态性" class="headerlink" title="1.多态性"></a>1.多态性</h4><p><img src="/2022/09/28/%E5%B0%9A%E7%A1%85%E8%B0%B7java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/Java%5Cimg%5CSnipaste_2022-01-16_10-49-40.png" alt="Snipaste_2022-01-16_10-49-40"></p><h1 id="Java编程基础"><a href="#Java编程基础" class="headerlink" title="Java编程基础"></a>Java编程基础</h1><h2 id="1-java概述"><a href="#1-java概述" class="headerlink" title="1.java概述"></a>1.java概述</h2><h3 id="1-1-Java通识介绍"><a href="#1-1-Java通识介绍" class="headerlink" title="1.1 Java通识介绍"></a>1.1 Java通识介绍</h3><p>(1)Java基础是学习JavaEE、大数据、Android开发的基石！</p><p>(2)人机交互方式：1.图形化界面GUI简单直观易于上手    2.命令行方式CLI需要一个控制台，输入特定的指令，让计算机完成一些</p><p>(3)Java    API 文档：习惯上将语言提供的 类库称为API，API文档是解释如何是这些泪流的说明书</p><h3 id="1-2常用的DOS命令"><a href="#1-2常用的DOS命令" class="headerlink" title="1.2常用的DOS命令"></a>1.2常用的DOS命令</h3><p>d: （进入D盘盘符)、cd（进入指定目录，可以直接进入也可一步一步进）、cd..（退回到上一级）、cd\（退回到根目录）、del（删除文件）、rd（删除目录，直接rd有文件的目录可选择删除该文件下的所有文件）、md（创建目录）、dir（列出当前目录下的文件及文件夹）、del *.txt（星花表示所有的意思）</p><h3 id="1-3-编写HelloWorld"><a href="#1-3-编写HelloWorld" class="headerlink" title="1.3 编写HelloWorld"></a>1.3 编写HelloWorld</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HelloChina</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Hello,World&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>首先创建一个java文件，在文件中写入内容（如以上格式），cmd命令操作进入到文件所在位置写入 <strong>编译</strong>操作javac  文件名.java，此时会自动生成一个HelloChina.class文件，在写入<strong>运行</strong>操作java  文件名（class的文件名)</p></li><li><p>在一个java源文件中可以声明多个class。但是只能最多有一个类声明为public的。而且要求声明为public的类的类名必须与源文件名相同。</p></li><li><p>程序的入口是main（）方法，格式是固定的</p></li><li><p>输出语句：</p><p>System.out.println();  先输出数据后换行，单写就是换行</p><p>System.out.print();       只输出数据</p></li><li><p>每一行语句执行都以分号“；”结束</p></li><li><p>编译的过程：编译以后，会生成一个或多个字结码文件</p></li></ol><p>注意：Java严格区分大小写</p><h3 id="1-4-注释（comment）"><a href="#1-4-注释（comment）" class="headerlink" title="1.4 注释（comment）"></a>1.4 注释（comment）</h3><ol><li><p>​         &#x2F;&#x2F;单行注释    </p></li><li><p>​         &#x2F;* 多行注释 *&#x2F;</p></li><li><p>​           文档注释 Java特有的  </p><p>   &#x2F;** </p><p>@author 指定Java程序作者</p><p>@version 指定源文件版本</p><p> *&#x2F;</p><p>注释内容可以被JDK提供的工具javadoc所解析，生成一套以网页文件形式体现的该程序的说明文档</p><p>操作码为Javadoc  -d  目录名  -author  -version 文件名.java（需要解析的文件）</p></li></ol><h2 id="2-java基础语法"><a href="#2-java基础语法" class="headerlink" title="2.java基础语法"></a>2.java基础语法</h2><h3 id="2-1关键字与保留字"><a href="#2-1关键字与保留字" class="headerlink" title="2.1关键字与保留字"></a>2.1关键字与保留字</h3><p>  定义：被java语言赋予特殊含义，用做专门用途的字符串</p><p>  特点：关键字中所有字母都为小写</p><ol><li><p>用于定义整型类型的关键字    class\interface\enum\byte\short\int\long\float\double\char\boolean\void</p></li><li><p>用于定义流程控制的关键字</p></li></ol><p>​     if\else\switch\case\default\while\do\for\break\continue\return</p><ol start="3"><li>用于定义访问权限修饰符的关键字</li></ol><p>   private\protected\public</p><ol start="4"><li><p>用于定义类、函数、变量修饰符的关键字</p><p>abstract\final\static\synchronized</p></li><li><p>用于定义类与类之间关系的关键字  </p><p>extends\implements\</p></li><li><p>用于定义建议实例及引用实例，判断实例的关键字</p><p>new\this\super\instanceof</p></li><li><p>用于异常处理的关键字</p><p>try\catch\finally\throw\throws</p></li><li><p>用于包的关键字</p><p>package\import</p></li><li><p>其他修饰符关键字</p><p>native\strictfp\transient\volatile\assert</p></li><li><p>用于定义数据类型值的字面值（不属于关键字）</p></li></ol><p>  true\false\null</p><ol start="11"><li>保留字goto、const</li></ol><h3 id="2-2-标识符"><a href="#2-2-标识符" class="headerlink" title="2.2 标识符"></a>2.2 标识符</h3><ol><li>定义：凡是自己可以起名字的地方都叫标识符</li></ol><p>​             比如：类名、变量名、方法名、接口名、包名</p><ol start="2"><li>标识符的命名规则（不规则影响运行）</li></ol><p>​            由26个英文字母大小写、0-9、__ 、或$组成</p><p>​            数字不可以开头</p><p>​            不可以使用关键字和保留字，但能包含</p><p>​            Java严格区分大小写，长度无限制</p><p>​            标识符不能包含空格</p><ol start="3"><li>Java中的名称命名的规范(不规范不影响运行，影响美观和可读性)</li></ol><p>​              包名：多组单词组成时所有字母都小写：xxxxyyzzz</p><p>​              类名、接口名：多组单词组成时，所有单词的首字母大写：XxxYyyZzz</p><p>​             变量名、方法名：多组单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写：xxYyyZzz</p><p>​             常量名：左右字母都大写，多单词时每个单词用下划线连接：XXX_YYY_ZZZ</p><h3 id="2-3变量"><a href="#2-3变量" class="headerlink" title="2.3变量"></a>2.3变量</h3><h4 id="1-变量的概念"><a href="#1-变量的概念" class="headerlink" title="1.变量的概念"></a>1.变量的概念</h4><p>​       变量是程序中最基本的存储单元，包含变量类型、变量名和存储的值，内存中的一个存储区域，用于在内存中保存数据</p><h4 id="2-使用变量注意："><a href="#2-使用变量注意：" class="headerlink" title="2.使用变量注意："></a>2.使用变量注意：</h4><p>2.1java 中每个变量必须先声明并赋值（a&#x3D;0），后使用</p><p>2.2使用变量名访问这块区域的数据，只能在作用域才有效，也就是{  }中</p><p>2.3同一个作用域内，不能定义重名的变量</p><h4 id="3-基本数据类型"><a href="#3-基本数据类型" class="headerlink" title="3.基本数据类型"></a>3.基本数据类型</h4><h5 id="1-整型："><a href="#1-整型：" class="headerlink" title="1.整型："></a>1.整型：</h5><p>​          byte\short\int\long </p><p>​         byte（1字节&#x3D;8bit）\short（2字节）\int（4字节）\long （8字节）</p><p>​         byte范围：-128 ~ 127</p><p>​         声明long型变量：必须以“l”或者“L”结尾  （long  b&#x3D; 1234L）</p><p>​          通常使用int类型</p><h5 id="2-浮点型："><a href="#2-浮点型：" class="headerlink" title="2. 浮点型："></a>2. 浮点型：</h5><p>​                    float\double</p><p>​                      float（4字节）\double（8字节）</p><p>​                    浮点型表示带小数点的数值</p><p>​                     float表示数值范围比long还大</p><p>​                    定义float类型变量时，变量要以“f”或者“F”结尾</p><p>​                     通常使用double型</p><h5 id="3-字符型："><a href="#3-字符型：" class="headerlink" title="3.字符型："></a>3.字符型：</h5><p>​    char  （1字符 &#x3D; 2字节）</p><p>​     定义char型变量，通常用一对 ‘ ’ ，内部只能写一个字符  a&#x3D;‘b’ 。也可用直接用数字</p><ol><li><p>当是char &#x3D; ‘A’ 时</p><p>直接输出，就是A</p><p>如果做运算在输出，这是对应的Ascll码值做运算后的数：’A’ &#x3D;65  ‘A’ -1&#x3D;64;</p></li><li><p>当是char  &#x3D;  65</p><p>直接输出就是对应的A（字符）</p><p>做运算后就是数</p></li><li><p>&#x3D;&#x3D;比较的是Ascll码值</p><p>char num5 &#x3D;’A’;</p><p>char num6 &#x3D;65;</p><p>System.out.println(num5&#x3D;&#x3D;num6);</p><p>&#x2F;&#x2F;true</p><p>  转义字符：\b退格符\n换行符\r回车符\t制表符大空格&quot;引号\\反斜杠</p></li></ol><h5 id="4-布尔型："><a href="#4-布尔型：" class="headerlink" title="4.布尔型："></a>4.布尔型：</h5><p>​                     boolean</p><p>​                     ture、false（常用于条件判断，循环结构中使用）</p><h4 id="4-引用数据类型"><a href="#4-引用数据类型" class="headerlink" title="4.引用数据类型"></a>4.引用数据类型</h4><p>补充：引用类型变量，只可能存储两类值：null  或  地址值（含变量类型）</p><h5 id="1-类：class"><a href="#1-类：class" class="headerlink" title="1.类：class"></a>1.类：class</h5><h5 id="2-接口：interface"><a href="#2-接口：interface" class="headerlink" title="2.接口：interface"></a>2.接口：interface</h5><h5 id="3-数组：array"><a href="#3-数组：array" class="headerlink" title="3.数组：array"></a>3.数组：array</h5><ol><li><p>强制转换</p><p>需要强制转换符（），注意转换时可能会导致精度损失</p><p>double d1&#x3D;12.9;</p><p>int i&#x3D;(int)d1;</p></li><li><p>自动类型提升</p><p>结论：当容量小的数据类型变量与容量大的数据类型变量做运算时，结果自动提升为容量大的数据类型</p><p>byte\char\short--&gt;int–&gt;long–&gt;float–&gt;double</p><p>特别地，当byte\char\short做运算时结果都为int</p></li></ol><h5 id="4-String类型变量"><a href="#4-String类型变量" class="headerlink" title="4.String类型变量"></a>4.String类型变量</h5><ol><li><p>String属于引用数据类型，意思是  字符串</p></li><li><p>声明String类型变量时，使用一对“”</p></li><li><p>String可以和八种数据类型变量做运算，且运算只能是连接运算 +  </p></li><li><p>在String之后的运算结果仍然是String类型</p><p>String s &#x3D; “ hello”</p><p>int  i &#x3D; 1；</p><p>int j &#x3D;  2；</p><p>s +  i  +j  &#x3D;hello12</p><p>i + j  +  s &#x3D; 3hello </p><p>注意定义String  s2 &#x3D; “”；  &#x2F;&#x2F;可为空</p><p> char  s3 &#x3D; ‘’  &#x2F;&#x2F;不可为空​</p></li></ol><h3 id="2-4进制转换"><a href="#2-4进制转换" class="headerlink" title="2.4进制转换"></a>2.4进制转换</h3><p>对于整数，有四种表达方式：</p><ol><li><p>二进制    满二进一，以0b或0B开头</p></li><li><p>十进制      满十进一</p></li><li><p>八进制      满八进一  以数字0开头表示</p></li><li><p>十六进制   满十六进一   以0x或0X开头 </p></li><li><p>二进制转换其他进制 0  、1 ，满二进一，以0b或0B开头</p><ol><li><p>十进制</p><p>1011&#x3D;1*2的0次方+1 *2的1次方+0 *2的2次方+1 *2的3次方&#x3D; 11</p><p><strong>注意</strong>有小数点时：1011.01 先计算整数部分剩余0.01&#x3D;0 *2的0次方+1 *2的-1次方&#x3D;0.5</p></li><li><p>八进制</p><p>1011看成三位一组001-011&#x3D;&gt;1+3&#x3D;4</p></li><li><p>十六进制</p><p>1011看成四位一组1011&#x3D;&gt;B</p></li></ol></li><li><p>十进制转换其他进制  0—9</p><p>​         想转什么进制就除什么倒取余法</p><p>​         <strong>注意</strong>转二进制有小数点时：先计算整数部分，如剩余0.5，不断乘2取整，直到小数部分为零0.5对应的二进制是0.1,0.25对应0.01</p></li><li><p>八进制转换其他进制 0—-7</p><ol><li><p>二进制</p><p>每个数看成三个位数一组的二进制</p></li><li><p>十进制</p><p>先转成二进制在二转十</p></li><li><p>十六进制</p><p>先转二在转十六</p></li></ol></li><li><p>十六进制转换其他进制 0—-F（A&#x3D;10….F&#x3D;15)</p><ol><li><p>二进制</p><p>每个数看成四个位数一组的二进制</p></li><li><p>十进制</p><p>先转成二进制在二转十</p></li><li><p>八进制</p><p>先转成二进制在二转八</p></li></ol><p>计算机底层以补码形式存储数据，注意给的码为原码要转补码进行计算，如果最高位为0则为正数，原码反码补码都一样，若最高位为1则为负数</p><p>则原码除最高位字符数不懂其余取反加一为补码</p></li><li><p>补充代码：十转十六(传统方法，一般直接调用类来算)</p><p>int  p1 &#x3D; 60 ;</p><p>int  p2 &#x3D; p1&amp;15;  &#x2F;&#x2F;由于60底层是二进制存储，和15逻辑与1111，保留了前四位数</p><p>String j &#x3D; (p2&gt;9)?(char)(p2-10+’A’)+”” : p2+”” ;  &#x2F;&#x2F;若大于9，则用字母表示</p><p>int temp &#x3D; p1&gt;&gt;&gt; 4;  &#x2F;&#x2F;右移4位，将后四位移到前面</p><p>p2 &#x3D; temp &amp; 15;     &#x2F;&#x2F;在次保留了后四位</p><p>String   k &#x3D;  (p2&gt;9)?(char)(p2-10+’A’)+”” : p2+ “” ;  </p><p>System.out.println(k+””+j);   &#x2F;&#x2F; 3 C</p></li></ol><h3 id="2-5-运算符"><a href="#2-5-运算符" class="headerlink" title="2.5 运算符"></a>2.5 运算符</h3><h4 id="1-算术运算符"><a href="#1-算术运算符" class="headerlink" title="1.算术运算符"></a>1.算术运算符</h4><p>+正号-负号+加号-减号*乘号&#x2F;除号%取余号 ，++,–,</p><p>(前)++，先自增1，后运算</p><p>(后)–，先运算后，自增1</p><p>short s1 &#x3D; 10 ；</p><p>&#x2F;&#x2F;s1 &#x3D; s1 + 1 &#x2F;&#x2F;编译失败，加 2 变为整型int</p><p>注意：s++ 不会改变本身的数据类型</p><h4 id="2-赋值运算符"><a href="#2-赋值运算符" class="headerlink" title="2.赋值运算符"></a>2.赋值运算符</h4><p>&#x3D;      +&#x3D;    -&#x3D;     *&#x3D;    &#x2F;&#x3D;    %&#x3D;</p><ol><li><p>int i &#x3D; 10 ;      int  j &#x3D; 10;</p></li><li><p>int i , j ;           i&#x3D;j&#x3D;10  ;</p></li><li><p>int i&#x3D;10,j&#x3D;10;</p></li><li><p>n +&#x3D;2     &#x2F;&#x2F; n &#x3D;  n  +   2</p></li><li><p>&#x2F;&#x2F;s1 &#x3D; s1 + 2 &#x2F;&#x2F;编译失败，加 2 变为整型int</p><p>注意：s1 +&#x3D; 2   不会改变本身的数据类型</p></li></ol><h4 id="3-比较运算符（关系运算符）"><a href="#3-比较运算符（关系运算符）" class="headerlink" title="3.比较运算符（关系运算符）"></a>3.比较运算符（关系运算符）</h4><p>&#x3D;&#x3D;     !&#x3D;   &gt;    &lt;     &gt;&#x3D;     &lt;&#x3D;    instanceof</p><p>比较运算符的结果是 boolean 类型 </p><p>   &lt;  &gt;   &gt;&#x3D;     &lt;&#x3D;  ：只能使用在数值类型的数据之间</p><p>&#x3D;&#x3D;     !&#x3D;     ：不仅可以使用在数值类型数据之间，还可以使用在引用类型变量之间</p><h4 id="4-逻辑运算符"><a href="#4-逻辑运算符" class="headerlink" title="4.逻辑运算符"></a>4.逻辑运算符</h4><p>&amp; （逻辑与）&amp;&amp;（短路与）  都一样 ，遇到false为false</p><blockquote><p>&amp;：前面表达式为真时，继续执行后面的表达式</p><p>&amp;&amp;：遇到false 不会执行后面的表达式</p></blockquote><p>|    （逻辑或）  ||    （短路或） 都一样 ， 遇到true 为true</p><blockquote><p>|：前面表达式为真时，继续执行后面的表达式</p><p>||：遇到true 不会执行后面的表达式</p></blockquote><p>！ （逻辑非）   ^    （逻辑异或） 异或一样则错，不同则对</p><h4 id="5-三元运算符"><a href="#5-三元运算符" class="headerlink" title="5.三元运算符"></a>5.三元运算符</h4><ol><li>结构： （条件表达式）？ 表达式1 ： 表达式2</li><li>说明：<ol><li>条件表达式结果为boolean </li><li>条件表达式为真选表达式1，反之2</li><li>表达式1和表达式2类型要求是一致的</li><li>三元运算符可以嵌套使用</li></ol></li><li>凡是可以使用三元运算符的地方，都可以改写为if -  else  反之不成立</li><li>如果程序两者都可用，优先选择三元运算符，原因：简洁，执行效率高</li></ol><h4 id="6-位运算符"><a href="#6-位运算符" class="headerlink" title="6.位运算符"></a>6.位运算符</h4><ol><li><p>位运算符操作都是整型操作的数据,二进制形式移动</p></li><li><p>&lt;&lt; :  空位补0，被移除的高位丢弃，空缺位补0</p><p>在一定范围内， 每向左移一位，相当于  乘2</p></li><li><p>(&gt;&gt;) : 被位移的二进制最高位是0，右移后空位缺位补0；最高位是1，空缺补1</p><p> 在一定范围内，每向右移一位，相当于  除二</p></li><li><p>面试题 ： 最高效方式计算 2 *  8  ?   2&lt;&lt; 3 或者  8&lt;&lt; 1</p></li><li><p>(&gt;&gt;&gt;): 被右移二进制最高位无论是0或者是1 ，空缺位都用零补</p></li><li><p>二进制运算  &amp; 有0则都为0   | 有1则都为1      ^  同则0 不同则1   ~ 取反</p></li></ol><h3 id="2-6-程序流程控制"><a href="#2-6-程序流程控制" class="headerlink" title="2.6 程序流程控制"></a>2.6 程序流程控制</h3><p>注意：以下流程控制语句都是可嵌套使用的</p><h4 id="1-if–else"><a href="#1-if–else" class="headerlink" title="1.if–else"></a>1.if–else</h4><p>第一种</p><p>if（条件表达式）{</p><p>执行表达式</p><p>}</p><p>第二种</p><p>if（条件表达式）{</p><p>执行表达式</p><p>}else{</p><p>执行表达式2</p><p>}</p><p>第三种（满足一个则终止下面的判断）多选一</p><p>if（条件表达式）{</p><p>执行表达式1</p><p>}else if（条件表达式）{</p><p>执行表达式2</p><p>}else if（条件表达式）{</p><p>执行表达式3</p><p>}</p><p>…..</p><p>else {</p><p>​     执行表达式n</p><p>}</p><p>注意：if–else可嵌套使用</p><h4 id="2-java中的输入，需要使用Scanner类"><a href="#2-java中的输入，需要使用Scanner类" class="headerlink" title="2.java中的输入，需要使用Scanner类"></a>2.java中的<strong>输入，需要使用Scanner类</strong></h4><p>具体操作步骤：</p><ol><li><p>导包： import java.util.Scanner;</p></li><li><p>Scanner的实例化：Scanner scan &#x3D; new Scanner(System.in);</p></li><li><p>调用Scanner类的相关方法（next（）这是输入String类型特殊&#x2F;nextXxx（）这是输入其他类型的)</p></li><li><p>注意：需要根据相应的类型来从键盘输入指定类型的值，否则会报错</p></li><li><p>代码示范：</p><p><strong>import java.util.Scanner;</strong></p><p>class ScannerTest{</p><p>public static void main(String[] args){</p><p><strong>Scanner scan &#x3D;  new Scanner(System.in);</strong></p><p><strong>int test &#x3D; scan.nextInt();</strong></p><p>&#x2F;&#x2F;第二种</p><p><strong>int test&#x3D;0;</strong></p><p><strong>test &#x3D;  scan.nextInt();</strong></p><p><strong>}</strong></p><p>}</p></li><li><p>对于char型的获取，Scanner没有提供相应的方法。一般只用String代替。如要获取则有如下方法</p><p>将String字符串中取出一个字符放入char中</p><p>String p &#x3D; “安娜娜”；</p><p>char  q &#x3D; p.charAt(0);  &#x2F;&#x2F;第一个字符从零开始  q&#x3D;‘安’</p></li></ol><h4 id="3-switch-表达式"><a href="#3-switch-表达式" class="headerlink" title="3.switch(表达式){"></a>3.switch(表达式){</h4><p>case x：执行语句；</p><p>​               break；</p><p>case m：</p><p>….</p><p>default：执行语句；</p><p>​              break；</p><p>}</p><ol><li><p>根据switch表达式中的值，依次匹配各个case中的<strong>常量</strong>。一旦匹配成功，则进入相应case结构中，调用其执行语句。执行本语句结束后，<strong>继续向下调</strong>用其余case结构中的执行语句，直到遇到break关键字或者直到switch末尾结束。</p></li><li><p>break与default是可加可不加的，default是没有其他选择后最后的选择</p></li><li><p>switch结构中的表达式，只能是这6种数据类型之一：</p><p>byte、short、char、int、枚举类型JDK5.0新增、String类型JDK7.0新增</p></li><li><p>switch两种情况测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(constant)&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>: a=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>: a=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>: a=<span class="number">3</span>;</span><br><span class="line"><span class="keyword">default</span>:a=<span class="number">4</span>;</span><br><span class="line">&#125;<span class="comment">//输入1，遍历1 语句后没有break，向下遍历，最终a=4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span>(constant)&#123;</span><br><span class="line"><span class="keyword">default</span>:a=<span class="number">4</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>: a=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>: a=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>: a=<span class="number">3</span>;</span><br><span class="line">&#125;    <span class="comment">//  输入1 ，没有break，直到末尾a=3，没有遍历default</span></span><br><span class="line">System.out.println(a);</span><br></pre></td></tr></table></figure></li><li><p>判断闰年：可以被4整除并且不可以被100整除或可以被400整除</p></li></ol><h4 id="4-for-循环语句"><a href="#4-for-循环语句" class="headerlink" title="4.for 循环语句"></a>4.for 循环语句</h4><ol><li><p>条件：</p><ol><li>初始条件</li><li>循环条件—–&gt;是boolean类型</li><li>循环体（执行语句）</li><li>迭代条件</li></ol></li><li><p>for 循环的结构:</p></li></ol><p>   for( 1初始条件 ;  2循环条件   ;  4迭代条件  ){</p><p>   ​        3循环体</p><p>   }</p><ol start="3"><li><p>for（int i &#x3D; 1 ;  i&lt;&#x3D;5 ; i++){</p><p>System.out.println(“Hello,world!”);</p><p>}</p><p><strong>注意：i在for循环内有效</strong>。出了for循环就失效，无法在调用。</p></li></ol><h4 id="5-while循环语句"><a href="#5-while循环语句" class="headerlink" title="5.while循环语句"></a>5.while循环语句</h4><ol><li><p>循环结构四个要素条件：</p><ol><li>初始条件</li><li>循环条件—–&gt;是boolean类型</li><li>循环体（执行语句）</li><li>迭代条件</li></ol></li><li><p>while循环的结构</p><p>int i &#x3D; 1；</p><p>while（i&lt;&#x3D;100）</p><p>{</p><p>执行语句；……</p><p>迭代条件 i + +</p><p>}</p><p>由于算法要求有限性，所以要避免死循环</p></li></ol><h4 id="6-do-–while循环"><a href="#6-do-–while循环" class="headerlink" title="6.do –while循环"></a>6.do –while循环</h4><ol><li><p>循环结构四个要素条件：</p><ol><li>初始条件</li><li>循环条件—–&gt;是boolean类型</li><li>循环体（执行语句）</li><li>迭代条件</li></ol></li><li><p>do—while循环结构</p><p>1初始条件</p><p>do{</p><p>3循环体（执行语句）；</p><p>4迭代条件；</p><p>}while（2循环条件）；</p></li><li><p>说明：</p><p>do—while循环至少会执行一次循环体！</p><p>开发中，使用for和while更多一些，较少使用do—while</p></li></ol><h3 id="2-7此节的一些零碎要点"><a href="#2-7此节的一些零碎要点" class="headerlink" title="2.7此节的一些零碎要点"></a>2.7此节的一些零碎要点</h3><h5 id="1-计算程序运行时间"><a href="#1-计算程序运行时间" class="headerlink" title="1.计算程序运行时间"></a>1.计算程序运行时间</h5><p>利用System.currentTimeMillis();</p><p>这返回的是1970-01-01 00:00:00long型的毫秒数时间：</p><p>long start &#x3D; System.currentTimeMillis();</p><p>需要计算的程序放中间</p><p>long end  &#x3D; System.currentTimeMillis();</p><p>用end - start得到的就是运行程序所需的时间</p><h5 id="2-Math-sqrt-i"><a href="#2-Math-sqrt-i" class="headerlink" title="2.Math.sqrt(i);"></a>2.Math.sqrt(i);</h5><p> 对i进行开根号</p><h5 id="3-关键字：return"><a href="#3-关键字：return" class="headerlink" title="3.关键字：return"></a>3.关键字：return</h5><p>并非专门用于结束循环的，它的功能是结束一个方法（函数）</p><h5 id="4-关键字：break和continue"><a href="#4-关键字：break和continue" class="headerlink" title="4.关键字：break和continue"></a>4.关键字：break和continue</h5><table><thead><tr><th></th><th align="left">使用范围</th><th>循环中的不同</th><th>相同点</th></tr></thead><tbody><tr><td>break</td><td align="left">循环结构中以及switchcase</td><td>结束当前循环</td><td>关键字后面不能在写语句</td></tr><tr><td>continue</td><td align="left">循环结构中</td><td>结束当次循环</td><td>关键字后面不能在写语句</td></tr></tbody></table><h5 id="5-Math-random-产生随机数"><a href="#5-Math-random-产生随机数" class="headerlink" title="5.Math.random()产生随机数"></a>5.Math.random()产生随机数</h5><p><strong>Math.random()<strong>这函数</strong>产生的随机数</strong>是double类型的范围是[0.0,1.0)</p><p>如何获取一个随机数10-99：</p><p>int  value &#x3D; (int)(Math.random()*90+10)</p><p>乘90范围变为[0.0,90.0)，加十[10.0,100.0)，强转int后[10,99]</p><p>得出公式：[a,b]：(int)(Math.random()*(b-a+1)+a)</p><p>注意：</p><ol><li><p>默认结束包裹此关键字最近的一层循环</p></li><li><p>label:for(int i&#x3D;1; i&lt;&#x3D;4;i++)</p><p>if (i%4&#x3D;&#x3D;0)</p><p> break label  ;  结束指定标识的一层循环结构</p><p>continue label；结束指定标识的一层循环结构当次循环</p></li></ol><h5 id="6-补充：衡量一个功能代码的优劣"><a href="#6-补充：衡量一个功能代码的优劣" class="headerlink" title="6.补充：衡量一个功能代码的优劣"></a>6.补充：衡量一个功能代码的优劣</h5><ol><li>正确性</li><li>可读性</li><li>健壮性</li><li>高效率与低存储：时间复杂度、空间复杂度（衡量算法的好坏）</li></ol><h2 id="3-数组"><a href="#3-数组" class="headerlink" title="3.数组"></a>3.数组</h2><h3 id="3-1数组的概述"><a href="#3-1数组的概述" class="headerlink" title="3.1数组的概述"></a>3.1数组的概述</h3><h4 id="1-数组的理解："><a href="#1-数组的理解：" class="headerlink" title="1. 数组的理解："></a>1. 数组的理解：</h4><p>数组（Array），是多个相同类型数据按一定顺序排序的集合，并使用一个名字命名，并通过编号的方式对这些数据进行统一管理。</p><h4 id="2-数组的相关概念："><a href="#2-数组的相关概念：" class="headerlink" title="2.数组的相关概念："></a>2.数组的相关概念：</h4><ol><li>数组名</li><li>元素</li><li>角标、下标、索引</li><li>数组的长度：元素个数</li></ol><h4 id="3-数组的特点："><a href="#3-数组的特点：" class="headerlink" title="3.数组的特点："></a>3.数组的特点：</h4><ol><li>数组是有序的</li><li>数组属于引用数据类型的变量。数组元素，既可以是基本数据类型，也可以是引用数据类型</li><li>创建数组对象会存在中开辟一整块连续的空间</li><li>数组的长度一旦确定，就不能修改</li></ol><h4 id="4-数组的分类："><a href="#4-数组的分类：" class="headerlink" title="4.数组的分类："></a>4.数组的分类：</h4><ol><li>按维数：一维数组、二维数组……….</li><li>按照数组元素的类型，基本数据元素的数组、引用数据类型元素的数组</li></ol><h3 id="3-2一维数组的使用"><a href="#3-2一维数组的使用" class="headerlink" title="3.2一维数组的使用"></a>3.2一维数组的使用</h3><h4 id="1-一维数组的声明和初始化"><a href="#1-一维数组的声明和初始化" class="headerlink" title="1.一维数组的声明和初始化"></a>1.一维数组的声明和初始化</h4><p>1.<strong>静态</strong>初始化：数组的初始化和数组元素的赋值操作<strong>同时进行</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>)</span><br><span class="line"><span class="type">int</span>[ ]  ids;</span><br><span class="line">ids = <span class="keyword">new</span>  <span class="title class_">int</span>[ ]&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;;</span><br><span class="line">(<span class="number">2</span>)</span><br><span class="line"><span class="type">int</span>[ ]  ids= <span class="keyword">new</span>  <span class="title class_">int</span>[ ]&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;;</span><br><span class="line">(<span class="number">3</span>)</span><br><span class="line"><span class="type">int</span>[ ]  ids = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;</span><br><span class="line">(<span class="number">4</span>)语法不错误，但不建议</span><br><span class="line"><span class="type">int</span>  ids[ ] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;</span><br></pre></td></tr></table></figure><p>2.<strong>动态</strong>初始化：数组的初始化和数组元素的赋值操作<strong>分开进行</strong></p><p>String[ ]  names &#x3D; new  String [5];</p><h4 id="2-如何调用数组的指定位置的元素"><a href="#2-如何调用数组的指定位置的元素" class="headerlink" title="2.如何调用数组的指定位置的元素"></a>2.如何调用数组的指定位置的元素</h4><p>通过角标的方式调用。</p><p>角标从0开始的，到数组长度-1结束</p><h4 id="3-如何获取数组的长度"><a href="#3-如何获取数组的长度" class="headerlink" title="3.如何获取数组的长度"></a>3.如何获取数组的长度</h4><p>int[ ]  ids;</p><p>ids &#x3D; new  int[ ]{1,3,4,5,6,7};</p><p>长度 &#x3D;  ids.length</p><h4 id="4-如何遍历数组"><a href="#4-如何遍历数组" class="headerlink" title="4.如何遍历数组"></a>4.如何遍历数组</h4><p>for(int i&#x3D;0 ; i&lt;ids.length ; i++){</p><p>System.out,println(ids[ i ]);</p><p>}</p><h4 id="5-数组元素的默认初始化值"><a href="#5-数组元素的默认初始化值" class="headerlink" title="5.数组元素的默认初始化值"></a>5.数组元素的默认初始化值</h4><p>数组元素是整型：0</p><p>数组元素是浮点型：0.0</p><p>数组元素是char型：0，而非’0’</p><p>数组元素是boolean型：false</p><h4 id="6-数组的内存解析"><a href="#6-数组的内存解析" class="headerlink" title="6.数组的内存解析"></a>6.数组的内存解析</h4><p><img src="/2022/09/28/%E5%B0%9A%E7%A1%85%E8%B0%B7java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/img%5CSnipaste_2022-01-07_17-12-47.png" alt="Snipaste_2022-01-07_17-12-47"></p><p><img src="/2022/09/28/%E5%B0%9A%E7%A1%85%E8%B0%B7java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/img%5CSnipaste_2022-01-07_18-06-56.png" alt="Snipaste_2022-01-07_18-06-56"></p><h3 id="3-3二维数组的使用："><a href="#3-3二维数组的使用：" class="headerlink" title="3.3二维数组的使用："></a>3.3二维数组的使用：</h3><h4 id="1-理解："><a href="#1-理解：" class="headerlink" title="1.理解："></a>1.理解：</h4><p>我们可以看成是一维数组array1又作为另一个一维数组array2的元素而存在</p><p>其实，从数组底层的运行机制来看，其实没有多维数组</p><p>见解：一维数组套另外一个一维数组</p><h4 id="2-二维数组的声明和初始化"><a href="#2-二维数组的声明和初始化" class="headerlink" title="2.二维数组的声明和初始化"></a>2.二维数组的声明和初始化</h4><p><strong>静态初始化：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>)</span><br><span class="line"><span class="type">int</span>[ &#125;[ ] ids;</span><br><span class="line">ids = <span class="keyword">new</span>  <span class="title class_">int</span>[ &#125;[ ]&#123; &#123;<span class="number">1</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;,&#123;<span class="number">7</span>&#125; &#125;;</span><br><span class="line">(<span class="number">2</span>)</span><br><span class="line"><span class="type">int</span>[ &#125;[ ]  ids= <span class="keyword">new</span>  <span class="title class_">int</span>[ &#125;[ ]&#123; &#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>&#125;,&#123;<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125; &#125;;</span><br><span class="line">(<span class="number">3</span>)</span><br><span class="line"><span class="type">int</span>[ &#125;[ ]  ids = &#123; &#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>&#125;,&#123;<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125; &#125;;</span><br><span class="line">(<span class="number">4</span>)语法不错误，但不建议</span><br><span class="line"><span class="type">int</span> []  arr[] =<span class="keyword">new</span>  <span class="title class_">int</span>[ &#125;[ ]&#123; &#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>&#125;,&#123;<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125; &#125;;</span><br><span class="line">(<span class="number">5</span>)语法不错误，但不建议</span><br><span class="line"><span class="type">int</span> []  arr[] = [ &#125;[ ]&#123; &#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>&#125;,&#123;<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125; &#125;;</span><br></pre></td></tr></table></figure><p><strong>动态初始化：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>)</span><br><span class="line">String[ &#125;[ ]  names = <span class="keyword">new</span>  <span class="title class_">String</span> [<span class="number">5</span>&#125;[<span class="number">4</span>];</span><br><span class="line">(<span class="number">2</span>)</span><br><span class="line">String[ &#125;[ ]  names = <span class="keyword">new</span>  <span class="title class_">String</span> [<span class="number">5</span>&#125;[ ];<span class="comment">//不能不写左边只写右边，根据内存解析更容易理解</span></span><br><span class="line">names[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">4</span>];</span><br><span class="line"><span class="comment">//单独将第一行所指的一维数组创建出来</span></span><br></pre></td></tr></table></figure><h4 id="3-如何调用数组的指定位置的元素"><a href="#3-如何调用数组的指定位置的元素" class="headerlink" title="3.如何调用数组的指定位置的元素"></a>3.如何调用数组的指定位置的元素</h4><p>arr【i】【j】</p><h4 id="4-如何获取数组的长度"><a href="#4-如何获取数组的长度" class="headerlink" title="4.如何获取数组的长度"></a>4.如何获取数组的长度</h4><p>arr.length是行数一维数组的长度</p><p>arr[1].length是指定第一行所指的一维数组的长度</p><h4 id="5-如何遍历数组"><a href="#5-如何遍历数组" class="headerlink" title="5.如何遍历数组"></a>5.如何遍历数组</h4><p>for(int i&#x3D;0 ; i&lt;arr.length ; i++){</p><p>​for(int j&#x3D;0 ; j&lt;arr[i].length ; j++)</p><p>​              System.out.print(arr[i}[j]);</p><p>}</p><h4 id="6-数组元素的默认初始化值"><a href="#6-数组元素的默认初始化值" class="headerlink" title="6.数组元素的默认初始化值"></a>6.数组元素的默认初始化值</h4><p>情况一：int[}[]  arr &#x3D; new int [4}[3];</p><p>外层元素初始化值：地址值</p><p>内层元素初始化值：与一维数组初始化情况相同</p><p>情况二：int[}[]  arr &#x3D; new int [4}[];</p><p>外层元素初始化：null</p><p>内层元素初始化值：不能调用，会报错</p><h4 id="7-数组的内存解析"><a href="#7-数组的内存解析" class="headerlink" title="7.数组的内存解析"></a>7.数组的内存解析</h4><p><img src="/2022/09/28/%E5%B0%9A%E7%A1%85%E8%B0%B7java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/img%5CSnipaste_2022-01-07_21-00-01.png" alt="Snipaste_2022-01-07_21-00-01"></p><h3 id="3-4-数组中涉及到常见算法"><a href="#3-4-数组中涉及到常见算法" class="headerlink" title="3.4 数组中涉及到常见算法"></a>3.4 数组中涉及到常见算法</h3><h4 id="1-数组元素的赋值"><a href="#1-数组元素的赋值" class="headerlink" title="1.数组元素的赋值"></a>1.数组元素的<strong>赋值</strong></h4><p>（杨辉三角、回形数等）</p><p>int[] array1,array2;   </p><p>int[]  array1 &#x3D;  new int[] {1,3,4,5,6,7,8};   </p><p>array2  &#x3D;   array1;</p><p>&#x2F;&#x2F;在栈空间中创建了两个数组类型的指针</p><p>&#x2F;&#x2F;new 的话，就是在堆空间创建了数组实体，array2 没有new，所以没有自己的数组实体</p><p>过程理解：将array1保存的数组的地址值赋给了array2，使得array1和array2共同指向堆空间中的同一个数组实体</p><h4 id="2-求数组中元素的最大值、最小值、平均数、总和"><a href="#2-求数组中元素的最大值、最小值、平均数、总和" class="headerlink" title="2.求数组中元素的最大值、最小值、平均数、总和"></a>2.求数组中元素的最大值、最小值、平均数、总和</h4><h4 id="3-数组的复制、反转、查找（线性查找、二分查找）"><a href="#3-数组的复制、反转、查找（线性查找、二分查找）" class="headerlink" title="3.数组的复制、反转、查找（线性查找、二分查找）"></a>3.数组的<strong>复制</strong>、反转、查找（线性查找、二分查找）</h4><p>数组的复制：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[]  array1 =  <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;;</span><br><span class="line"><span class="type">int</span>[]  array2 = <span class="keyword">new</span> <span class="title class_">int</span>[array1.length];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span> ; i&lt;array2.length ; i++)&#123;</span><br><span class="line">    array2[i]  =  array1[i] ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数组的反转：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span> ; i&lt;arr.length / <span class="number">2</span> ; i++)&#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">arr[i] = arr[arr.length-<span class="number">1</span>-i];</span><br><span class="line">arr[arr.length-<span class="number">1</span>-i] = temp;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数组的二分查找：</p><h4 id="4-数组元素的排序算法"><a href="#4-数组元素的排序算法" class="headerlink" title="4.数组元素的排序算法"></a>4.数组元素的排序算法</h4><p>十大内部排序算法：</p><ol><li>选择排序：直接选择排序、<u>堆排序</u>（次要）</li><li>交换排序：<strong>冒泡排序、快速排序</strong>（重点了解）</li><li>插入排序：直接插入排序、折半插入排序、希尔shell排序</li><li><u>归并排序</u>（次要）</li><li>桶式排序</li><li>基数排序</li></ol><p><strong>冒泡排序：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>（<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i&lt;arr.length -<span class="number">1</span> ;  i++)&#123;</span><br><span class="line"><span class="keyword">for</span>( <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span> ;  j&lt;arr.length-<span class="number">1</span>-i  ;   j++)</span><br><span class="line">      <span class="keyword">if</span> ( arr[ j ] &gt; arr[ j + <span class="number">1</span> ])&#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[ j ];</span><br><span class="line">arr[ j ] =  arr[ j + <span class="number">1</span>] ;</span><br><span class="line">arr[ j + <span class="number">1</span> ] = temp ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>快速排序 时间复杂度 O(olog n )   归并和堆排序也是一样</p><p>冒泡排序时间复杂度 O( n^2 )</p><h3 id="3-5零碎知识："><a href="#3-5零碎知识：" class="headerlink" title="3.5零碎知识："></a>3.5零碎知识：</h3><h4 id="1-排序算法的分类："><a href="#1-排序算法的分类：" class="headerlink" title="1.排序算法的分类："></a>1.排序算法的分类：</h4><p>内部排序：不借助外部存储器（如磁盘），所有排序操作都在内存中完成</p><p>外部排序：参与排序数据非常多，数据量非常大，计算机无法把整个排序过程在内存中完成，必须借助于外部存储器（如磁盘）。最常见的是多路归并排序。可以认为外部排序是由多次内部排序组成的。</p><h4 id="2-算法的5大特征"><a href="#2-算法的5大特征" class="headerlink" title="2.算法的5大特征"></a>2.算法的5大特征</h4><p>输入、输出、有穷性（有限性）、确定性（明确性算法中每一步都有确定的含义）、可行性、</p><h4 id="3-数据结构"><a href="#3-数据结构" class="headerlink" title="3.数据结构:"></a>3.数据结构:</h4><ol><li><p>数据与数据之间的逻辑关系：集合、一对一、一对多、多对多</p></li><li><p>数据的存储结构;线性表、树形结构、图形结构</p></li><li><p>算法：</p><p>排序算法、搜索（查找）算法</p></li></ol><h4 id="4-小习题："><a href="#4-小习题：" class="headerlink" title="4.小习题："></a>4.小习题：</h4><p>​            声明一维数组x[]、二维数组y[}[]</p><ol><li><p>x[0] &#x3D; y  ;   no -&gt;一维数组值不能存放二维数组的地址</p></li><li><p>y[0]  &#x3D;  x ;  yes -&gt; 二维数组的外层本来就是放一维数组地址的，因此可以放x的地址</p></li><li><p>y[0}[0] &#x3D; x ; no -&gt; 二维数组的内层放的就是值，不能放地址了</p></li><li><p>x[0}[0] &#x3D;  y ;  no -&gt; x是一维数组，计算机是可以分辨的</p></li><li><p>y[0}[0]  &#x3D;  x[0]  yes -&gt; 两个都是值，可以相互赋值</p></li><li><p>x &#x3D;y ;  no -&gt; 一维数组不能指向二维数组</p><p>总结：创建数组过程：声明（在栈空间中创建了地址）&#x3D;&gt;有new的话（在堆空间中创建数组实体内存（栈空间的声明指向它）如果是二维数组外层一维数组存放自己对应内层一维数组的地址值</p></li></ol><h3 id="3-5Arrays工具类的使用"><a href="#3-5Arrays工具类的使用" class="headerlink" title="3.5Arrays工具类的使用"></a>3.5Arrays工具类的使用</h3><p><strong>需要调用这个类import java.util.Arrays;</strong></p><ol><li><p>boolean   equals(int[] a , int[] b )   前面是返回值类型&#x2F;&#x2F;判断两个数组是否相等</p><p>int [] arr1&#x3D;  new int[]{1,2,3,4,5};</p><p>int [] arr2&#x3D;  new int[]{1,2,3,4,5,6,7,8};</p><p>boolean  isEquals &#x3D; Arrays.equals(arr1,arr2);</p></li><li><p>String   toString(int[]  a)          输出数组信息</p><p>System.out.println(Arrays.toString(arr1));</p></li><li><p>void   fill(int[] a ,  int val)      将数组中的值都换成指定值</p><p>Arrays.fill(arr1,10);</p></li><li><p>void  sort (int[] a)              对数组进行排序（快速排序）</p><p>Arrays.sort(arr1);</p></li><li><p>int  binarySearch(int[]  a , int  key)    对排序后的数组进行二分法查找指定的值  ，没找到会返回一个负数</p><p>int [] arr2&#x3D;  new int[]{1,2,3,4,5,6,7,8};</p><p>int index  &#x3D;Arrays.binarySeatch(arr2,10);</p></li></ol><h3 id="3-6数组中常见的异常"><a href="#3-6数组中常见的异常" class="headerlink" title="3.6数组中常见的异常"></a>3.6数组中常见的异常</h3><ol><li><p>数组角标越界的异常：ArrayIndexOutOfBoundsEception</p><p>合理范围：[ 0 , arr.length - 1 ]</p><p>越界： arr[-1]…  ,   arr[arr.length]</p></li><li><p>空指针异常：NullPointerEception</p><p>int[]  arr  &#x3D;   null ; </p><p>arr[0];</p><p>二维数组的外层为空null，在调用内层时就是空指针异常</p><p>注意： 一旦程序出现异常，未处理时，就终止执行。</p></li></ol><h2 id="4-面向对象（上）"><a href="#4-面向对象（上）" class="headerlink" title="4.面向对象（上）"></a>4.面向对象（上）</h2><h3 id="4-1-Java面向对象学习三条主线（4-6章）"><a href="#4-1-Java面向对象学习三条主线（4-6章）" class="headerlink" title="4.1 Java面向对象学习三条主线（4-6章）"></a>4.1 Java面向对象学习三条主线（4-6章）</h3><ol><li>Java类及类的成员：属性、方法、构造器、代码块、内部类</li><li>面向对象的三大特性：封装性、继承性、多态性、（抽象性）</li><li>其他关键字：this、 super、 static、 final、 abstract、 interface、 package、 import等。</li></ol><h3 id="4-2面向过程与面向对象："><a href="#4-2面向过程与面向对象：" class="headerlink" title="4.2面向过程与面向对象："></a>4.2面向过程与面向对象：</h3><h4 id="1-面向过程："><a href="#1-面向过程：" class="headerlink" title="1.面向过程："></a>1.面向过程：</h4><p>强调的是功能行为，以函数为最小单位，考虑怎么做</p><p>把冰箱门打开</p><p>抬起大象，塞进冰箱</p><p>把冰箱门关闭</p><h4 id="2-面向对象："><a href="#2-面向对象：" class="headerlink" title="2.面向对象："></a>2.面向对象：</h4><p>强调具备了功能的对象，以类&#x2F;&#x2F;对象为最小单位，考虑谁来做。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">人&#123;</span><br><span class="line"></span><br><span class="line">打开（冰箱）&#123;</span><br><span class="line">冰箱.开门</span><br><span class="line">&#125;</span><br><span class="line">        抬起（大象）&#123;</span><br><span class="line">大象.进入（冰箱）</span><br><span class="line">&#125;</span><br><span class="line">关闭（冰箱）&#123;</span><br><span class="line">冰箱.关门</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">冰箱&#123;</span><br><span class="line">开门</span><br><span class="line">关门</span><br><span class="line">&#125;</span><br><span class="line">大象&#123;</span><br><span class="line">进入</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序员从面向过程的<strong>执行者</strong>转化成了面向对象的<strong>指挥者</strong></p><h4 id="3-面向对象的思想概述"><a href="#3-面向对象的思想概述" class="headerlink" title="3.面向对象的思想概述"></a>3.面向对象的思想概述</h4><p>类 &#x3D; 现实世界中抽象具有属性和行为的事物 ；对一类事物抽象的描述</p><p> 对象 &#x3D;  计算机世界的实体  是实际存在的该类事物的每个个体，也称为<strong>实例</strong></p><p>对象，是由类new( 造 )出来的</p><p>面向对象<strong>程序设计的重点</strong>是<strong>类的设计</strong></p><p>类的设计， <strong>其实就是类成员的设计</strong></p><h3 id="4-3-类和对象"><a href="#4-3-类和对象" class="headerlink" title="4.3 类和对象"></a>4.3 类和对象</h3><h4 id="1-JVM-内存结构"><a href="#1-JVM-内存结构" class="headerlink" title="1.JVM 内存结构"></a>1.JVM 内存结构</h4><p>编译完源程序以后，生成一个或多个字节码文件。</p><p>我们使用JVM中的类的加载器和解释器堆生成的字节码文件进行解释运行。意味着，需要将字节码文件对应的类的加载到内存中，涉及到内存解析。<img src="/2022/09/28/%E5%B0%9A%E7%A1%85%E8%B0%B7java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/img%5CSnipaste_2022-01-10_13-24-41.png" alt="Snipaste_2022-01-10_13-24-41"></p><p>虚拟机栈，即为平时提到的栈结构。我们将局部变量存储到栈结构中</p><p>堆，我们将new出来的结构（比如：数组、对象）加载在堆空间中 。补充：对象的属性（非static的）加载在堆空间中</p><p>方法区：类的加载信息、常量池、静态域</p><h4 id="2-关键字-return："><a href="#2-关键字-return：" class="headerlink" title="2.关键字 return："></a>2.关键字 return：</h4><ol><li>使用范围：使用在方法体中</li><li>作用： <ol><li>结束方法</li><li>针对于返回值类型的方法，使用“return   数据”方法返回所要的数据</li><li>注意点：return 关键字后面不可以在声明执行语句</li></ol></li></ol><h4 id="3-java类及类的成员"><a href="#3-java类及类的成员" class="headerlink" title="3.java类及类的成员"></a>3.java类及类的成员</h4><p>初识理解：<strong>类</strong>相似与C语言的结构体； 而这个结构体中有变量和函数</p><p>一个程序可以有很多类，只能有一个public公共类，类中基本的成员是属性（成员变量）和方法。但是只能有一个main方法（函数）也叫程序的入口。</p><p>属性 &#x3D; 成员变量 &#x3D;  field &#x3D;  域、字段</p><p>方法 &#x3D; 成员方法 &#x3D; 函数 &#x3D;  method </p><p>创建类的对象 &#x3D;  类的实例化 &#x3D; 实例化类</p><h4 id="4-类和类对象的创建和使用"><a href="#4-类和类对象的创建和使用" class="headerlink" title="4.类和类对象的创建和使用"></a>4.类和类对象的创建和使用</h4><p>（面向对象思想落地的实现）</p><ol><li><p>创建类，设计类成员</p><p>class  Person{</p><p>​String name;</p><p>​int age;           &#x2F;&#x2F;属性</p><p>​public void  eat() {        &#x2F;&#x2F;行为或方法</p><p>​  System.out.print(“吃面条”)</p><p>​}</p><p>}</p></li><li><p>创建类的对象</p><p>Person  p1  &#x3D;  new  Person() ; </p><p>Person  p2  &#x3D;  new  Person() ;   &#x2F;&#x2F;（<strong>非static的</strong>）两个是独立的个体，互不影响</p><p>&#x2F;&#x2F;数组类型的对象</p><p>Person[]   p4 &#x3D;  new Person[20];  </p><p>for(int i&#x3D;0 ; i &lt; p4.length ; i++){</p><p>​p4[ i ] &#x3D;  new  Person(); &#x2F;&#x2F;给数组元素赋值，也是给属性new空间</p><p>}</p></li><li><p>通过“对象 . 属性”或“对象 . 方法”调用对象的结构</p><p>​            p1.name &#x3D; “Tom”;</p><p>​             p1. age &#x3D; 2;</p><p>​     p1. eat() ;  &#x2F;&#x2F; 输出“吃面条”</p><p>​     p4[ 1 ].name &#x3D;” katrina”;</p><p>​     p4[ 1 ].age &#x3D; 18;</p><p>​            p4[ 1 ].eat() ;&#x2F;&#x2F; 输出“吃面条”</p></li><li><p>Person  p3 &#x3D; p1 ;</p><p>p3没有new，有new在堆空间中才有自己的实体，否则只是在栈空间中创建了一个指针</p><p>将p1变量保存的对象地址值赋给p3，导致p1和p3指向了堆空间中的同一个对象实体</p></li><li><p>后期补充：static  和非static</p><p>非static是以上提到的</p><p>static </p><p>public class newclassTest {</p><p>public static void main(String[] args){</p><p>newClass.walk();   &#x2F;&#x2F;不用new 也能用 ，类名. 方法名</p><p>newClass.age;&#x2F;&#x2F;错  只能调用方法，属性不能调用</p><p>}</p><p>}</p><p>class newClass{</p><p>int age &#x3D;1;</p><p>public static void walk(){  &#x2F;&#x2F;方法声明时加static</p><p>System.out.println(“走路上学！”);</p><p>}</p><p>}</p></li></ol><h4 id="5-对象的创建和使用：内存解析"><a href="#5-对象的创建和使用：内存解析" class="headerlink" title="5.对象的创建和使用：内存解析"></a>5.对象的创建和使用：内存解析</h4><p><img src="/2022/09/28/%E5%B0%9A%E7%A1%85%E8%B0%B7java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/Java%5Cimg%5CSnipaste_2022-01-09_17-04-02.png" alt="Snipaste_2022-01-09_17-04-02"></p><ol><li><p>创建对象：在栈空间中创建指针将可存放类的地址</p></li><li><p>创建类及类的属性：在堆空间中创建带有地址的类实体</p><p>​    实体中存放属性</p></li><li><p>创建对象为数组类型：</p><p>​Student[] stus &#x3D; new Student[20];  &#x2F;&#x2F;在堆空间中创建数组实体，但是每个数组元素存放的是类中的属性的地址值</p><p>因此还需要在给每个数组元素new创建属性，也叫给数组元素赋值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span> ; i&lt;stus.length ; i++)&#123;</span><br><span class="line"><span class="comment">//给数组元素赋值</span></span><br><span class="line">stus[i] = <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br></pre></td></tr></table></figure><p><img src="/2022/09/28/%E5%B0%9A%E7%A1%85%E8%B0%B7java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/img%5CSnipaste_2022-01-10_11-52-53.png" alt="Snipaste_2022-01-10_11-52-53"></p></li></ol><h3 id="4-4类的结构–属性"><a href="#4-4类的结构–属性" class="headerlink" title="4.4类的结构–属性"></a>4.4类的结构–属性</h3><p>​             （属性）成员变量  VS   局部变量</p><ol><li><p>相同点：</p><p>定义变量的格式：数据类型  变量名  &#x3D;   变量值</p><p>先声明，后使用</p><p>变量都有对应的作用域。（只在指定范围内可用）</p></li><li><p>不同点：</p><ol><li><p>在类中声明的位置不同</p><p>属性：直接定义在类的一对{   }内</p><p>局部变量：声明在方法内、方法形参、代码块内、构造器形参、构造器内部的变量</p></li><li><p>关于权限修饰符的不同</p><p>属性：可以子啊声明属性时，指明其权限，使用权限修饰符</p><p>常用的权限修饰符：private、public、缺省（什么都不写）、protected–&gt;封装性在细讲</p><p>局部变量：不可以使用权限修饰符</p><p><strong>权限修饰符理解</strong>：允许调用的范围程度</p><p>private最小译为私人的，public最大译为公共</p></li><li><p>作用域：</p><p>属性：在类中和类中方法里</p><p>局部变量：方法中</p></li><li><p>初始化值</p><p>属性的初始值：String -null 、整型 -0、浮点型 - 0.0 、boolean - false；</p><p>局部变量：没默认初始化值，调用之前必须赋值。特别地，形参可以在调用时赋值即可</p><p>u1.talk(“中国话”)；&#x2F;&#x2F;用时赋值</p><p>public void talk(String  language){</p><p>​int newAge &#x3D; 10；&#x2F;&#x2F;提前赋值</p><p>​System.out.print(language)</p><p>}</p></li><li><p>内存的加载位置：</p><p>属性：加载到堆空间中（非static)</p><p>局部变量：加载到栈空间</p></li></ol></li></ol><h3 id="4-5类的结构–方法"><a href="#4-5类的结构–方法" class="headerlink" title="4.5类的结构–方法"></a>4.5类的结构–方法</h3><ol><li><p>方法的声明：</p><p>权限修饰符  返回值类型  方法名（形参列表）{</p><p>​方法体</p><p>}</p><p>注意：至于static 、final、abstract 来修饰的方法，后面在讲</p></li><li><p>举例</p><p>方法：描述类应该具有的功能</p><p>比如：Math类：sqrt()    \random()…….</p><p>Scanner类：nextXxx()….</p><p>Arrays类：sort()  \binarySearch()  \ toString() \ equals()…….</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">(<span class="type">int</span> hour)</span>&#123;  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>  String <span class="title function_">getNmae</span><span class="params">()</span>&#123;  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getNation</span><span class="params">(String nation)</span>&#123;  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getNation</span><span class="params">(String nation , <span class="type">int</span>  key)</span>&#123;  &#125;</span><br><span class="line"></span><br><span class="line">.................</span><br></pre></td></tr></table></figure></li><li><p>返回值类型：有返回值 VS  没有返回值（void）</p><p>有返回值：声明方法时，必须写返回值类型。同时，在方法中，有return 数据；返回值，该值类型是对应返回值类型</p><p>没有返回值：声明方法是用void 。方法中，return可用可不用，仅代表结束方法 —–return；不加返回值</p></li><li><p>方法的使用中，可以调用当前类的属性或方法</p><p>特殊的，方法A调用方法A：递归方法</p><p>方法中，不可以定义方法</p></li><li><p>注意：</p><ol><li>有无返回值视题目要求而定</li><li>方法名：命名需要“见名知意”</li><li>形参可有多个</li><li>方法体：方法功能的体现</li></ol></li></ol><h3 id="4-6-“万事万物皆对象”"><a href="#4-6-“万事万物皆对象”" class="headerlink" title="4.6 “万事万物皆对象”"></a>4.6 “万事万物皆对象”</h3><p>在Java语言范畴中，我们都将功能、结构等封装到类中，通过类的实例化(造对象)，来调用具体的功能结构</p><p>&#x3D;&gt; Scanner ,String 等</p><p>&#x3D;&gt;文件：File</p><p>&#x3D;&gt;网络资源：URL</p><h3 id="4-6-匿名对象的使用"><a href="#4-6-匿名对象的使用" class="headerlink" title="4.6 匿名对象的使用"></a>4.6 匿名对象的使用</h3><ol><li><p>理解：我们创建的对象，没有显式的赋给一个变量名。即为匿名对象</p></li><li><p>特征 ：匿名对象只能调用一次</p></li><li><p>使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InstanceTest</span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]  args)</span>&#123;</span><br><span class="line">      <span class="type">Person</span> <span class="variable">pop</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span> ();</span><br><span class="line">       pop.name= <span class="number">10</span>;<span class="comment">//这是正常做法</span></span><br><span class="line">       <span class="keyword">new</span>  <span class="title class_">Person</span>().name = <span class="number">10</span>;<span class="comment">//匿名</span></span><br><span class="line">       <span class="comment">//匿名对象：减少简单操作去创建新的变量及内存</span></span><br><span class="line">       <span class="keyword">new</span> <span class="title class_">Person</span>().eat(<span class="number">5</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="type">int</span> name</span><br><span class="line">    <span class="type">int</span>  age </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">(<span class="type">int</span> n )</span>&#123;</span><br><span class="line">        System.out.print(n+<span class="string">&quot;碗面&quot;</span>)；</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>开发中使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    <span class="type">PhoneMall</span> <span class="variable">mall</span>  <span class="operator">=</span>  <span class="keyword">new</span>  <span class="title class_">PhoneMall</span>();</span><br><span class="line">    mall.show(<span class="keyword">new</span> <span class="title class_">Phone</span>());</span><br><span class="line"><span class="comment">//其中</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PhoneMall</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(Phone  phone)</span>&#123;</span><br><span class="line">phone.sendEmail();</span><br><span class="line">phone.playGame();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-7-数组：基本操作代码演示"><a href="#4-7-数组：基本操作代码演示" class="headerlink" title="4.7  数组：基本操作代码演示"></a>4.7  数组：基本操作代码演示</h3><h3 id="4-8-在谈方法"><a href="#4-8-在谈方法" class="headerlink" title="4.8  在谈方法"></a>4.8  在谈方法</h3><h4 id="1-方法的重载"><a href="#1-方法的重载" class="headerlink" title="1.方法的重载"></a>1.方法的重载</h4><ol><li><p>定义：在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或者参数类型不同即可。</p><p>总结定义：<strong>“两同一不同”</strong></p><p>同一类、相同方法名</p><p>参数列表不同：参数个数不同，参数类型不同</p><p>其原因使计算机能够辨别那些是不同的方法</p></li><li><p>举例：</p><p>Arrays类中重载sort() &#x2F;binarySearch()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">add（<span class="type">int</span> i， intj）</span><br><span class="line"></span><br><span class="line">add(<span class="type">double</span> i ,<span class="type">double</span> j)</span><br><span class="line"></span><br><span class="line">add(<span class="type">int</span> i ,<span class="type">double</span> j)</span><br><span class="line"></span><br><span class="line">add(<span class="type">int</span> i ，String  j)</span><br><span class="line"></span><br><span class="line">add (String j ,<span class="type">int</span>  i)</span><br></pre></td></tr></table></figure><p>以上都是重载，计算机能够识别</p></li><li><p>判断是否重载：</p><p>只需遵从定义，跟方法权限修饰符、返回值类型、形参变量名、方法体都没关系</p></li><li><p>在通过对象调用方法时，如何确定某一个指定的方法</p><p>方法名，不行。则形参列表</p></li></ol><h4 id="2-可变形参的方法"><a href="#2-可变形参的方法" class="headerlink" title="2.可变形参的方法"></a>2.可变形参的方法</h4><ol><li><p>jdk  5.0 新增的内容</p><p>（String…形参名）</p></li><li><p>具体使用：</p><p>2.1 可变个数形参<strong>格式</strong> ：数据类型 . . . 变量名</p><p>2.2 当调用可变个数形参的方法时，传入的<strong>参数个数</strong>可以是：0,1,2,3，…</p><p>2.3 可变个数形参的方法与本类方法名相同，形参不同的方法之间<strong>构成重载</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span> <span class="params">(<span class="type">int</span> ... ints)</span>&#123;  &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span> <span class="params">(<span class="type">double</span>  i  )</span>&#123;  &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span> <span class="params">(String ... strs)</span>&#123;  &#125;</span><br></pre></td></tr></table></figure><p>2.4可变个数形参的方法与本类中方法名相同，形参类型也相同的数组之间<strong>不构成重载</strong>。换句话说，二者不能共存 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span> <span class="params">(String []   strs)</span>&#123;  &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span> <span class="params">(String ... str )</span>&#123;  &#125;<span class="comment">//错误，两者其实是一样的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//都能吸收可变个个数，计算法无法分辨</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span> <span class="params">(<span class="type">int</span> i , String ... str)</span>&#123;  &#125;<span class="comment">//正确的</span></span><br></pre></td></tr></table></figure><p>2.5可变个数形参方法的形参中，<strong>必须声明在末尾</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span> <span class="params">(String []   strs)</span>&#123;  &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span> <span class="params">(<span class="type">int</span> i , String ... str)</span>&#123;  &#125;<span class="comment">//正确</span></span><br></pre></td></tr></table></figure><p>2.6可变个数形参在方法的形参中，<strong>最多只能声明一个可变形参</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(String...strings,<span class="type">int</span>...strs)</span>&#123; &#125;</span><br></pre></td></tr></table></figure><p>2.7优先选择不是可变个数形参</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> val.show(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(<span class="type">int</span>  i)</span>&#123;   <span class="comment">//优先这个</span></span><br><span class="line">System.out.print(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(<span class="type">int</span>...strs)</span>&#123;</span><br><span class="line">System.out.print(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-方法参数的”值传递”机制"><a href="#3-方法参数的”值传递”机制" class="headerlink" title="3.方法参数的”值传递”机制"></a>3.方法参数的”值传递”机制</h4><p>方法的形参的传递机制：值传递</p><ol><li><p>形参：方法定义时，声明的小括号（）内的参数</p></li><li><p>实参：方法调用时，实际传递给形参的数据 val.show(2);&#x2F;&#x2F; 2–实参</p></li><li><p>值传递机制:</p><p>如果参数是基本数据类型，此时实参赋给形参的是实参真实存储的<strong>数据值</strong></p><p>如果参数是引用数据类型，此时实参赋给形参的是实参存储数据的<strong>地址值</strong></p></li><li><p>举例：交换数组中 下标i  和  j  的值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[]  arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="comment">//错误做法</span></span><br><span class="line">Test.swap(arr[<span class="number">1</span>],arr[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> i  , <span class="type">int</span>  j)</span>&#123;</span><br><span class="line">         <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> i ; </span><br><span class="line">                i = j   ; </span><br><span class="line">             j = temp;  </span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//正确做法</span></span><br><span class="line">Test.swap(arr, <span class="number">1</span>, <span class="number">2</span>) ;   <span class="comment">//传地址值和下标</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arrss, <span class="type">int</span> i  , <span class="type">int</span>  j)</span>&#123;</span><br><span class="line">             <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arrss[i] ; </span><br><span class="line">                    arrss[i] = arrss[ j]; </span><br><span class="line">                 arrss[ j] = temp;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="4-递归方法（了解）"><a href="#4-递归方法（了解）" class="headerlink" title="4.递归方法（了解）"></a>4.递归方法（了解）</h4><ol><li><p>递归方法：一个方法体内调用它自身</p></li><li><p>方法递归包含了一种隐式的循环，它的重复执行某段代码，但这种重复执行无须循环控制</p><p>按已知方向递归，也要有终止条件，否则会导致死循环</p></li></ol><h3 id="4-9面向对象特征之一：封装和隐藏"><a href="#4-9面向对象特征之一：封装和隐藏" class="headerlink" title="4.9面向对象特征之一：封装和隐藏"></a>4.9面向对象特征之一：封装和隐藏</h3><h4 id="1-概念初理解："><a href="#1-概念初理解：" class="headerlink" title="1.概念初理解："></a>1.概念初理解：</h4><p>我们程序设计追求 “ 高内聚 ” ， “ 低耦合 ”</p><p>高内聚：类的内部数据操作细节自己完成，不允许外部干涉</p><p>低耦合：仅对外暴露少量的方法用于使用</p><p>俗话说：把该隐藏的隐藏起来，该暴露的暴露出来。这就是封装性的设计思想。</p><h4 id="2-问题引入："><a href="#2-问题引入：" class="headerlink" title="2.问题引入："></a>2.问题引入：</h4><p>当我们创建一个类的对象以后，我们通过 “ 对象 . 属性 ”的方式，对对象的属性进行赋值。</p><p>这里，赋值操作要受到属性的数据类型和存储范围的制约。除此之外，没有其他制约条件。</p><p>但是，在实际问题中，我们往往需要给属性赋值加入额外的限制条件。这个就不能在属性声明时体现，我们只能通过方法进行限制条件的添加。（比如 setLegs()）</p><p>同时，我们需要避免用户在使用 “ 对象 . 属性 ” 的方式对属性进行赋值。则需要将属性声明为私有的（private）。</p><p>此时，针对–属性 –就体现了封装性。</p><h4 id="3-封装性的体现"><a href="#3-封装性的体现" class="headerlink" title="3.封装性的体现"></a>3.封装性的体现</h4><p>我们将类的属性xxx私有化（private）, 同时，提供公共的（public）方法来获取（getXxx）和设置（setXxx）此属性的值</p><p>拓展：封装性的体现：</p><ol><li>以上提到的</li><li>不对外暴露的私有方法</li><li>单例模式(私有化构造器)</li><li>如果不希望类在包外被调用，可以将类设置为缺省的</li><li>……….</li></ol><p>代码示范：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">String name ;</span><br><span class="line"><span class="keyword">private</span>  <span class="type">int</span> age ;      <span class="comment">//私有化</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> ages)</span>&#123;</span><br><span class="line">age = ages  ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">return</span> age ; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-封装性与权限修饰符"><a href="#4-封装性与权限修饰符" class="headerlink" title="4.封装性与权限修饰符"></a>4.封装性与权限修饰符</h4><ol><li><p>Java规定的4 种权限（从小到大）：private、缺省、protected、public</p></li><li><p>4 种权限可以用来修饰类及类的内部结构：属性、方法、构造器、内部类</p></li><li><p>具体的使用范围</p><p>4 种权限，都可以用来修饰类的内部结构：属性、方法、构造器、内部类</p><p>修饰类，只能用：缺省、public</p><table><thead><tr><th>修饰符</th><th>类内部</th><th>同一个包</th><th>不同包的子类</th><th>同一个工程</th></tr></thead><tbody><tr><td>private</td><td>yes</td><td></td><td></td><td></td></tr><tr><td>缺省</td><td>yes</td><td>yes</td><td></td><td></td></tr><tr><td>protected（暂不考虑）</td><td>yes</td><td>yes</td><td>yes</td><td></td></tr><tr><td>public</td><td>yes</td><td>yes</td><td>yes</td><td>yes</td></tr></tbody></table><p>private：出了这个类用不了</p><p>缺省：出了包用不了</p><p>public：基本都可以用</p></li></ol><p>总结封装性：Java提供了4 种权限修饰符来修饰类及类的内部结构，体现类及类的内部结构在被调用时的可见性的大小</p><h3 id="4-10-类的结构–构造器"><a href="#4-10-类的结构–构造器" class="headerlink" title="4.10 类的结构–构造器"></a>4.10 类的结构–构造器</h3><ol><li><p>构造器的作用（constructor）</p><ol><li>创建对象</li><li>初始化对象的信息</li></ol></li><li><p>说明：</p><ol><li><p>如果没有显式的定义类的构造器的话，则系统就默认提供一个空参的构造器</p><p>&#x2F;&#x2F;创建对象：new+构造器</p><p>Person  p  &#x3D;   new <strong>Person()</strong>;</p><p>加粗的为构造器的使用</p><p>class  Person{</p><p>​此时类中并没有构造器，也能够使用，也只能使用空参的</p><p>}</p></li><li><p>定义构造器的格式：权限修饰符 类名（形参列表）{  }</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span>  <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">age = n;  <span class="comment">//初始化对象的信息</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>一个类中可以定义多个构造器，彼此构成重载</p></li><li><p>一旦我们显式的定义了类的构造器之后，系统就不在提供默认的空参构造器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span>  <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(); <span class="comment">//报错，除非在造个空参的构造器</span></span><br><span class="line"><span class="type">Person</span>  <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">18</span>);<span class="comment">//正确</span></span><br><span class="line"><span class="keyword">class</span>  <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">age = n;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>一个类中，至少会有一个构造器</p></li><li><p>关于初始化属性总结</p><ol><li><p>默认初始化</p></li><li><p>显式初始化</p></li><li><p>构造器初始化</p></li><li><p>通过 “ 对象 . 方法 ” 或 “ 对象 . 属性 ” 的方式，赋值</p><p>这是按先后顺序覆盖的，也一定是按这个顺序</p></li></ol></li></ol></li></ol><h3 id="4-11-拓展：JavaBean"><a href="#4-11-拓展：JavaBean" class="headerlink" title="4.11 拓展：JavaBean"></a>4.11 拓展：JavaBean</h3><ol><li><p>JavaBean是一种Java语言写成的可重用组件</p></li><li><p>所谓的javaBean，是指符合如下标准的java类：</p><p>类是公共的</p><p>有一个无参的公共的构造器</p><p>有属性，且有对应的get、set方法</p><p>未完待续…..</p></li></ol><h3 id="4-12-关键字：this"><a href="#4-12-关键字：this" class="headerlink" title="4.12 关键字：this"></a>4.12 关键字：this</h3><h4 id="1-this的作用"><a href="#1-this的作用" class="headerlink" title="1.this的作用"></a>1.this的作用</h4><p>可以用来修饰和调用：（属性、方法、构造器）</p><h4 id="2-this-修饰属性和方法"><a href="#2-this-修饰属性和方法" class="headerlink" title="2.this 修饰属性和方法"></a>2.this 修饰属性和方法</h4><p>this理解为：当前对象或者当前正在创建的对象</p><p>1.在<strong>类的方法</strong>中，我们可以使用 “ this . 属性  ” 或 “ this . 方法” 的方式，调用当前对象属性或方法。</p><p>通常情况下，我们都选择省略 “this” </p><p>特殊情况下，如果方法的形参和类的属性同名时，我们必须显式的使用 “ this . 变量 ” 的方式，表明此变量是属性，而非形参</p><p>2.同理，在类的构造器也是这个道理</p><p>在<strong>类的构造器</strong>中，我们可以使用 “ this . 属性  ” 或 “ this . 方法” 的方式，调用当前对象属性或方法。</p><p>通常情况下，我们都选择省略 “this” </p><p>特殊情况下，如果构造器的形参和类的属性同名时，我们必须显式的使用 “ this . 变量 ” 的方式，表明此变量是属性，而非形参</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line">Stirng  name;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span>&#123;<span class="comment">//方法中</span></span><br><span class="line">重名，使用<span class="built_in">this</span></span><br><span class="line"><span class="built_in">this</span> . age = age ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>  <span class="title function_">Person</span><span class="params">(String name)</span>&#123;</span><br><span class="line"><span class="comment">//构造器中</span></span><br><span class="line"><span class="built_in">this</span> . name = name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-this-调用构造器"><a href="#3-this-调用构造器" class="headerlink" title="3.this 调用构造器"></a>3.this 调用构造器</h4><ol><li><p>我们在类的构造器中，可以显式的使用 “ this(形参列表) ” 方式，调用本类中指定的其他构造器</p><p>可能原因：每个构造器或者两个构造器间有相同代码的重复操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"></span><br><span class="line">String name ;</span><br><span class="line"><span class="type">int</span>  age ;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span>&#123;</span><br><span class="line">     一些操作</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>();</span><br><span class="line"><span class="built_in">this</span>.name = name ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>构造器中不能通过 “this (形参列表)” 方式调用自己</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"></span><br><span class="line">   String name ;</span><br><span class="line">   <span class="type">int</span>  age ;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span>&#123;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>(<span class="string">&quot;Tom&quot;</span>);<span class="comment">//不能调用自己</span></span><br><span class="line">  <span class="built_in">this</span>.name = name ;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果一个类中有n个构造器，则最多有n-1构造器中使用了“this (形参列表)” </p><p>构造器间不能出现成环调用–死循环</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"></span><br><span class="line">String name ;</span><br><span class="line"><span class="type">int</span>  age ;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="built_in">this</span>(<span class="string">&quot;Tom&quot;</span>); <span class="comment">//你调它</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">this</span>(); <span class="comment">//它调你</span></span><br><span class="line"><span class="built_in">this</span>.name = name ;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>规定：“this (形参列表)” 必须声明在当前构造器的首行</p><p>防止你调用的构造器和你下面出现的操作相同，覆盖了你的操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>(); <span class="comment">//它调你</span></span><br><span class="line"><span class="built_in">this</span>.name = name ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>构造器内部，最多只能声明一个“this (形参列表)” ,用来调用其他的构造器</p><p>人呐，只能有一个女朋友</p></li></ol><h4 id="4-this-表示当前对象，作为实参被调用"><a href="#4-this-表示当前对象，作为实参被调用" class="headerlink" title="4.this 表示当前对象，作为实参被调用"></a>4.this 表示当前对象，作为实参被调用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span>  <span class="title class_">Boy</span>&#123;</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">marry</span><span class="params">(Girl  girl)</span>&#123;</span><br><span class="line">一些操作</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span>  <span class="title class_">Girl</span>&#123;</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">marry</span><span class="params">(Boy  boy)</span>&#123;</span><br><span class="line">Boy.marry(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>this 是当前对象，类型为Girl</strong></p><p><strong>补充：也可单独表示：</strong></p><p><strong>obj &#x3D;&#x3D; this  ：判断形参obj是否等于当前对象</strong></p></blockquote><h3 id="4-13-关键字-package"><a href="#4-13-关键字-package" class="headerlink" title="4.13 关键字 package"></a>4.13 关键字 package</h3><ol><li><p>为了更好的实现项目中类的管理，提供包的概念</p></li><li><p>使用package声明类或接口所属的包，声明在源文件的首行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.java2</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">xxx</span>&#123;  </span><br><span class="line">   &#125; </span><br></pre></td></tr></table></figure><blockquote><p>包，属于标识符，遵循标识符的命名规则、规范（xxxyyyzzz）、“见名知意”</p></blockquote></li><li><p>每点“ . ”一次，就代表一层文件目录</p><p>com.atguigu.java2</p></li><li><p>补充：</p><p>同一个包下，不能命名同名的接口、类</p><p>不同的包下，可以命名同名的接口、类</p></li><li><p>JDK主要包介绍</p><ol><li>java.lang–包含一些java语言的核心类，比如String、Math、Integer、System和Thread，提供常用的功能</li><li>java.util—包含一些实用工具类，比如系统特性、接口的集合框架类、实用与日期日历相关的函数</li><li>java.net</li><li>java.io</li><li>java.text</li><li>java.sql</li><li>java.awt</li></ol></li></ol><p>4.14  MVC 模式设计<img src="/2022/09/28/%E5%B0%9A%E7%A1%85%E8%B0%B7java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/img%5CSnipaste_2022-01-11_20-51-35.png" alt="Snipaste_2022-01-11_20-51-35"></p><h3 id="4-15-关键字-import"><a href="#4-15-关键字-import" class="headerlink" title="4.15 关键字 import"></a>4.15 关键字 import</h3><p>​    import：导入</p><ol><li><p>在源文件中显式的使用import结构导入指定包下的类、接口</p></li><li><p>声明在包的声明和类的声明之间</p></li><li><p>如果需要导入多个结构，可以并列写写出即可</p></li><li><p>如果使用的类或接口是java.lang包下定义的，则可以省略import结构</p></li><li><p>如果使用的类或接口是本包下定义的，则可以省略import</p></li><li><p>如果在源文件中，使用了不同包下同名的类，则必须至少有一个需要一全类名的方式显示</p><p>应在前面加上具体的文件路径(每个都可以加上路径，只是为了美观简约的去掉)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.atguigu.java2.Account</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">xxxx</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Account</span> <span class="variable">acc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Account</span> (<span class="number">100</span>);</span><br><span class="line">        com.atguigu.java5.<span class="type">Account</span> <span class="variable">acc1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Accout</span>(<span class="number">100</span>,<span class="number">0</span>,<span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用“xxx .*” 方式表明可以调用xxx包下的所有结构。但是如果使用的是xxx子包下的结构，则仍需要显式</p></li><li><p>import static ：导入指定类或接口中的静态结构;属性和方法</p></li></ol><h2 id="5-面向对象（中）"><a href="#5-面向对象（中）" class="headerlink" title="5.面向对象（中）"></a>5.面向对象（中）</h2><h3 id="5-1面向对象特征之二：继承性"><a href="#5-1面向对象特征之二：继承性" class="headerlink" title="5.1面向对象特征之二：继承性"></a>5.1面向对象特征之二：继承性</h3><h4 id="1-继承性的好处"><a href="#1-继承性的好处" class="headerlink" title="1.继承性的好处"></a>1.继承性的好处</h4><ol><li>减少代码的冗余，提高代码的复用性</li><li>便于功能的扩展</li><li>为了之后多态性的使用，提供了前提</li></ol><h4 id="2-继承性的格式"><a href="#2-继承性的格式" class="headerlink" title="2.继承性的格式"></a>2.继承性的格式</h4><p>class  A  <strong>extends</strong>  B {  }</p><p>A : 子类、派生类、subclass</p><p>B :  父类、超类、基类、superclass</p><h4 id="3-用处体现："><a href="#3-用处体现：" class="headerlink" title="3.用处体现："></a>3.用处体现：</h4><ol><li>一旦子类A继承父类B以后，<strong>子类A中就获取了父类B中声明的所有属性和方法</strong></li></ol><p>特别地，父类中声明为private的属性或方法，子类继承父类以后，仍然认为获取了私有结构。只是因为封装性的影响，使得子类不能直接调用父类此结构</p><ol start="2"><li><strong>子类继承父类</strong>以后，还可以声明自己特有的属性或方法，实现功能的扩展。也就是<strong>子类有的父类没有，反之。父类有的子类都有</strong></li></ol><h4 id="4-Java中关于继承性的规定："><a href="#4-Java中关于继承性的规定：" class="headerlink" title="4.Java中关于继承性的规定："></a>4.Java中关于继承性的规定：</h4><ol><li><p>一个类可以被多个子类继承</p></li><li><p>Java中类的单继承性：一个类只能有一个类</p></li><li><p>子父类是相对的概念</p></li><li><p>子类直接继承的父类，称为：直接父类。间接继承的父类称为：0间接父类。</p><p>也就是子类有父类，父类还有父类，这样，子类继承以上的两个父类</p></li><li><p>子类继承父类以后，就获取了直接父类以及所有间接父类中声明的属性和方法</p></li></ol><p><strong>Object类</strong></p><ol><li>如果我们没有显式的声明一个类的父类的话，则此类继承于java.lang.Object类</li><li>所有的java类（除了java.lang.Object类之外）都直接或间接的继承于java.lang.Object类</li><li>意味着，所有的java类具有java.lang.Object类声明的功能</li></ol><h3 id="5-2-方法的重写"><a href="#5-2-方法的重写" class="headerlink" title="5.2 方法的重写"></a>5.2 方法的重写</h3><p>（overeide 、overwrite）</p><ol><li><p><strong>重写：子类继承父类以后，可以对父类中同名同参数的方法，进行覆盖</strong></p></li><li><p><strong>应用：重写以后，且当创建子类对象以后，通过子类对象调用子父类中的同名同参数的方法时，参数实际执行的是子类重写父类的方法</strong></p></li><li><p>重写的规定：约定俗称：子类中的叫重写的方法，父类中的叫被重写的方法</p><ol><li>子类重写的<strong>方法名和形参列表</strong>和父类被重写的<strong>方法名和形参列表相同</strong></li><li>子类重写的方法的权限修饰符不小于被重写的方法的权限修饰符</li></ol><p>​                    特殊情况：子类不能重写父类中声明为private的<strong>方法</strong></p></li><li><p>返回值类型;</p><ol><li>父类被重写的方法的返回值类型是void，则子类重写的方法的返回值类型只能是void</li><li>父类被重写的方法的返回值类型是A类型，则子类重写的方法的返回值类型只能是A类或A类的子类</li><li>父类被重写的方法的返回值类型是基本数据类型，则子类重写的方法的返回值类型只能是相同的基本数据类型</li><li>子类重写的方法抛出异常类型不大于父类被重写的方法抛出异常类型</li></ol></li><li><p><strong>由于注意事项很多，一般都写和父类的方法一样的即可</strong></p></li><li><p>补充：子类和父类的同名同参数的方法要么都声明为非static的（考虑重写），要么都声明static（不考虑重写）</p></li><li><p>面试题：区分方法的重写和重载？</p><ol><li><p>二者的概念：</p><p>重载：在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或者参数类型不同即可。—构造器也能重写</p><p>重写：子类继承父类以后，可以对父类中同名同参数的方法，进行覆盖—构造器不能重写</p></li><li><p>在谈谈二者具体规则</p></li><li><p>最后;</p><p>重载：不表现为多态性</p><p>​            调用的地址在编译期就绑定了，在方法调用之前，编译器就已经确定了所要调用的方法，称为早绑定或静态绑定</p><p>重写：表现为多态性</p><p>​           在方法调用的那一刻，解释运行器才会确定所要调用的方法，   重写称为  晚绑定 或动态绑定</p></li></ol></li></ol><h3 id="5-3-关键字：super"><a href="#5-3-关键字：super" class="headerlink" title="5.3 关键字：super"></a>5.3 关键字：super</h3><h4 id="1-理解和用处"><a href="#1-理解和用处" class="headerlink" title="1.理解和用处"></a>1.理解和用处</h4><p>理解：父类的（<strong>继承性提到superclass说的就是父类</strong>）</p><p>用处：可以用来调用：属性、方法、构造器</p><p><strong>与this类似，都用来区分相同名字不同内涵的代码</strong></p><p>this（形参列表）：本类重载的其它构造器（不能自己调自己）</p><p>super（形参列表）：调用父类中指定的构造器</p><h4 id="2-super的使用"><a href="#2-super的使用" class="headerlink" title="2.super的使用"></a>2.super的使用</h4><ol><li><p>我们可以在子类的方法或构造器中。通过使用 <strong>“super.属性”或“super .方法 ”</strong>的方式显式调用父类中声明的属性或方法。但是，通常情况下，我们习惯省略super.</p></li><li><p>特殊情况：当子类和父类中定义了<strong>同名的属性</strong>时，我们想要在子类中调用父类中声明的属性，则必须显式的使用 “super.属性” 的方式，表明调用的是父类中声明的属性</p></li><li><p>特殊情况：当子类<strong>重写了父类中的方法</strong>以后，我们想在子类的方法中调用父类中被重写的方法时，则必须显式的使用“super .方法 ”的方式，表明调用的是父类中被重写的方法</p><p>(2)(3) 代码演示</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span>&#123;   <span class="comment">//父类</span></span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">int</span> id；</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//吃饭</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span>&#123;          子类</span><br><span class="line">    String id ;</span><br><span class="line">    id = <span class="string">&quot;23456&quot;</span>;   <span class="comment">//这表示的是子类的id</span></span><br><span class="line">    <span class="built_in">super</span>.id = <span class="number">23</span>;  <span class="comment">//这是父类中声明的id</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//吃席</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">walk</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//走十公里；</span></span><br><span class="line">        eat();<span class="comment">//表明的是子类已经重写过的  </span></span><br><span class="line">        <span class="built_in">super</span>.eat( ); <span class="comment">// 表明是父类中的</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-super-调用构造器"><a href="#3-super-调用构造器" class="headerlink" title="3.super 调用构造器"></a>3.super 调用构造器</h4><ol><li><p>我们可以在子类的构造器中显式的使用 “super(形参列表)”的方式，调用父类中声明的指定的构造器</p></li><li><p>“super(形参列表)”的使用，必须声明在子类<strong>构造器的首行</strong></p></li><li><p>我们在类的构造器中，针对与 “this(形参列表)”或 “super(形参列表)”<strong>只能二选一</strong></p></li><li><p>在构造器的首行，<strong>没有显式的声明</strong> “this(形参列表)”或 “super(形参列表)”则<strong>默认用的是父类中空参的构造器</strong></p></li><li><p>在类的多个构造器中，<strong>至少有一个类的构造器中使用了 “super(形参列表)”</strong>，调用父类中的构造器</p></li><li><p>总结(1)(4)(5):</p><p><strong>子类必须在多个构造器中调用至少调用一次父类的构造器“super(形参列表)”</strong>（5）</p><p>所有类父类都是Object类</p><p><strong>每个构造器中都默认有super（），来调用父类的构造器空参构造器(4)</strong></p><p><strong>如果程序经过修改：父类使用带参构造器，则系统不在提供空参构造器，那么子类就得在构造器中调用与父类构造器匹配的super(形参列表)   (1)</strong></p></li></ol><h4 id="4-子类对象实例化的全过程"><a href="#4-子类对象实例化的全过程" class="headerlink" title="4.子类对象实例化的全过程"></a>4.子类对象实例化的全过程</h4><ol><li><p>从结果上来看（继承性）</p><p>子类继承父类以后，就获取了父类中声明的属性或方法</p><p>创建子类对象，在堆空间中，就会加载所有父类中声明的属性</p></li><li><p>从过程上来看</p><p>​    当我们通过子类的构造器创建子类对象时，我们一定会直接或间接的调用其父类的构造器，进而调用父类的父类的构造器，直到调用了java.lang.Object 类中空参的构造器为止。正因为加载过所有的父类的结构，所以才可以看到内存中有父类中的结构，子类对象才可以考虑进行调用</p></li><li><p>明确：虽然创建子类对象时，调用了父类的构造器，但是自始至终就创建过一个对象，即为new的子类对象</p></li></ol><h3 id="5-4面向对象特征之三：多态性"><a href="#5-4面向对象特征之三：多态性" class="headerlink" title="5.4面向对象特征之三：多态性"></a>5.4面向对象特征之三：多态性</h3><h4 id="1-理解"><a href="#1-理解" class="headerlink" title="1.理解"></a>1.理解</h4><ol><li><p>可以理解为一个事物的多种形态</p></li><li><p>对象的多态性：父类的引用指向子类对象，(或子类的对象赋给父类的引用)</p><p>Person  p1 &#x3D;  new Student();  &#x2F;&#x2F;person父类，student子类</p></li></ol><p><strong>多态的使用前提</strong></p><ol><li>有，类的继承关系</li><li>有，方法的重写</li></ol><h4 id="2-虚拟方法调用："><a href="#2-虚拟方法调用：" class="headerlink" title="2.虚拟方法调用："></a>2.虚拟方法调用：</h4><p>有了对象的多态性以后，我们在编译期，只能调用父类中声明的方法，但是在运行期，我们<strong>实际执行的是子类重写父类的方法</strong></p><p>总结：编译看左边，运行看右边</p><p>Person  p1 &#x3D;  new Student();  &#x2F;&#x2F;person父类，student子类</p><p>举例一：</p><p>假设Animal动物是所有动物的父类（比如 Dog 、Fish…)</p><p>他们是继承关系，且eat()  和  shuot () 都经过重写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Animal</span>  <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>() ;  <span class="comment">// 虚拟方法调用   编译看左边，运行看右边</span></span><br><span class="line">func(test) ;                         <span class="comment">//编译期，test是Animal类型，满足方法形参</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span>  <span class="title function_">func</span> <span class="params">(Animal  animal)</span>&#123;</span><br><span class="line">       animal.eat();                   <span class="comment">//运行时，实际执行的是已经重写的方法</span></span><br><span class="line">       animal.shout();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>总结：方法形参写父类，利用多态性（虚拟方法调用）任意声明一个子类都可以满足此方法——多态性的好处</p><p>举例二：</p><p>public  void  method(Object  obj){ &#x2F;&#x2F;Object类是任意类的父类</p><p>利用虚拟调用Object  ob &#x3D; new  任意类（）；都可以调用此方法</p><h4 id="3-使用说明"><a href="#3-使用说明" class="headerlink" title="3.使用说明"></a>3.使用说明</h4><p>对象的多态性，只适用于方法，不适用于属性（编译和运行都看左边）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span>  <span class="variable">p1</span> <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">Student</span>();  <span class="comment">//person父类，student子类</span></span><br></pre></td></tr></table></figure><h4 id="4-多态性的转型"><a href="#4-多态性的转型" class="headerlink" title="4.多态性的转型"></a>4.多态性的转型</h4><h5 id="1-向上转型：即为多态"><a href="#1-向上转型：即为多态" class="headerlink" title="1.向上转型：即为多态"></a>1.向上转型：即为多态</h5><p>将 Person p1 &#x3D; new Student（）;</p><p>声明用父类 ，new用子类  </p><p>编译时认为 p1 是Person类的，所以只能调用Person类中声明的属性和方法</p><p>实际运行时是执行子类重写父类的方法</p><p>（不包括属性）</p><h5 id="2-向下转型：父类–-gt-子类"><a href="#2-向下转型：父类–-gt-子类" class="headerlink" title="2.向下转型：父类–&gt;子类"></a>2.向下转型：父类–&gt;子类</h5><p><strong>需求</strong>：为了在使用多态虚拟方法调用后，<strong>还能使用子类特有的属性和方法</strong></p><p>操作：使用强制类型转换符</p><p>Person p1 &#x3D; new Man（）;</p><p>Man  m1  &#x3D;   （Man）p1 ;</p><p>此时 m1 是Man类型</p><p>出现问题：使用强转时，可能出现ClassCastException的异常</p><p>Woman  w1 &#x3D; new  (Woman) p2 ;</p><p>此时编译不报错，但是运行报错</p><p>虽然他们父类都是Person，但是不能够操作</p><p>解决问题：使用instanceof关键字</p><p><strong>a  instanceof   A</strong> :判断对象a(变量名) 是否是A类(类型)的实例。如果是，返回true。如果不是，返回false。</p><p>使用前提：</p><ol><li><p>要求两个类必须是必须有子父类的关系，否则编译错误。</p></li><li><p>：e  instanceof  a </p><p>a  只能是  e  的父类 或者 是 e</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">if</span>(p2  <span class="keyword">instanceof</span>  Woman) &#123;</span><br><span class="line"><span class="type">Woman</span>  <span class="variable">w1</span> <span class="operator">=</span> (Woman )p2;</span><br><span class="line">w1.goShopping();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(p2  <span class="keyword">instanceof</span>  Man) &#123;</span><br><span class="line"><span class="type">Man</span>  <span class="variable">w1</span> <span class="operator">=</span> (Man)p2;</span><br><span class="line">w1.earnMoney();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>练习：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span>  <span class="variable">p3</span>  <span class="operator">=</span> <span class="keyword">new</span>  <span class="title class_">Woman</span>();</span><br><span class="line"><span class="type">Object</span>  <span class="variable">obj</span> <span class="operator">=</span>  <span class="keyword">new</span>  <span class="title class_">Woman</span>();</span><br><span class="line"><span class="type">Woman</span>  <span class="variable">w1</span> <span class="operator">=</span> (Woman) p3; 编译运行都通过</span><br><span class="line"><span class="type">Man</span>  <span class="variable">m1</span>  <span class="operator">=</span>  (Man) p3 ;  编译通过，运行不通过</span><br><span class="line"><span class="type">Person</span>  <span class="variable">p</span>   <span class="operator">=</span>   (Person)obj ;编译运行都通过</span><br></pre></td></tr></table></figure><h4 id="5-小练习"><a href="#5-小练习" class="headerlink" title="5.小练习"></a>5.小练习</h4><p>Base 是父类 ，其中有属性 count &#x3D;10 和方法 display() —调用会输出count</p><p>Sub 是子类 重写了count &#x3D;20 ，也重写了display，调用会输出count</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Sub</span>  <span class="variable">s</span>  <span class="operator">=</span>  <span class="keyword">new</span>  <span class="title class_">Sub</span> ();</span><br><span class="line">s.display(); <span class="comment">//20</span></span><br><span class="line"></span><br><span class="line"><span class="type">Base</span> <span class="variable">b</span> <span class="operator">=</span> s ;  <span class="comment">// 多态性，这时b是直接得到s的地址</span></span><br><span class="line">System.out.println( b ==s）; <span class="comment">//地址一样返回true</span></span><br><span class="line">b.count <span class="comment">//输出10  ，多态不适用属性</span></span><br><span class="line">b.display(); <span class="comment">//输出20   适用于方法</span></span><br></pre></td></tr></table></figure><h3 id="5-5-Object类使用"><a href="#5-5-Object类使用" class="headerlink" title="5.5 Object类使用"></a>5.5 Object类使用</h3><h4 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h4><p>java.lang.Object 类</p><ol><li><p>Object类是所有Java类的跟父类（想象类构成的树，它为根节点）</p></li><li><p>如果在类的声明中为使用extends 关键字指明其父类，则默认父类为java.lang.Object 类</p></li><li><p>Object 类的功能（属性、方法）就具有通用性</p><p>属性：无</p><p>方法：equals ()  &#x2F;   toString()   &#x2F;    getClass()  &#x2F;  hashCode()  &#x2F;  clone() &#x2F; finalize()  &#x2F;  wait()  、 notify()、notifyAll()</p></li><li><p>Object类只声明了一个空参构造器</p></li><li><p>补充：数组也是可以理解为Object类的子类，其可以调用Object类中声明的方法 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="type">int</span>[ ]  arr  =  <span class="keyword">new</span>  <span class="title class_">int</span>[ ]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">System.out.println(arr.toString()); </span><br><span class="line">System.out.println(arr);</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>两者输出都是该数组的地址</p></blockquote><h4 id="2-equals-和-x3D-x3D"><a href="#2-equals-和-x3D-x3D" class="headerlink" title="2.equals() 和 &#x3D; &#x3D;"></a>2.equals() 和 &#x3D; &#x3D;</h4><h5 id="1-x3D-x3D-运算符"><a href="#1-x3D-x3D-运算符" class="headerlink" title="1.&#x3D;&#x3D;运算符"></a>1.&#x3D;&#x3D;运算符</h5><ol><li><p>可以使用在基本数据类型变量和引用数据类型变量中</p></li><li><p>如果比较的是基本数据类型：比较两个变量保存的数据是否相等（不一定类型相同，但会自动类型提升）</p></li><li><p>如果比较的是引用数据类型变量：比较哦两个对象的地址值是否相同。即两个引用是否指向同一个对象实体</p></li><li><p>补充：使用 &#x3D;&#x3D;  符号时，必须保证左右两边的变量类型一致</p></li><li><p>特别关于String 类型</p><p>String类型赋值是放在常量池中，不像以往说的放在堆空间中，它有复用性，发现有相同的字符就只调用相同字符的地址赋给它</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span>  <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;BB&quot;</span> ;<span class="comment">//此类声明可不写new</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span>  <span class="operator">=</span> <span class="string">&quot;BB&quot;</span> ; </span><br><span class="line">System.out.println(s1==s2) ; <span class="comment">//ture</span></span><br></pre></td></tr></table></figure></li></ol><h5 id="2-equals（）"><a href="#2-equals（）" class="headerlink" title="2.equals（）"></a>2.equals（）</h5><ol><li><p>是一个方法，而非运算符</p></li><li><p>只能使用于引用数据类型</p></li><li><p>Object 类中 equals() 的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span>  <span class="title function_">equals</span><span class="params">(Object  obj)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="built_in">this</span> ==obj) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：Object类中定义的equals() 和 &#x3D;&#x3D;</p><p>的作用是相同的 ：</p><p>都是比较两个对象的地址值是否相同。即两个引用是否指向同一个对象实体</p></li><li><p>类似String 、Date、File 、包装类等都重写了Object类中equals()方法。</p><p>重写以后，比较的不是两个引用的地址是否相同，而是根据问题所需比较两个对象的”实体内容“ 是否相同</p><p>比如：首先是不是一个类声明的，其中想要比较的属性是相等</p></li><li><p>通常情况下，我们自定义的类如果使用equals() 的话，也通常是比较两个对象的“实体内容” 是否相同。 那么我们就需要堆Object类中的equals() 进行重写</p><p>重写的原则：比较两个对象的实体内容是否相同</p></li><li><p>补充：自己写容易出错，开发中都是自动生成的</p></li></ol><h4 id="3-toString-使用"><a href="#3-toString-使用" class="headerlink" title="3.toString() 使用"></a>3.toString() 使用</h4><ol><li><p>当我们输出一个对象的引用时，实际上就是调用当前对象的toString()</p></li><li><p>Object类中toString() 的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> 返回的是类的名字及地址</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>类似String 、Date、File 、包装类等都重写了Object类中toString()方法。</p><p>我们想要调用这个方法来输出时，返回的是我们最想看到的结构，所以都会考虑重写</p></li><li><p>手动实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span>&#123;</span><br><span class="line">reutrn  <span class="string">&quot;name=&quot;</span>+name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5.小问题</p><p>（1）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span>  <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">System.out.println(p1);</span><br><span class="line">System.ou.println(p1.toString());</span><br><span class="line"><span class="comment">//二者是一样的结果</span></span><br><span class="line"><span class="comment">//前者，最后还是会去调用toString</span></span><br></pre></td></tr></table></figure><p>（2）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span>  <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot; a b c&quot;</span> ;</span><br><span class="line">System.out.println(s);<span class="comment">//输出结果一样</span></span><br><span class="line">System.ou.println(p1.toString());</span><br></pre></td></tr></table></figure><p>（3）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span>  <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot; a b c&quot;</span> ;</span><br><span class="line">    s   =   <span class="literal">null</span>;</span><br><span class="line">System.out.println(s);</span><br><span class="line">System.ou.println(p1.toString());</span><br><span class="line"><span class="comment">//前者输出null，后者不输出，出现指针异常NullPointerException</span></span><br><span class="line"><span class="comment">//由于前者最后还是会去调用toString()</span></span><br><span class="line"><span class="comment">//但是途中有保护机制</span></span><br><span class="line"><span class="keyword">if</span>(s==<span class="literal">null</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;null&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>补充：自己写容易出错，开发中都是自动生成的</p></li></ol><h3 id="5-6-单元测试"><a href="#5-6-单元测试" class="headerlink" title="5.6 单元测试"></a>5.6 单元测试</h3><p>Java中的JUnit单元测试</p><ol><li><p>创建Java类，进行单元测试</p><p>此时的Java类要求是public的，并且此类提供公共的无参构造器</p></li><li><p>此单元测试方法上需要声明注释：@Test，将鼠标覆盖注释，点击出现的超链接，系统会自动为加入JUnit4和导入该类</p></li><li><p>此类中声明单元测试的方法</p><p>此时要求方法的权限是public，没有返回值，没有形参</p></li><li><p>声明好单元测试方法以后，就可以在方法体内测试相关的代码</p></li><li><p>写完代码以后，双击单元测试方法名，右键 run  as  – –JUnit Test</p></li><li><p>说明：</p><p>如果执行结果没有任何异常：绿条</p><p>执行结果出现异常：红条</p></li></ol><h3 id="5-7-包装类的使用"><a href="#5-7-包装类的使用" class="headerlink" title="5.7 包装类的使用"></a>5.7 包装类的使用</h3><h4 id="1-理解：-1"><a href="#1-理解：-1" class="headerlink" title="1.理解："></a>1.理解：</h4><p>针对八种基本数据类型定义的引用类型—-包装类（封装类）</p><p>有了类的特点，就可以调用类中的方法，Java才是真正的面向对象</p><h4 id="2-今昔对比"><a href="#2-今昔对比" class="headerlink" title="2.今昔对比"></a>2.今昔对比</h4><p>基本数据类型： byte  &#x2F;  short &#x2F;  int  &#x2F;  long &#x2F;  float &#x2F;  double  &#x2F;  boolean  &#x2F;  char</p><p>包装类： <strong>B</strong>yte  &#x2F;  <strong>S</strong>hort &#x2F;  Integer  &#x2F;  <strong>L</strong>ong &#x2F;  <strong>F</strong>loat &#x2F;  <strong>D</strong>ouble  &#x2F;  <strong>B</strong>oolean  &#x2F;  Character</p><p>除了 Boolean  &#x2F;  Character  其他的父类都是Number</p><h4 id="3-一般操作—1"><a href="#3-一般操作—1" class="headerlink" title="3.一般操作—1"></a>3.一般操作—1</h4><p>基本数据类型—&gt;包装类调用包装类的构造器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>  <span class="variable">p1</span>  <span class="operator">=</span>  <span class="number">10</span></span><br><span class="line"><span class="type">Itnteger</span>  <span class="variable">in1</span>  <span class="operator">=</span>  <span class="keyword">new</span>  <span class="title class_">Integer</span>(p1);</span><br><span class="line"><span class="comment">//或Itnteger  in1  =  new  Integer(10);</span></span><br><span class="line">System.out.println(in1.toString());<span class="comment">//10</span></span><br><span class="line">System.out.println(in1); <span class="comment">//这样是一样的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//可以从String中抽离数字，的那是也只能是纯数字</span></span><br><span class="line"><span class="type">Itnteger</span>  <span class="variable">in1</span>  <span class="operator">=</span>  <span class="keyword">new</span>  <span class="title class_">Integer</span>(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">System.out.println(in1.toString());<span class="comment">//123</span></span><br><span class="line"><span class="type">Itnteger</span>  <span class="variable">in1</span>  <span class="operator">=</span>  <span class="keyword">new</span>  <span class="title class_">Integer</span>(<span class="string">&quot;123abc&quot;</span>);</span><br><span class="line">System.out.println(in1.toString());<span class="comment">//这样则会报错</span></span><br><span class="line"></span><br><span class="line"><span class="type">Float</span>  <span class="variable">f1</span>  <span class="operator">=</span> <span class="keyword">new</span>  <span class="title class_">Float</span>(<span class="number">12.3f</span>);</span><br><span class="line"><span class="type">Float</span> <span class="variable">f2</span> <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">Float</span>(<span class="string">&quot;12.3&quot;</span>);<span class="comment">//两者一样</span></span><br><span class="line"></span><br><span class="line"><span class="type">Boolean</span>  <span class="variable">b1</span> <span class="operator">=</span> <span class="keyword">new</span>  <span class="title class_">Boolean</span>(<span class="literal">true</span>);</span><br><span class="line"><span class="type">Boolean</span>  <span class="variable">b2</span> <span class="operator">=</span> <span class="keyword">new</span>  <span class="title class_">Boolean</span>(<span class="string">&quot;true&quot;</span>);</span><br><span class="line"><span class="comment">//在双引号内不区分大小写，如有多余的字符，返回的也是false</span></span><br></pre></td></tr></table></figure><h4 id="4-一般操作–2"><a href="#4-一般操作–2" class="headerlink" title="4.一般操作–2"></a>4.一般操作–2</h4><p>包装类—&gt;基本数据类型：调用包装类Xxx的xxxValue()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Itnteger</span>  <span class="variable">in1</span>  <span class="operator">=</span>  <span class="keyword">new</span>  <span class="title class_">Integer</span>(<span class="number">10</span>);</span><br><span class="line"><span class="type">int</span>  <span class="variable">i1</span>  <span class="operator">=</span>  in1.intValue();</span><br><span class="line"></span><br><span class="line"><span class="type">Float</span>  <span class="variable">f1</span>  <span class="operator">=</span> <span class="keyword">new</span>  <span class="title class_">Float</span>(<span class="number">12.3f</span>);</span><br><span class="line"><span class="type">float</span>   <span class="variable">f2</span>  <span class="operator">=</span>  f1.floatValue();</span><br><span class="line"></span><br><span class="line"><span class="type">Boolean</span>  <span class="variable">b1</span> <span class="operator">=</span> <span class="keyword">new</span>  <span class="title class_">Boolean</span>(<span class="literal">true</span>);</span><br><span class="line"><span class="type">boolean</span>  <span class="variable">b2</span> <span class="operator">=</span> b1.booleanValue();</span><br></pre></td></tr></table></figure><h4 id="5-便捷操作—-1"><a href="#5-便捷操作—-1" class="headerlink" title="5.便捷操作—-1"></a>5.便捷操作—-1</h4><p>基本数据类型—&gt;包装类</p><p>自动装箱</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>  <span class="variable">num1</span>  <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">Integer</span>  <span class="variable">in1</span>  <span class="operator">=</span>  num2  ;</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span>  <span class="variable">b1</span>  <span class="operator">=</span>   <span class="literal">true</span>  ;</span><br><span class="line"><span class="type">Boolean</span> <span class="variable">b2</span>  <span class="operator">=</span>   b1  ;</span><br><span class="line"></span><br><span class="line"><span class="type">Float</span>  <span class="variable">f1</span>  <span class="operator">=</span> <span class="number">12.3</span> ;</span><br></pre></td></tr></table></figure><blockquote><p>不用new了，就可以直接使用</p></blockquote><h4 id="6包装类和基本数据类型比较问题"><a href="#6包装类和基本数据类型比较问题" class="headerlink" title="6包装类和基本数据类型比较问题"></a>6包装类和基本数据类型比较问题</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span>  <span class="variable">i</span>   <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>);</span><br><span class="line"><span class="type">Integer</span>  <span class="variable">j</span>  <span class="operator">=</span> newInteger(<span class="number">1</span>);</span><br><span class="line">System.out.println(i == j);</span><br><span class="line"><span class="comment">//false 比的是地址</span></span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span>  <span class="variable">m</span> <span class="operator">=</span>  <span class="number">1</span> ;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">n</span> <span class="operator">=</span>  <span class="number">1</span> ;</span><br><span class="line">System.out.println(m == n);</span><br><span class="line"><span class="comment">//ture  地址一样</span></span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span>  <span class="variable">x</span> <span class="operator">=</span>  <span class="number">128</span> ;</span><br><span class="line"><span class="type">Integer</span>  <span class="variable">y</span> <span class="operator">=</span>  <span class="number">128</span> ;</span><br><span class="line">System.out.println(x == y);</span><br><span class="line"><span class="comment">//false 地址不一样</span></span><br></pre></td></tr></table></figure><blockquote><p>1、<strong>基本型和基本型封装型</strong>进行<strong>“&#x3D;&#x3D;”运算符的比较</strong>，<strong>基本型封装型</strong>将会<strong>自动拆箱</strong>变为<strong>基本型</strong>后再<strong>进行比较</strong>，因此Integer(0)会自动拆箱为int类型再进行比较，显然返回true；<br>2、<strong>两个Integer类型</strong>进行<strong>“&#x3D;&#x3D;”比较</strong>，如果其值在-128至127，那么返回true，否则返回false, 这跟Integer.valueOf()的缓冲对象有关，这里不进行赘述。<br>3、<strong>两个基本型的封装型进行equals()比较</strong>，首先equals()会比较类型，如果类型相同，则继续比较值，如果值也相同，返回true<br>4、基本型封装类型调用equals(),但是参数是基本类型，这时候，先会进行自动装箱，基本型转换为其封装类型，再进行3中的比较。</p><p>解释：new 过的空间地址不一样，Integer中存在数组存放使用频率最大的数  -128 ~~ 127 之间，在这区间内的数可以使用的是相同的地址</p><p>超过此范围，才会自动装箱给你new新空间来存放128</p></blockquote><h4 id="7-便捷操作—2"><a href="#7-便捷操作—2" class="headerlink" title="7.便捷操作—2"></a>7.便捷操作—2</h4><p>包装类- —&gt;基本数据类型</p><p>自动拆箱：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span>  <span class="variable">in1</span> <span class="operator">=</span> <span class="number">10</span> ; <span class="comment">//自动装箱</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>  <span class="variable">num1</span> <span class="operator">=</span> in1 ; <span class="comment">//自动拆箱</span></span><br></pre></td></tr></table></figure><h4 id="8-第三者String—1"><a href="#8-第三者String—1" class="headerlink" title="8.第三者String—1"></a>8.第三者String—1</h4><p>基本数据类型、包装类–&gt;String类型.</p><p>调用String重载的valueOf(Xxx  xxx)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">num1</span>  <span class="operator">=</span> <span class="number">10</span> ;</span><br><span class="line"><span class="type">Integer</span>  <span class="variable">num2</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式一：</span></span><br><span class="line"><span class="type">String</span>  <span class="variable">str1</span> <span class="operator">=</span> num1 +<span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="type">String</span>  <span class="variable">str2</span>  <span class="operator">=</span> num2 +<span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式二：</span></span><br><span class="line"><span class="type">String</span>  <span class="variable">str1</span> <span class="operator">=</span> String . valueOf(num1)；</span><br><span class="line"><span class="type">String</span>  <span class="variable">str2</span> <span class="operator">=</span> String . valueOf(num2)；</span><br></pre></td></tr></table></figure><h4 id="9-第三者String-–2"><a href="#9-第三者String-–2" class="headerlink" title="9.第三者String –2"></a>9.第三者String –2</h4><p>String类型—&gt;基本数据类型、包装类.</p><p>调用包装类的parseXxx(String   s  )</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span>  <span class="variable">str1</span>  <span class="operator">=</span>  <span class="string">&quot;123&quot;</span>;</span><br><span class="line"><span class="type">int</span>  <span class="variable">num1</span> <span class="operator">=</span> Integer . parseInt(str1)  ;</span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span>  <span class="variable">num2</span> <span class="operator">=</span> Integer . parseInt(str1)  ;</span><br></pre></td></tr></table></figure><h2 id="6-面向对象（下）"><a href="#6-面向对象（下）" class="headerlink" title="6. 面向对象（下）"></a>6. 面向对象（下）</h2><h3 id="6-1关键字：static"><a href="#6-1关键字：static" class="headerlink" title="6.1关键字：static"></a>6.1关键字：static</h3><h4 id="1-介绍："><a href="#1-介绍：" class="headerlink" title="1.介绍："></a>1.介绍：</h4><p>static：静态的</p><p>static可以用来修饰：属性、方法、代码块、内部类</p><h4 id="2-修饰属性："><a href="#2-修饰属性：" class="headerlink" title="2.修饰属性："></a>2.修饰属性：</h4><p>static  String  nation ;     静态变量  （或类变量）</p><ol><li><p>属性：按是否使用static修饰，分为：修饰属性 vs 非静态属性（实例变量）</p></li><li><p>实例变量</p><p>我们创建了类的多个对象，每个对象都独立的拥有一套类中的非静态属性。当<strong>修改其中一个对象中的非静态属性时，不会导致其中对象中同样的属性值的修改</strong></p></li><li><p>静态变量</p><p>我们创建了类的多个对象，多个对象共享同一个静态变量。当<strong>通过该某一个对象修改静态变量时，会导致其他对象调用此静态变量时，是修改过了的</strong></p></li><li><p>修饰属性的其他说明</p><ol><li><p>静态变量随这类的加载而加载(在方法区的静态域中)。可以通过 “ 类 . 静态变量 ” 的方式进行调用</p></li><li><p>静态变量的加载要早于对象的创建</p></li><li><p>由于类只会加载一次，则静态变量在内存汇总也只会存在一份：存在方法区的静态域中</p></li><li><p>类：可以直接调用类变量（静态变量），不能调用实例变量</p></li></ol><p>   对象：可以直接调用类变量（静态变量），也可以调用实例变量</p><p>   <strong>举例以上：</strong></p>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">   Person.nation  =  <span class="string">&quot;中国华人民共和国&quot;</span> ; </span><br><span class="line">   <span class="comment">//可以直接调用也可以改 </span></span><br><span class="line">   Person.name <span class="comment">//错，不能调用非静态的</span></span><br><span class="line">   <span class="type">Person</span>  <span class="variable">p1</span>  <span class="operator">=</span>  <span class="keyword">new</span>  <span class="title class_">Person</span>();</span><br><span class="line">   p1.nation  =  <span class="string">&quot;China&quot;</span> ;</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line"><span class="comment">//造完对象后可以直接调也可以改</span></span><br><span class="line">   <span class="type">Person</span>  <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">p2 . nation = <span class="string">&quot;CHN&quot;</span> ;</span><br><span class="line">   <span class="comment">//改完以后p1.nation 也是CHN</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="type">String</span>  <span class="variable">nation</span> <span class="operator">=</span> <span class="string">&quot;中国&quot;</span> ;</span><br><span class="line">   String  name ;</span><br><span class="line"><span class="type">int</span>   age ;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li><p>类变量内存解析</p></li></ol><p><img src="/2022/09/28/%E5%B0%9A%E7%A1%85%E8%B0%B7java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/img%5CSnipaste_2022-01-16_12-18-48.png" alt="Snipaste_2022-01-16_12-18-48"></p><h4 id="3-修饰方法"><a href="#3-修饰方法" class="headerlink" title="3.修饰方法"></a>3.修饰方法</h4><p>静态方法</p><ol><li><p>随着类的加载而加载，可以通过 “ 类 . 静态方法” 的方式进行调用</p></li><li><p>补充：如果在本类中调用本类的静态的属性或方法可以  nation 或Person . nation    , walk() 或  Person . walk()</p><p>通常会省略类名</p></li><li><p><strong>静态方法中，只能调用静态的方法或属性</strong></p><p><strong>要想调用非静态的，只能在本方法内创建类的对象实例，进行间接调用</strong></p></li><li><p>非静态的方法中，既可以调用非静态的方法或属性，也可以调用静态的方法或属性</p></li><li><p>实例化子类对象时，涉及到父类、子类中（静态代码块、非静态代码块、构造器–也是此顺序）的加载顺序</p><p>由父及子，静态先行</p><p>代码</p></li><li><p>static 注意点</p><ol><li><p>在静态方法内，不能使用this关键字 、super关键字</p></li><li><p>关于静态属性和静态方法的使用，大家都从生命周期的角度去解释</p></li><li><p>所谓“生命周期”</p><p>首先程序先加载类，而静态就是跟随了类的加载。</p><p>其次造对象，才有非静态的（属性或方法）</p><p>其中可能一些对象执行程序结束被回收，而静态的始终还在</p><p>最后全部程序结束，静态的才被回收</p><p>就此看来，在一开始类就可以调用静态的属性或方法，当然这也规划了类不能调用非静态的属性或方法。</p><p>对象是后出现的，所以其可以调用非静态的属性或方法</p></li></ol></li><li><p>开发中应用</p><ol><li><p>开发中，如何确定一个属性是否声明为static的？</p><p>属性是可以被多个所共享的，不会随者对象的不同而不同的</p><p>类中的常量也常常声明为static  比如Math.PI</p></li><li><p>开发中，如何确定一个方法是否要声明为static的</p><p>操作（调用）静态属性的方法，通常也是设置为静态的</p><p>工具类中的方法，习惯上声明为static 的。比如：Math、Arrays 、Collections</p><p>都是大家通用的操作，不需要在一一造对象的</p></li><li><p>小举例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>  <span class="type">int</span>  id  ；</span><br><span class="line"><span class="keyword">private</span>  <span class="keyword">static</span>  <span class="type">int</span>  <span class="variable">inti</span> <span class="operator">=</span> <span class="number">1001</span>;<span class="comment">//编号</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Circle</span><span class="params">()</span>&#123;</span><br><span class="line">id  =  init ++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ol><h4 id="4-单例设计模式"><a href="#4-单例设计模式" class="headerlink" title="4.单例设计模式"></a>4.单例设计模式</h4><h5 id="1-理解-1"><a href="#1-理解-1" class="headerlink" title="1.理解"></a>1.理解</h5><p>设计模式是在大量的实践中总结和理论化之后优选的代码结构、编程风格、以及解决问题的思考方式。——-23种设计模式</p><p>所谓的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例</p><p>两种实现方式：</p><p>饿汉式    VS     懒汉式</p><h5 id="2-饿汉式"><a href="#2-饿汉式" class="headerlink" title="2.饿汉式"></a>2.饿汉式</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span>  <span class="title class_">Bank</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Bank</span><span class="params">()</span>&#123;   <span class="comment">//1.私有化构造器</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//2. 内部创建类的对象</span></span><br><span class="line"><span class="comment">// 4. 要求此对象必须声明为静态的</span></span><br><span class="line"><span class="keyword">private</span>  <span class="keyword">static</span>  <span class="type">Bank</span>  <span class="variable">inst</span>  <span class="operator">=</span>   <span class="keyword">new</span>  <span class="title class_">Bank</span>() ;</span><br><span class="line"><span class="comment">// 3. 提供公共的静态的方法，返回类的对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>  Bank  <span class="title function_">getInst</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> inst ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-懒汉式"><a href="#3-懒汉式" class="headerlink" title="3.懒汉式"></a>3.懒汉式</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span>  <span class="title class_">Bank</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  <span class="title function_">Bank</span><span class="params">()</span>&#123;   <span class="comment">//1.私有化构造器</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2. 声明当前类的对象，没有初始化</span></span><br><span class="line">    <span class="comment">// 4. 要求此对象必须声明为静态的</span></span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">static</span>  <span class="type">Bank</span>  <span class="variable">inst</span>  <span class="operator">=</span>   <span class="literal">null</span> ;</span><br><span class="line">    <span class="comment">// 3. 提供公共的静态的方法，返回类的当前对象对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>  Bank  <span class="title function_">getInst</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( inst == <span class="literal">null</span> )&#123;  </span><br><span class="line">        inst  =  <span class="keyword">new</span>  <span class="title class_">Bank</span>() ;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">return</span> inst ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-两种模式利弊"><a href="#4-两种模式利弊" class="headerlink" title="4.两种模式利弊"></a>4.两种模式利弊</h5><p>饿汉式：</p><p>好处：饿汉式是线程安全的</p><p>坏处：对象加载时间过长</p><p>懒汉式;</p><p>好处：延迟对象的创建</p><p>坏处：目前写法坏处：线程不安全–&gt;讲到多线程内容时，再修改</p><p>举例：你有一银行账户2000元：你同时在手机中和在ATM机中取款，这时你可能有机会同时进入并将前同时取出。</p><p>这里的懒汉式也是这个道理，两个操作同时进行，就有可能判断他们都为空null，继而创建出了两个对象</p><p>如是这样，将导致你高铁抢到的票，有三四个票是重复的</p><h5 id="5-应用场所"><a href="#5-应用场所" class="headerlink" title="5.应用场所"></a>5.应用场所</h5><p><img src="/2022/09/28/%E5%B0%9A%E7%A1%85%E8%B0%B7java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/img%5CSnipaste_2022-01-16_15-36-11.png" alt="Snipaste_2022-01-16_15-36-11"></p><h3 id="6-3-main-方法详解"><a href="#6-3-main-方法详解" class="headerlink" title="6.3 main() 方法详解"></a>6.3 main() 方法详解</h3><h4 id="1-使用说明"><a href="#1-使用说明" class="headerlink" title="1.使用说明"></a>1.使用说明</h4><ol><li>main( ) 方法作为程序的入口</li><li>main ( ) 方法也是一个普通的静态方法 </li><li>main ( ) 方法可以作为我们与控制台交互的方式</li></ol><h4 id="2-理解："><a href="#2-理解：" class="headerlink" title="2.理解："></a>2.理解：</h4><ol><li><p>格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">( String[ ]  args )</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//是一个public 公共的，静态的，返回值为空的，形参为String[]  args 和方法名叫main的一个方法</span></span><br></pre></td></tr></table></figure></li><li><p>小结：一叶知秋</p><p>public static void main( String[ ]  args ){        方法体      }</p><p>权限修饰符：private 、缺省、protected、public—封装性</p><p>修饰符：static、final、abstract、native—-可以用来修饰方法</p><p>返回值类型：无返回值、有返回值–return</p><p>方法名：“见名知意”</p><p>形参列表：重载    VS  重写（参数的值传递机制、体现对象的多态性</p><p>方法体：来体现方法的功能</p></li><li><p>注意：</p><ol><li><p>在每个类中都可以声明名字叫main的方法，在运行时，会手动区分</p></li><li><p><strong>因为是static ,所以方法内只能调用静态的属性或方法</strong></p><p><strong>要想调用非静态的，只能在本方法内创建类的对象，进行间接调用</strong></p></li><li><p>形参中的String类型的数组可以在控制台中传入一些值</p><p>右键—Run Configuration—MainDemo—Arguments</p><p>在Program arguments 中带双引号输入你想要传的数值或字符</p></li><li><p>cmd 控制台中</p><p>java  类名  。。。</p><p>在类名后带双引号输入你想要传的数值或字符</p></li></ol></li></ol><h3 id="6-4-类的结构–代码块"><a href="#6-4-类的结构–代码块" class="headerlink" title="6.4 类的结构–代码块"></a>6.4 类的结构–代码块</h3><p>或初始化块</p><h4 id="1-介绍：-1"><a href="#1-介绍：-1" class="headerlink" title="1.介绍："></a>1.介绍：</h4><ol><li><p><strong>代码块的作用：用来初始化类、对象</strong></p></li><li><p>代码块如果有修饰的话，只能使用static</p></li><li><p>分类：静态代码块 VS  非静态代码块</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//VS</span></span><br><span class="line">  &#123;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="2-静态代码块"><a href="#2-静态代码块" class="headerlink" title="2.静态代码块"></a>2.静态代码块</h4><ol><li>内部可以有输出语句</li><li><strong>随着类的加载而执行，而且只执行一次</strong></li><li><strong>作用：初始化类的信息</strong></li><li>如果一个类中定义了多个静态代码块，则按声明的先后顺序执行</li><li><strong>静态代码块的执行要优先于非静态代码块的执行</strong></li><li><strong>静态代码块内只能调用静态的属性、静态的方法，</strong>不能调用非静态的结构</li></ol><h4 id="3-非静态代码块"><a href="#3-非静态代码块" class="headerlink" title="3.非静态代码块"></a>3.非静态代码块</h4><ol><li><p>内部可以有输出语句</p></li><li><p><strong>随着对象的创建而执行</strong></p></li><li><p><strong>每创建一个对象，就执行一次非静态代码块</strong></p></li><li><p>作用：可以在创建对象时，对对象的属性等进行初始化</p></li><li><p>如果一个类中定义了多个非静态代码块，则按声明的先后顺序执行</p></li><li><p><strong>非静态代码块内可以调用静态的属性、静态的方法，或非静态的属性、非静态的方法</strong></p></li><li><p>顺序说明</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span><span class="number">1</span>; <span class="comment">//---------------A</span></span><br><span class="line">    &#123;<span class="comment">//--------------B</span></span><br><span class="line">    age =<span class="number">2</span>;</span><br><span class="line">    &#125;<span class="comment">//这两个是按先后顺序执行的结果age=2，B 和A</span></span><br><span class="line">    <span class="comment">//反过来，age=1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//static的也一样</span></span><br><span class="line">    <span class="keyword">static</span>  <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">    age  =<span class="number">2</span> ;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="4-属性可以赋值的位置"><a href="#4-属性可以赋值的位置" class="headerlink" title="4.属性可以赋值的位置"></a>4.属性可以赋值的位置</h4><ol><li>默认初始化</li><li>显式初始化、代码块初始化</li><li>构造器初始化</li><li>有了对象以后，通过 “对象 . 属性”或“对象  . 方法” 的方式，进行赋值</li></ol><p>执行先后顺序也是这个顺序，至于2 . 中，因上述顺序代码说明，他们执行是有先后顺序的，</p><h3 id="6-5-关键字：f-inal"><a href="#6-5-关键字：f-inal" class="headerlink" title="6.5 关键字：f inal"></a>6.5 关键字：f inal</h3><h4 id="1-介绍-1"><a href="#1-介绍-1" class="headerlink" title="1.介绍"></a>1.介绍</h4><p>译为：最终的             在这表：最终的形态</p><p>final 可以用来修饰的结构：类、方法、变量</p><h4 id="2-修饰一个类："><a href="#2-修饰一个类：" class="headerlink" title="2.修饰一个类："></a>2.修饰一个类：</h4><p>此类不能被其他类所继承</p><p>后面没有子类了，没有儿子了</p><p>比如：String类、System类、StringBuffer类</p><h4 id="3-修饰方法："><a href="#3-修饰方法：" class="headerlink" title="3.修饰方法："></a>3.修饰方法：</h4><p>表明此方法不可以被重写了（也是最终的形态了）</p><p>比如：Object类中getClass() ;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="keyword">static</span>  <span class="keyword">void</span>  <span class="title function_">eat</span> <span class="params">()</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-修饰变量："><a href="#4-修饰变量：" class="headerlink" title="4.修饰变量："></a>4.修饰变量：</h4><p>此时的“变量” 就称为是一个常量。(最终的形态，数据不能在被修改)</p><ol><li><p>final修饰属性：</p><p>可以考虑赋值的位置有：显式初始化、代码块中的初始化、构造器中的初始化（按优先级排的序，有了显式初始化，代码块就不能在初始化了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式一：</span></span><br><span class="line">    <span class="keyword">final</span>  <span class="type">int</span>  <span class="variable">AGE</span> <span class="operator">=</span> <span class="number">1</span> ;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式二：</span></span><br><span class="line"><span class="keyword">final</span>  <span class="type">int</span>  GG;</span><br><span class="line">&#123;</span><br><span class="line">GG=<span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式三：</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Person</span>&#123;       </span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="variable">AGE</span> <span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> AA;</span><br><span class="line">        </span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span>&#123;</span><br><span class="line">AA =<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>final 修饰局部变量：</p><p>尤其是使用final 修饰形参时，表明此形参是一个常量。当我们调用此方法时，给常量形参赋一个实参，一旦赋值以后，就只能在方法体内使用此形参，但不能进行赋值或修改该值了</p></li></ol><h4 id="5-全局变量"><a href="#5-全局变量" class="headerlink" title="5.全局变量"></a>5.全局变量</h4><p>全局变量（成员变量）：包含类属性和实例属性</p><p>static final  用来修饰属性：全局变量</p><h3 id="6-6关键字：abstract"><a href="#6-6关键字：abstract" class="headerlink" title="6.6关键字：abstract"></a>6.6关键字：abstract</h3><h4 id="1-介绍-2"><a href="#1-介绍-2" class="headerlink" title="1.介绍"></a>1.介绍</h4><p>abstract :  抽象的</p><p>abstract 可以用来修饰的结构：类、方法</p><p>此类不能实例化（不能new对象）</p><h4 id="2-修饰类"><a href="#2-修饰类" class="headerlink" title="2.修饰类"></a>2.修饰类</h4><ol><li>此类不能实例化（不能new对象）</li><li>抽象类中一定有构造器，便于子类实例化时调用（子类还是要调用父类的构造器）</li><li>开发中，都会提供抽象类的子类，让子类对象实例化，完成相关的操作。</li><li>abstract  class   类名{  }</li></ol><h4 id="3-修饰方法-1"><a href="#3-修饰方法-1" class="headerlink" title="3.修饰方法"></a>3.修饰方法</h4><ol><li><p>抽象方法只有方法的声明，没有方法体,用分号结尾</p><p>比如： public  abstract  void  eat() ;</p></li><li><p>包含抽象方法的类，一定是一个抽象类。反之，抽象类中不一定有抽象方法</p></li><li><p>子类要想实例化，需要重写父类中的所有的抽象方法</p></li><li><p>若子类没有重写父类中的所有的抽象方法，则此子类也是一个抽象类，需要加上abstract进行修饰</p></li></ol><h4 id="4-使用注意点"><a href="#4-使用注意点" class="headerlink" title="4.使用注意点"></a>4.使用注意点</h4><ol><li>abstract不能用来修饰：属性、构造器等结构</li><li>abstract 不能用来修饰私有方法、静态方法、final 的方法、final 的类</li><li>好处：有继承关系，父类为抽象类，且有抽象方法不提供实现，此抽象方法是由于每个子类公有的但是具体方法体不同，所以必须得重写。<strong>提供抽象类，就是为了提醒所有子类用时必须重写抽象方法</strong></li></ol><h4 id="5-匿名子类的对象"><a href="#5-匿名子类的对象" class="headerlink" title="5.匿名子类的对象"></a>5.匿名子类的对象</h4><ol><li><p>一般有类的匿名和不匿名、对象的匿名和不匿名</p></li><li><p>非匿名类非匿名对象： Person  p &#x3D; new  Student()</p></li><li><p>非匿名类匿名对象： new  Student()</p></li><li><p>匿名类非匿名对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假设Person类是一个抽象类 </span></span><br><span class="line"><span class="type">Person</span>  <span class="variable">p</span>  <span class="operator">=</span>  <span class="keyword">new</span>   <span class="title class_">Person</span> () &#123;</span><br><span class="line">  <span class="comment">//这里面，重写抽象类中的所有抽象方法</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">Person</span>  <span class="variable">p</span>  <span class="operator">=</span>  <span class="keyword">new</span>   <span class="title class_">Person</span> () &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span>  <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;吃饭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//此时完成了创建匿名子类非匿名对象</span></span><br><span class="line"><span class="comment">//对象名是知道的p，父类是Person(抽象类)，但是子类的类名不知道。</span></span><br><span class="line"><span class="comment">//假设有一个方法：</span></span><br><span class="line"><span class="keyword">public</span>  <span class="keyword">void</span>  <span class="title function_">method</span><span class="params">(Person  per)</span>&#123;</span><br><span class="line">per.eat();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//此时调用该方法 method (p) ;</span></span><br><span class="line"><span class="comment">//这里体现了多态，实际执行的是匿名子类中的重写的方法</span></span><br></pre></td></tr></table></figure></li><li><p>匿名类匿名对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">method(<span class="keyword">new</span>   <span class="title class_">Person</span> () &#123;</span><br><span class="line">  <span class="comment">//这里面，重写抽象类中的所有抽象方法</span></span><br><span class="line">&#125; ) ;</span><br></pre></td></tr></table></figure></li></ol><h4 id="6-模板方法的设计模式"><a href="#6-模板方法的设计模式" class="headerlink" title="6.模板方法的设计模式"></a>6.模板方法的设计模式</h4><p>多态以及abstract 的应用</p><p>抽象类体现的就是一种模板模式的设计，抽象类作为多个子类的通用模板，子类在抽象类的基础上进行扩展、改造，但子类总体上会保留抽象类的行为方式。</p><p>解决的问题： </p><p> 当功能内部一部分实现是确定的，一部分实现是不确定的。这时可以把不确定的部分暴露出去，让子类去实现。 </p><p>换句话说，在软件开发中实现一个算法时，整体步骤很固定、通用，这些步骤已经在父类中写好了。但是某些部分易变，易变部分可以抽象出来，供不同子类实现。这就是一种模板模式</p><p>代码举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Template</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">getTime</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">code();</span><br><span class="line"><span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">&quot;执行时间是：&quot;</span> + (end - start));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">code</span><span class="params">()</span>;   <span class="comment">//抽象方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubTemplate</span> <span class="keyword">extends</span> <span class="title class_">Template</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">code</span><span class="params">()</span> &#123;    <span class="comment">//重写抽象方法</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">System.out.println(i);</span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个子类想要想要计算运行时间就只需重写抽象方法即可</p><p>还有一种银行举例：抽象类中写有抽象方法和非抽象方法，抽象方法因为子类的此方法体各不相同，所以需要子类重写。</p><p>取号  干什么事    排队</p><p>取号和排队非抽象方法，干什么事是抽象方法</p><p>将这个流程封装为一个方法，当不同子类调用时，输出–干什么事–也不同</p><h3 id="6-8-interface-接口"><a href="#6-8-interface-接口" class="headerlink" title="6.8 interface 接口"></a>6.8 interface 接口</h3><h4 id="1-介绍-3"><a href="#1-介绍-3" class="headerlink" title="1.介绍"></a>1.介绍</h4><ol><li><p>接口使用interface 来定义</p></li><li><p>Java中，接口和类是并列的两个结构</p></li><li><p>不能实例化</p></li></ol><h4 id="2-定义接口"><a href="#2-定义接口" class="headerlink" title="2.定义接口"></a>2.定义接口</h4><p>定义接口中的成员</p><ol><li><p><strong>JDK 7 及以前，只能定义全局常量和抽象方法</strong><br><strong>全局常量：public  static  final</strong> </p><p>全局常量：包含类属性和实例属性</p><p><strong>抽象方法：public abstract</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">AAA</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">static</span>  <span class="keyword">final</span> <span class="type">int</span> <span class="variable">AGE</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">AGE</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">static</span>  <span class="keyword">final</span> <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">    <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();  <span class="comment">//public  static  final在接口中书写时可以省略不写</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;   &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;    &#125;  <span class="comment">//在接口中书写时可以省略不写</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>JDK 8 除了定义全局常量和抽象方法之外，还可以定义静态方法、默认方法（暂时先不考虑）</strong></p><p>  接口中不能定义构造器，意味者不能实例化</p></li></ol><h4 id="3-使用方式"><a href="#3-使用方式" class="headerlink" title="3.使用方式"></a>3.使用方式</h4><ol><li>Java开发中，接口通过让类去实现（implement）的方式来使用</li><li>如果实现类覆盖（重写）了接口中所有抽象方法，则此实现类就可以实例化</li><li>如果实现类没有覆盖接口中所有的抽象方法，则此实现类仍为一个抽象类（要么重写所有抽象方法，要么加上abstract）</li></ol><p>​              格式：假设CC为接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span>  <span class="title class_">AA</span>  <span class="keyword">implements</span> <span class="title class_">CC</span>,EE,DD&#123;   &#125;</span><br></pre></td></tr></table></figure><ol start="4"><li><p>接口可以作为声明使用，但不能够new对象(声明在类中和方法形参中)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">USB</span>  <span class="variable">usb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Flash</span>();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">(USB  usb)</span>&#123;</span><br><span class="line">    usb.start();</span><br><span class="line">    usb.stop();</span><br><span class="line">&#125;   <span class="comment">// USB是接口， Flash是实现类  ，方法内调用的实际是实现类重写的方法----类似于子父类关系--体现了多态性</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="4-体现继承性"><a href="#4-体现继承性" class="headerlink" title="4.体现继承性"></a>4.体现继承性</h4><ol><li><p>Java类中可以实现多个接口—&gt;弥补了Java单继承性的局限性</p></li><li><p>格式：        </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span>  <span class="title class_">AA</span> <span class="keyword">extends</span>  <span class="title class_">BB</span> <span class="keyword">implements</span>  <span class="title class_">CC</span>,DD,EE&#123;    &#125; </span><br></pre></td></tr></table></figure><p>AA继承了BB ，还实现了很多接口</p></li><li><p>AA得重写所有实现的接口中的抽象方法</p></li><li><p>接口与接口之间可以继承，而且还可以多继承</p></li></ol><p>​     </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">AA</span>&#123;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">BB</span>&#123;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">CC</span>  <span class="keyword">extends</span> <span class="title class_">AA</span>,BB&#123;</span><br><span class="line">    <span class="comment">//接口内东西可写可不写</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果有个EE去实现CC，得重写AA，BB，CC中所有的抽象方法</span></span><br></pre></td></tr></table></figure><h4 id="5-接口是一种规范"><a href="#5-接口是一种规范" class="headerlink" title="5.接口是一种规范"></a>5.接口是一种规范</h4><p>接口，实际上可以看做一种规范</p><p>USB接口全球同一口径、人就要会思考、鸟就会飞、鱼就会游等等</p><p>将口径、思考、飞、游，都可作为接口</p><h4 id="6-体现多态性"><a href="#6-体现多态性" class="headerlink" title="6.体现多态性"></a>6.体现多态性</h4><ol><li><p>接口指定具体使用，体现多态性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">USB</span> &#123;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span>  <span class="title class_">BB</span>  <span class="keyword">implements</span> <span class="title class_">USB</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;开始工作&quot;</span>)； &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;停止工作&quot;</span>)； &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">USBTest</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[ ]  args)</span>&#123;</span><br><span class="line">        <span class="type">USBTest</span> <span class="variable">com</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">USBTest</span>();</span><br><span class="line">        <span class="type">BB</span>  <span class="variable">bb</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BB</span>();</span><br><span class="line">        com.Computer(bb);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span>  <span class="title function_">Computer</span><span class="params">(USB  usb)</span> &#123;</span><br><span class="line">        usb.start();</span><br><span class="line">        <span class="comment">//调用其他方法进行操作</span></span><br><span class="line">        usb.stop();      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//此时体现多态性</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="7-匿名子类的对象"><a href="#7-匿名子类的对象" class="headerlink" title="7.匿名子类的对象"></a>7.匿名子类的对象</h4><ol><li><p>创建了接口的匿名实现类的非匿名对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">USB</span>  <span class="variable">p</span>  <span class="operator">=</span>  <span class="keyword">new</span>   <span class="title class_">USB</span> () &#123;</span><br><span class="line">  <span class="comment">//这里面，重写接口中的抽象方法</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">USB</span>  <span class="variable">p</span>  <span class="operator">=</span>  <span class="keyword">new</span>   <span class="title class_">USB</span> () &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span>  <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;吃饭&quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对象名是知道的p，接口名，但是实现类的类名不知道。</span></span><br><span class="line"><span class="comment">//假设有一个方法：</span></span><br><span class="line"><span class="keyword">public</span>  <span class="keyword">void</span>  <span class="title function_">method</span><span class="params">(USB  per)</span>&#123;</span><br><span class="line">per.eat();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时调用该方法 method (p) ;<br>这里体现了多态，实际执行的是匿名实现类中的重写的方法</p></li><li><p>匿名类匿名对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">method( <span class="keyword">new</span>   <span class="title class_">USB</span> () &#123;  <span class="comment">/*这里面，重写接口中的抽象方法*/</span>  &#125; ) ;</span><br></pre></td></tr></table></figure></li></ol><h4 id="8-接口实例化在说明"><a href="#8-接口实例化在说明" class="headerlink" title="8.接口实例化在说明"></a>8.接口实例化在说明</h4><p>接口到底能不能实例化？</p><p>接口不可以实例化，因为它没有构造器（它需要通过实现类进行实例化，不能new</p><p>除了，在匿名内部类可以new＋接口&#x3D;实现类，其实是接口的子类，只是名字(类名)和接口一样）类似于抽象类</p><h4 id="9-JDK-8新增"><a href="#9-JDK-8新增" class="headerlink" title="9.JDK 8新增"></a>9.JDK 8新增</h4><h5 id="1-介绍-4"><a href="#1-介绍-4" class="headerlink" title="1.介绍"></a>1.介绍</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="keyword">interface</span> <span class="title class_">CompareA</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span>&#123;      方法体    &#125; <span class="comment">//--------静态方法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123; 方法体   &#125;  <span class="comment">//--------默认方法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>  <span class="keyword">void</span>  <span class="title function_">method3</span><span class="params">()</span>&#123;      方法体     &#125;  <span class="comment">//----修饰符都为public可省略</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-使用细节："><a href="#2-使用细节：" class="headerlink" title="2.使用细节："></a>2.使用细节：</h5><ol><li><p>接口中定义的静态方法，只能通过接口来调用</p><p>CompareA . method1();</p></li><li><p>通过实现类的对象，可以调用接口中的默认方法。</p></li><li><p>如果实现类重写了接口中的默认方法，调用时，仍然调用的是重写以后的方法</p></li><li><p>如果子类（或实现类）继承的父类和实现的接口中声明了同名同参数的方法，那么子类在没有重写此方法的情况下，默认调用的是父类中同名同参数的默认方法——&gt;类优先原则（只针对于方法，属性不考虑，如果父类和接口属性重名就会报错，别重名。）</p></li><li><p>如果实现类实现的两个接口中存在同名同参数的默认方法，则必须要在实现类中进行重写。</p></li><li><p>如何咋子类（或实现类）的方法中调用父类、接口中被重写的方法</p><ol><li><p>调用自已定义的重写的方法：method3();</p></li><li><p>调用的是父类中声明的：super . method3() ;</p></li><li><p>调用接口中的默认方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CompareA . <span class="built_in">super</span> . method3() ;</span><br><span class="line"></span><br><span class="line">CompareB . <span class="built_in">super</span> . method3() ;</span><br></pre></td></tr></table></figure></li></ol></li></ol><h3 id="6-9-类的结构–内部类"><a href="#6-9-类的结构–内部类" class="headerlink" title="6.9 类的结构–内部类"></a>6.9 类的结构–内部类</h3><h4 id="1-介绍-5"><a href="#1-介绍-5" class="headerlink" title="1.介绍"></a>1.介绍</h4><ol><li>Java中允许将一个类A声明在另一个类B中，则类A结合水内部类，类B称为外部类</li><li>内部类的分类：成员内部类（静态、非静态）  VS  局部内部类（方法内、代码块内、构造器内）</li></ol><h4 id="2-成员内部"><a href="#2-成员内部" class="headerlink" title="2.成员内部"></a>2.成员内部</h4><ol><li><p>首先它是作为外部类的成员</p><ol><li>调用外部类的结构</li><li>可以被static 的修饰</li><li>可以被4种不同的修饰</li></ol></li><li><p>另外：作为一个类</p><ol><li>类内可以定义属性、方法、构造器等</li><li>可以被final 修饰，表示此类不能被继承。言外之意，不使用final，就可以被继承</li><li>可以被abstract 修饰</li></ol></li><li><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">class</span> <span class="title class_">Animal</span>&#123;   </span><br><span class="line">   </span><br><span class="line">        <span class="keyword">class</span>  <span class="title class_">Dog</span>&#123;    </span><br><span class="line">   <span class="keyword">public</span>  <span class="title function_">Dog</span><span class="params">()</span>&#123;   &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title function_">display</span><span class="params">( String  name )</span>&#123;   &#125; </span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">public</span>  <span class="keyword">static</span>  <span class="keyword">class</span>  <span class="title class_">Bird</span>&#123;       &#125;</span><br><span class="line"><span class="keyword">public</span>   <span class="keyword">final</span> <span class="keyword">class</span>  <span class="title class_">Cat</span>&#123;       &#125;</span><br><span class="line">   <span class="keyword">public</span>   <span class="keyword">abstract</span> <span class="keyword">class</span>  <span class="title class_">Cat</span>&#123;       &#125;</span><br><span class="line">   </span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### <span class="number">3.</span>关注如下的<span class="number">3</span>个问题</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 如何实例化成员内部类的对象</span><br><span class="line"></span><br><span class="line">   ```java</span><br><span class="line">   <span class="comment">//创建Dog实例（静态的成员内部类）</span></span><br><span class="line">   Person . <span class="type">Dog</span>  <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span> . Dog() ;</span><br><span class="line">   dog . show() ;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//创建Bird实例（非静态的实例成员内部类）</span></span><br><span class="line">   <span class="type">Person</span>  <span class="variable">p</span>  <span class="operator">=</span>   <span class="keyword">new</span>   <span class="title class_">Person</span>() ;</span><br><span class="line">   Person . <span class="type">Bird</span>  <span class="variable">bird</span> <span class="operator">=</span>  p . <span class="keyword">new</span> . Bird() ;</span><br><span class="line">   bird . sing();</span><br></pre></td></tr></table></figure></li><li><p>如何在成员内部类中区分调用外部类的结构</p><p>调用属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">class</span> <span class="title class_">Animal</span>&#123;    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;动物&quot;</span> ;</span><br><span class="line">   </span><br><span class="line">           <span class="keyword">class</span>  <span class="title class_">Dog</span>&#123;    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;狗&quot;</span> ;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span>  <span class="title function_">display</span><span class="params">( String  name )</span>&#123;</span><br><span class="line">   </span><br><span class="line">   System.out.println(name);  <span class="comment">//形参</span></span><br><span class="line">   System.out.println(<span class="built_in">this</span> . name);  <span class="comment">//内部类的</span></span><br><span class="line">   System.out.println(Person . <span class="built_in">this</span> . name);  <span class="comment">//外部类的</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   调用内部类和外部类方法也是如此，不重名时，可省略</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> 开发中局部内部类的使用---匿名</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line"><span class="comment">//返回一个实现了Comparable 接口的类的对象</span></span><br><span class="line"><span class="keyword">public</span> Comparable  <span class="title function_">getComparable</span><span class="params">( )</span> &#123;</span><br><span class="line"><span class="comment">//方式一：创建一个实现了Comparable接口的类：局部内部类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyComparable</span> implement Comparable &#123;</span><br><span class="line"><span class="comment">//重写接口抽象方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Object  o )</span>&#123;   方法体  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>  <span class="keyword">new</span> <span class="title class_">MyComparable</span> ;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//方式二：</span></span><br><span class="line">    <span class="keyword">return</span>  <span class="keyword">new</span> <span class="title class_">Comparable</span>( ) &#123;</span><br><span class="line"><span class="keyword">public</span>  <span class="type">int</span>  <span class="title function_">compareTo</span><span class="params">(Object  o )</span>&#123;   方法体  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>方式一：有类名，没有对象名</p><p>方式二：没有类名，没有对象名</p></blockquote><h2 id="7-异常处理"><a href="#7-异常处理" class="headerlink" title="7. 异常处理"></a>7. 异常处理</h2><h3 id="1-异常"><a href="#1-异常" class="headerlink" title="1.异常"></a>1.异常</h3><h4 id="1-异常的体系结构"><a href="#1-异常的体系结构" class="headerlink" title="1.异常的体系结构"></a>1.异常的体系结构</h4><ul><li><p>java.lang.Throwable</p><ul><li>java.lang.Error:一般不编写针对性的代码进行处理。<br>* java.lang.Exception:可以进行异常的处理</li></ul><pre><code>* **编译时异常**(checked)   * IOException      * FileNotFoundException         * ClassNotFoundException          * **运行时异常**(unchecked,RuntimeException)          * NullPointerException          * ArrayIndexOutOfBoundsException           * ClassCastException           * NumberFormatException           * InputMismatchException           * ArithmeticException</code></pre></li></ul><h4 id="2-从程序执行过程"><a href="#2-从程序执行过程" class="headerlink" title="2.从程序执行过程"></a>2.从程序执行过程</h4><p>看编译时异常和运行时异常</p><p>编译时异常：执行javac.exe命名时，可能出现的异常<br>运行时异常：执行java.exe命名时，出现的异常</p><h4 id="3-常见的异常类型"><a href="#3-常见的异常类型" class="headerlink" title="3.常见的异常类型"></a>3.常见的异常类型</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">                 <span class="comment">//******************以下是运行时异常***************************</span></span><br><span class="line"><span class="comment">//ArithmeticException</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test6</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">System.out.println(a / b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//InputMismatchException</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test5</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="type">int</span> <span class="variable">score</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">System.out.println(score);</span><br><span class="line"></span><br><span class="line">scanner.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//NumberFormatException</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;123&quot;</span>;</span><br><span class="line">str = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> Integer.parseInt(str);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ClassCastException</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> (String)obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//IndexOutOfBoundsException</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">//ArrayIndexOutOfBoundsException</span></span><br><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">System.out.println(arr[<span class="number">10</span>]);</span><br><span class="line"><span class="comment">//StringIndexOutOfBoundsException</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">System.out.println(str.charAt(<span class="number">3</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//NullPointerException</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>[] arr = <span class="literal">null</span>;</span><br><span class="line">System.out.println(arr[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">str = <span class="literal">null</span>;</span><br><span class="line">System.out.println(str.charAt(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">//******************以下是编译时异常***************************</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test7</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line"><span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> fis.read();</span><br><span class="line"><span class="keyword">while</span>(data != -<span class="number">1</span>)&#123;</span><br><span class="line">System.out.print((<span class="type">char</span>)data);</span><br><span class="line">data = fis.read();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fis.close();</span><br><span class="line"></span><br><span class="line">&#125;                       </span><br></pre></td></tr></table></figure><h3 id="2-异常处理"><a href="#2-异常处理" class="headerlink" title="2.异常处理"></a>2.异常处理</h3><h4 id="1-java异常处理的抓抛模型"><a href="#1-java异常处理的抓抛模型" class="headerlink" title="1.java异常处理的抓抛模型"></a>1.java异常处理的抓抛模型</h4><p>过程一：”抛”：程序在正常执行的过程中，一旦出现异常，就会在异常代码处生成一个对应异常类的对象。</p><ol><li>并将此对象抛出。</li><li>一旦抛出对象以后，其后的代码就不再执行。</li></ol><p>关于异常对象的产生：</p><p>① 系统自动生成的异常对象</p><p>② 手动的生成一个异常对象，并抛出（<strong>throw</strong>）</p><p>过程二：”抓”：可以理解为异常的处理方式：</p><p>① try-catch-finally  </p><p>② throws</p><h4 id="2-异常处理方式一"><a href="#2-异常处理方式一" class="headerlink" title="2.异常处理方式一"></a>2.异常处理方式一</h4><p><strong>try-catch-finally</strong></p><h5 id="1-使用说明："><a href="#1-使用说明：" class="headerlink" title="1. 使用说明："></a>1. 使用说明：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//可能出现异常的代码</span></span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">1</span> 变量名<span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理异常的方式1</span></span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">2</span> 变量名<span class="number">2</span>)&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理异常的方式2</span></span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">3</span> 变量名<span class="number">3</span>)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理异常的方式3</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">....</span><br><span class="line"></span><br><span class="line"><span class="keyword">finally</span>&#123;</span><br><span class="line"><span class="comment">//一定会执行的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <strong>代码演示：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line"><span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> fis.read();</span><br><span class="line"><span class="keyword">while</span>(data != -<span class="number">1</span>)&#123;</span><br><span class="line">System.out.print((<span class="type">char</span>)data);</span><br><span class="line">data = fis.read();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fis.close();</span><br><span class="line">&#125;<span class="keyword">catch</span>(FileNotFoundException e)&#123;</span><br><span class="line">e.printStackTrace(); <span class="comment">//输出异常</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(IOException e)&#123;   <span class="comment">//子类在它上面</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-说明及解释"><a href="#2-说明及解释" class="headerlink" title="2.说明及解释"></a>2.说明及解释</h5><p><strong>finally是可选的</strong>，可有，可没有。</p><ol><li>使用try将可能出现异常代码包装起来，在执行过程中，一旦出现异常，就会生成一个对应异常类的对象，根据此对象的类型，去catch中进行匹配</li><li><strong>一旦try中的异常对象匹配到某一个catch时，就进入catch中进行异常的处理。一旦处理完成，就跳出当前的try-catch结构（在没写finally的情况。继续执行其后的代码）</strong></li><li>catch中的异常类型如果没子父类关系，则谁声明在上，谁声明在下无所谓。</li><li>catch中的异常类型如果满足子父类关系，则要求子类一定声明在父类的上面。否则，报错</li><li><strong>常用的异常对象处理的方式： ① String  getMessage()    ② printStackTrace()</strong></li><li>在try结构中声明的变量，再出了try结构以后，就不能再被调用</li><li><strong>try-catch-finally结构可以嵌套</strong></li></ol><p>​    <strong>代码演示</strong>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testMethod</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> method();</span><br><span class="line">System.out.println(num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">System.out.println(arr[<span class="number">10</span>]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>; <span class="comment">//如果没异常，在执行这之前会执行finally</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(ArrayIndexOutOfBoundsException e)&#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span>;  <span class="comment">//在执行这之前会执行finally</span></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;我一定会被执行&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">3</span>;  <span class="comment">//到这直接退出了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-小结："><a href="#3-小结：" class="headerlink" title="3.小结："></a>3.小结：</h4><h5 id="1-如何看待代码中的编译时异常和运行时异常？"><a href="#1-如何看待代码中的编译时异常和运行时异常？" class="headerlink" title="1.如何看待代码中的编译时异常和运行时异常？"></a>1.如何看待代码中的编译时异常和运行时异常？</h5><p>体会1：使用try-catch-finally处理编译时异常，是得程序在编译时就不再报错，但是运行时仍可能报错。相当于我们使用try-catch-finally将一个编译时可能出现的异常，延迟到运行时出现。</p><p>体会2：开发中，由于运行时异常比较常见，所以我们通常就不针对运行时异常编写try-catch-finally了。针对于编译时异常，我们说一定要考虑异常的处理。</p><h5 id="2-finally的再说明："><a href="#2-finally的再说明：" class="headerlink" title="2.finally的再说明："></a>2.finally的再说明：</h5><p>1.finally是可选的</p><p>2.<strong>finally中声明的是一定会被执行的代码。即使catch中又出现异常了，try中return语句，catch中return语句等情况。</strong></p><p>3.像数据库连接、输入输出流、网络编程Socket等资源，JVM是不能自动的回收的，我们需要自己手动的进行资源的释放。此时的资源释放，就需要声明在finally中。</p><h4 id="4-面试题"><a href="#4-面试题" class="headerlink" title="4.面试题"></a>4.面试题</h4><p>final、finally、finalize三者的区别？</p><p>类似：<br>throw 和 throws<br>Collection 和 Collections<br>String 、StringBuffer、StringBuilder<br>ArrayList 、 LinkedList<br>HashMap 、LinkedHashMap<br>重写、重载</p><p>结构不相似的：<br>抽象类、接口<br>&#x3D;&#x3D; 、 equals()<br>sleep()、wait()</p><h4 id="5-异常处理方式二"><a href="#5-异常处理方式二" class="headerlink" title="5.异常处理方式二"></a>5.异常处理方式二</h4><ol><li>“throws + 异常类型”写在方法的声明处。指明此方法执行时，可能会抛出的异常类型。</li><li>一旦当方法体执行时，出现异常，仍会在异常代码处生成一个异常类的对象，此对象满足throws后异常类型时，就会被抛出。异常代码后续的代码，就不再执行！</li></ol><p><strong>代码演示：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionTest2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            method2();  <span class="comment">//抛出异常,用try-catch-finally解决</span></span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//method3();//解决后在调用也不报错</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method3</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            method2(); <span class="comment">//抛出异常,用try-catch-finally解决</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> <span class="keyword">throws</span> IOException&#123;<span class="comment">//抛出异常</span></span><br><span class="line">        method1(); <span class="comment">//method1抛出异常,如果在method2不解决可以在向上抛出</span></span><br><span class="line">                    <span class="comment">//，直到被解决才不报错</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException,IOException&#123;  <span class="comment">//可能会抛出的异常类型，抛出                                      //异常</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;hello1.txt&quot;</span>);</span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> fis.read();</span><br><span class="line">        <span class="keyword">while</span>(data != -<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.print((<span class="type">char</span>)data);</span><br><span class="line">            data = fis.read();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fis.close();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;hahaha!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-对比两种处理方式"><a href="#6-对比两种处理方式" class="headerlink" title="6.对比两种处理方式"></a><strong>6</strong>.对比两种处理方式</h4><ol><li>try-catch-finally:真正的将异常给处理掉了。</li><li>throws的方式只是将异常抛给了方法的调用者。并没真正将异常处理掉。</li></ol><h4 id="7-开发中如何选择两种处理方式？"><a href="#7-开发中如何选择两种处理方式？" class="headerlink" title="7.开发中如何选择两种处理方式？"></a>7.开发中如何选择两种处理方式？</h4><ol><li>如果父类中被重写的方法没throws方式处理异常，则子类重写的方法也不能使用throws，意味着如果子类重写的方法中异常，必须使用try-catch-finally方式处理。</li><li>执行的方法a中，先后又调用了另外的几个方法，这几个方法是递进关系执行的。我们建议这几个方法使用throws的方式进行处理。而执行的方法a可以考虑使用try-catch-finally方式进行处理。（也就是都向上抛调用上抛，最后都在一个方法内统一处理）</li></ol><h4 id="8-补充"><a href="#8-补充" class="headerlink" title="8.补充"></a>8.补充</h4><p>方法重写的规则之一：<br>子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型</p><h3 id="3-手动抛出异常对象"><a href="#3-手动抛出异常对象" class="headerlink" title="3.手动抛出异常对象"></a>3.手动抛出异常对象</h3><h4 id="1-使用说明-1"><a href="#1-使用说明-1" class="headerlink" title="1.使用说明"></a>1.使用说明</h4><p>在程序执行中，除了自动抛出异常对象的情况之外，我们还可以手动的throw一个异常类的对象。</p><h4 id="2-面试题"><a href="#2-面试题" class="headerlink" title="2.面试题"></a>2.面试题</h4><p>throw 和  throws区别：</p><ol><li>throw 表示抛出一个异常类的对象，生成异常对象的过程。声明在方法体内。</li><li>throws 属于异常处理的一种方式，声明在方法的声明处。</li></ol><h4 id="3-典型例题"><a href="#3-典型例题" class="headerlink" title="3.典型例题"></a>3.典型例题</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentTest</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">s.regist(-<span class="number">1001</span>);</span><br><span class="line">System.out.println(s);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="comment">//e.printStackTrace();</span></span><br><span class="line">System.out.println(e.getMessage());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">regist</span><span class="params">(<span class="type">int</span> id)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="keyword">if</span>(id &gt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">this</span>.id = id;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//手动抛出异常对象</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;您输入的数据非法！&quot;</span>);</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;您输入的数据非法！&quot;</span>);</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MyException</span>(<span class="string">&quot;不能输入负数&quot;</span>);</span><br><span class="line"><span class="comment">//这些提示文字最后可以通过getMassage()获取并输出</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;Student [id=&quot;</span> + id + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-自定义异常类"><a href="#4-自定义异常类" class="headerlink" title="4.自定义异常类"></a>4.自定义异常类</h3><h4 id="1-如何自定义异常类？"><a href="#1-如何自定义异常类？" class="headerlink" title="1.如何自定义异常类？"></a>1.如何自定义异常类？</h4><ol><li>继承于现的异常结构：RuntimeException 、Exception</li><li>提供全局常量：serialVersionUID（相当于一个编号，可以自己写）</li><li>提供重载的构造器</li></ol><h4 id="2-代码演示"><a href="#2-代码演示" class="headerlink" title="2.代码演示"></a>2.代码演示</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">7034897193246939L</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyException</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyException</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;项目及工具&quot;&gt;&lt;a href=&quot;#项目及工具&quot; class=&quot;headerlink&quot; title=&quot;项目及工具&quot;&gt;&lt;/a&gt;项目及工具&lt;/h1&gt;&lt;h2 id=&quot;1-eclipse&quot;&gt;&lt;a href=&quot;#1-eclipse&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Java考试</title>
    <link href="http://example.com/2022/09/27/java%E8%80%83%E8%AF%95/"/>
    <id>http://example.com/2022/09/27/java%E8%80%83%E8%AF%95/</id>
    <published>2022-09-27T09:45:41.000Z</published>
    <updated>2022-09-28T08:11:18.768Z</updated>
    
    <content type="html"><![CDATA[<p>题型：</p><ul><li>选择题40分</li><li>判断题20分</li><li>填空题20分</li><li>简答题10分</li><li>程序设计10分（设计只需写出核心代码）</li></ul><h1 id="一入门"><a href="#一入门" class="headerlink" title="一入门"></a>一入门</h1><p>1.1.1什么是Java<br>计算机语言（ComputerLanguage）是人与计算机之间通讯的语言，分成&#x3D;&#x3D;机器语言、汇编语言、高级语言&#x3D;&#x3D;三大类。</p><p>Java是一种高级计算机语言，它是由Sun公司（已被Oracle公司收购）于&#x3D;&#x3D;1995年5月推出&#x3D;&#x3D;的一种可以编写跨平台应用软件、完全面向对象的程序设计语言。</p><p>1.1.2Java语言特点</p><blockquote><p>简单易用<br>安全可靠<br>跨平合<br>面向对象性<br>支持多线程</p></blockquote><p>1.2.1什么是JDK<br>定义：JDK(JavaDevelopmentKit），是SUN公司提供的一套Java开发环境。<br>说明：JDK是整个Java的核心，其中包括Java编译器、Java运行工具、Java文档生成工具、Java打包工具等。</p><p>Java程序运行时，必须经过编译和运行两个步骤：<br>①先将后缀名为.java的源文件进行编译，生成后缀名为.class的字节码文件：<br>②然后Java虚拟机将字节码文件进行解释执行，并将结果显示出来。</p><h1 id="二、Java编程基础"><a href="#二、Java编程基础" class="headerlink" title="二、Java编程基础"></a>二、Java编程基础</h1><p>Java语言是严格<strong>区分大小写</strong>的</p><p>用加号（+）将这两个字符串拼接起来</p><p>2.1.4Java中的标识符</p><p>定义：在编程过程中，经常需要在程序中定义一些符号来标记一些名称，如包名、类名、方法名、参数名、变量名等，这些符号被称为标识符。<br>组成：标识符可以由任意顺序的大小写字母、数字、下划线（_）和美元符号（$）组成，但标识符不能以数字开头，也不能是Java中的关键字</p><p>在Java中变量的数据类型分为两种：基本数据类型和引用数据类型。</p><p>byte 8位（1个字节）<br>short 16位（2个字节）<br>int 32位（4个字节）<br>long 64位（8个字节）<br>float 32位（4个字节）<br>double 64位（8个字节）<br>char占用2个字节</p><p>\r：表示回车，将光标定位到当前行的开头，不会跳到下一行。<br>\n：表示换行，换到下一行的开头。<br>\t：表示制表符，将光标移到下一个制表符的位置，就像在文档中用Tab键一样。<br>\b：表示退格符号，就像键盘上的Backspace</p><p> \ ‘：表示单引号字符</p><p>\“ ：表示双引号字符</p><p>\ ：表示反斜杠转义字符</p><p>算术运算符</p><p>赋值运算符</p><p>比较运算符</p><p>逻辑运算符</p><p>位运算符</p><p>条件运算符</p><p>最大公约数</p><p>两个数能够同时整数的最大数字</p><p>最小公倍数</p><p>4和6的最小公倍数为12</p><p>只需要先求出最大公约数。用两个数的乘积除以最大公约数即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Scanner scan=<span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">System.out.println(<span class="string">&quot;请输入两个整数：&quot;</span>);</span><br><span class="line"><span class="type">int</span> m=scan.nextInt();</span><br><span class="line"><span class="type">int</span> n=scan.nextInt();</span><br><span class="line"><span class="type">int</span> <span class="variable">fan</span> <span class="operator">=</span> <span class="number">0</span>,x=m,y=n;</span><br><span class="line">   <span class="keyword">if</span>(m&lt;n) &#123;              <span class="comment">//始终保持m比n大，</span></span><br><span class="line">   fan=m;</span><br><span class="line">   m=n;</span><br><span class="line">   n=fan;   </span><br><span class="line">   &#125;</span><br><span class="line"><span class="keyword">while</span>(m%n!=<span class="number">0</span>) &#123;        <span class="comment">//运用辗转相除法求出最大公约数</span></span><br><span class="line">fan=m%n;</span><br><span class="line">m=n;</span><br><span class="line">    n=fan;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;最大公约数：&quot;</span>+n);</span><br><span class="line">System.out.print(<span class="string">&quot;最小公倍数：&quot;</span>+x*y/n);</span><br></pre></td></tr></table></figure><p>素数又叫质数，有无限个。质数定义为在大于1的自然数中，除了1和它本身以外不再有其他因数。</p><p>数组</p><p>数据类型  默认初始值<br>byte、 short、 int、 long —- 0</p><p>float、 double —-  0.0<br>char—一个空字符，即10000</p><p>boolean—false<br>引用数据类型—null，表示变量不引用任何对象</p><blockquote><p>二维数组的定义</p><ul><li><p>指定二维数组的长度和每个数组的元素个数。<br>int arr&#x3D; new int[3] [4]</p></li><li><p>只指定二维数组的长度，不确定每个数组的元素个数。<br>int arr&#x3D; new int[3] []</p></li><li><p>直接使用嵌套大括号“{}”，对二维数组初始化赋值。</p><p>int[][] arr&#x3D;</p></li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;题型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;选择题40分&lt;/li&gt;
&lt;li&gt;判断题20分&lt;/li&gt;
&lt;li&gt;填空题20分&lt;/li&gt;
&lt;li&gt;简答题10分&lt;/li&gt;
&lt;li&gt;程序设计10分（设计只需写出核心代码）&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;一入门&quot;&gt;&lt;a href=&quot;#一入</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Linux静态网络配置</title>
    <link href="http://example.com/2022/09/07/Linux%E9%9D%99%E6%80%81%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/"/>
    <id>http://example.com/2022/09/07/Linux%E9%9D%99%E6%80%81%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/</id>
    <published>2022-09-07T13:22:52.000Z</published>
    <updated>2022-09-07T14:06:12.014Z</updated>
    
    <content type="html"><![CDATA[<p>发士大夫十分</p><p>基本环境：</p><p>电脑：Windows10</p><p>虚拟机：VMware</p><p>Linux：CentOS 7</p><p>基本操作：</p><ul><li>步骤一：查看VMware 虚拟网络编辑器</li></ul><p><img src="/2022/09/07/Linux%E9%9D%99%E6%80%81%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/image-20220907212906951.png" alt="image-20220907212906951"></p><ul><li>步骤二：取消DHCP勾选</li></ul><img src="/2022/09/07/Linux%E9%9D%99%E6%80%81%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/image-20220907213330974.png" alt="image-20220907213330974" style="zoom:67%;"><ul><li>步骤三：查看网络信息，待会儿用</li></ul><img src="/2022/09/07/Linux%E9%9D%99%E6%80%81%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/image-20220907213433960.png" alt="image-20220907213433960" style="zoom: 67%;"><ul><li><p>步骤四：修改电脑上的VMnet8网卡的ip</p><p>VMnet8是windows为虚拟机虚拟出来的网卡</p></li></ul><img src="/2022/09/07/Linux%E9%9D%99%E6%80%81%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/image-20220907213812894.png" alt="image-20220907213812894" style="zoom:67%;"><img src="/2022/09/07/Linux%E9%9D%99%E6%80%81%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/image-20220907213853648.png" alt="image-20220907213853648" style="zoom: 67%;"><img src="/2022/09/07/Linux%E9%9D%99%E6%80%81%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/image-20220907213921391.png" alt="image-20220907213921391" style="zoom:67%;"><img src="/2022/09/07/Linux%E9%9D%99%E6%80%81%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/image-20220907214005008.png" alt="image-20220907214005008" style="zoom:67%;"><blockquote><p>IP地址：步骤三查看的网络信息为192.168.227.0，这里使用192.168.227.1</p><p>子网掩码：同步骤三的子网掩码</p><p>网关：同步骤三的网关</p><p>首选DNS：可以和网关一样，备用的随便写一个</p></blockquote><ul><li>步骤五：虚拟设置里选择NAT模式，就可以启动虚拟机了</li></ul><p>![image-20220907214737319]Linux静态网络配置&#x2F;&#x2F;image-20220907214737319.png)</p><ul><li><p>步骤六：修改网卡配置文件</p><ul><li><p>在root用户下</p></li><li><p>打开ifcfg-ens33文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/sysconfig/network-scripts/ifcfg-ens33</span><br></pre></td></tr></table></figure></li></ul><p>![image-20220907215447567]Linux静态网络配置&#x2F;&#x2F;image-20220907215447567.png)</p></li></ul><blockquote><p>ip地址选择192.168.227.3末位为3及以上的，因为末位为0、1和2都被占用了</p></blockquote><p>:wq 或 :wq! 保存并退出</p><ul><li>步骤七：重启网络</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart network </span><br><span class="line">或 </span><br><span class="line">service network restart</span><br></pre></td></tr></table></figure><p> 查看网卡信息，看到你的 ip地址说明配置完成了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip addr</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;发士大夫十分&lt;/p&gt;
&lt;p&gt;基本环境：&lt;/p&gt;
&lt;p&gt;电脑：Windows10&lt;/p&gt;
&lt;p&gt;虚拟机：VMware&lt;/p&gt;
&lt;p&gt;Linux：CentOS 7&lt;/p&gt;
&lt;p&gt;基本操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;步骤一：查看VMware 虚拟网络编辑器&lt;/li&gt;
&lt;/ul&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Linux克隆后无法重启网络</title>
    <link href="http://example.com/2022/09/07/Linux%E5%85%8B%E9%9A%86%E5%90%8E%E6%97%A0%E6%B3%95%E9%87%8D%E5%90%AF%E7%BD%91%E7%BB%9C/"/>
    <id>http://example.com/2022/09/07/Linux%E5%85%8B%E9%9A%86%E5%90%8E%E6%97%A0%E6%B3%95%E9%87%8D%E5%90%AF%E7%BD%91%E7%BB%9C/</id>
    <published>2022-09-07T13:04:31.000Z</published>
    <updated>2022-09-07T13:21:20.022Z</updated>
    
    <content type="html"><![CDATA[<p>转载文章：<a href="https://blog.csdn.net/qq_37010445/article/details/115727074">https://blog.csdn.net/qq_37010445/article/details/115727074</a></p><p>由于最近在学习Hadoop的需要，在虚拟机VM上，搭建Linux以CentOS7例，在原始机上配置了静态网络，之后克隆两台一样的虚拟机。</p><p>打开原始机，发现ip没有了，使用service network restart一直显示错误，在两台克隆机上也是同样问题</p><p>查找了一下午，终于找到了篇对症下药的文章：</p><ul><li>这是NetworkManager本身的问题启动网卡方面应该是出现了漏洞导致。</li><li>在CentOS系统上，目前有NetworkManager和network两种网络管理工具。</li><li>配置了静态网络使用network就行了。</li></ul><p>解决方案：</p><ul><li>第一步：暂停NetworkManager</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop NetworkManager</span><br></pre></td></tr></table></figure><ul><li>第二步：永久暂停NetworkManager</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl disable NetworkManager</span><br></pre></td></tr></table></figure><p>之后就可以重启网络了</p><p>克隆机需要修改网卡配置文件ifcfg-ens33中的IP地址，在重启网络</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;转载文章：&lt;a href=&quot;https://blog.csdn.net/qq_37010445/article/details/115727074&quot;&gt;https://blog.csdn.net/qq_37010445/article/details/115727074&lt;/a</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>集合</title>
    <link href="http://example.com/2022/08/30/Java%E9%AB%98%E7%BA%A7-%E9%9B%86%E5%90%88-%E6%B3%9B%E5%9E%8B-IO%E6%B5%81/"/>
    <id>http://example.com/2022/08/30/Java%E9%AB%98%E7%BA%A7-%E9%9B%86%E5%90%88-%E6%B3%9B%E5%9E%8B-IO%E6%B5%81/</id>
    <published>2022-08-30T09:45:41.000Z</published>
    <updated>2022-09-28T08:12:13.349Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java高级编程4-6"><a href="#Java高级编程4-6" class="headerlink" title="Java高级编程4-6"></a>Java高级编程4-6</h1><h2 id="4-集合"><a href="#4-集合" class="headerlink" title="4.集合"></a>4.集合</h2><h3 id="1-集合的概述"><a href="#1-集合的概述" class="headerlink" title="1.集合的概述"></a>1.集合的概述</h3><h4 id="1-集合与数组"><a href="#1-集合与数组" class="headerlink" title="1.集合与数组"></a>1.集合与数组</h4><ol><li>集合、数组都是对多个数据进行存储操作的结构，简称Java容器。</li><li>说明：此时的存储，主要指的是内存层面的存储，不涉及到持久化的存储（.txt,.jpg,.avi，数据库中）</li></ol><p><strong>数组优缺点：</strong></p><ol><li>数组在存储多个数据方面的特点：<ol><li>一旦初始化以后，其长度就确定了。</li><li>数组一旦定义好，其元素的类型也就确定了。我们也就只能操作指定类型的数据了。比如：String[] arr;int[] arr1;Object[] arr2;</li></ol></li><li>数组在存储多个数据方面的缺点：<ol><li>一旦初始化以后，其长度就不可修改。</li><li>数组中提供的方法非常有限，对于添加、删除、插入数据等操作，非常不便，同时效率不高。</li><li>获取数组中实际元素的个数的需求，数组没有现成的属性或方法可用</li><li>数组存储数据的特点：有序、可重复。对于无序、不可重复的需求，不能满足。</li></ol></li></ol><h4 id="2-集合的框架"><a href="#2-集合的框架" class="headerlink" title="2.集合的框架"></a>2.集合的框架</h4><ol><li><p>Collection接口：单列集合，用来存储一个一个的对象</p><ol><li><p><strong>List接口：存储有序的、可重复的数据</strong>。  –&gt;“动态”数组</p><p>例如：ArrayList、LinkedList、Vector（实现类）</p></li><li><p><strong>Set接口：存储无序的、不可重复的数据</strong>   –&gt;高中讲的“集合”</p><p>例如：HashSet、LinkedHashSet、TreeSet（实现类）</p></li></ol></li><li><p>Map接口：双列集合，用来存储一对(key - value)一对的数据   –&gt;高中函数：y &#x3D; f(x)</p><p>例如：HashMap、LinkedHashMap、TreeMap、Hashtable、Properties（实现类）</p></li></ol><h3 id="2-Collection接口中方法"><a href="#2-Collection接口中方法" class="headerlink" title="2.Collection接口中方法"></a>2.Collection接口中方法</h3><p>声明方式一：Collection coll &#x3D; new ArrayList()</p><p>声明方式二：调用Arrays的静态方法asList,<strong>形参为可变形参</strong>，返回ArrayList<br>Collection coll1 &#x3D; Arrays.asList(123,456);</p><ol><li><p>add(Object e)</p><p>将元素e添加到集合coll中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Collection</span> <span class="variable">coll</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();    <span class="comment">//集合的声明</span></span><br><span class="line">coll.add(<span class="string">&quot;AA&quot;</span>);</span><br><span class="line">coll.add(<span class="string">&quot;BB&quot;</span>);</span><br><span class="line">coll.add(<span class="number">123</span>);<span class="comment">//自动装箱Integer</span></span><br><span class="line">coll.add(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br></pre></td></tr></table></figure></li><li><p>size()</p><p>获取添加的元素的个数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(coll.size());  //4</span><br></pre></td></tr></table></figure></li><li><p>addAll(Collection coll1)</p><p>将coll1集合中的元素添加到当前的集合中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Collection coll1 = new ArrayList();</span><br><span class="line">coll1.add(456);</span><br><span class="line">coll1.add(&quot;CC&quot;);</span><br><span class="line">coll.addAll(coll1); </span><br></pre></td></tr></table></figure></li><li><p>clear()</p><p>清空集合元素，不是删除集合，而是清空元素</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">coll.clear();  </span><br></pre></td></tr></table></figure></li><li><p>isEmpty()</p><p>判断当前集合是否为空</p></li><li><p>boolean   contains(Object obj)</p><p>判断当前集合中是否包含obj，我们在判断时会调用obj对象所在类的equals()。如果不重写equals方法，则会调用Object中的equals()，使用的是&#x3D;&#x3D;，不同对象比的是地址，所以必须重写equals( )</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">boolean contains = coll.contains(123);</span><br><span class="line"></span><br><span class="line">contain1 = coll.contains(new Person(&quot;Jerry&quot;,20));</span><br></pre></td></tr></table></figure></li><li><p>containsAll(Collection coll1)</p><p>判断形参coll1中的所有元素是否都存在于当前集合中。同样调用equals方法，所以重写equals很重要</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Collection</span> <span class="variable">coll</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        coll.add(<span class="number">456</span>);</span><br><span class="line">        coll.add(<span class="number">123</span>);</span><br><span class="line"><span class="comment">//        Person p = new Person(&quot;Jerry&quot;,20);</span></span><br><span class="line"><span class="comment">//        coll.add(p);</span></span><br><span class="line">        coll.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Jerry&quot;</span>,<span class="number">20</span>));</span><br><span class="line">        coll.add(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Tom&quot;</span>));</span><br><span class="line">        coll.add(<span class="literal">false</span>);</span><br><span class="line">声明方式：调用Arrays的静态方法asList,形参为可变形参，返回ArrayList</span><br><span class="line"><span class="type">Collection</span> <span class="variable">coll1</span> <span class="operator">=</span> Arrays.asList(<span class="number">123</span>,<span class="number">456</span>);</span><br><span class="line">System.out.println(coll.containsAll(coll1));</span><br><span class="line"><span class="type">Collection</span> <span class="variable">coll2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">coll2.add(<span class="number">123</span>);</span><br><span class="line">coll2.add(<span class="number">456</span>);</span><br><span class="line">coll2.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Jerry&quot;</span>,<span class="number">20</span>));</span><br><span class="line">System.out.println(coll.containsAll(coll2));</span><br></pre></td></tr></table></figure></li><li><p>remove(Object obj)</p><p>从当前集合中移除obj元素。无返回值，直接修改当前集合元素</p><p>同样调用equals方法，查找是否存在此元素</p><p>coll.remove(1234);</p></li><li><p>removeAll(Collection coll1)</p><p>差集：从当前集合中移除coll1中所有的元素。移除该集合与形参集合交集部分。也是调用equals方法，查找是否存在此元素，</p></li><li><p>retainAll(Collection coll1)</p><p>交集：获取当前集合和coll1集合的交集，并返回给当前集合。将两集合交集替换当前集合元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Collection</span> <span class="variable">coll1</span> <span class="operator">=</span> Arrays.asList(<span class="number">123</span>,<span class="number">456</span>,<span class="number">789</span>);</span><br><span class="line">   coll.retainAll(coll1);  </span><br><span class="line">     System.out.println(coll); <span class="comment">//123,456</span></span><br></pre></td></tr></table></figure></li><li><p>equals(Object obj)</p><p>要想返回true，需要当前集合和形参集合的元素都相同（加入顺序和集合元素都是相同的）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Collection</span> <span class="variable">coll1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">coll1.add(<span class="number">123</span>);</span><br><span class="line">coll1.add(<span class="number">456</span>);</span><br><span class="line"><span class="type">Collection</span> <span class="variable">coll2</span> <span class="operator">=</span> Arrays.asList(<span class="number">123</span>,<span class="number">456</span>);</span><br><span class="line">System.out.println(coll.equals(coll2));</span><br></pre></td></tr></table></figure></li><li><p>hashCode()</p><p>返回当前对象的哈希值</p></li><li><p>集合 —&gt;数组：  toArray()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Object[] arr = coll.toArray();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; arr.length;i++)&#123;</span><br><span class="line">    System.out.println(arr[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拓展：数组 —&gt;集合:调用Arrays类的静态方法asList(T…..t)   形参为对象的可变形参，看做一个个对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;AA&quot;</span>, <span class="string">&quot;BB&quot;</span>, <span class="string">&quot;CC&quot;</span>&#125;);</span><br><span class="line">System.out.println(list);</span><br><span class="line"></span><br><span class="line"><span class="type">List</span> <span class="variable">arr1</span> <span class="operator">=</span> Arrays.asList(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">123</span>, <span class="number">456</span>&#125;);</span><br><span class="line">System.out.println(arr1.size());<span class="comment">//1 这int数组看做一个对象，所以里面只有 1 </span></span><br><span class="line"></span><br><span class="line"><span class="type">List</span> <span class="variable">arr2</span> <span class="operator">=</span> Arrays.asList(<span class="keyword">new</span> <span class="title class_">Integer</span>[]&#123;<span class="number">123</span>, <span class="number">456</span>&#125;);</span><br><span class="line">System.out.println(arr2.size());<span class="comment">//2  这Integer数组内部成员可看成一个个对象，所以为 2 </span></span><br></pre></td></tr></table></figure></li><li><p>iterator( ）    迭代器</p><p>返回Iterator接口的实例，用于遍历集合元素。放在IteratorTest.java中测试——下一结介绍</p></li></ol><h3 id="3-Iterator-迭代器接口"><a href="#3-Iterator-迭代器接口" class="headerlink" title="3.Iterator 迭代器接口"></a>3.Iterator 迭代器接口</h3><h4 id="1-iterator-）-迭代器"><a href="#1-iterator-）-迭代器" class="headerlink" title="1.iterator(） 迭代器"></a>1.iterator(） 迭代器</h4><p><strong>Collection中的方法：iterator( ）    迭代器</strong></p><p>返回Iterator接口的实例，<strong>用于遍历集合元素。用于集合元素的遍历操作</strong>，使用迭代器Iterator接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Collection</span> <span class="variable">coll</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">coll.add(<span class="number">123</span>);</span><br><span class="line">coll.add(<span class="number">456</span>);</span><br><span class="line"><span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> coll.iterator();</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Iterator接口介绍：</strong></p><ol><li><p>内部的方法：</p><p>hasNext() ： 判断是否还有下一个元素</p><p>  next()   ：①指针下移 ②将下移以后集合位置上的元素返回</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">一般使用方式：用于遍历集合   </span><br><span class="line">    <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> coll.iterator();</span><br><span class="line">       <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">           System.out.println(iterator.next());</span><br><span class="line">   </span><br></pre></td></tr></table></figure></li><li><p>集合对象每次调用iterator()方法都得到一个全新的迭代器对象，默认游标都在集合的第一个元素之前。</p></li><li><p>内部定义了remove(),可以在遍历的时候，删除集合中的元素。此方法不同于集合直接调用remove()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除集合中&quot;Tom&quot;</span></span><br><span class="line"><span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> coll.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">     <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;Tom&quot;</span>.equals(obj))&#123; 防止空指针，将Tom放外面</span><br><span class="line">            iterator.remove();</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">错误方式：</span><br><span class="line">如果还未调用next()或在上一次调用 next 方法之后已经调用了 remove 方法，再调用remove都会报IllegalStateException。</span><br><span class="line"> <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> coll.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line"> 错误一：    iterator.remove();</span><br><span class="line">            <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&quot;Tom&quot;</span>.equals(obj))&#123;</span><br><span class="line"> 错误二：        iterator.remove();</span><br><span class="line">                iterator.remove();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">   </span><br></pre></td></tr></table></figure></li></ol><h4 id="2-foreach循环"><a href="#2-foreach循环" class="headerlink" title="2.foreach循环"></a>2.foreach循环</h4><p>jdk 5.0 新增了forEach循环（或增强for循环），用于遍历集合、数组</p><ol><li><p>格式：for(集合元素的类型 局部变量 : 集合对象)        </p></li><li><p>内部仍然调用了迭代器。（循环过程：集合对象从内部调用迭代器判断并获取，将元素<strong>赋给</strong>局部变量）       </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(Object obj : coll)&#123;</span><br><span class="line">        System.out.println(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    <span class="comment">//for(数组元素的类型 局部变量 : 数组对象)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i : arr)&#123;</span><br><span class="line">    <span class="comment">//i = 3; 修改i不能真正修改集合中元素</span></span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h3 id="4-List接口实现类及方法"><a href="#4-List接口实现类及方法" class="headerlink" title="4.List接口实现类及方法"></a>4.List接口实现类及方法</h3><h4 id="1-三者实现类的比较"><a href="#1-三者实现类的比较" class="headerlink" title="1.三者实现类的比较"></a>1.三者实现类的比较</h4><p><strong>面试题：</strong>ArrayList、LinkedList、Vector三者的异同？</p><p><strong>相同：</strong>三个类都是实现了List接口，存储数据的特点相同：存储有序的、可重复的数据</p><p><strong>补充使用须知：三者添加的数据，其所在的类一定要重写equals( ) 方法（原因：比如说调用Collection接口中的contains()时会调用所在类的equals，没有重写则会调用Object中的equals，即&#x3D;&#x3D;）</strong></p><p><strong>不同：</strong></p><ol><li>ArrayList：作为List接口的主要实现类；线程不安全的，效率高；底层使用Object[] elementData存储</li><li>LinkedList：对于频繁的插入、删除操作，使用此类效率比ArrayList高；底层使用双向链表存储</li><li>Vector：作为List接口的古老实现类；线程安全的，效率低；底层使用Object[] elementData存储</li></ol><p><strong>三者源码深入分析：</strong></p><p><strong>一、ArrayList的源码分析：</strong></p><p><strong>1.jdk 7情况下</strong></p><ol><li><p>ArrayList list &#x3D; new ArrayList();</p><p><strong>&#x2F;&#x2F;底层创建了长度是10的Object[]数组elementData</strong></p><p>list.add(123);    &#x2F;&#x2F;<strong>底层：elementData[0] &#x3D; new Integer(123);</strong></p><p>…</p><p>list.add(11);&#x2F;&#x2F;<strong>如果此次的添加导致底层elementData数组容量不够，则扩容。</strong></p><p><strong>默认情况下，扩容为原来的容量的1.5倍，同时需要将原有数组中的数据复制到新的数组中。</strong></p><p><strong>结论：建议开发中使用带参的构造器：ArrayList list &#x3D; new ArrayList(int capacity)</strong></p></li></ol><p><strong>2.jdk 8中ArrayList的变化：</strong></p><ol><li><p>ArrayList list &#x3D; new ArrayList();</p><p>&#x2F;&#x2F;<strong>底层Object[] elementData初始化为{}.并没有创建长度为10的数组</strong></p><p>list.add(123);&#x2F;<strong>&#x2F;第一次调用add()时，底层才创建了长度10的数组，并将数据123添加到elementData[0]</strong></p><p>…</p><p><strong>后续的添加和扩容操作与jdk 7 无异。</strong></p></li></ol><p><strong>小结：jdk7中的ArrayList的对象的创建类似于单例的饿汉式，而jdk8中的ArrayList的对象的创建类似于单例的懒汉式，延迟了数组的创建，节省内存。</strong></p><p><strong>二、LinkedList的源码分析：</strong></p><ol><li><p>LinkedList list &#x3D; new LinkedList(); 内部声明了Node类型的first和last属性，默认值为null</p><p>list.add(123);&#x2F;&#x2F;将123封装到Node中，创建了Node对象。其中，Node定义为：体现了LinkedList的双向链表的说法</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">底层源码：</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt; &#123;</span><br><span class="line">    E item;</span><br><span class="line">     Node&lt;E&gt; next;</span><br><span class="line">     Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">     Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">     <span class="built_in">this</span>.item = element;</span><br><span class="line">     <span class="built_in">this</span>.next = next;</span><br><span class="line">     <span class="built_in">this</span>.prev = prev;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>三、Vector的源码分析：</strong></p><p>jdk7和jdk8中通过Vector()构造器创建对象时，底层都创建了长度为10的数组。</p><p>在扩容方面，默认扩容为原来的数组长度的2倍。</p><h4 id="2-List接口中常用方法"><a href="#2-List接口中常用方法" class="headerlink" title="2.List接口中常用方法"></a>2.List接口中常用方法</h4><ol><li><p>void add(int index, Object ele)</p><p>在index位置插入ele元素</p><p>list.add(1,”BB”);</p></li><li><p>boolean addAll(int index, Collection eles)</p><p>从index位置开始将eles中的所有元素添加进来</p><p> List list1 &#x3D; Arrays.asList(1, 2, 3);</p><p>list.addAll(list1);   不写index默认为0</p></li><li><p>Object get(int index)</p><p>获取指定index位置的元素</p></li><li><p>int indexOf(Object obj)</p><p>返回obj在集合中首次出现的位置</p></li><li><p>int lastIndexOf(Object obj)</p><p>返回obj在当前集合中末次出现的位置</p></li><li><p>Object remove(int index)</p><p>移除指定index位置的元素，并返回此元素</p></li><li><p>Object set(int index, Object ele)</p><p>设置指定index位置的元素为ele</p></li><li><p>List subList(int fromIndex, int toIndex)</p><p>返回从fromIndex到toIndex位置的子集合</p></li><li><p>总结：常用方法<br>增：add(Object obj)<br>删：List接口：remove(int index) &#x2F; Collection接口：remove(Object obj)<br>改：set(int index, Object ele)<br>查：get(int index)<br>插：add(int index, Object ele)<br>长度：size()<br>遍历：① Iterator迭代器方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> list.iterator();</span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">    System.out.println(iterator.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​             ② 增强for循环</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(Object obj : list)&#123;</span><br><span class="line">    System.out.println(obj);</span><br><span class="line">&#125;         </span><br></pre></td></tr></table></figure></li></ol><p>​                     ③ 普通的循环</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; list.size();i++)&#123;</span><br><span class="line">    System.out.println(list.get(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-Set接口及实现类介绍"><a href="#5-Set接口及实现类介绍" class="headerlink" title="5.Set接口及实现类介绍"></a>5.Set接口及实现类介绍</h3><h4 id="1-三个实现类介绍"><a href="#1-三个实现类介绍" class="headerlink" title="1.三个实现类介绍"></a>1.三个实现类介绍</h4><p>Collection接口：单列集合，用来存储一个一个的对象</p><p>Collection接口子Set接口：<strong>存储无序的、不可重复的数据</strong>   –&gt;高中讲的“集合”</p><p><strong>使用须知：HashSet、LinkedHashSet添加的数据，其所在的类一定要重写hashCode()和equals()。TreeSet则需要重写compareTo或compare方法</strong></p><p><strong>说明：</strong></p><ol><li><p>HashSet：<strong>作为Set接口的主要实现类；线程不安全的；可以存储null值</strong></p><p>补充：new HashSet()其实底层是new HashMap() , 但是Set是单列Map是双列，所以用key来保存HashSet元素，value用一个常量来暂时隐蔽起来</p></li><li><p>LinkedHashSet：作为HashSet的子类；遍历其内部数据时，可以按照添加的顺序遍历</p><p>LinkedHashSet的使用<br><strong>LinkedHashSet作为HashSet的子类，在添加数据的同时，每个数据还维护了两个引用，记录此数据前一个数据和后一个数据。</strong>（因此该类迭代效率高于HashSet）<br>优点：对于频繁的遍历操作，LinkedHashSet效率高于HashSet</p><p>底层图示：</p><p><img src="/2022/08/30/Java%E9%AB%98%E7%BA%A7-%E9%9B%86%E5%90%88-%E6%B3%9B%E5%9E%8B-IO%E6%B5%81/img%5CSnipaste_2022-02-02_20-12-36.png" alt="Snipaste_2022-02-02_20-12-36"></p></li><li><p>TreeSet：<strong>可以按照添加对象的指定属性，进行排序。遍历时可有序遍历</strong></p><ol><li><p><strong>向TreeSet中添加的数据，要求是同一个类的对象。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">TreeSet</span> <span class="variable">set</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeSet</span>();</span><br><span class="line">set.add(<span class="number">34</span>);</span><br><span class="line">set.add(-<span class="number">34</span>);</span><br><span class="line">set.add(<span class="number">43</span>);</span><br><span class="line">set.add(<span class="number">11</span>);</span><br><span class="line">set.add(<span class="number">8</span>)；输出：按照从从小到大输出</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><strong>TreeSet对属性进行排序使用两种排序方式</strong>：自然排序（实现Comparable接口） 和 定制排序（Comparator）</p><p>1.自然排序中，比较两个对象是否相同的标准为：compareTo()返回0.不再是equals()，<strong>该类要求实现Comparable接口，重写compareTo</strong></p><p><img src="/2022/08/30/Java%E9%AB%98%E7%BA%A7-%E9%9B%86%E5%90%88-%E6%B3%9B%E5%9E%8B-IO%E6%B5%81/Learn_data\Java\Java笔记\img\image-20220320101407300.png" alt="image-20220320101407300"></p><p>2.定制排序中，比较两个对象是否相同的标准为：compare()返回0.不再是equals()，<strong>TreeSet有形参为Comparator的构造器</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Comparator</span> <span class="variable">com</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Comparator</span>() &#123;</span><br><span class="line">    <span class="comment">//按照年龄从小到大排列</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object o1, Object o2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(o1 <span class="keyword">instanceof</span> User &amp;&amp; o2 <span class="keyword">instanceof</span> User)&#123;</span><br><span class="line">            <span class="type">User</span> <span class="variable">u1</span> <span class="operator">=</span> (User)o1;</span><br><span class="line">            <span class="type">User</span> <span class="variable">u2</span> <span class="operator">=</span> (User)o2;</span><br><span class="line">            <span class="keyword">return</span> Integer.compare(u1.getAge(),u2.getAge());</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;输入的数据类型不匹配&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">TreeSet</span> <span class="variable">set</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeSet</span>(com);</span><br><span class="line">set.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Tom&quot;</span>,<span class="number">12</span>));</span><br><span class="line">set.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Jerry&quot;</span>,<span class="number">32</span>));</span><br><span class="line">set.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Jim&quot;</span>,<span class="number">2</span>));</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol></li></ol><h4 id="2-Set接口介绍"><a href="#2-Set接口介绍" class="headerlink" title="2.Set接口介绍"></a>2.Set接口介绍</h4><p><strong>Set接口使用说明：</strong></p><ol><li><p><strong>Set接口中没有额外定义新的方法，使用的都是Collection中声明过的方法。</strong></p></li><li><p>要求：向Set(主要指：HashSet、LinkedHashSet)中<strong>添加的数据，其所在的类一定要重写hashCode()和equals()</strong></p></li><li><p>要求：重写的hashCode()和equals()尽可能保持一致性：相等的对象必须具有相等的散列码（一般用自动生成）</p></li><li><p>重写两个方法的小技巧：对象中用作 equals() 方法比较的 Field，都应该用来计算 hashCode 值。<br>​</p><p><strong>一、Set：存储无序的、不可重复的数据</strong><br>以HashSet为例说明：</p><ol><li><strong>无序性</strong>：不等于随机性。存储的数据在底层数组中并非按照数组索引的顺序添加，而是根据数据的哈希值决定的。</li><li><strong>不可重复性</strong>：保证添加的元素按照equals()判断时，不能返回true.即：相同的元素只能添加一个。</li></ol><p><strong>二、添加元素的过程介绍两个特性：以HashSet为例：</strong></p><p>我们向HashSet中添加元素a,首先调用元素a所在类的hashCode()方法，计算元素a的哈希值，此哈希值接着通过某种算法计算出在HashSet底层数组中的存放位置（即为：索引位置），判断数组此位置上是否已经有元素：</p><p>1.如果此位置上没有其他元素，则元素a添加成功。 —&gt;情况1<br>2.如果此位置上有其他元素b(或以链表形式存在的多个元素），则比较元素a与元素b的hash值：</p><ol><li>如果hash值不相同，则元素a添加成功。—&gt;情况2</li><li>如果hash值相同，进而需要调用元素a所在类的equals()方法：<ol><li>equals()返回true,元素a添加失败</li><li>equals()返回false,则元素a添加成功。—&gt;情况3</li></ol></li></ol><p><strong>过程总结：先计算hashcode，将元素按某种算法算出下标填入数组，如有重复则进行比较两者hashcode值</strong>（<strong>若不等则就以链表形式一起存在该数组下标，若相等则用equals方法继续比较，还相等则不要，否则就要</strong></p><p><strong>—-小结：hashcode相等两者不一定相等，但两者相等，hashcode一定相等</strong></p><p><strong>—补充特例：首先添加元素为1，后又通过地址修改元素为2，在添加一个元素为2，此时的hashcode值是不同，有位置就直接存入数组了，就存在相同元素了</strong>）</p><p>对于添加成功的情况2和情况3而言：元素a 与已经存在指定索引位置上数据以链表的方式存储。</p><p>jdk 7 :元素a放到数组中，指向原来的元素。<br>jdk 8 :原来的元素在数组中，指向元素a<br>总结：七上八下</p><p>HashSet底层：数组+链表的结构。</p></li></ol><h3 id="6-Map的实现类及理解"><a href="#6-Map的实现类及理解" class="headerlink" title="6.Map的实现类及理解"></a>6.Map的实现类及理解</h3><h4 id="1-Map的实现类的结构："><a href="#1-Map的实现类的结构：" class="headerlink" title="1.Map的实现类的结构："></a>1.Map的实现类的结构：</h4><p>Map:<strong>双列数据，存储key-value对的数据</strong>   —类似于高中的函数：y &#x3D; f(x)</p><ol><li><p>HashMap:<strong>作为Map的主要实现类；线程不安全的，效率高；存储null的key和value</strong></p></li><li><p>LinkedHashMap<strong>继承于</strong>HashMap:<strong>保证在遍历map元素时，可以按照添加的顺序实现遍历。</strong></p><p>原因：在原有的HashMap底层结构基础上，添加了一对指针，指向前一个和后一个元素。</p><p>对于频繁的遍历操作，此类执行效率高于HashMap。</p></li><li><p>TreeMap:<strong>保证按照添加的key-value对进行排序，实现排序遍历。此时考虑key的自然排序或定制排序。底层使用红黑树</strong></p></li><li><p>Hashtable:作为古老（出现早）的实现类<strong>；线程安全的，效率低；不能存储null的key和value</strong></p></li><li><p>Properties<strong>继承于</strong>Hashtable:<strong>常用来处理配置文件。key和value都是String类型</strong></p></li></ol><p>HashMap的底层：数组+链表  （jdk7及之前）</p><p>数组+链表+红黑树 （jdk 8）</p><p>面试题：</p><p>HashMap的底层实现原理？</p><p>HashMap 和 Hashtable的异同？</p><p>CurrentHashMap 与 Hashtable的异同？（暂时不讲）</p><h4 id="2-Map结构的理解："><a href="#2-Map结构的理解：" class="headerlink" title="2.Map结构的理解："></a>2.Map结构的理解：</h4><p>通俗理解：高中的函数：key &#x3D; x  value &#x3D; y;  x 可是无序的，但不能重复，y也可是无序的，但可以重复（二次函数多个x对一个y)</p><ol><li><p>Map中的key:<strong>无序的、不可重复的，使用Set存储所有的key  —&gt; key所在的类要重写equals()和hashCode() （以HashMap为例）</strong></p></li><li><p>Map中的value:<strong>无序的、可重复的，使用Collection存储所有的value —&gt;value所在的类要重写equals()</strong></p></li><li><p><strong>一个键值对：key-value构成了一个Entry对象。</strong></p></li><li><p><strong>Map中的entry:无序的、不可重复的，使用Set存储所有的entry</strong></p></li><li><p>Entry将键值对的对应关系封装成了对象，即键值对对象，这样我们在遍历Map集合时，就可以从每一个键值对（Entry）对象中获取对应的键与对应的值。</p><p><strong>Entry静态内部嵌套接口，修饰为静态可以通过类名调用。</strong></p><p><strong>Entry中方法：getKey()和getValue(),获取键值对</strong></p></li><li><p>图示：</p><p><img src="/2022/08/30/Java%E9%AB%98%E7%BA%A7-%E9%9B%86%E5%90%88-%E6%B3%9B%E5%9E%8B-IO%E6%B5%81/img%5CSnipaste_2022-02-03_10-41-34.png" alt="Snipaste_2022-02-03_10-41-34"></p></li></ol><h4 id="3-HashMap底层实现原理"><a href="#3-HashMap底层实现原理" class="headerlink" title="3.HashMap底层实现原理"></a>3.HashMap底层实现原理</h4><p>面试题：<strong>HashMap的底层实现原理？以jdk7为例说明：</strong></p><ol><li><p>HashMap map &#x3D; new HashMap()</p><p>在实例化以后，底层创建了长度是16的一维数组Entry[] table。</p><p>…可能已经执行过多次put…</p></li><li><p>map.put(key1,value1)</p><p>首先，调用key1所在类的hashCode()计算key1哈希值，此哈希值经过某种算法计算以后，得到在Entry数组中的存放位置。</p><p>1.如果此位置上的数据为空，此时的key1-value1添加成功。 —-情况1</p><p>2.如果此位置上的数据不为空，(意味着此位置上存在一个或多个数据(以链表形式存在)),<strong>比较key1和已经存在的一个或多个数据的哈希值：</strong></p><ol><li>如果key1的哈希值与已经存在的数据的哈希值都不相同，此时key1-value1添加成功。—-情况2</li><li>如果key1的哈希值和已经存在的某一个数据(key2-value2)的哈希值相同，继续比较：<strong>调用key1所在类的equals(key2)方法，比较：</strong><ol><li>如果equals()返回false:此时key1-value1添加成功。—-情况3</li><li><strong>如果equals()返回true:使用value1替换value2。put因此也有修改的作用</strong></li></ol></li><li>补充：关于情况2和情况3：此时key1-value1和原来的数据以链表的方式存储。</li></ol></li></ol><p><strong>扩容问题：</strong></p><p>在不断的添加过程中，会涉及到扩容问题，当超出临界值(且要存放的位置非空–凌临界值不等于数组长度)时，扩容。默认的扩容方式：<strong>扩容为原来容量的2倍，并将原有的数据复制过来</strong>。</p><p><strong>jdk8 相较于jdk7在底层实现方面的不同：</strong></p><ol><li><p>new HashMap():<strong>底层没有创建一个长度为16的数组</strong></p></li><li><p>jdk 8底层的数组是：Node[],而非Entry[]</p></li><li><p><strong>首次调用put()方法时，底层创建长度为16的数组</strong></p></li><li><p><strong>jdk7底层结构只有：数组+链表。jdk8中底层结构：数组+链表+红黑树。</strong></p><p>4.1 形成链表时，<strong>七上八下（jdk7:新的元素指向旧的元素。jdk8：旧的元素指向新的元素）</strong></p><p>4.2 <strong>当数组的某一个索引位置上的元素以链表形式存在的数据个数 &gt; 8 且当前数组的长度 &gt; 64（如小于64则转为扩容）时，此时此索引位置上的所数据改为使用红黑树存储。</strong></p></li></ol><p><strong>底层代码的关键常量：</strong></p><ol><li>DEFAULT_INITIAL_CAPACITY : HashMap的默认容量，16</li><li>DEFAULT_LOAD_FACTOR：HashMap的默认加载因子：0.75</li><li>threshold：<strong>扩容的临界值</strong>，&#x3D;容量*填充因子：16 * 0.75 &#x3D;&gt; 12</li><li>TREEIFY_THRESHOLD：Bucket中链表长度大于该默认值，转化为红黑树:8</li><li>MIN_TREEIFY_CAPACITY：桶中的Node被树化时最小的hash表容量:64</li></ol><h4 id="4-LinkedHashMap的底层实现原理（了解）"><a href="#4-LinkedHashMap的底层实现原理（了解）" class="headerlink" title="4.LinkedHashMap的底层实现原理（了解）"></a>4.LinkedHashMap的底层实现原理（了解）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> 源码中：</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">HashMap</span>.Node&lt;K,V&gt; &#123;</span><br><span class="line">Entry&lt;K,V&gt; before, after;<span class="comment">//能够记录添加的元素的先后顺序</span></span><br><span class="line"> Entry(<span class="type">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">              <span class="built_in">super</span>(hash, key, value, next);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="5-TreeMap实现类使用"><a href="#5-TreeMap实现类使用" class="headerlink" title="5.TreeMap实现类使用"></a>5.TreeMap实现类使用</h4><p>向TreeMap中添加key-value，要求key必须是由同一个类创建的对象<br>因为要按照key进行排序：自然排序 、定制排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自然排序：在User重写compareTo方法</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">TreeMap</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeMap</span>();</span><br><span class="line">    <span class="type">User</span> <span class="variable">u1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Tom&quot;</span>,<span class="number">23</span>);</span><br><span class="line">    <span class="type">User</span> <span class="variable">u2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Jerry&quot;</span>,<span class="number">32</span>);</span><br><span class="line">    <span class="type">User</span> <span class="variable">u3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Jack&quot;</span>,<span class="number">20</span>);</span><br><span class="line">    <span class="type">User</span> <span class="variable">u4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Rose&quot;</span>,<span class="number">18</span>);</span><br><span class="line"></span><br><span class="line">    map.put(u1,<span class="number">98</span>);</span><br><span class="line">    map.put(u2,<span class="number">89</span>);</span><br><span class="line">    map.put(u3,<span class="number">76</span>);</span><br><span class="line">    map.put(u4,<span class="number">100</span>);<span class="comment">//添加类型一致</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//定制排序</span></span><br><span class="line">  <span class="type">TreeMap</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeMap</span>(<span class="keyword">new</span> <span class="title class_">Comparator</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object o1, Object o2)</span> &#123;</span><br><span class="line">         <span class="keyword">if</span>(o1 <span class="keyword">instanceof</span> User &amp;&amp; o2 <span class="keyword">instanceof</span> User)&#123;</span><br><span class="line">             <span class="type">User</span> <span class="variable">u1</span> <span class="operator">=</span> (User)o1;</span><br><span class="line">             <span class="type">User</span> <span class="variable">u2</span> <span class="operator">=</span> (User)o2;</span><br><span class="line">            <span class="keyword">return</span> Integer.compare(u1.getAge(),u2.getAge());</span><br><span class="line">                &#125;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;输入的类型不匹配！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><h4 id="6-Properties实现类子类的使用"><a href="#6-Properties实现类子类的使用" class="headerlink" title="6.Properties实现类子类的使用"></a>6.Properties实现类子类的使用</h4><p>Properties:常用来处理配置文件。key和value都是String类型</p><p>配置文件：是一种计算机文件，可以为一些计算机程序配置参数和初始设置。”</p><p>配置文件的创建：一般创建在整个工程下，创建File 后缀名为properties，也可直接点击Resource  Bundle 创建自动添加后缀名</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先做简单了解：</span></span><br><span class="line"><span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">Properties</span> <span class="variable">pros</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line"></span><br><span class="line">    fis = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;jdbc.properties&quot;</span>);</span><br><span class="line">    pros.load(fis);<span class="comment">//加载流对应的文件</span></span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;name = &quot;</span> + name + <span class="string">&quot;, password = &quot;</span> + password);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="7-Map接口中常用方法"><a href="#7-Map接口中常用方法" class="headerlink" title="7.Map接口中常用方法"></a>7.Map接口中常用方法</h3><h4 id="1-添加、删除、修改操作："><a href="#1-添加、删除、修改操作：" class="headerlink" title="1.添加、删除、修改操作："></a>1.添加、删除、修改操作：</h4><ol><li><p>Object put(Object key,Object value)</p><p>将指定key-value<strong>添加到(或修改)当前map对象中</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"><span class="comment">//添加</span></span><br><span class="line">map.put(<span class="string">&quot;AA&quot;</span>,<span class="number">123</span>);</span><br><span class="line">map.put(<span class="number">45</span>,<span class="number">123</span>);</span><br><span class="line">map.put(<span class="string">&quot;BB&quot;</span>,<span class="number">56</span>);</span><br><span class="line"><span class="comment">//修改</span></span><br><span class="line">map.put(<span class="string">&quot;AA&quot;</span>,<span class="number">87</span>); <span class="comment">//只看key，如果有相同，则替换为新加的</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>void putAll(Map m)</p><p>将m中的所有key-value对存放到当前map中</p></li><li><p>Object remove(Object key)</p><p>移除指定key的key-value对，并返回value</p></li><li><p>void clear()</p><p>清空当前map中的所有数据</p></li></ol><h4 id="2-元素查询的操作："><a href="#2-元素查询的操作：" class="headerlink" title="2.元素查询的操作："></a>2.元素查询的操作：</h4><ol><li><p>Object get(Object key)</p><p><strong>获取指定key对应的value</strong></p></li><li><p>boolean containsKey(Object key)</p><p>是否包含指定的key</p></li><li><p>boolean containsValue(Object value)</p><p><strong>是否包含指定的value</strong></p></li><li><p>int size()</p><p>返回map中key-value对的个数</p></li><li><p>boolean isEmpty()</p><p>判断当前map是否为空</p></li><li><p>boolean equals(Object obj)</p><p>判断当前map和参数对象obj是否相等</p></li></ol><h4 id="3-元视图及遍历操作"><a href="#3-元视图及遍历操作" class="headerlink" title="3.元视图及遍历操作"></a>3.元视图及遍历操作</h4><p>元视图操作(能够单独取出key集或value集或key-value集)的方法：</p><ol><li><p>Set keySet()：返回所有key构成的Set集合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        map.put(<span class="string">&quot;AA&quot;</span>,<span class="number">123</span>);</span><br><span class="line">        map.put(<span class="number">45</span>,<span class="number">1234</span>);</span><br><span class="line">        map.put(<span class="string">&quot;BB&quot;</span>,<span class="number">56</span>);</span><br><span class="line"><span class="comment">//遍历所有的key集：keySet()</span></span><br><span class="line"><span class="type">Set</span> <span class="variable">set</span> <span class="operator">=</span> map.keySet();</span><br><span class="line">    <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> set.iterator();</span><br><span class="line">    <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">        System.out.println(iterator.next());</span><br></pre></td></tr></table></figure></li><li><p>Collection values()：返回所有value构成的Collection集合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历所有的value集：values()</span></span><br><span class="line"><span class="type">Collection</span> <span class="variable">values</span> <span class="operator">=</span> map.values();</span><br><span class="line"><span class="keyword">for</span>(Object obj : values)&#123;</span><br><span class="line">    System.out.println(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Set entrySet()：返回所有key-value对构成的Set集合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历所有的key-value</span></span><br><span class="line"><span class="comment">//方式一：entrySet()</span></span><br><span class="line"><span class="type">Set</span> <span class="variable">entrySet</span> <span class="operator">=</span> map.entrySet();</span><br><span class="line"><span class="type">Iterator</span> <span class="variable">iterator1</span> <span class="operator">=</span> entrySet.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator1.hasNext())&#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> iterator1.next();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//entrySet集合中的元素都是entry：一个key一个value</span></span><br><span class="line">    Map.<span class="type">Entry</span> <span class="variable">entry</span> <span class="operator">=</span> (Map.Entry) obj; <span class="comment">//强转</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//getKey()getValue()为entry接口内部静态方法</span></span><br><span class="line">    System.out.println(entry.getKey() + <span class="string">&quot;----&gt;&quot;</span> + entry.getValue());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//方式二：利用keySet()和Map中get()配合</span></span><br><span class="line">        <span class="type">Set</span> <span class="variable">keySet</span> <span class="operator">=</span> map.keySet(); 取出集合key</span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">iterator2</span> <span class="operator">=</span> keySet.iterator();</span><br><span class="line">        <span class="keyword">while</span>(iterator2.hasNext())&#123;</span><br><span class="line">           <span class="type">Object</span> <span class="variable">key</span> <span class="operator">=</span> iterator2.next();</span><br><span class="line">           <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> map.get(key);<span class="comment">//key对应value</span></span><br><span class="line">          System.out.println(key + <span class="string">&quot;=====&quot;</span> + value);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h4 id="4-总结：常用方法"><a href="#4-总结：常用方法" class="headerlink" title="4.总结：常用方法"></a>4.总结：常用方法</h4><ul><li>添加：put(Object key,Object value)</li><li>删除：remove(Object key)</li><li>修改：put(Object key,Object value)</li><li>查询：get(Object key)</li><li>长度：size()</li><li>遍历：keySet() &#x2F; values() &#x2F; entrySet()</li></ul><h3 id="8-Collections工具类"><a href="#8-Collections工具类" class="headerlink" title="8.Collections工具类"></a>8.Collections工具类</h3><h4 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h4><p>Collections 是一个操作Set、List、和Map等集合的工具类。类似于操作数组的工具类：Arrays，其内部方法都是静态方法</p><h4 id="2-常用方法"><a href="#2-常用方法" class="headerlink" title="2.常用方法"></a>2.常用方法</h4><p>Collections:操作Collection、Map的工具类</p><p>面试题：Collection 和 Collections的区别？</p><ol><li><p>void  reverse(List)</p><p>反转 List 中元素的顺序</p></li><li><p>void shuffle(List)</p><p>对 List 集合元素进行<strong>随机排序</strong></p></li><li><p>void  sort(List)    <strong>自然排序</strong></p><p>根据元素的自然顺序对指定 List 集合元素按升序排序</p></li><li><p>void  sort(List，Comparator)    <strong>定制排序</strong></p><p>根据指定的 Comparator 产生的顺序对 List 集合元素进行排序</p></li><li><p>void  swap(List，int， int)</p><p>将指定 list 集合中的 i 处元素和 j 处元素进行交换</p></li><li><p>Object max(Collection)</p><p>根据元素的<strong>自然顺序</strong>，返回给定集合中的最大元素</p></li><li><p>Object max(Collection，Comparator)</p><p>根据 Comparator <strong>指定的顺序</strong>，返回给定集合中的最大元素</p></li><li><p>Object min(Collection)</p></li><li><p>Object min(Collection，Comparator)</p></li><li><p>int frequency(Collection，Object)</p><p>返回指定集合中指定元素的出现次数</p></li><li><p>void copy(List dest,List src)</p><p>将src中的内容复制到dest中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//        List dest = new ArrayList();</span></span><br><span class="line"><span class="comment">//        Collections.copy(dest,list);</span></span><br><span class="line"><span class="comment">//报异常：IndexOutOfBoundsException(&quot;Source does not fit in dest&quot;)内部需要list.size()&lt;=dest.size()才能复制</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//正确的：利用工具类Arrays中asList将一个list.size()数组作为形参建一个的神态</span></span><br><span class="line">  <span class="type">List</span> <span class="variable">dest</span> <span class="operator">=</span> Arrays.asList(<span class="keyword">new</span> <span class="title class_">Object</span>[list.size()]);</span><br><span class="line">        System.out.println(dest.size());<span class="comment">//list.size();</span></span><br><span class="line">        Collections.copy(dest,list);</span><br><span class="line"></span><br><span class="line">        System.out.println(dest);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>boolean replaceAll(List list，Object oldVal，Object newVal)</p><p>使用新值替换 List 对象的所有旧值</p></li><li><p>ArrayList 和 HashMap 都是线程不安全的，如果程序要求线程安全，我们<strong>可以将ArrayList、HashMap转换线程安全的。</strong></p><p>使用<strong>synchronizedList(List  list) 和 synchronizedMap(Map  map)</strong></p></li></ol><h2 id="5-泛型"><a href="#5-泛型" class="headerlink" title="5.泛型"></a>5.泛型</h2><h3 id="1-为什么要有泛型"><a href="#1-为什么要有泛型" class="headerlink" title="1.为什么要有泛型"></a>1.为什么要有泛型</h3><p><strong>1.生活中例子</strong></p><p>举例：     泛型：标签</p><ol><li>中药店，每个抽屉外面贴着标签</li><li>超市购物架上很多瓶子，每个瓶子装的是什么，有标签</li></ol><p><strong>2.泛型的理解</strong></p><ol><li>把元素的类型设计成一个参数，这个<strong>类型参数</strong>叫做<strong>泛型</strong></li><li>所谓泛型，就是允许<strong>在定义类、接口时通过一个标识</strong>表示类中某个<strong>属性的类型</strong>或者是某个<strong>方法的返回值</strong>及<strong>参数类型</strong>。</li><li>这个类型参数将在使用时（例如，继<strong>承或实现这个接口，用这个类型声明变量、创建对象</strong>时）确定（即传入实际的类型参数，也称为类型实参）。</li></ol><p><strong>3.那么为什么要有泛型呢，直接Object不是也可以存储数据吗？</strong></p><ol><li>解决元素存储的安全性问题，好比商品、药品标签，不会弄错。</li><li>解决获取数据元素时，需要类型强制转换的问题，好比不用每回拿商品、药品都要辨别。</li><li>Java泛型可以保证如果程序在编译时没有发出警告，运行时就不会产生ClassCastException异常。同时，代码更加简洁、健壮。</li><li>由于数据类型的不确定性，因此使用泛型，提高代码的复用性</li></ol><h3 id="2-集合中使用泛型"><a href="#2-集合中使用泛型" class="headerlink" title="2.集合中使用泛型"></a>2.集合中使用泛型</h3><p>泛型的使用：jdk 5.0新增的特性</p><ol><li><p>在集合没有泛型之前出现的问题：</p><ul><li>问题一：添加数据时，有统一类型的需要，类型可以不一致的集合成为缺点</li><li>问题二：需要强转时，可能会出现类型转换异常ClassCastException</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ArrayList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        <span class="comment">//需求：存放学生的成绩</span></span><br><span class="line">        list.add(<span class="number">78</span>);</span><br><span class="line">        list.add(<span class="number">76</span>);</span><br><span class="line">        list.add(<span class="number">89</span>);</span><br><span class="line">        list.add(<span class="number">88</span>);</span><br><span class="line">        <span class="comment">//问题一：类型不安全</span></span><br><span class="line"><span class="comment">//        list.add(&quot;Tom&quot;);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(Object score : list)&#123;</span><br><span class="line">            <span class="comment">//问题二：强转时，可能出现ClassCastException</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">stuScore</span> <span class="operator">=</span> (Integer) score;</span><br><span class="line"></span><br><span class="line">            System.out.println(stuScore);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li><li><p>使用泛型后，会将这些问题解决。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> ArrayList&lt;Integer&gt; list =  <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">        list.add(<span class="number">78</span>);</span><br><span class="line">        list.add(<span class="number">87</span>);</span><br><span class="line">        list.add(<span class="number">99</span>);</span><br><span class="line">        list.add(<span class="number">65</span>);</span><br><span class="line">        <span class="comment">//编译时，就会进行类型检查，保证数据的安全</span></span><br><span class="line"><span class="comment">//        list.add(&quot;Tom&quot;);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//方式一：直接声明为Integer</span></span><br><span class="line">        <span class="keyword">for</span>(Integer score : list)&#123;</span><br><span class="line">            <span class="comment">//避免了强转操作</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">stuScore</span> <span class="operator">=</span> score;</span><br><span class="line"></span><br><span class="line">            System.out.println(stuScore);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//方式二：Iterator也是声明泛型接口</span></span><br><span class="line">        Iterator&lt;Integer&gt; iterator = list.iterator();</span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">stuScore</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">            System.out.println(stuScore);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>集合接口或集合类在jdk5.0时都修改为带泛型的结构。</p></li><li><p>在实例化集合类时，可以指明具体的泛型类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; list =  <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br></pre></td></tr></table></figure></li><li><p>如有声明多个泛型，则用逗号隔开。以Map接口中key - value为例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String,Integer&gt;();</span><br></pre></td></tr></table></figure></li><li><p>泛型可嵌套—遍历操作</p><p>有泛型的遍历操作：entrySet()返回所有key-value对构成的Set集合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Map.Entry&lt;String,Integer&gt;&gt; entry = map.entrySet();</span><br><span class="line">Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; iterator = entry.iterator();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">    Map.Entry&lt;String, Integer&gt; e = iterator.next();</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> e.getKey();</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">value</span> <span class="operator">=</span> e.getValue();</span><br><span class="line">    System.out.println(key + <span class="string">&quot;----&quot;</span> + value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>指明完以后，在集合类或接口中凡是定义类或接口时，内部结构（比如：方法、构造器、属性等）使用到类的泛型的位置，都指定为实例化的泛型类型。</p><p>比如：内部结构：add(E e)  —&gt;实例化以后：使用时：add(Integer e)</p></li><li><p><strong>注意点：泛型的类型必须是类，不能是基本数据类型。</strong>需要用到基本数据类型的位置，拿包装类替换</p></li><li><p>如果实例化时，没有指明泛型的类型。默认类型为java.lang.Object类型。</p></li></ol><h3 id="3-自定义泛型结构"><a href="#3-自定义泛型结构" class="headerlink" title="3.自定义泛型结构"></a>3.自定义泛型结构</h3><p>可自定义泛型类、泛型接口、泛型方法</p><h4 id="1-自定义泛型类注意点"><a href="#1-自定义泛型类注意点" class="headerlink" title="1.自定义泛型类注意点"></a>1.自定义泛型类注意点</h4><ol><li><p>泛型类可能有多个参数，此时应将多个参数一起放在尖括号内。比如：&lt;E1,E2,E3&gt;</p></li><li><p>泛型类的声明构造器时不需要加<E>声明</E></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public GenericClass()&#123;&#125;</span><br><span class="line"></span><br><span class="line">//错误的：public GenericClass&lt;E&gt;()&#123;&#125;</span><br></pre></td></tr></table></figure><p>形参中是可以用的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">T info ;</span><br><span class="line">public Person(T info) &#123;</span><br><span class="line">this.info = info; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>实例化后，操作原来泛型位置的结构必须与指定的泛型类型一致。</strong></p></li><li><p><strong>泛型不同的引用不能相互赋值。</strong>尽管在编译时ArrayList<String>和ArrayList<Integer>是两种类型，但是，在运行时只有一个ArrayList被加载到JVM中。</Integer></String></p></li><li><p><strong>泛型如果不指定，将被擦除，泛型对应的类型均按照Object处理，但不等价于Object。</strong></p><p>经验：泛型要使用一路都用。要不用，一路都不要用。</p></li><li><p>如果泛型结构是一个接口或抽象类，则不可创建泛型类的对象。</p><p>本质是接口和抽象类不能实例化，但是能做声明时使用–多态性</p></li><li><p>jdk1.7，泛型的简化操作：ArrayList<Fruit> flist &#x3D; new ArrayList&lt;&gt;();</Fruit></p></li><li><p>泛型的指定中不能使用基本数据类型，可以使用包装类替换。</p></li><li><p><strong>在类&#x2F;接口上声明的泛型，在本类或本接口中即代表某种类型，可以作为非静态属性的类型、非静态方法的参数类型、非静态方法的返回值类型。</strong></p><p>但在<strong>静态方法中不能使用类的泛型</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(T orderT)</span>&#123;  <span class="comment">//编译不通过</span></span><br><span class="line"><span class="comment">//        System.out.println(orderT);</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>异常类不能是泛型的</strong></p><p>错误的：try{ } catch(T e){ }</p></li><li><p><strong>不能直接使用new E[]。</strong></p><p>但是可以：E[] elements &#x3D; (E[])new Object[capacity];</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编译不通过</span></span><br><span class="line">T[] arr = <span class="keyword">new</span> <span class="title class_">T</span>[<span class="number">10</span>];</span><br><span class="line"><span class="comment">//编译通过</span></span><br><span class="line">T[] arr = (T[]) <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">10</span>];</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>参考：ArrayList源码中声明：Object[] elementData，而非泛型参数类型数组。</p></li><li><p><strong>父类有泛型，子类可以选择保留泛型也可以选择指定泛型类型：</strong></p><p>1.子类不保留父类的泛型：按需实现</p><ol><li><p>没有类型 擦除</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span>  <span class="keyword">extends</span> <span class="title class_">Father</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等价于class Son extends Father&lt;Object,Object&gt;&#123;    &#125;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span>&lt;T&gt;  <span class="keyword">extends</span> <span class="title class_">Father</span>&#123;  <span class="comment">//自已定义自己用</span></span><br></pre></td></tr></table></figure></li><li><p>具体类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Son2</span> <span class="keyword">extends</span> <span class="title class_">Father</span>&lt;Integer, String&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son2</span>&lt;A, B&gt; <span class="keyword">extends</span> <span class="title class_">Father</span>&lt;Integer, String&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;   <span class="comment">//自已定义自己用</span></span><br></pre></td></tr></table></figure></li></ol><p>2.子类保留父类的泛型：泛型子类</p><ol><li><p>全部保留</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Son3</span>&lt;T1, T2&gt; <span class="keyword">extends</span> <span class="title class_">Father</span>&lt;T1, T2&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son3</span>&lt;T1, T2, A, B&gt; <span class="keyword">extends</span> <span class="title class_">Father</span>&lt;T1, T2&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;   <span class="comment">//自已定义多余的自己用</span></span><br></pre></td></tr></table></figure></li><li><p>部分保留</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Son4</span>&lt;T2&gt; <span class="keyword">extends</span> <span class="title class_">Father</span>&lt;Integer, T2&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son4</span>&lt;T2, A, B&gt; <span class="keyword">extends</span> <span class="title class_">Father</span>&lt;Integer, T2&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;    <span class="comment">//自已定义多余的自己用</span></span><br></pre></td></tr></table></figure></li></ol><p>结论：子类必须是“富二代”，子类除了指定或保留父类的泛型，还可以增加自己的泛型。</p><p><strong>使用细节：父类有泛型时</strong></p><ol><li><p><strong>子类不保留的泛型，则在继承时父类一定要指明泛型类型，父类中用该泛型声明的变量也就确定了，进而子类继承的是指明后的父类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Son4</span> <span class="keyword">extends</span> <span class="title class_">Father</span>&lt; String&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure></li><li><p><strong>子类保留的泛型，则在继承时只需写出泛型形式<T></T></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Son4</span>&lt;T2&gt; <span class="keyword">extends</span> <span class="title class_">Father</span>&lt; T2&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;     </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son4</span>&lt;T2&gt; <span class="keyword">extends</span> <span class="title class_">Father</span>&lt;Integer, T2&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li></ol></li></ol><h4 id="2-自定义泛型方法"><a href="#2-自定义泛型方法" class="headerlink" title="2.自定义泛型方法"></a>2.自定义泛型方法</h4><p>如下的方法都不是泛型方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">getOrderT</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> orderT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setOrderT</span><span class="params">(T orderT)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.orderT = orderT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>泛型方法：</p><ol><li><p>在方法中出现了泛型的结构，泛型参数与类的泛型参数没有任何关系。</p><p>换句话说，<strong>泛型方法所属的类是不是泛型类都没有关系。</strong></p></li><li><p>泛型方法，<strong>可以声明为静态的。</strong></p><p>原因：泛型参数是在调用方法时确定的。并非在实例化类时确定。</p><ul><li>自定义泛型类中，泛型声明在类的声明中，可提供给属性，非静态方法使用，在new本类对象时指明就不会出错</li><li>自定义泛型类中，泛型方法声明在方法声明中，泛型方法所属的类是不是泛型类都没有关系，所以<strong>泛型方法可以是静态的也可以是非静态的</strong>，泛型参数是在调用方法时确定的。并非在实例化类时确定。</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//格式如下：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt;  List&lt;E&gt; <span class="title function_">copyFromArrayToList</span><span class="params">(E[] arr)</span>&#123; </span><br><span class="line"></span><br><span class="line">    ArrayList&lt;E&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(E e : arr)&#123;</span><br><span class="line">        list.add(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-泛型在继承方面的体现"><a href="#4-泛型在继承方面的体现" class="headerlink" title="4.泛型在继承方面的体现"></a>4.泛型在继承方面的体现</h3><ol><li><p>虽然类A是类B的父类，但是G<A> 和G<B>二者不具备子父类关系，二者是并列关系。</B></A></p></li><li><p>面向对象–具有子父类关系的可以相互赋值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">   <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">   obj = str;</span><br><span class="line">   </span><br><span class="line">   Object[] arr1 = <span class="literal">null</span>;</span><br><span class="line">   String[] arr2 = <span class="literal">null</span>;</span><br><span class="line">   arr1 = arr2; </span><br></pre></td></tr></table></figure><p>以下使用情况–二者是并列关系。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Object&gt; list1 = <span class="literal">null</span>;</span><br><span class="line">List&lt;String&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line"><span class="comment">//此时的list1和list2的类型不具有子父类关系</span></span><br><span class="line"><span class="comment">//编译不通过</span></span><br><span class="line"><span class="comment">//    list1 = list2;</span></span><br></pre></td></tr></table></figure></li><li><p>补充：类A是类B的父类，A<G> 是 B<G> 的父类</G></G></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list2 = <span class="literal">null</span>;</span><br><span class="line">ArrayList&lt;String&gt; list3 = <span class="literal">null</span>;</span><br><span class="line">   list2 = list3;</span><br></pre></td></tr></table></figure></li></ol><h3 id="5-通配符的使用"><a href="#5-通配符的使用" class="headerlink" title="5.通配符的使用"></a>5.通配符的使用</h3><p>1.出现背景</p><p>由于泛型不体现多态性，在调用方法方法形参和实参只能一对一，因此引入通配符，多个不同泛型对象可以使用一个通配符，这样就这可实现一个方法对多个对象了</p><p>2.说明</p><p>  通配符：?</p><p>  类A是类B的父类，G<A>和G<B>是没有关系的，二者共同的父类是：G&lt;?&gt;</B></A></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    List&lt;Object&gt; list1 = <span class="literal">null</span>;</span><br><span class="line">    List&lt;String&gt; list2 = <span class="literal">null</span>;</span><br><span class="line">    List&lt;?&gt; list = <span class="literal">null</span>;</span><br><span class="line">    list = list1;</span><br><span class="line">    list = list2;</span><br><span class="line">    <span class="comment">//编译通过</span></span><br><span class="line"><span class="comment">//    print(list1);</span></span><br><span class="line"><span class="comment">//    print(list2);</span></span><br><span class="line"><span class="comment">//此print方法声明：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(List&lt;?&gt; list)</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​     </p><p>3.使用通配符声明后的操作说明</p><ol><li><p><strong>添加(写入)：对于List&lt;?&gt;就不能向其内部添加数据。</strong></p><p>除了添加null之外。</p><p>list.add(“DD”);</p><p>list.add(‘?’);</p><p>list.add(null);</p></li><li><p><strong>获取(读取)：允许读取数据，读取的数据类型为Object</strong>。<br>Object o &#x3D; list.get(0);<br>System.out.println(o);</p></li></ol><p>4.有限制条件的通配符的使用</p><ol><li><p>? extends A:      理解：? &lt;&#x3D;  A  小于等于</p><p>G&lt;? extends A&gt; 可以作为G<A>和G<B>的父类，其中B是A的子类</B></A></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;? <span class="keyword">extends</span> <span class="title class_">Person</span>&gt; list1 = <span class="literal">null</span>;</span><br><span class="line">List&lt;Student&gt; list3 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Student&gt;();</span><br><span class="line">List&lt;Person&gt; list4 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Person&gt;();</span><br><span class="line">List&lt;Object&gt; list5 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Object&gt;();</span><br><span class="line">list1 = list3;</span><br><span class="line">list1 = list4</span><br></pre></td></tr></table></figure></li><li><p>? super A:         理解：? &gt;&#x3D;  A  大于等于</p><p>G&lt;? super A&gt; 可以作为G<A>和G<B>的父类，其中B是A的父类</B></A></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;? <span class="built_in">super</span> Person&gt; list2 = <span class="literal">null</span>;</span><br><span class="line">list2 = list4;</span><br><span class="line">list2 = list5;</span><br></pre></td></tr></table></figure></li><li><p>有限制条件通配符读取和写入数据 </p><p>读取数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> List&lt;? <span class="keyword">extends</span> <span class="title class_">Person</span>&gt; list1 = <span class="literal">null</span>;</span><br><span class="line"> List&lt;? <span class="built_in">super</span> Person&gt; list2 = <span class="literal">null</span>;</span><br><span class="line"> List&lt;Student&gt; list3 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Student&gt;();</span><br><span class="line"> List&lt;Person&gt; list4 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Person&gt;();</span><br><span class="line"> List&lt;Object&gt; list5 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Object&gt;();</span><br><span class="line"> list1 = list3;</span><br><span class="line"> <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> list1.get(<span class="number">0</span>);</span><br><span class="line"> <span class="comment">//编译不通过:返回值小于等于Person，因此用Person接收</span></span><br><span class="line">    <span class="comment">//Student s = list1.get(0);</span></span><br><span class="line">    list2 = list4;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> list2.get(<span class="number">0</span>);</span><br><span class="line">`</span><br><span class="line">    <span class="comment">//编译不通过：返回值大于等于Person，因此用Object接收</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">//Person obj = list2.get(0);</span></span><br></pre></td></tr></table></figure><p>写入数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编译不通过：list1不能写入数据，由于父类不能赋给子类，而？ extend A 小于等于A 所以当？是Student的子类不能赋Student</span></span><br><span class="line"><span class="comment">//  list1.add(new Student());</span></span><br><span class="line"><span class="comment">//编译通过：list2都可以写，由于大于等于，所以？是Person或Person的父类，所以可以赋Person和Person的子类</span></span><br><span class="line"> list2.add(<span class="keyword">new</span> <span class="title class_">Person</span>());</span><br><span class="line"> list2.add(<span class="keyword">new</span> <span class="title class_">Student</span>());</span><br></pre></td></tr></table></figure></li></ol><h2 id="6-IO流"><a href="#6-IO流" class="headerlink" title="6.IO流"></a>6.IO流</h2><h3 id="1-File类的使用"><a href="#1-File类的使用" class="headerlink" title="1.File类的使用"></a>1.File类的使用</h3><h4 id="1-介绍-1"><a href="#1-介绍-1" class="headerlink" title="1.介绍"></a>1.介绍</h4><ol><li>File类的一个对象，代表一个文件或一个文件目录(俗称：文件夹)</li><li>File类声明在java.io包下</li><li>File类中涉及到关于文件或文件目录的创建、删除、重命名、修改时间、文件大小等方法，并未涉及到写入或读取文件内容的操作。如果需要读取或写入文件内容，必须使用IO流来完成。后续File类的对象常会作为参数传递到流的构造器中，指明读取或写入的”终点”.</li></ol><h4 id="2-构造器介绍"><a href="#2-构造器介绍" class="headerlink" title="2.构造器介绍"></a>2.构造器介绍</h4><p><strong>1.两种路径说明</strong></p><ol><li><p>相对路径：相较于某个路径下，指明的路径。</p><p>File file1 &#x3D; new File(“hello.txt”);</p></li><li><p>绝对路径：包含盘符在内的文件或文件目录的路径</p><p>File file2 &#x3D;  new File(“D:\workspace_idea1\JavaSenior\day08\he.txt”);</p></li></ol><p>相对路径说明：</p><p>IDEA中：开发中使用JUnit单元测试方法测试，相对路径即为当前Module下。如果使用main( ) 测试，相对路径即为当前的Project下。</p><p>Eclipse中：不管使用单元测试还是使用main( ) 测试，相对路径都是当前的Project</p><p><strong>2.路径分隔符</strong><br> windows: \ <br> unix: &#x2F;</p><p> <strong>3.如何创建File类的实例</strong></p><ol><li><p>File(String filePath)—构造器1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">File file1 = new File(&quot;hello.txt&quot;);//相对于当前module</span><br><span class="line">File file2 =  new File(&quot;D:\\workspace_idea1\\JavaSenior\\day08\\he.txt&quot;);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>File(String parentPath,String childPath)—构造器2</p><p>File file3 &#x3D; new File(“D:\workspace_idea1”,”JavaSenior”);</p></li><li><p>File(File parentFile,String childPath)—构造器3</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">File file4 = new File(file3,&quot;hi.txt&quot;);</span><br><span class="line">   </span><br></pre></td></tr></table></figure></li></ol><h4 id="3-File中的常用方法"><a href="#3-File中的常用方法" class="headerlink" title="3.File中的常用方法"></a>3.File中的常用方法</h4><h5 id="1-获取File基本信息"><a href="#1-获取File基本信息" class="headerlink" title="1.获取File基本信息"></a>1.获取File基本信息</h5><ol><li><p>public String getAbsolutePath()</p><p>获取绝对路径</p></li><li><p>public String getPath() </p><p>获取路径</p></li><li><p>public String getName() </p><p>获取名称</p></li><li><p>public String getParent()</p><p>获取上层文件目录路径。若无，返回null</p></li><li><p>public long length() </p><p>获取文件长度（即：字节数）。不能获取目录的长度。</p></li><li><p>public long lastModified() </p><p>获取最后一次的修改时间，毫秒值–可用Date接收显示</p></li></ol><h5 id="2-获取文件目录"><a href="#2-获取文件目录" class="headerlink" title="2.获取文件目录"></a>2.获取文件目录</h5><ol><li>public String[] list() ：获取指定目录下的所有文件或者文件目录的名称数组</li><li>public File[] listFiles() ：获取指定目录下的所有文件或者文件目录的File数组</li></ol><h5 id="3-重命名文件路径"><a href="#3-重命名文件路径" class="headerlink" title="3.重命名文件路径"></a>3.重命名文件路径</h5><p> public boolean renameTo(File dest):把文件重命名为指定的文件路径</p><p>比如：file1.renameTo(file2)为例：要想保证返回true,需要file1在硬盘中是存在的，且file2不能在硬盘中存在。</p><h5 id="4-判断File基本信息"><a href="#4-判断File基本信息" class="headerlink" title="4.判断File基本信息"></a>4.判断File基本信息</h5><ol><li>public boolean isDirectory()：判断是否是文件目录</li><li>public boolean isFile() ：判断是否是文件</li><li>public boolean exists() ：判断是否存在</li><li>public boolean canRead() ：判断是否可读</li><li>public boolean canWrite() ：判断是否可写</li><li>public boolean isHidden() ：判断是否隐藏</li></ol><h5 id="5-创建硬盘中对应的文件或文件目录"><a href="#5-创建硬盘中对应的文件或文件目录" class="headerlink" title="5.创建硬盘中对应的文件或文件目录"></a>5.创建硬盘中对应的文件或文件目录</h5><ol><li><p>public  boolean createNewFile() —会报异常</p><p>创建文件。若文件存在，则不创建，返回false</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">File file1 = new File(&quot;hi.txt&quot;);</span><br><span class="line">if(!file1.exists())&#123;</span><br><span class="line">     //文件的创建</span><br><span class="line">     file1.createNewFile();</span><br><span class="line">     System.out.println(&quot;创建成功&quot;);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>public boolean mkdir() </p><p>创建文件目录。如果此文件目录存在，就不创建了。<strong>如果此文件目录的上层目录不存在，也不创建。</strong></p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> //文件目录的创建</span><br><span class="line">File file1 = new File(&quot;d:\\io\\io1\\io3&quot;);</span><br><span class="line"> boolean mkdir = file1.mkdir();</span><br><span class="line">  if(mkdir)&#123;</span><br><span class="line">      System.out.println(&quot;创建成功1&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li><p>public boolean mkdirs() </p><p>创建文件目录。如果此文件目录存在，就不创建了。<strong>如果上层文件目录不存在，一并创建</strong></p></li></ol><h5 id="6-删除磁盘中的文件或文件目录"><a href="#6-删除磁盘中的文件或文件目录" class="headerlink" title="6.删除磁盘中的文件或文件目录"></a>6.删除磁盘中的文件或文件目录</h5><p>public boolean delete()：删除文件或者文件夹</p><p>删除注意事项：</p><ol><li>Java中的删除不走回收站。</li><li>删除目录：只能删除空目录，该目录下不能有子目录或文件</li></ol><h3 id="2-IO原理及流的分类"><a href="#2-IO原理及流的分类" class="headerlink" title="2. IO原理及流的分类"></a>2. IO原理及流的分类</h3><h4 id="1-IO原理介绍"><a href="#1-IO原理介绍" class="headerlink" title="1.IO原理介绍"></a>1.IO原理介绍</h4><ol><li>I&#x2F;O是Input&#x2F;Output的缩写， I&#x2F;O技术是非常实用的技术，<strong>用于处理设备之间的数据传输</strong>。如读&#x2F;写文件，网络通讯等。</li><li>Java程序中，对于数据的输入&#x2F;输出操作以“流(stream)” 的方式进行。</li><li>java.io包下提供了各种“流”类和接口，用以获取不同种类的数据，并<strong>通过标准的方法</strong>输入或输出数据</li><li>输入（读入）input：<strong>读取外部数据</strong>（磁盘、光盘等存储设备的数据）<strong>到程序（内存）中</strong>。</li><li>输出（写出）output：<strong>将程序（内存）数据输出到磁盘、光盘等存储设备</strong>中</li></ol><h4 id="2-流的分类"><a href="#2-流的分类" class="headerlink" title="2.流的分类"></a>2.流的分类</h4><h5 id="1-流的分类"><a href="#1-流的分类" class="headerlink" title="1.流的分类"></a>1.流的分类</h5><ol><li><p>按操作<strong>数据单位</strong>不同分为：字节流(8 bit)，字符流(16 bit)</p><p>字节流：是操作进制数表示的数据（如：图片）</p><p>字符流：是来操作字符数据（如：文件）</p></li><li><p>按数据流的<strong>流向</strong>不同分为：输入流，输出流</p></li><li><p>按流的<strong>角色</strong>的不同分为：节点流，处理流</p><p>节点流：直接操作流的传输</p><p>处理流：对流的传输加以修饰（如：加速传输）</p></li></ol><p><strong>图示：在操作中的位置</strong></p><p><img src="/2022/08/30/Java%E9%AB%98%E7%BA%A7-%E9%9B%86%E5%90%88-%E6%B3%9B%E5%9E%8B-IO%E6%B5%81/img%5CSnipaste_2022-02-06_20-59-41.png" alt="Snipaste_2022-02-06_20-59-41"></p><p><strong>字节流和字符流使用结论：</strong></p><ol><li>对于文本文件(.txt,.java,.c,.cpp)，使用字符流处理</li><li>对于非文本文件(.jpg,.mp3,.mp4,.avi,.doc,.ppt,…)，使用字节流处理</li><li><strong>如果只是单纯的复制文本文件，字节流也可处理，只不过用字符流更高效</strong></li></ol><h5 id="2-流的体系结构"><a href="#2-流的体系结构" class="headerlink" title="2.流的体系结构"></a>2.流的体系结构</h5><p>一、Java的IO流共涉及40多个类，实际上非常规则，<strong>都是从如下4个抽象基类派生的。</strong></p><table><thead><tr><th>抽象基类</th><th>字节流</th><th>字符流</th></tr></thead><tbody><tr><td>输入流</td><td>InputStream</td><td>Reader</td></tr><tr><td>输出流</td><td>OutputStream</td><td>Writer</td></tr></tbody></table><p>二、由这四个类派生出来的子类名称都是以其父类名作为子类名后缀</p><p><img src="/2022/08/30/Java%E9%AB%98%E7%BA%A7-%E9%9B%86%E5%90%88-%E6%B3%9B%E5%9E%8B-IO%E6%B5%81/img%5CSnipaste_2022-02-07_21-34-55.png" alt="Snipaste_2022-02-07_21-34-55"></p><p>三、列举最基本的流</p><p>抽象基类</p><ol><li>InputStream</li><li>OutputStream</li><li>Reader</li><li>Writer</li></ol><p>节点流（或文件流） –后加使用时对应的读写方法</p><ol><li>FileInputStream  (read(byte[] buffer))</li><li>FileOutputStream    (write(byte[] buffer,0,len)</li><li>FileReader    (read(char[] cbuf))</li><li>FileWriter    (write(char[] cbuf,0,len)</li></ol><p>缓冲流（处理流的一种）–后加使用时对应的读写方法</p><ol><li>BufferedInputStream    (read(byte[] buffer))</li><li>BufferedOutputStream    (write(byte[] buffer,0,len) &#x2F; flush()</li><li>BufferedReader    (read(char[] cbuf) &#x2F; readLine())</li><li>BufferedWriter    (write(char[] cbuf,0,len) &#x2F; flush()</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">抽象基类         节点流（或文件流）                               缓冲流（处理流的一种）</span><br><span class="line">*               </span><br><span class="line">*      </span><br><span class="line">*                            </span><br><span class="line">*                     </span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-节点流-或文件流"><a href="#3-节点流-或文件流" class="headerlink" title="3.节点流(或文件流)"></a>3.节点流(或文件流)</h3><h4 id="一、共有四种节点流"><a href="#一、共有四种节点流" class="headerlink" title="一、共有四种节点流"></a>一、共有四种节点流</h4><ol><li><p>字节流读入写出</p><p>FileInputStream  ： (read(byte[] buffer))          </p><p>FileOutputStream  ：(write(byte[] buffer,0,len)  </p></li><li><p>字符流读入写出</p><p>FileReader ：(read(char[] cbuf))                 </p><p>FileWriter： (write(char[] cbuf,0,len))</p></li></ol><h4 id="二、字符流读写演示"><a href="#二、字符流读写演示" class="headerlink" title="二、字符流读写演示"></a>二、字符流读写演示</h4><p>读写方法：</p><ol><li>read()返回Ascll码值，没有返回-1&#x2F;writer(String str)</li><li>read(char[] cbuf)&#x2F;write(char[] cbuf,0,len) – 常用这个</li></ol><h5 id="1-FileReader"><a href="#1-FileReader" class="headerlink" title="1.FileReader"></a>1.FileReader</h5><p><strong>说明点：</strong></p><ol><li>read()的理解：返回读入的一个字符。如果达到文件末尾，返回-1</li><li>异常的处理：为了保证流资源一定可以执行关闭操作。需要使用try-catch-finally处理</li><li>读入的文件一定要存在，否则就会报FileNotFoundException。</li></ol><p>代码及步骤演示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">一般不使用read（）空参方法，而是使用带参重载的</span><br><span class="line"></span><br><span class="line">//将day09下的hello.txt文件内容读入程序中，并输出到控制台</span><br><span class="line">FileReader fr = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            //1.实例化File类的对象，指明要操作的文件</span><br><span class="line">            File file = new File(&quot;hello.txt&quot;);//相较于当前Module</span><br><span class="line">            //2.提供具体的流</span><br><span class="line">            fr = new FileReader(file);</span><br><span class="line"></span><br><span class="line">            //3.数据的读入</span><br><span class="line">            //read():返回读入的一个字符。如果达到文件末尾，返回-1   </span><br><span class="line">            int data;</span><br><span class="line">            while((data = fr.read()) != -1)&#123;</span><br><span class="line">                System.out.print((char)data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            //4.流的关闭操作</span><br><span class="line">            if(fr != null)&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    fr.close();</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>由于上述对操作每次只读一个字符速度过慢，可使用read()操作升级：使用read的重载方法read(char[] cbuf)读入字符数组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"> 对read()操作升级：使用read的重载方法</span><br><span class="line">    @Test</span><br><span class="line">    public void testFileReader1()  &#123;</span><br><span class="line">        FileReader fr = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            //1.File类的实例化</span><br><span class="line">            File file = new File(&quot;hello.txt&quot;);</span><br><span class="line"></span><br><span class="line">            //2.FileReader流的实例化</span><br><span class="line">            fr = new FileReader(file);</span><br><span class="line"></span><br><span class="line">            //3.读入的操作</span><br><span class="line">            //read(char[] cbuf):返回每次读入cbuf数组中的字符的个数。如果达到文件末尾，返回-1</span><br><span class="line"> 由于最后读入的数据可能不超过5，防止最后输出之前输出过的数据，所以用len记录个数便于输出</span><br><span class="line">            char[] cbuf = new char[5];</span><br><span class="line">            int len;</span><br><span class="line">            while((len = fr.read(cbuf)) != -1)&#123;</span><br><span class="line">                </span><br><span class="line">                //正确的写法--for循环</span><br><span class="line">//                for(int i = 0;i &lt; len;i++)&#123;</span><br><span class="line">//                    System.out.print(cbuf[i]);</span><br><span class="line">//                &#125;</span><br><span class="line">   </span><br><span class="line">                //正确的写法--使用String给的构造器</span><br><span class="line">                String str = new String(cbuf,0,len);</span><br><span class="line">                System.out.print(str);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if(fr != null)&#123;</span><br><span class="line">                //4.资源的关闭</span><br><span class="line">                try &#123;</span><br><span class="line">                    fr.close();</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="2-FileWriter"><a href="#2-FileWriter" class="headerlink" title="2.FileWriter"></a>2.FileWriter</h5><p><strong>说明：</strong></p><ol><li>输出操作，对应的File可以不存在的。并不会报异常</li><li>File对应的硬盘中的文件如果不存在，在输出的过程中，会自动创建此文件。</li><li>File对应的硬盘中的文件如果存在：<ol><li>如果流使用的构造器是：FileWriter(file,false) &#x2F; FileWriter(file):对原有文件的覆盖</li><li>如果流使用的构造器是：FileWriter(file,true):不会对原有文件覆盖，而是在原有文件基础上追加内容</li></ol></li></ol><p>代码演示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">//从内存中写出数据到硬盘的文件里。</span><br><span class="line">@Test</span><br><span class="line">public void testFileWriter() &#123;</span><br><span class="line">    FileWriter fw = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        //1.提供File类的对象，指明写出到的文件</span><br><span class="line">        File file = new File(&quot;hello1.txt&quot;);</span><br><span class="line"></span><br><span class="line">        //2.提供FileWriter的对象，用于数据的写出</span><br><span class="line">        fw = new FileWriter(file,false);</span><br><span class="line"></span><br><span class="line">        //3.写出的操作</span><br><span class="line">        fw.write(&quot;I have a dream!\n&quot;);</span><br><span class="line">        fw.write(&quot;you need to have a dream!&quot;);</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        //4.流资源的关闭</span><br><span class="line">        if(fw != null)&#123;</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                fw.close();</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="3-复制文本数据操作"><a href="#3-复制文本数据操作" class="headerlink" title="3.复制文本数据操作"></a>3.复制文本数据操作</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public void testFileReaderFileWriter() &#123;</span><br><span class="line">        FileReader fr = null;</span><br><span class="line">        FileWriter fw = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            //1.创建File类的对象，指明读入和写出的文件</span><br><span class="line">            File srcFile = new File(&quot;hello.txt&quot;);</span><br><span class="line">            File destFile = new File(&quot;hello2.txt&quot;);</span><br><span class="line"></span><br><span class="line">            //不能使用字符流来处理图片等字节数据</span><br><span class="line">//            File srcFile = new File(&quot;爱情与友情.jpg&quot;);</span><br><span class="line">//            File destFile = new File(&quot;爱情与友情1.jpg&quot;);</span><br><span class="line"></span><br><span class="line">            //2.创建输入流和输出流的对象</span><br><span class="line">            fr = new FileReader(srcFile);</span><br><span class="line">            fw = new FileWriter(destFile);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            //3.数据的读入和写出操作</span><br><span class="line">            char[] cbuf = new char[5];</span><br><span class="line">            int len;//记录每次读入到cbuf数组中的字符的个数</span><br><span class="line">            while((len = fr.read(cbuf)) != -1)&#123;</span><br><span class="line">                //每次写出len个字符</span><br><span class="line">                fw.write(cbuf,0,len);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            //4.关闭流资源</span><br><span class="line">            try &#123;</span><br><span class="line">                if(fw != null)</span><br><span class="line">                    fw.close();</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                if(fr != null)</span><br><span class="line">                    fr.close();</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="三、字节流读入演示"><a href="#三、字节流读入演示" class="headerlink" title="三、字节流读入演示"></a>三、字节流读入演示</h4><p>读写方法：</p><p>read(byte[] buffer)   和  write(byte[] buffer,0,len)</p><h5 id="1-FileInputStream"><a href="#1-FileInputStream" class="headerlink" title="1.FileInputStream"></a>1.FileInputStream</h5><p> FileOutputStream操作在复制图片演示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">//使用字节流FileInputStream处理文本文件，可能出现乱码。</span><br><span class="line">@Test</span><br><span class="line">public void testFileInputStream() &#123;</span><br><span class="line">    FileInputStream fis = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        //1. 造文件</span><br><span class="line">        File file = new File(&quot;hello.txt&quot;);</span><br><span class="line"></span><br><span class="line">        //2.造流</span><br><span class="line">        fis = new FileInputStream(file);</span><br><span class="line"></span><br><span class="line">        //3.读数据</span><br><span class="line">        byte[] buffer = new byte[5];</span><br><span class="line">        int len;//记录每次读取的字节的个数</span><br><span class="line">        while((len = fis.read(buffer)) != -1)&#123;</span><br><span class="line"></span><br><span class="line">            String str = new String(buffer,0,len);</span><br><span class="line">            System.out.print(str);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if(fis != null)&#123;</span><br><span class="line">            //4.关闭资源</span><br><span class="line">            try &#123;</span><br><span class="line">                fis.close();</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="2-复制图片数据"><a href="#2-复制图片数据" class="headerlink" title="2.复制图片数据"></a>2.复制图片数据</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testFileInputOutputStream()  &#123;</span><br><span class="line">    FileInputStream fis = null;</span><br><span class="line">    FileOutputStream fos = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        //</span><br><span class="line">        File srcFile = new File(&quot;爱情与友情.jpg&quot;);</span><br><span class="line">        File destFile = new File(&quot;爱情与友情2.jpg&quot;);</span><br><span class="line"></span><br><span class="line">        //</span><br><span class="line">        fis = new FileInputStream(srcFile);</span><br><span class="line">        fos = new FileOutputStream(destFile);</span><br><span class="line"></span><br><span class="line">        //复制的过程</span><br><span class="line">        byte[] buffer = new byte[5];</span><br><span class="line">        int len;</span><br><span class="line">        while((len = fis.read(buffer)) != -1)&#123;</span><br><span class="line">            fos.write(buffer,0,len);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if(fos != null)&#123;</span><br><span class="line">            //</span><br><span class="line">            try &#123;</span><br><span class="line">                fos.close();</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(fis != null)&#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                fis.close();</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="4-缓冲流-处理流之一"><a href="#4-缓冲流-处理流之一" class="headerlink" title="4.缓冲流(处理流之一)"></a>4.缓冲流(处理流之一)</h3><h4 id="一、共有四种缓冲流"><a href="#一、共有四种缓冲流" class="headerlink" title="一、共有四种缓冲流"></a>一、共有四种缓冲流</h4><p>1.缓冲流（处理流的一种）–后加使用时对应的读写方法</p><ol><li>BufferedInputStream    (read(byte[] buffer))</li><li>BufferedOutputStream    (write(byte[] buffer,0,len) &#x2F; flush()</li><li>BufferedReader    (read(char[] cbuf) &#x2F; readLine())</li><li>BufferedWriter    (write(char[] cbuf,0,len) &#x2F; flush()</li></ol><p>flush() : 刷新缓冲区 —writer内部方法已经调用为加速写出，这里只作了解</p><p>readLine() : 读入一行文本数据，但不自动换行，以下是换行方法</p><ol><li>readLine(流 + “\n”)</li><li>在使用后调用一次newLine()</li></ol><p>2.作用：提供流的读取、写入的速度</p><p>提高读写速度的原因：内部提供了一个缓冲区</p><p>3.处理流，就是“套接”在已有的流的基础上。</p><h4 id="二、复制非文本文件"><a href="#二、复制非文本文件" class="headerlink" title="二、复制非文本文件"></a>二、复制非文本文件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">实现非文本文件的复制 BufferedInputStream和BufferedOutputStream </span><br><span class="line">   </span><br><span class="line">    @Test</span><br><span class="line">    public void BufferedStreamTest() throws FileNotFoundException &#123;</span><br><span class="line">        BufferedInputStream bis = null;</span><br><span class="line">        BufferedOutputStream bos = null;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            //1.造文件</span><br><span class="line">            File srcFile = new File(&quot;爱情与友情.jpg&quot;);</span><br><span class="line">            File destFile = new File(&quot;爱情与友情3.jpg&quot;);</span><br><span class="line">            //2.造流</span><br><span class="line">            //2.1 造节点流</span><br><span class="line">      FileInputStream fis = new FileInputStream((srcFile));</span><br><span class="line">      FileOutputStream fos = new FileOutputStream(destFile);</span><br><span class="line">            //2.2 造缓冲流</span><br><span class="line">            bis = new BufferedInputStream(fis);</span><br><span class="line">            bos = new BufferedOutputStream(fos);</span><br><span class="line"></span><br><span class="line">            //3.复制的细节：读取、写入</span><br><span class="line">            byte[] buffer = new byte[10];</span><br><span class="line">            int len;</span><br><span class="line">            while((len = bis.read(buffer)) != -1)&#123;</span><br><span class="line">                bos.write(buffer,0,len);</span><br><span class="line">//                bos.flush();//刷新缓冲区--不需要调用</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            //4.资源关闭</span><br><span class="line">            //要求：先关闭外层的流，再关闭内层的流</span><br><span class="line">            if(bos != null)&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    bos.close();</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            if(bis != null)&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    bis.close();</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            //说明：关闭外层流的同时，内层流也会自动的进行关闭。关于内层流的关闭，我们可以省略.</span><br><span class="line">//        fos.close();</span><br><span class="line">//        fis.close();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="三、复制文本文件"><a href="#三、复制文本文件" class="headerlink" title="三、复制文本文件"></a>三、复制文本文件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">    使用BufferedReader和BufferedWriter实现文本文件的复制</span><br><span class="line"></span><br><span class="line">     */</span><br><span class="line">    @Test</span><br><span class="line">    public void testBufferedReaderBufferedWriter()&#123;</span><br><span class="line">        BufferedReader br = null;</span><br><span class="line">        BufferedWriter bw = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            //创建文件和相应的流---匿名方式简单创建</span><br><span class="line">         br = new BufferedReader(new FileReader(new File(&quot;dbcp.txt&quot;)));</span><br><span class="line">         bw = new BufferedWriter(new FileWriter(new File(&quot;dbcp1.txt&quot;)));</span><br><span class="line"></span><br><span class="line">            //读写操作</span><br><span class="line">            //方式一：使用char[]数组</span><br><span class="line">//            char[] cbuf = new char[1024];</span><br><span class="line">//            int len;</span><br><span class="line">//            while((len = br.read(cbuf)) != -1)&#123;</span><br><span class="line">//                bw.write(cbuf,0,len);</span><br><span class="line">//    //            bw.flush();</span><br><span class="line">//            &#125;</span><br><span class="line"> </span><br><span class="line">            //方式二：使用String   readLine()</span><br><span class="line">            String data;</span><br><span class="line">            while((data = br.readLine()) != null)&#123;</span><br><span class="line">                //方法一：</span><br><span class="line">//                bw.write(data + &quot;\n&quot;);//data中不包含换行符</span><br><span class="line">                //方法二：</span><br><span class="line">                bw.write(data);//data中不包含换行符</span><br><span class="line">                bw.newLine();//提供换行的操作</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            //关闭资源</span><br><span class="line">            if(bw != null)&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    bw.close();</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if(br != null)&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    br.close();</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="四、复制视频及对比节点流和缓冲流速度"><a href="#四、复制视频及对比节点流和缓冲流速度" class="headerlink" title="四、复制视频及对比节点流和缓冲流速度"></a>四、复制视频及对比节点流和缓冲流速度</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">这里只列举了缓冲流复制视频，也有测试结果//618 和 176</span><br><span class="line">public void copyFileWithBuffered(String srcPath,String destPath)&#123;</span><br><span class="line">        BufferedInputStream bis = null;</span><br><span class="line">        BufferedOutputStream bos = null;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            //1.造文件</span><br><span class="line">            File srcFile = new File(srcPath);</span><br><span class="line">            File destFile = new File(destPath);</span><br><span class="line">            //2.造流</span><br><span class="line">            //2.1 造节点流</span><br><span class="line">            FileInputStream fis = new FileInputStream((srcFile));</span><br><span class="line">            FileOutputStream fos = new FileOutputStream(destFile);</span><br><span class="line">            //2.2 造缓冲流</span><br><span class="line">            bis = new BufferedInputStream(fis);</span><br><span class="line">            bos = new BufferedOutputStream(fos);</span><br><span class="line"></span><br><span class="line">            //3.复制的细节：读取、写入</span><br><span class="line">            byte[] buffer = new byte[1024];</span><br><span class="line">            int len;</span><br><span class="line">            while((len = bis.read(buffer)) != -1)&#123;</span><br><span class="line">                bos.write(buffer,0,len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            //4.资源关闭</span><br><span class="line">            //要求：先关闭外层的流，再关闭内层的流</span><br><span class="line">            if(bos != null)&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    bos.close();</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if(bis != null)&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    bis.close();</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    @Test</span><br><span class="line">    public void testCopyFileWithBuffered()&#123;</span><br><span class="line">        long start = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        String srcPath = &quot;C:\\Users\\Administrator\\Desktop\\01-视频.avi&quot;;</span><br><span class="line">        String destPath = &quot;C:\\Users\\Administrator\\Desktop\\03-视频.avi&quot;;</span><br><span class="line"></span><br><span class="line">        copyFileWithBuffered(srcPath,destPath);</span><br><span class="line"></span><br><span class="line">        long end = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;复制操作花费的时间为：&quot; + (end - start));//618 - 176</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="课后练习题之加密解密图片"><a href="#课后练习题之加密解密图片" class="headerlink" title="课后练习题之加密解密图片"></a>课后练习题之加密解密图片</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">//图片的加密</span><br><span class="line">@Test</span><br><span class="line">public void test1() &#123;</span><br><span class="line"></span><br><span class="line">    FileInputStream fis = null;</span><br><span class="line">    FileOutputStream fos = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        fis = new FileInputStream(&quot;爱情与友情.jpg&quot;);</span><br><span class="line">        fos = new FileOutputStream(&quot;爱情与友情secret.jpg&quot;);</span><br><span class="line"></span><br><span class="line">        byte[] buffer = new byte[20];</span><br><span class="line">        int len;</span><br><span class="line">        while ((len = fis.read(buffer)) != -1) &#123;</span><br><span class="line">     //主要代码：利用异或，同0不同1 有规律的改变字节       </span><br><span class="line">            for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">                buffer[i] = (byte) (buffer[i] ^ 5);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fos.write(buffer, 0, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (fos != null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                fos.close();</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (fis != null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                fis.close();</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//图片的解密</span><br><span class="line">@Test</span><br><span class="line">public void test2() &#123;</span><br><span class="line"></span><br><span class="line">    FileInputStream fis = null;</span><br><span class="line">    FileOutputStream fos = null;</span><br><span class="line">    try &#123; //调换位置</span><br><span class="line">        fis = new FileInputStream(&quot;爱情与友情secret.jpg&quot;);</span><br><span class="line">        fos = new FileOutputStream(&quot;爱情与友情4.jpg&quot;);</span><br><span class="line"></span><br><span class="line">        byte[] buffer = new byte[20];</span><br><span class="line">        int len;</span><br><span class="line">        while ((len = fis.read(buffer)) != -1) &#123;</span><br><span class="line">         //在用异或一次相同数，就可进行解密</span><br><span class="line">            for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">                buffer[i] = (byte) (buffer[i] ^ 5);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fos.write(buffer, 0, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (fos != null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                fos.close();</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (fis != null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                fis.close();</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="获取文本上字符出现的次数"><a href="#获取文本上字符出现的次数" class="headerlink" title="获取文本上字符出现的次数"></a>获取文本上字符出现的次数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">练习3:获取文本上字符出现的次数,把数据写入文件</span><br><span class="line"> *</span><br><span class="line"> * 思路：</span><br><span class="line"> * 1.遍历文本每一个字符</span><br><span class="line"> * 2.字符出现的次数存在Map中</span><br><span class="line"> *</span><br><span class="line"> * Map&lt;Character,Integer&gt; map = new HashMap&lt;Character,Integer&gt;();</span><br><span class="line"> * map.put(&#x27;a&#x27;,18);</span><br><span class="line"> * map.put(&#x27;你&#x27;,2);</span><br><span class="line"> *</span><br><span class="line"> * 3.把map中的数据写入文件</span><br><span class="line"> *</span><br><span class="line"> * @author shkstart</span><br><span class="line"> * @create 2019 下午 3:47</span><br><span class="line"> */</span><br><span class="line">public class WordCount &#123;</span><br><span class="line">    /*</span><br><span class="line">    说明：如果使用单元测试，文件相对路径为当前module</span><br><span class="line">          如果使用main()测试，文件相对路径为当前工程</span><br><span class="line">     */</span><br><span class="line">    @Test</span><br><span class="line">    public void testWordCount() &#123;</span><br><span class="line">        FileReader fr = null;</span><br><span class="line">        BufferedWriter bw = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            //1.创建Map集合</span><br><span class="line">            Map&lt;Character, Integer&gt; map = new HashMap&lt;Character, Integer&gt;();</span><br><span class="line"></span><br><span class="line">            //2.遍历每一个字符,每一个字符出现的次数放到map中</span><br><span class="line">            fr = new FileReader(&quot;dbcp.txt&quot;);</span><br><span class="line">            int c = 0;</span><br><span class="line">            while ((c = fr.read()) != -1) &#123;</span><br><span class="line">                //int 还原 char</span><br><span class="line">                char ch = (char) c;</span><br><span class="line">                // 判断char是否在map中第一次出现</span><br><span class="line">                if (map.get(ch) == null) &#123;</span><br><span class="line">                    map.put(ch, 1);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    map.put(ch, map.get(ch) + 1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //3.把map中数据存在文件count.txt</span><br><span class="line">            //3.1 创建Writer</span><br><span class="line">            bw = new BufferedWriter(new FileWriter(&quot;wordcount.txt&quot;));</span><br><span class="line"></span><br><span class="line">            //3.2 遍历map,再写入数据</span><br><span class="line">            Set&lt;Map.Entry&lt;Character, Integer&gt;&gt; entrySet = map.entrySet();</span><br><span class="line">            for (Map.Entry&lt;Character, Integer&gt; entry : entrySet) &#123;</span><br><span class="line">                switch (entry.getKey()) &#123;</span><br><span class="line">                    case &#x27; &#x27;:</span><br><span class="line">                        bw.write(&quot;空格=&quot; + entry.getValue());</span><br><span class="line">                        break;</span><br><span class="line">                    case &#x27;\t&#x27;://\t表示tab 键字符</span><br><span class="line">                       bw.write(&quot;tab键=&quot; + entry.getValue());</span><br><span class="line">                        break;</span><br><span class="line">                    case &#x27;\r&#x27;:</span><br><span class="line">                        bw.write(&quot;回车=&quot; + entry.getValue());</span><br><span class="line">                        break;</span><br><span class="line">                    case &#x27;\n&#x27;:</span><br><span class="line">                        bw.write(&quot;换行=&quot; + entry.getValue());</span><br><span class="line">                        break;</span><br><span class="line">                    default:</span><br><span class="line">          bw.write(entry.getKey() + &quot;=&quot; + entry.getValue());</span><br><span class="line">                        break;</span><br><span class="line">                &#125;</span><br><span class="line">                bw.newLine();//每次弄一次换行</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            //4.关流</span><br><span class="line">            if (fr != null) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    fr.close();</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            if (bw != null) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    bw.close();</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="5-转换流-处理流之二"><a href="#5-转换流-处理流之二" class="headerlink" title="5.转换流(处理流之二)"></a>5.转换流(处理流之二)</h3><h4 id="1-转换流介绍"><a href="#1-转换流介绍" class="headerlink" title="1.转换流介绍"></a>1.转换流介绍</h4><p><strong>1.转换流：属于字符流—看后缀</strong></p><ol><li>InputStreamReader：将一个字节的输入流转换为字符的输入流</li><li>OutputStreamWriter：将一个字符的输出流转换为字节的输出流</li></ol><p><strong>2.作用：</strong></p><ol><li>提供字节流与字符流之间的转换</li><li>字节流中的数据都是字符时，转成字符流操作更高效。 </li><li>很多时候我们使用转换流来处理文件乱码问题。实现编码和解码的功能<ol><li>解码：字节、字节数组  —&gt;字符数组、字符串</li><li>编码：字符数组、字符串 —&gt; 字节、字节数组</li></ol></li></ol><p>3.转换过程图示：</p><p><img src="/2022/08/30/Java%E9%AB%98%E7%BA%A7-%E9%9B%86%E5%90%88-%E6%B3%9B%E5%9E%8B-IO%E6%B5%81/img%5CSnipaste_2022-02-07_17-43-10.png" alt="Snipaste_2022-02-07_17-43-10"></p><h4 id="2-转换流的使用"><a href="#2-转换流的使用" class="headerlink" title="2.转换流的使用"></a>2.转换流的使用</h4><p>一、InputStreamReader的使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">为清晰看代码此时处理异常的话，仍然应该使用try-catch-finally</span><br><span class="line">InputStreamReader的使用，实现字节的输入流到字符的输入流的转换</span><br><span class="line">     */</span><br><span class="line">    @Test</span><br><span class="line">    public void test1() throws IOException &#123;</span><br><span class="line"></span><br><span class="line">     FileInputStream fis = new FileInputStream(&quot;dbcp.txt&quot;);</span><br><span class="line">//   InputStreamReader isr = new InputStreamReader(fis);//使用系统默认的字符集</span><br><span class="line">//参数2指明了字符集，具体使用哪个字符集，取决于文件dbcp.txt保存时使用的字符集，这里使用系统默认的字符集</span><br><span class="line">InputStreamReader isr = new InputStreamReader(fis,&quot;UTF-8&quot;);</span><br><span class="line">      </span><br><span class="line">        char[] cbuf = new char[20];</span><br><span class="line">        int len;</span><br><span class="line">        while((len = isr.read(cbuf)) != -1)&#123;</span><br><span class="line">            String str = new String(cbuf,0,len);</span><br><span class="line">            System.out.print(str);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        isr.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>二、综合使用InputStreamReader和OutputStreamWriter</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">此时处理异常的话，仍然应该使用try-catch-finally</span><br><span class="line"></span><br><span class="line">综合使用InputStreamReader和OutputStreamWriter</span><br><span class="line"> */</span><br><span class="line">@Test</span><br><span class="line">public void test2() throws Exception &#123;</span><br><span class="line">    //1.造文件、造流</span><br><span class="line">    File file1 = new File(&quot;dbcp.txt&quot;);</span><br><span class="line">    File file2 = new File(&quot;dbcp_gbk.txt&quot;);</span><br><span class="line"></span><br><span class="line">    FileInputStream fis = new FileInputStream(file1);</span><br><span class="line">    FileOutputStream fos = new FileOutputStream(file2);</span><br><span class="line"></span><br><span class="line"> InputStreamReader isr = new InputStreamReader(fis,&quot;utf-8&quot;);</span><br><span class="line"> OutputStreamWriter osw = new OutputStreamWriter(fos,&quot;gbk&quot;);</span><br><span class="line">//写出时可自己选择字符集</span><br><span class="line"></span><br><span class="line">    //2.读写过程</span><br><span class="line">    char[] cbuf = new char[20];</span><br><span class="line">    int len;</span><br><span class="line">    while((len = isr.read(cbuf)) != -1)&#123;</span><br><span class="line">        osw.write(cbuf,0,len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //3.关闭资源</span><br><span class="line">    isr.close();</span><br><span class="line">    osw.close();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="3-多种字符编码集"><a href="#3-多种字符编码集" class="headerlink" title="3.多种字符编码集"></a>3.多种字符编码集</h4><p>1.常见种类</p><ol><li>ASCII：美国标准信息交换码，用一个字节的7位可以表示。</li><li>ISO8859-1：拉丁码表。欧洲码表，用一个字节的8位表示。</li><li>GB2312：中国的中文编码表，最多两个字节编码所有字符</li><li>GBK：中国的中文编码表升级，融合了更多的中文文字符号。最多两个字节编码</li><li>Unicode：国际标准码，融合了目前人类使用的所有字符。为每个字符分配唯一的字符码。所有的文字都用两个字节来表示。</li><li>UTF-8：变长的编码方式，可用1-4个字节来表示一个字符。</li></ol><p>2.Unicode和UTF-8</p><p>一、Unicode不完美，这里就有三个问题</p><ol><li><p>一个是，我们已经知道，英文字母只用一个字节表示就够了</p></li><li><p>第二个问题是如何才能区别Unicode和ASCII？计算机怎么知道两个字节表示一个符号，而不是分别表示两个符号呢？</p></li><li><p>第三个，如果和GBK等双字节编码方式一样，用最高位是1或0表示两个字节和一个字节，就少了很多值无法用于表示字符，不够表示所有字符。Unicode在很长一段时间内无法推广，直到互联网的出现。</p></li></ol><p>二、面向传输的众多 UTF（UCS Transfer Format）标准出现了，顾名思义，UTF- </p><p>8就是每次8个位传输数据，而UTF-16就是每次16个位。这是为传输而设计的</p><p>编码，并使编码无国界，这样就可以显示全世界上所有文化的字符了。</p><p>三、Unicode只是定义了一个庞大的、全球通用的字符集，并为每个字符规定了唯</p><p>一确定的编号，具体存储成什么样的字节流，取决于字符编码方案。推荐的</p><p>Unicode编码是UTF-8和UTF-16</p><p>四、Unicode转换到UTF-8</p><p><img src="/2022/08/30/Java%E9%AB%98%E7%BA%A7-%E9%9B%86%E5%90%88-%E6%B3%9B%E5%9E%8B-IO%E6%B5%81/img%5CSnipaste_2022-02-07_20-20-05.png" alt="Snipaste_2022-02-07_20-20-05"></p><p>五、所有字符编码集关系</p><p><img src="/2022/08/30/Java%E9%AB%98%E7%BA%A7-%E9%9B%86%E5%90%88-%E6%B3%9B%E5%9E%8B-IO%E6%B5%81/img%5CSnipaste_2022-02-07_20-20-19.png" alt="Snipaste_2022-02-07_20-20-19"></p><h3 id="6-标准输入输出流"><a href="#6-标准输入输出流" class="headerlink" title="6.标准输入输出流"></a>6.标准输入输出流</h3><h4 id="1-介绍-2"><a href="#1-介绍-2" class="headerlink" title="1.介绍"></a>1.介绍</h4><p>System.in和System.out分别代表了系统标准的输入和输出设备</p><ol><li>默认输入设备是：键盘，输出设备是：显示器</li><li>System.in的类型是InputStream</li><li>System.out的类型是PrintStream，其是OutputStream的子类FilterOutputStream 的子类</li></ol><p>重定向：通过System类的setIn，setOut方法对默认设备进行改变。（<strong>重新指定一个流进行读取写出。例如从文件中读数据而不是键盘中输入，输出数据到指定文件中而不是控制台）</strong></p><ol><li>public static void setIn(InputStream in)</li><li>public static void setOut(PrintStream out)</li></ol><h4 id="2-练习演示1"><a href="#2-练习演示1" class="headerlink" title="2.练习演示1"></a>2.练习演示1</h4><p>从键盘输入字符串，要求将读取到的整行字符串转成大写输出。然后继续进行输入操作，直至当输入“e”或者“exit”时，退出程序。</p><p>方法一：使用Scanner实现，调用next()返回一个字符串<br>方法二：使用System.in实现。System.in  —&gt;  转换流 —&gt; BufferedReader的readLine()</p><p>代码演示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">//方法二：使用System.in实现。System.in  ---&gt;  转换流 ---&gt; BufferedReader的readLine()</span><br><span class="line">//想用用字符流的缓冲流中readLine(),由于System.in是字节流，所以可以放入转换流构造器中</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    BufferedReader br = null;</span><br><span class="line">    try &#123;</span><br><span class="line">  InputStreamReader isr = new InputStreamReader(System.in);</span><br><span class="line">        br = new BufferedReader(isr);</span><br><span class="line"></span><br><span class="line">        while (true) &#123;</span><br><span class="line">            System.out.println(&quot;请输入字符串：&quot;);</span><br><span class="line">            String data = br.readLine();</span><br><span class="line">            //equalsIgnoreCase(data)忽略大小写</span><br><span class="line">           if (&quot;e&quot;.equalsIgnoreCase(data) || &quot;exit&quot;.equalsIgnoreCase(data)) &#123;</span><br><span class="line">                System.out.println(&quot;程序结束&quot;);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            String upperCase = data.toUpperCase();</span><br><span class="line">            System.out.println(upperCase);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (br != null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                br.close();</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="3-练习2"><a href="#3-练习2" class="headerlink" title="3.练习2"></a>3.练习2</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">// MyInput.java: Contain the methods for reading int, double, float, boolean, short, byte and</span><br><span class="line">// string values from the keyboard</span><br><span class="line">相当于创建一个System.in输入类，调用方法，从键盘中输入获取想要类型的值</span><br><span class="line">import java.io.*;</span><br><span class="line"></span><br><span class="line">public class MyInput &#123;</span><br><span class="line">    // Read a string from the keyboard</span><br><span class="line">    public static String readString() &#123;</span><br><span class="line">        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));</span><br><span class="line"></span><br><span class="line">        // Declare and initialize the string</span><br><span class="line">        String string = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">        // Get the string from the keyboard</span><br><span class="line">        try &#123;</span><br><span class="line">            string = br.readLine();</span><br><span class="line"></span><br><span class="line">        &#125; catch (IOException ex) &#123;</span><br><span class="line">            System.out.println(ex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Return the string obtained from the keyboard</span><br><span class="line">        return string;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Read an int value from the keyboard</span><br><span class="line">    public static int readInt() &#123;</span><br><span class="line">        return Integer.parseInt(readString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Read a double value from the keyboard</span><br><span class="line">    public static double readDouble() &#123;</span><br><span class="line">        return Double.parseDouble(readString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Read a byte value from the keyboard</span><br><span class="line">    public static double readByte() &#123;</span><br><span class="line">        return Byte.parseByte(readString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Read a short value from the keyboard</span><br><span class="line">    public static double readShort() &#123;</span><br><span class="line">        return Short.parseShort(readString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Read a long value from the keyboard</span><br><span class="line">    public static double readLong() &#123;</span><br><span class="line">        return Long.parseLong(readString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Read a float value from the keyboard</span><br><span class="line">    public static double readFloat() &#123;</span><br><span class="line">        return Float.parseFloat(readString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="7-打印流-了解"><a href="#7-打印流-了解" class="headerlink" title="7.打印流(了解)"></a>7.打印流(了解)</h3><p>实现将基本数据类型的数据格式转化为字符串输出</p><ol><li><strong>打印流：PrintStream和PrintWriter</strong></li><li><strong>提供了一系列重载的print()和println()方法，用于多种数据类型的输出</strong></li><li>PrintStream和PrintWriter的输出不会抛出IOException异常</li><li>PrintStream和PrintWriter有自动flush功能</li><li>PrintStream 打印的所有字符都使用平台的默认字符编码转换为字节。</li><li>在需要写入字符而不是写入字节的情况下，应该使用 PrintWriter 类。 </li><li><strong>System.out返回的是PrintStream的实例</strong></li></ol><p>练习演示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test2() &#123;</span><br><span class="line">    PrintStream ps = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        FileOutputStream fos = new FileOutputStream(new File(&quot;D:\\IO\\text.txt&quot;));</span><br><span class="line">        // 创建打印输出流,设置为自动刷新模式(写入换行符或字节 &#x27;\n&#x27; 时都会刷新输出缓冲区)</span><br><span class="line">        ps = new PrintStream(fos, true);</span><br><span class="line">        if (ps != null) &#123;// 把标准输出流(控制台输出)改成文件</span><br><span class="line">            System.setOut(ps);</span><br><span class="line">        &#125;</span><br><span class="line">  //此时输出流被改为输出到指定文件</span><br><span class="line">        for (int i = 0; i &lt;= 255; i++) &#123; // 输出ASCII字符</span><br><span class="line">            System.out.print((char) i);</span><br><span class="line">            if (i % 50 == 0) &#123; // 每50个数据一行</span><br><span class="line">                System.out.println(); // 换行</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (ps != null) &#123;</span><br><span class="line">            ps.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="8-数据流-了解"><a href="#8-数据流-了解" class="headerlink" title="8.数据流(了解)"></a>8.数据流(了解)</h3><p>1.为了方便地操作Java语言的基本数据类型和String的数据，可以使用数据流。</p><p>2.数据流有两个类：用于读取和写出基本数据类型、String类的数据</p><p>3.DataInputStream 和 DataOutputStream分别“套接”在 InputStream 和 OutputStream 子类的流上 </p><p>DataInputStream中的方法</p><ol><li>boolean readBoolean() </li><li>byte readByte()</li><li>char readChar() </li><li>float readFloat()</li><li>double readDouble() </li><li>short readShort()</li><li>long readLong() </li><li>int readInt()</li><li>String readUTF() void readFully(byte[] b)</li></ol><p>DataOutputStream中的方法</p><p>将上述的方法的read改为相应的write即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">练习：将内存中的字符串、基本数据类型的变量写出到文件中。</span><br><span class="line">注意：处理异常的话，仍然应该使用try-catch-finally.</span><br><span class="line">  @Test</span><br><span class="line">    public void test3() throws IOException &#123;</span><br><span class="line">        //1.</span><br><span class="line">        DataOutputStream dos = new DataOutputStream(new FileOutputStream(&quot;data.txt&quot;));</span><br><span class="line">        //2.</span><br><span class="line">        dos.writeUTF(&quot;刘建辰&quot;);</span><br><span class="line">        dos.flush();//刷新操作，将内存中的数据写入文件</span><br><span class="line">        dos.writeInt(23);</span><br><span class="line">        dos.flush();</span><br><span class="line">        dos.writeBoolean(true);</span><br><span class="line">        dos.flush();</span><br><span class="line">        //3.</span><br><span class="line">        dos.close();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    /*</span><br><span class="line">    将文件中存储的基本数据类型变量和字符串读取到内存中，保存在变量中。</span><br><span class="line"></span><br><span class="line">    注意点：读取不同类型的数据的顺序要与当初写入文件时，保存的数据的顺序一致！</span><br><span class="line">     */</span><br><span class="line">    @Test</span><br><span class="line">    public void test4() throws IOException &#123;</span><br><span class="line">        //1.</span><br><span class="line">        DataInputStream dis = new DataInputStream(new FileInputStream(&quot;data.txt&quot;));</span><br><span class="line">        //2.</span><br><span class="line">        String name = dis.readUTF();</span><br><span class="line">        int age = dis.readInt();</span><br><span class="line">        boolean isMale = dis.readBoolean();</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;name = &quot; + name);</span><br><span class="line">        System.out.println(&quot;age = &quot; + age);</span><br><span class="line">        System.out.println(&quot;isMale = &quot; + isMale);</span><br><span class="line"></span><br><span class="line">        //3.</span><br><span class="line">        dis.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="9-对象流"><a href="#9-对象流" class="headerlink" title="9.对象流"></a>9.对象流</h3><h4 id="1-介绍-3"><a href="#1-介绍-3" class="headerlink" title="1.介绍"></a>1.介绍</h4><p>对象流涵盖了数据流，它不仅可以用于存储和读取基本数据类型数据且存储和读取对象。</p><p>ObjectInputStream和OjbectOutputSteam</p><ul><li>用于存储和读取基本数据类型数据或对象的处理流。它的强大之处就是可以把Java中的对象写入到数据源中，也能把对象从数据源中还原回来。</li></ul><p>序列化：用ObjectOutputStream类保存基本类型数据或对象的机制</p><p>反序列化：用ObjectInputStream类读取基本类型数据或对象的机制</p><h4 id="2-对象流的使用"><a href="#2-对象流的使用" class="headerlink" title="2.对象流的使用"></a>2.对象流的使用</h4><h5 id="1-使用步骤："><a href="#1-使用步骤：" class="headerlink" title="1.使用步骤："></a>1.使用步骤：</h5><p>序列化：  —-<strong>用String举例：String类本身也实现了Serializable 接口</strong></p><ol><li><p>若某个<strong>类实现了 Serializable 接口</strong>，该类的对象就是可序列化的：</p></li><li><p><strong>创建一个 ObjectOutputStream流</strong></p><p>ObjectOutputStream  oos &#x3D;   new ObjectOutputStream(new FileOutputStream(“object.dat”)); &#x2F;&#x2F;文件后缀可自选</p></li><li><p>调用 ObjectOutputStream 对象的 writeObject(对象) 方法输出可序列化对象</p><p>oos.writeObject(new String(“我爱北京天安门”));</p><p>&#x2F;&#x2F;这里将String类型序列化</p></li><li><p>注意写出一次，操作flush()一次</p><p>oos.flush();&#x2F;&#x2F;刷新操作</p></li><li><p>关闭流</p><p>oos.close()</p></li><li><p>仍需要用try-catch-finally解决异常</p></li></ol><p>反序列化：</p><ol><li><p>创建一个 ObjectInputStream</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ObjectInputStream  ois = new ObjectInputStream(new FileInputStream(&quot;object.dat&quot;));</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>调用 readObject() 方法读取流中的对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Object obj = ois.readObject();</span><br><span class="line">String str = (String) obj;</span><br><span class="line">System.out.println(str);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>关闭流</p><p>ois.close()</p></li><li><p>仍需要用try-catch-finally解决异常</p></li></ol><p><strong>详细代码演示：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">//提醒：一般只序列化一种类型，但是有多种类型时，反序列化时得按照序列化时的优先顺序--这也是所有流读入写出时遇到多种类型时需要遵守的</span><br><span class="line">@Test</span><br><span class="line">        public void testObjectOutputStream()&#123;</span><br><span class="line">            ObjectOutputStream oos = null;</span><br><span class="line">            try &#123;</span><br><span class="line">                //1.</span><br><span class="line">                oos = new ObjectOutputStream(new FileOutputStream(&quot;object.dat&quot;));</span><br><span class="line">                //2.</span><br><span class="line">                oos.writeObject(new String(&quot;我爱北京天安门&quot;));</span><br><span class="line">                oos.flush();//刷新操作</span><br><span class="line"></span><br><span class="line">                oos.writeObject(new Person(&quot;王铭&quot;,23));</span><br><span class="line">                oos.flush();</span><br><span class="line"></span><br><span class="line">                oos.writeObject(new Person(&quot;张学良&quot;,23,1001,new Account(5000)));</span><br><span class="line">                oos.flush();</span><br><span class="line"></span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if(oos != null)&#123;</span><br><span class="line">            //3.</span><br><span class="line">            try &#123;</span><br><span class="line">                oos.close();</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">反序列化：将磁盘文件中的对象还原为内存中的一个java对象</span><br><span class="line">使用ObjectInputStream来实现</span><br><span class="line"> */</span><br><span class="line">@Test</span><br><span class="line">public void testObjectInputStream()&#123;</span><br><span class="line">    ObjectInputStream ois = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        ois = new ObjectInputStream(new FileInputStream(&quot;object.dat&quot;));</span><br><span class="line"></span><br><span class="line">        Object obj = ois.readObject();</span><br><span class="line">        String str = (String) obj;</span><br><span class="line"></span><br><span class="line">        Person p = (Person) ois.readObject();</span><br><span class="line">        Person p1 = (Person) ois.readObject();</span><br><span class="line"></span><br><span class="line">        System.out.println(str);</span><br><span class="line">        System.out.println(p);</span><br><span class="line">        System.out.println(p1);</span><br><span class="line"></span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if(ois != null)&#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                ois.close();</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="2-自定义类可序列化"><a href="#2-自定义类可序列化" class="headerlink" title="2.自定义类可序列化"></a>2.自定义类可序列化</h5><p>Person需要满足如下的要求，方可序列化</p><ol><li><p>需要实现接口：Serializable</p></li><li><p>当前类提供一个全局常量（<strong>序列版本号</strong>）：serialVersionUID</p><p>意思是给每个序列化指定一个ID区分，不写的话，系统会自动分配，但是建议写上</p></li><li><p>除了当前Person类需要实现Serializable接口之外，还必须保证其内部所有属性也必须是可序列化的。（默认情况下，基本数据类型可序列化）</p><p>强调：如果某个类声明的属性不是基本数据类型或 String 类型，而是另一个引用类型，那么这个引用类型必须是可序列化的，否则拥有该类型的Field 的类也不能序列化</p></li></ol><p><strong>补充</strong>：ObjectOutputStream和ObjectInputStream不能序列化static和transient修饰的成员变量</p><ol><li>static ：本身属于类而不是属于对象，所以不能序列化</li><li>transient：用于修饰不想被序列化的属性</li></ol><p>代码演示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//代码简化：只需要看有没有满足可序列条件</span><br><span class="line">public class Person implements Serializable&#123; 1.实现接口</span><br><span class="line">    public static final long serialVersionUID = 475463534532L;                               2.提供一个全局常量</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line">    private transient int age;  4.不想被序列化，可用该关键字修饰</span><br><span class="line">    private int id;</span><br><span class="line">    private Account acct;      3.如果有引用类型声明的属性，那么该引用类型也是可序列化的</span><br><span class="line">    public Person(String name, int age, int id, Account acct) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">        this.id = id;</span><br><span class="line">        this.acct = acct;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">class Account implements Serializable&#123;</span><br><span class="line">    public static final long serialVersionUID = 4754534532L;</span><br><span class="line">    private double balance;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="10-随机存取文件流"><a href="#10-随机存取文件流" class="headerlink" title="10.随机存取文件流"></a>10.随机存取文件流</h3><h4 id="1-介绍-4"><a href="#1-介绍-4" class="headerlink" title="1.介绍"></a>1.介绍</h4><p>一、RandomAccessFile 类</p><ol><li>RandomAccessFile 声明在java.io包下，但直接继承于java.lang.Object类。并且它实现了DataInput、DataOutput这两个接口，也就意味着这个类既可以读也可以写。</li><li>RandomAccessFile 类支持 “随机访问” 的方式，程序可以直接跳到文件的任意地方来读、写文件<ol><li>支持只访问文件的部分内容</li><li>可以向已存在的文件后追加内容</li></ol></li></ol><p>二、细节使用</p><ol><li>RandomAccessFile 对象包含一个记录指针，用以标示当前读写处的位置。</li><li>RandomAccessFile 类对象可以自由移动记录指针：<ol><li>long getFilePointer()：获取文件记录指针的当前位置</li><li>void seek(long pos)：将文件记录指针定位到 pos 位置</li></ol></li></ol><p>三、构造器</p><ol><li>public RandomAccessFile(File file, String mode) </li><li>public RandomAccessFile(String name, String mode)</li></ol><p>四、构造器mode参数说明</p><p>创建 RandomAccessFile 类实例需要指定一个 mode 参数，该参数指定 RandomAccessFile 的访问模式：</p><ol><li>r: 以只读方式打开</li><li>rw：打开以便读取和写入</li><li>rwd:打开以便读取和写入；同步文件内容的更新</li><li>rws:打开以便读取和写入；同步文件内容和元数据的更新</li></ol><p>五、四种访问模式使用区别</p><p>r 和 rw：如果模式为只读r。则不会创建文件，而是会去读取一个已经存在的文件，如果读取的文件不存在则会出现异常。 如果模式为rw读写。如果文件不存在则会去创建文件，如果存在则不会创建。</p><p>rw和rwd：JDK 1.6 上面写的每次write数据时，“rw”模式，数据不会立即写到硬盘中；而“rwd”，写数据会被立即写入硬盘中。好处是如果写数据过程发生异常，“rwd”模式中已被write的数据被保存带硬盘中，而“rw”则全部丢失</p><h4 id="2-RandomAccessFile使用"><a href="#2-RandomAccessFile使用" class="headerlink" title="2.RandomAccessFile使用"></a>2.RandomAccessFile使用</h4><p>说明：</p><ol><li><p>RandomAccessFile直接继承于java.lang.Object类，实现了DataInput和DataOutput接口</p></li><li><p>RandomAccessFile既可以作为一个输入流，又可以作为一个输出流。</p><p><strong>代码演示一–说明</strong></p></li><li><p>如果RandomAccessFile作为输出流时，写出到的文件如果不存在，则在执行过程中自动创建。</p><p>如果写出到的文件存在，则会对原有文件内容进行覆盖。（默认情况下，从头覆盖）—-<strong>-代码演示二–说明</strong></p></li><li><p>可以通过相关的操作，实现RandomAccessFile“插入”数据的效果，满足一些需求而不在是覆盖 —-<strong>-代码演示三–说明</strong></p></li></ol><p>代码演示 一：(RandomAccessFile既可作为输入流，又可作为输出流)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public class RandomAccessFileTest &#123;</span><br><span class="line"></span><br><span class="line">    @Test   //复制图片</span><br><span class="line">    public void test1() &#123;</span><br><span class="line"></span><br><span class="line">        RandomAccessFile raf1 = null;</span><br><span class="line">        RandomAccessFile raf2 = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            //1.造文件造流</span><br><span class="line">raf1 = new RandomAccessFile(new File(&quot;爱情与友情.jpg&quot;),&quot;r&quot;);</span><br><span class="line">raf2 = new RandomAccessFile(new File(&quot;爱情与友情1.jpg&quot;),&quot;rw&quot;);</span><br><span class="line">            //2.读入写出过程</span><br><span class="line">            byte[] buffer = new byte[1024];</span><br><span class="line">            int len;</span><br><span class="line">            while((len = raf1.read(buffer)) != -1)&#123;</span><br><span class="line">                raf2.write(buffer,0,len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            //3.关闭流</span><br><span class="line">            if(raf1 != null)&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    raf1.close();</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if(raf2 != null)&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    raf2.close();</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>代码演示二：如果写出到的文件存在，则会对原有文件内容进行覆盖。（默认情况下，从头覆盖）–也可使用seek()指定角标位置进行覆盖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Test //为笔记清晰，省略使用try-catch-finally</span><br><span class="line">public void test2() throws IOException &#123;</span><br><span class="line"></span><br><span class="line">    RandomAccessFile raf1 = new RandomAccessFile(&quot;hello.txt&quot;,&quot;rw&quot;);</span><br><span class="line"></span><br><span class="line">    raf1.seek(3);//将指针调到角标为3的位置</span><br><span class="line">    raf1.write(&quot;xyz&quot;.getBytes());//这里write形参是byte数组</span><br><span class="line">//不是字符串</span><br><span class="line">    raf1.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>代码演示三：可以通过相关的操作，实现RandomAccessFile“插入”数据的效果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">使用RandomAccessFile实现数据的插入效果</span><br><span class="line"> */</span><br><span class="line">@Test</span><br><span class="line">public void test3() throws IOException &#123;</span><br><span class="line"></span><br><span class="line">    RandomAccessFile raf1 = new RandomAccessFile(&quot;hello.txt&quot;,&quot;rw&quot;);</span><br><span class="line">    //方式一：使用StringBuilder</span><br><span class="line">    raf1.seek(3);//将指针调到角标为3的位置</span><br><span class="line">    //保存指针3后面的所有数据到StringBuilder中</span><br><span class="line">    StringBuilder builder = new StringBuilder((int) new File(&quot;hello.txt&quot;).length());</span><br><span class="line">    </span><br><span class="line">    byte[] buffer = new byte[20];</span><br><span class="line">    int len;</span><br><span class="line">    while((len = raf1.read(buffer)) != -1)&#123;</span><br><span class="line">        builder.append(new String(buffer,0,len)) ;</span><br><span class="line">    &#125;</span><br><span class="line">    //调回指针，写入“xyz”</span><br><span class="line">    raf1.seek(3);</span><br><span class="line">    raf1.write(&quot;xyz&quot;.getBytes());</span><br><span class="line"></span><br><span class="line">    //将StringBuilder中的数据写入到文件中</span><br><span class="line">    raf1.write(builder.toString().getBytes());</span><br><span class="line"></span><br><span class="line">    raf1.close();</span><br><span class="line"></span><br><span class="line">    //方式二：思考：将StringBuilder替换为ByteArrayOutputStream</span><br><span class="line">ByteArrayOutputStream baos = new ByteArrayOutputStream();</span><br><span class="line">byte[] buffer = new byte[10];</span><br><span class="line">int len;</span><br><span class="line">while((len = raf1.read(buffer)) != -1)&#123;</span><br><span class="line">baos.write(buffer, 0, len);</span><br><span class="line">&#125;</span><br><span class="line">raf1.seek(5);</span><br><span class="line">raf1.write(&quot;xyz&quot;.getBytes());</span><br><span class="line">raf1.write(baos.toString().getBytes());</span><br><span class="line">baos.close();</span><br><span class="line">raf1.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="11-NIO-2中Path、Paths、Files类的使用"><a href="#11-NIO-2中Path、Paths、Files类的使用" class="headerlink" title="11.NIO.2中Path、Paths、Files类的使用"></a>11.NIO.2中Path、Paths、Files类的使用</h3><p>由于难度跳跃且暂时用不到，这里暂做了解</p><h4 id="1-NIO概述"><a href="#1-NIO概述" class="headerlink" title="1.NIO概述"></a>1.NIO概述</h4><ol><li>Java NIO (New IO，Non-Blocking IO)是从Java 1.4版本开始引入的一套新 的IO API，可以替代标准的Java IO API。NIO与原来的IO有同样的作用和目的，但是使用的方式完全不同，NIO支持面向缓冲区的(IO是面向流的)、基于通道的IO操作。NIO将以更加高效的方式进行文件的读写操作</li><li>Java API中提供了两套NIO，一套是针对标准输入输出NIO，另一套就是网络编程NIO。 </li><li>java.nio.channels.Channel</li><li>FileChannel:处理本地文件</li><li>SocketChannel：TCP网络编程的客户端的Channel</li><li>ServerSocketChannel:TCP网络编程的服务器端的Channel</li><li>DatagramChannel：UDP网络编程中发送端和接收端的Channel</li></ol><h4 id="2-NIO-2概述"><a href="#2-NIO-2概述" class="headerlink" title="2.NIO.2概述"></a>2.NIO.2概述</h4><ol><li>随着 JDK 7 的发布，Java对NIO进行了极大的扩展，增强了对文件处理和文件系统特性的支持，以至于我们称他们为 NIO.2。</li><li>因为 NIO 提供的一些功能，NIO已经成为文件处理中越来越重要的部分。</li><li>早期的Java只提供了一个File类来访问文件系统，但File类的功能比较有限，所提供的方法性能也不高。而且，大多数方法在出错时仅返回失败，并不会提供异常信息。</li><li>NIO. 2为了弥补这种不足，引入了Path接口，代表一个平台无关的平台路径，描述了目录结构中文件的位置。<strong>Path可以看成是File类的升级版本</strong>，实际引用的资源也可以不存在。</li></ol><p>Path、Paths和Files核心API</p><ul><li>同时，NIO.2在java.nio.file包下还提供了Files、Paths工具类，Files包含了大量静态的工具方法来操作文件；Paths则包含了两个返回Path的静态工厂方法。</li></ul><p>Paths 类提供的静态 get() 方法用来获取 Path 对象：</p><ol><li>static Path get(String first, String … more) : 用于将多个字符串串连成路径</li><li>static Path get(URI uri): 返回指定uri对应的Path路径</li></ol><h4 id="3-Path接口"><a href="#3-Path接口" class="headerlink" title="3.Path接口"></a>3.Path接口</h4><p>说明：Path替换File</p><p>如何实例化：</p><p>Paths 类提供的静态 get() 方法用来获取 Path 对象：</p><ol><li>static Path get(String first, String … more) : 用于将多个字符串串连成路径</li><li>static Path get(URI uri): 返回指定uri对应的Path路径</li></ol><p>常用方法：</p><p>Path 常用方法：</p><ol><li>String toString() ： 返回调用 Path 对象的字符串表示形式</li><li>boolean startsWith(String path) : 判断是否以 path 路径开始</li><li>boolean endsWith(String path) : 判断是否以 path 路径结束</li><li>boolean isAbsolute() : 判断是否是绝对路径</li><li>Path getParent() ：返回Path对象包含整个路径，不包含 Path 对象指定的文件路径</li><li>Path getRoot() ：返回调用 Path 对象的根路径</li><li>Path getFileName() : 返回与调用 Path 对象关联的文件名</li><li>int getNameCount() : 返回Path 根目录后面元素的数量</li><li>Path getName(int idx) : 返回指定索引位置 idx 的路径名称</li><li>Path toAbsolutePath() : 作为绝对路径返回调用 Path 对象</li><li>Path resolve(Path p) :合并两个路径，返回合并后的路径对应的Path对象</li><li>File toFile(): 将Path转化为File类的对象</li></ol><h4 id="4-Files工具类"><a href="#4-Files工具类" class="headerlink" title="4.Files工具类"></a>4.Files工具类</h4><p>作用：java.nio.file.Files 用于操作文件或目录的工具类。</p><p>常用方法：</p><ol><li>Path copy(Path src, Path dest, CopyOption … how) : 文件的复制</li><li>Path createDirectory(Path path, FileAttribute&lt;?&gt; … attr) : 创建一个目录</li><li>Path createFile(Path path, FileAttribute&lt;?&gt; … arr) : 创建一个文件</li><li>void delete(Path path) : 删除一个文件&#x2F;目录，如果不存在，执行报错</li><li>void deleteIfExists(Path path) : Path对应的文件&#x2F;目录如果存在，执行删除</li><li>Path move(Path src, Path dest, CopyOption…how) : 将 src 移动到 dest 位置</li><li>long size(Path path) : 返回 path 指定文件的大小</li></ol><p>Files常用方法：用于判断</p><ol><li>boolean exists(Path path, LinkOption … opts) : 判断文件是否存在</li><li>boolean isDirectory(Path path, LinkOption … opts) : 判断是否是目录</li><li>boolean isRegularFile(Path path, LinkOption … opts) : 判断是否是文件</li><li>boolean isHidden(Path path) : 判断是否是隐藏文件</li><li>boolean isReadable(Path path) : 判断文件是否可读</li><li>boolean isWritable(Path path) : 判断文件是否可写</li><li>boolean notExists(Path path, LinkOption … opts) : 判断文件是否不存在</li></ol><p>Files常用方法：用于操作内容</p><ol><li>SeekableByteChannel newByteChannel(Path path, OpenOption…how) : 获取与指定文件的连接，how 指定打开方式。</li><li>DirectoryStream<Path> newDirectoryStream(Path path) : 打开 path 指定的目录</Path></li><li>InputStream newInputStream(Path path, OpenOption…how):获取 InputStream 对象</li><li>OutputStream newOutputStream(Path path, OpenOption…how) : 获取 OutputStream 对象</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java高级编程4-6&quot;&gt;&lt;a href=&quot;#Java高级编程4-6&quot; class=&quot;headerlink&quot; title=&quot;Java高级编程4-6&quot;&gt;&lt;/a&gt;Java高级编程4-6&lt;/h1&gt;&lt;h2 id=&quot;4-集合&quot;&gt;&lt;a href=&quot;#4-集合&quot; class=&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>常用类</title>
    <link href="http://example.com/2022/08/29/Java%E9%AB%98%E7%BA%A7-%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%B8%B8%E7%94%A8%E7%B1%BB-%E6%9E%9A%E4%B8%BE%E7%B1%BB%E4%B8%8E%E6%B3%A8%E8%A7%A3/"/>
    <id>http://example.com/2022/08/29/Java%E9%AB%98%E7%BA%A7-%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%B8%B8%E7%94%A8%E7%B1%BB-%E6%9E%9A%E4%B8%BE%E7%B1%BB%E4%B8%8E%E6%B3%A8%E8%A7%A3/</id>
    <published>2022-08-29T09:45:41.000Z</published>
    <updated>2022-09-28T08:11:51.318Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-编程高级"><a href="#Java-编程高级" class="headerlink" title="Java 编程高级"></a>Java 编程高级</h1><h2 id="1-多线程"><a href="#1-多线程" class="headerlink" title="1.多线程"></a>1.多线程</h2><h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1.基本概念"></a>1.基本概念</h3><h4 id="1-程序"><a href="#1-程序" class="headerlink" title="1.程序"></a>1.程序</h4><p><strong>程序(program)是为完成特定任务、用某种语言编写的一组指令的集合</strong>。即指一段静态的代码，静态对象。</p><h4 id="2-进程"><a href="#2-进程" class="headerlink" title="2.进程"></a>2.进程</h4><ol><li>进程(process)是程序的一次执行过程，或是正在运行的一个程序。是一个动态的过程：有它自身的产生、存在和消亡的过程。——生命周期</li><li>如：运行中的QQ，运行中的MP3播放器</li><li>程序是静态的，进程是动态的</li><li>进程作为资源分配的单位，系统在运行时会为每个进程分配不同的内存区域</li></ol><h4 id="3-线程"><a href="#3-线程" class="headerlink" title="3.线程"></a>3.线程</h4><ol><li>线程(thread)，进程可进一步细化为线程，是<strong>一个程序内部的一条执行路径</strong>。</li><li>若<strong>一个进程同一时间并行执行多个线程</strong>，就是支持多线程的</li><li><strong>线程作为调度和执行的单位，每个线程拥有独立的运行栈和程序计数器(pc)，线程切换的开销小</strong> </li><li><strong>一个进程中的多个线程共享相同的内存单元&#x2F;内存地址空间它们从同一堆中分配对象，可以访问相同的变量和对象。</strong>这就使得线程间通信更简便、高效。但<strong>多个线程操作共享的系统资源可能就会带来安全的隐患。</strong></li></ol><p>内存结构：</p><p><strong>每个线程，拥有自己独立的：栈、程序计数器</strong></p><p><strong>多个线程，共享同一个进程中的结构：方法区、堆</strong></p><p><img src="/2022/08/29/Java%E9%AB%98%E7%BA%A7-%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%B8%B8%E7%94%A8%E7%B1%BB-%E6%9E%9A%E4%B8%BE%E7%B1%BB%E4%B8%8E%E6%B3%A8%E8%A7%A3/img%5CSnipaste_2022-01-10_13-24-41.png" alt="Snipaste_2022-01-10_13-24-41"></p><h4 id="4-单核和多核CPU理解"><a href="#4-单核和多核CPU理解" class="headerlink" title="4.单核和多核CPU理解"></a>4.单核和多核CPU理解</h4><ol><li><strong>单核CPU，其实是一种假的多线程</strong>，因为在一个时间单元内，也只能执行一个线程的任务。例如：一个干多份活，但是由于动作熟练和切换快速，使人感觉有好多人同时在干活</li><li>如果是多核的话，才能更好的发挥多线程的效率。（现在的服务器都是多核的）</li><li>一<strong>个Java应用程序java.exe，其实至少有三个线程：main()主线程，gc()垃圾回收线程，异常处理线程</strong>。当然如果发生异常，会影响主线程。</li></ol><h4 id="5-并行与并发"><a href="#5-并行与并发" class="headerlink" title="5.并行与并发"></a>5.并行与并发</h4><ol><li>并行：多个CPU同时执行多个任务。比如：多个人同时做不同的事。 </li><li>并发：一个CPU(采用时间片)同时执行多个任务。比如：秒杀、多个人做同一件事。</li></ol><h4 id="6-多线程程序的优点"><a href="#6-多线程程序的优点" class="headerlink" title="6.多线程程序的优点"></a>6.多线程程序的优点</h4><ol><li>提高应用程序的响应。对图形化界面更有意义，可增强用户体验。</li><li>提高计算机系统CPU的利用率</li><li>改善程序结构。将既长又复杂的进程分为多个线程，独立运行，利于理解和修改</li></ol><h4 id="7-何时需要多线程"><a href="#7-何时需要多线程" class="headerlink" title="7.何时需要多线程"></a>7.何时需要多线程</h4><ol><li>程序需要同时执行两个或多个任务。</li><li>程序需要实现一些需要等待的任务时，如用户输入、文件读写操作、网络操作、搜索等。</li><li>需要一些后台运行的程序时</li></ol><h3 id="2-多线程的创建和使用"><a href="#2-多线程的创建和使用" class="headerlink" title="2.多线程的创建和使用"></a>2.多线程的创建和使用</h3><h4 id="1-方式一："><a href="#1-方式一：" class="headerlink" title="1.方式一："></a>1.方式一：</h4><h5 id="1-继承于Thread类"><a href="#1-继承于Thread类" class="headerlink" title="1.继承于Thread类"></a>1.继承于Thread类</h5><ol><li>创建一个继承于Thread类的子类</li><li>重写Thread类的run() —&gt;将此线程执行的操作声明在run() 中</li><li>创建Thread类的子类的对象</li><li>通过此对象调用 start () 方法</li></ol><h5 id="2-代码演示"><a href="#2-代码演示" class="headerlink" title="2.代码演示"></a>2.代码演示</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123; <span class="comment">//创建一个继承于Thread类的子类</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;  <span class="comment">//重写Thread类的run() </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span> ; i&lt;<span class="number">100</span> ; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">fristCode</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">mt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(); <span class="comment">//创建Thread类的子类的对象</span></span><br><span class="line">        mt.start();通过此对象调用 start () 方法</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="3-问题"><a href="#3-问题" class="headerlink" title="3.问题"></a>3.问题</h5><ol><li><p>我们不能直接调用run() 的方式启动线程</p></li><li><p>每个线程对象只能调用一次，不可以再让已经start () 的线程去执行。会报错，我们需要重新创建一个线程的对象</p></li><li><p>&#96;&#96;&#96;java<br>MyThread mt &#x3D; new MyThread();<br>mt.start();<br>MyThread mv &#x3D; new MyThread();<br>mv.start();</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 2.创建Thread类的匿名子类的方式一</span><br><span class="line"></span><br><span class="line">继承于Thread类的方式去创建匿名子类</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">new Thread() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        for (int i = 0; i &lt; 100; i++) &#123;</span><br><span class="line">            if (i % 2 != 0) &#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.start();</span><br></pre></td></tr></table></figure></li></ol><h4 id="3-Thread类中的常用方法"><a href="#3-Thread类中的常用方法" class="headerlink" title="3.Thread类中的常用方法"></a>3.Thread类中的常用方法</h4><ol><li><p>start ()：启动当前线程，调用当前线程的run()</p></li><li><p>run ()：通常需要重写Thread类中的此方法，将创建的线程要执行的操作声明在此方法中</p></li><li><p>currentThread() ：静态方法，返回执行当前代码的线程（在方法中调用）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//public static native Thread currentThread();</span></span><br><span class="line">Thread.currentThread()；</span><br><span class="line"><span class="comment">//在什么方法中调用就返回什么方法的线程</span></span><br></pre></td></tr></table></figure></li><li><p>getName()：获取当前线程的名字</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span> ; i&lt;<span class="number">100</span> ; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">     <span class="comment">//三者是一样的 ，都是获取当前线程的名字 </span></span><br><span class="line">        <span class="comment">//System.out.println(Thread.currentThread().getName());                        //System.out.println(getName());</span></span><br><span class="line">        System.out.println(<span class="built_in">this</span>.getName());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>setName()：设置当前线程的名字</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">fristCode</span> &#123;</span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">   </span><br><span class="line">           Thread.currentThread().setName(<span class="string">&quot;主线程&quot;</span>);  System.out.println(Thread.currentThread().getName());</span><br><span class="line">   </span><br><span class="line">           <span class="type">MyThread</span> <span class="variable">mt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">           mt.setName(<span class="string">&quot;线程一&quot;</span>);</span><br><span class="line">           System.out.println( mt.getName());</span><br><span class="line"></span><br><span class="line"><span class="number">6.</span> yield()：释放当前CPU的执行权，（释放执行权后cup会重新分配执行任务）</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span> ; i&lt;<span class="number">100</span> ; i++)&#123;</span><br><span class="line">       <span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">           System.out.println(i);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(i==<span class="number">20</span>)&#123;</span><br><span class="line">           yield();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li><p>join()：在线程 a 中调用线程 b . join() ，此时线程a 就进入阻塞状态 ，直到线程b完全执行完以后，线程a才结束阻塞</p><p>会报错   ； 有形参 join(1000) 遇到此方法的其他线程要等待该方法的主人1000毫秒</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//在主方法中</span></span><br><span class="line"> <span class="type">MyThread</span> <span class="variable">mt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line"> mt.start(); <span class="comment">//此时有mt线程和main线程同时在跑</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">     System.out.println(<span class="string">&quot;主方法&quot;</span> + i);</span><br><span class="line">     <span class="keyword">if</span> (i == <span class="number">30</span>) &#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             mt.join();  <span class="comment">//mt.join()放在main()相当于main线程会碰到（调用）之后等mt线程结束之后才开启</span></span><br><span class="line">         &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">             e.printStackTrace();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> <span class="comment">//在run中</span></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span> ; i&lt;<span class="number">100</span> ; i++)&#123;</span><br><span class="line">     <span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">         System.out.println(i);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span>(i==<span class="number">20</span>)&#123;<span class="comment">//20处停止，执行别的线程</span></span><br><span class="line">         <span class="keyword">try</span> &#123;<span class="comment">//由于join会报异常，所以解决异常</span></span><br><span class="line">             join();</span><br><span class="line">         &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">             e.printStackTrace();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ol start="8"><li><p>stop()：已过时。当执行此方法时，强制结束当前线程</p></li><li><p>sleep(long  millitime)：让当前线程“睡眠”指定的millitime毫秒。在指定的millitime 的毫秒时间内，当前线程是阻塞状态<br>例如：限流、降低网页加载速度</p></li><li><p>isAlive()：判断当前线程是否存活–（返回boolean类型）</p></li></ol><h4 id="4-线程的优先级"><a href="#4-线程的优先级" class="headerlink" title="4.线程的优先级"></a>4.线程的优先级</h4><ol><li><p>MAX_PRIORITY  :  10</p></li><li><p>MIN_PRIORITY   :   1</p></li><li><p>NORM_PRIORITY  :  5—&gt;默认优先级</p></li><li><p>如何获取和设置当前线程的优先级：</p><p>getPriority( ) : 获取线程的优先级</p><p>setPriority ( ) : 设置线程的优先级</p></li><li><p>说明</p><p><strong>高优先级的线程只是抢到CPU执行权的概率上高，不意味着低优先级不能执行在高优先级之前</strong></p></li><li><p>&#96;&#96;&#96;java<br>HelloThread h1 &#x3D; new HelloThread();<br>    h1.setName(“线程一”);<br>    &#x2F;&#x2F;设置分线程的优先级<br>    h1.setPriority(Thread.MAX_PRIORITY);<br>    h1.start();<br><br>    &#x2F;&#x2F;给主线程命名<br>    Thread.currentThread().setName(“主线程”);  Thread.currentThread().setPriority(Thread.MIN_PRIORITY);</p></li></ol><h4 id="5-方式二"><a href="#5-方式二" class="headerlink" title="5.方式二"></a>5.方式二</h4><h5 id="1-实现Runnable-接口"><a href="#1-实现Runnable-接口" class="headerlink" title="1.实现Runnable( ) 接口"></a>1.实现Runnable( ) 接口</h5><ol><li><p>创建一个实现类Runnable接口的类</p></li><li><p>实现类去实现Runnable 中的抽象方法：run（）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建实现类的对象</p></li><li><p>将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//底层代码</span></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Thread</span><span class="params">(Runnable target)</span> &#123;</span><br><span class="line">       init(<span class="literal">null</span>, target, <span class="string">&quot;Thread-&quot;</span> + nextThreadNum(), <span class="number">0</span>);</span><br><span class="line">&#125;<span class="comment">//将实现类的对象传给Runnable类型的target，因为可以传递实现类的对象--多态性</span></span><br></pre></td></tr></table></figure></li><li><p>通过Thread类的对象调用start （）</p><p>这个在去调用target . run（），此run是实现重写的（private Runnable target;）</p></li></ol><h5 id="2-代码演示-1"><a href="#2-代码演示-1" class="headerlink" title="2.代码演示"></a>2.代码演示</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 创建一个实现了Runnable接口的类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 实现类去实现Runnable中的抽象方法：run()</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//3. 创建实现类的对象</span></span><br><span class="line">        <span class="type">MThread</span> <span class="variable">mThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MThread</span>();</span><br><span class="line">        <span class="comment">//4. 将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(mThread);</span><br><span class="line">        t1.setName(<span class="string">&quot;线程1&quot;</span>);</span><br><span class="line">        <span class="comment">//5. 通过Thread类的对象调用start():① 启动线程 ②调用当前线程的run()--&gt;调用了Runnable类型的target的run()</span></span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//再启动一个线程，遍历100以内的偶数</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(mThread);</span><br><span class="line">        t2.setName(<span class="string">&quot;线程2&quot;</span>);</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-方式二好处"><a href="#3-方式二好处" class="headerlink" title="3.方式二好处"></a>3.方式二好处</h5><p>只需要创建一次实现类的对象，可以创建多个线程的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Window1</span> <span class="variable">w</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Window1</span>();</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(w);</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(w);</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(w);</span><br><span class="line"></span><br><span class="line">t1.setName(<span class="string">&quot;窗口1&quot;</span>);</span><br><span class="line">t2.setName(<span class="string">&quot;窗口2&quot;</span>);</span><br><span class="line">t3.setName(<span class="string">&quot;窗口3&quot;</span>);</span><br><span class="line"></span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br><span class="line">t3.start();</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="6-创建Thread类的匿名子类的方式二"><a href="#6-创建Thread类的匿名子类的方式二" class="headerlink" title="6.创建Thread类的匿名子类的方式二"></a>6.创建Thread类的匿名子类的方式二</h4><p>实现Runnable接口的方式去创建匿名子类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>()&#123;<span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125; ).start();</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="7-比较两种方式"><a href="#7-比较两种方式" class="headerlink" title="7.比较两种方式"></a>7.比较两种方式</h4><p>比较创建线程的两种方式。</p><p><strong>开发中：优先选择：实现Runnable接口的方式</strong></p><p><strong>原因：</strong></p><ol><li><p>实现的方式没有类的单继承性的局限性  （实现方式：可以在去实现别的接口或继承父类。继承方式：只能继承一个，操作局限）</p></li><li><p>实现的方式更适合来处理多个线程有共享数据的情况。</p><p>Window w &#x3D; new Window();&#x2F;&#x2F; 只new一个实现类，下面都共用<br>Thread t1 &#x3D; new Thread(w);<br>Thread t2 &#x3D; new Thread(w);<br>Thread t3 &#x3D; new Thread(w);</p></li><li><p>卖票问题：继承方式：票得声明成static ，实现方式：票不用声明成static</p></li></ol><p><strong>两种方式的联系：</strong>public class Thread implements Runnable（<strong>都直接或间接的实现了Runnable接口</strong>）</p><p><strong>相同点：</strong>两种方式都需要重写run(),将线程要执行的逻辑声明在run()中。</p><p>​                  都是调用Thread类中start() 方法启动线程</p><h4 id="8-总结"><a href="#8-总结" class="headerlink" title="8.总结"></a>8.总结</h4><p>程序是一段静态的代码，进程是正在运行的程序（相对于程序是动态的），线程是进程中执行的任务（例如：360卫士，同时清理垃圾、扫描病毒、检测电脑）</p><p>在java程序中的线程，是通过Thread类去体现的：</p><ol><li>继承Thread</li><li>实现Runnable接口</li><li>Thread类也是通过实现了Runnable接口</li><li>都要重写Runnable接口中的run方法</li><li>都是调用Thread类中start() 方法启动线程</li><li>在Java代码运行中相当于只有一个CPU，去给每个线程不断分配执行权，所以可能两个操作无规律的交错进行</li></ol><h3 id="3-线程的生命周期"><a href="#3-线程的生命周期" class="headerlink" title="3.线程的生命周期"></a>3.线程的生命周期</h3><p><img src="/2022/08/29/Java%E9%AB%98%E7%BA%A7-%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%B8%B8%E7%94%A8%E7%B1%BB-%E6%9E%9A%E4%B8%BE%E7%B1%BB%E4%B8%8E%E6%B3%A8%E8%A7%A3/img%5CSnipaste_2022-01-23_15-11-45.png" alt="Snipaste_2022-01-23_15-11-45"></p><h3 id="4-线程的同步"><a href="#4-线程的同步" class="headerlink" title="4.线程的同步"></a>4.线程的同步</h3><h4 id="1-火车卖票问题"><a href="#1-火车卖票问题" class="headerlink" title="1.火车卖票问题"></a>1.火车卖票问题</h4><h5 id="1-引入例子："><a href="#1-引入例子：" class="headerlink" title="1.引入例子："></a>1.引入例子：</h5><p><strong>使用实现Runnable类的方式</strong>，创建三个窗口卖票，总票数为100张</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Windows</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">//Thread.sleep(100); --sleep会抛异常，写时得解决     System.out.println(Thread.currentThread().getName() + &quot;票号：&quot; + ticket);</span></span><br><span class="line">                ticket--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">sellTticket</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">Windows</span> <span class="variable">win</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Windows</span>();</span><br><span class="line"></span><br><span class="line">      <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(win);</span><br><span class="line">      <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(win);</span><br><span class="line">      <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(win);</span><br><span class="line">      t1.setName(<span class="string">&quot;窗口一&quot;</span>);</span><br><span class="line">      t2.setName(<span class="string">&quot;窗口二&quot;</span>);</span><br><span class="line">      t3.setName(<span class="string">&quot;窗口三&quot;</span>);</span><br><span class="line">      t1.start();</span><br><span class="line">      t2.start();</span><br><span class="line">      t3.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>使用继承于Thread类的方式</strong>，创建三个窗口卖票，总票数为100张</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WindowTwo</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">ticket1</span> <span class="operator">=</span> <span class="number">100</span>; <span class="comment">//为了保证多个窗口票数同步，使用static</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ticket1 &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;票号：&quot;</span> + ticket1);</span><br><span class="line">                ticket1--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">sellTticket</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">WindowTwo</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WindowTwo</span>();</span><br><span class="line">        <span class="type">WindowTwo</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WindowTwo</span>();</span><br><span class="line">        <span class="type">WindowTwo</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WindowTwo</span>();</span><br><span class="line"></span><br><span class="line">        t1.setName(<span class="string">&quot;窗口一&quot;</span>);</span><br><span class="line">        t2.setName(<span class="string">&quot;窗口二&quot;</span>);</span><br><span class="line">        t3.setName(<span class="string">&quot;窗口三&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="2-存在问题："><a href="#2-存在问题：" class="headerlink" title="2.存在问题："></a>2.存在问题：</h5><ol><li><p>问题：</p><ul><li><p><strong>卖票过程中，都出现重票、错票–&gt;出现了线程的安全问题</strong></p></li><li><p><strong>可以在卖票过程中加个阻塞，问题更加明显</strong></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">       <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">       Thread.sleep(<span class="number">100</span>); <span class="comment">//sleep会抛异常，写时得解决    System.out.println(Thread.currentThread().getName() + &quot;票号：&quot; + ticket);</span></span><br><span class="line">            ticket--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>出现问题的原因：当某个线程操作车票的过程中，尚未操作完成，其他线程参与进来，操作车票</p></li><li><p>如何解决：；当一个线程a在操作ticket的时候，其他线程不能参与进来。直到线程a操作完成ticket时，其他线程才可以开始操作，这种情况即使线程a出现了阻塞，也不能改变。（相当于给厕所装个锁）</p></li></ol><h4 id="2-解决问题方式一"><a href="#2-解决问题方式一" class="headerlink" title="2.解决问题方式一"></a>2.解决问题方式一</h4><h5 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h5><p>在Java中，我们通过同步机制，来解决线程的安全问题</p><p><strong>《方式一：同步代码块》</strong></p><p>synchronized (同步监视器){</p><p>&#x2F;&#x2F;需要被同步的代码—-<strong>不能多也不能少</strong></p><p><strong>包少：一些共享数据还是会出现线程安全问题</strong></p><p><strong>包多：首先单线程效率会变低，其次，例如：卖票问题，如果包了while(true),就会一个窗口把票都卖了，不满足题意</strong></p><p>}</p><p>说明：</p><ol><li><p>操作<strong>共享数据</strong>的代码，即为需要被同步的代码</p></li><li><p>共享数据：多个线程共同操作的变量。比如：ticket就是共享数据</p></li><li><p>同步监视器，俗称：锁。<strong>任何一个类的对象</strong>，都可以充当锁</p><p>要求：<strong>多个线程必须要共用同一把锁</strong>（不能声明在run方法）</p></li></ol><h5 id="2-解决实现类的卖票"><a href="#2-解决实现类的卖票" class="headerlink" title="2.解决实现类的卖票"></a>2.解决实现类的卖票</h5><p>该方式的问题通常在处理同步监视器，以及括号包含的需要被同步的代码上，不能多也不能少。</p><p>同步监视器：实现类可以直接使用this关键字充当当前对象，因为在main方法中只创建了一个该类的对象，所以多个线程使用的是同一个this。当然，也可以通过造一个对象在该类中</p><p>代码演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span>  <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span> ( ) ;<span class="comment">//不能声明在方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;    </span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"><span class="comment">//    synchronized( obj )&#123;   //方式一 使用万能的obj</span></span><br><span class="line">    <span class="keyword">synchronized</span>( <span class="built_in">this</span> )&#123;   <span class="comment">//方式二  直接使用当前对象 this （不用在去new对象）</span></span><br><span class="line">        <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="comment">//Thread.sleep(100); --sleep会抛异常，写时得解决     System.out.println(Thread.currentThread().getName() + &quot;票号：&quot; + ticket);</span></span><br><span class="line">            ticket--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-解决继承Thread卖票"><a href="#3-解决继承Thread卖票" class="headerlink" title="3.解决继承Thread卖票"></a>3.解决继承Thread卖票</h5><p>因为其一个窗口造一个对象，使用造新对象的方式充当当前对象去作为同步监视器，该对象得声明成static类型的，这样多个窗口才能使用同一个对象</p><p>当然，<strong>也有不用造新对象的方法，直接用 “ 类名 . class ” 充当当前对象作为同步监视器 ，因为类只加载一次，也可以充当对象使用–即所有都是面向对象</strong></p><p>代码演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Object <span class="type">static</span>  <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span> ( ) ;<span class="comment">//不能声明在方法，static的</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"><span class="comment">//    synchronized( obj )&#123;   //方式一  造object对象</span></span><br><span class="line"><span class="keyword">synchronized</span>( WindowTwo.class )&#123;   <span class="comment">//方式二  使用此类对象充当当前对象</span></span><br><span class="line"> <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="comment">//Thread.sleep(100); --sleep会抛异常，写时得解决     System.out.println(Thread.currentThread().getName() + &quot;票号：&quot; + ticket);</span></span><br><span class="line">  ticket--;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="3-解决问题方式二"><a href="#3-解决问题方式二" class="headerlink" title="3.解决问题方式二"></a>3.解决问题方式二</h4><h5 id="1-介绍-1"><a href="#1-介绍-1" class="headerlink" title="1.介绍"></a>1.介绍</h5><p>此方式为《同步方法》同样说明与《同步代码块》一样，也是使用的synchronized，也是得有共享数据。也是要求synchronized覆盖的括号内不能有代码不能多也不能少。</p><p>关于同步方法的总结：</p><ol><li><p><strong>同步方法仍然涉及到同步监视器</strong>，只是<strong>不需要我们显式的声明</strong></p></li><li><p><strong>非静态的同步方法，同步监视器是：this</strong></p><p><strong>静态的同步方法，同步监视器是：当前类本身</strong></p></li></ol><h5 id="2-解决实现类的卖票-1"><a href="#2-解决实现类的卖票-1" class="headerlink" title="2.解决实现类的卖票"></a>2.解决实现类的卖票</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//run中无多余代码-------使用非静态的同步方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">run</span> <span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//共享数据被操作的代码</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//如果run又包含了多余的代码，则需要将共享数据被操作的代码封装到另外的方法中，且在该方法声明使用时synchronized。然后在run中调用此方法。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">void</span>  <span class="title function_">run</span> <span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            show();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;<span class="comment">//同步监视器：this</span></span><br><span class="line"><span class="comment">//共享数据被操作的代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="2-解决继承Thread卖票"><a href="#2-解决继承Thread卖票" class="headerlink" title="2.解决继承Thread卖票"></a>2.解决继承Thread卖票</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//run中无多余代码-------使用静态的同步方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">run</span> <span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//共享数据被操作的代码</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果run又包含了多余的代码，则需要将共享数据被操作的代码封装到另外的方法中，且在该方法声明使用时synchronized。然后在run中调用此方法。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">void</span>  <span class="title function_">run</span> <span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            show();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;<span class="comment">//同步监视器：当前类本身</span></span><br><span class="line"><span class="comment">//共享数据被操作的代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="4-解决问题的利弊"><a href="#4-解决问题的利弊" class="headerlink" title="4.解决问题的利弊"></a>4.解决问题的利弊</h4><p>同步的方式，解决了线程的安全问题。—-好处</p><p>操作同步代码时，只能有一个线程参与，其他线程等待。相当于是一个单线程的过程，效率低——坏处</p><h4 id="5-在谈单例模式懒汉式"><a href="#5-在谈单例模式懒汉式" class="headerlink" title="5.在谈单例模式懒汉式"></a>5.在谈单例模式懒汉式</h4><p>由于面向对象（下）讲过单例模式的懒汉式，其中<strong>存在线程不安全问题，现在利用线程同步的解决不安全问题</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bank</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Bank</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Bank</span>  <span class="variable">instance</span>  <span class="operator">=</span> <span class="literal">null</span> ;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Bank <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Bank</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">//多个线程可能同时进入，造了多个对象</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>方式一同步代码块改进：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bank</span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Bank</span>  <span class="variable">instance</span>  <span class="operator">=</span> <span class="literal">null</span> ;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Bank</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">//第一种：效率稍低</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Bank <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(Bank.class)&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123; </span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Bank</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">//因为一个线程拿到锁后造了对象走了，其他线程还在等待，后再拿锁</span></span><br><span class="line">    </span><br><span class="line">     <span class="comment">//第二种：效率稍高</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> Bank <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(instance == <span class="literal">null</span>)</span><br><span class="line">    <span class="keyword">synchronized</span>(Bank.class)&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Bank</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;<span class="comment">//因为一个线程拿锁造对象走了，别的线程判断一下就走了，不用在等待拿锁</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方式二同步方法改进：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bank</span> &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Bank</span>  <span class="variable">instance</span>  <span class="operator">=</span> <span class="literal">null</span> ;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Bank</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Bank <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Bank</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="6-死锁问题"><a href="#6-死锁问题" class="headerlink" title="6.死锁问题"></a>6.死锁问题</h4><h5 id="1-介绍-2"><a href="#1-介绍-2" class="headerlink" title="1.介绍"></a>1.介绍</h5><p><strong>不同线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁</strong></p><h5 id="2-说明"><a href="#2-说明" class="headerlink" title="2.说明"></a>2.说明</h5><ol><li>出现死锁后，不会出现异常，不会出现提示，知识所有的线程都处于阻塞状态，无法继续</li><li>我们使用同步时，要避免出现死锁</li></ol><p>解决方法：</p><ol><li>专门的算法、原则</li><li><strong>尽量减少同步资源</strong>的定义</li><li><strong>尽量避免嵌套同步</strong></li></ol><p>代码演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="type">Object</span> <span class="variable">obj2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(obj1)&#123;</span><br><span class="line">     <span class="comment">// 执行一些代码</span></span><br><span class="line">      <span class="keyword">synchronized</span>(obj2)&#123;  <span class="comment">//拿了1等2</span></span><br><span class="line">    <span class="comment">//    在执行一些代码</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.start();</span><br><span class="line"><span class="comment">//上面拿了obj1下面拿了obj2，接下来又嵌套了一层，且他们需要的锁相反，都在等待对方先给锁----这演示的是最简单的死锁--可以将一个锁封装为方法，调用</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>()&#123;<span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(obj2)&#123;</span><br><span class="line">      <span class="comment">//执行一些代码</span></span><br><span class="line">      <span class="keyword">synchronized</span>(obj1)&#123;  <span class="comment">//拿了2等1</span></span><br><span class="line">       <span class="comment">// 在执行一些代码</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; ).start();</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="7-解决问题方式三"><a href="#7-解决问题方式三" class="headerlink" title="7.解决问题方式三"></a>7.解决问题方式三</h4><p>解决线程安全问题的方式三：Lock锁—-JDK 5.0新增</p><ol><li><strong>实例化ReentrantLock(若是继承的方式，则实例化对象得是static的)</strong></li><li>调用锁定方法Lock( ) </li><li>调用解锁方法unlock</li></ol><p>代码演示：</p><p>下面实现类方式演示，(若是继承的方式，则实例化对象得是static的，为了使每个线程的Lock一样）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Window</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="comment">//实例化ReentrantLock</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>( );</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;    </span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"><span class="keyword">try</span>&#123;  <span class="comment">//用try包裹共享数据被操作的代码，最后用finally调用方法解锁</span></span><br><span class="line">lock.lock();<span class="comment">//调用锁定方法Lock( ) </span></span><br><span class="line">    <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">//Thread.sleep(100); --sleep会抛异常，写时得解决     System.out.println(Thread.currentThread().getName() + &quot;票号：&quot; + ticket);</span></span><br><span class="line">              ticket--;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">     lock.unlock();<span class="comment">//调用解锁方法unlock</span></span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>面试题：</p><ol><li><p>synchronized 与Lock 的异同？</p><p>相同：二者都可以解决线程安全问题</p><p>不同：synchronized机制在执行完相应的同步代码以后，自动的释放同步锁</p><p>​            Lock 需要手动的启动同步（Lock( ) ），同时结束同步也需要手动释放</p></li><li><p>如何解决线程安全问题？有几种方式</p></li></ol><p><strong>优先使用顺序：</strong></p><p><strong>Lock —&gt; 同步代码块（已经进入了方法体，分配了相应资源）—&gt;同步方法</strong>                                                                                                                                                                                                                                                                                                                                        </p><h3 id="5-线程的通信"><a href="#5-线程的通信" class="headerlink" title="5.线程的通信"></a>5.线程的通信</h3><h4 id="1-介绍-3"><a href="#1-介绍-3" class="headerlink" title="1.介绍"></a>1.介绍</h4><ol><li>线程之间通信的两个基本问题是互斥和同步。</li><li>线程同步是指线程之间所具有的一种制约关系，<strong>一个线程的执行依赖另一个线程的消息</strong>，当它没有得到另一个线程的消息时应等待，直到消息到达时才被唤醒。</li><li>线程互斥是指对于共享的操作系统资源，在各线程访问时的排它性。当有若干个线程都要使用某一共享资源时，任何时刻最多只允许一个线程去使用，其它要使用该资源的线程必须等待，直到占用资源者释放该资源。</li></ol><h4 id="2-涉及三个方法"><a href="#2-涉及三个方法" class="headerlink" title="2.涉及三个方法"></a>2.涉及三个方法</h4><p>1.wati() :一旦执行此方法，当前<strong>线程就进入阻塞状态，并释放同步监视器</strong></p><p>2.notify() ：一旦执行此方法，就会<strong>唤醒被wait 的一个</strong>线程，如有多个线程被wait ，就唤醒优先级高的线程</p><p>3.notifyAll()：一旦执行此方法，就会<strong>唤醒所有</strong>被wait 的线程</p><p>说明：</p><ol><li><p>wait() 、notify()、notifyAll(<strong>) 三个方法必须使用在同步代码块中或同步方法中</strong></p></li><li><p>wait() 、notify()、notifyAll() 三个方法的<strong>调用者必须是同步代码块或同步方法中的同步监视器</strong>，否则，会出现IllegalMonitorStateExcption异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (<span class="built_in">this</span>)&#123;</span><br><span class="line"><span class="comment">//或synchronized (obj)</span></span><br><span class="line">    <span class="built_in">this</span>.notify();。</span><br><span class="line">  <span class="comment">//或  obj.wait();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>wait() 、notify()、notifyAll() 三个方法是定义在java.lang.Object类中</strong>（因为这三个方法只能在同步代码块或同步方法中使用，又同步监视器可以是任何的一个类，所以就将这三方法定义在Object类中）</p></li></ol><h4 id="3-sleep-和wait-的区别"><a href="#3-sleep-和wait-的区别" class="headerlink" title="3.sleep()和wait()的区别"></a>3.sleep()和wait()的区别</h4><ol><li>相同点：一旦执行方法，都可以使得当前的<strong>线程进入阻塞状态</strong></li><li>不同点：<ol><li><strong>两个方法声明的位置不同</strong>：sleep() 声明在Thread类中，wait() 声明在Object类中</li><li><strong>调用的要求不同</strong>：sleep() 可以在任何需要的场景下调用。wait() 必须在同步代码块或同步方法中</li><li><strong>关于是否释放同步监视器</strong>：如果两个方法都使用在同步代码块或同步方法中，sleep()不会释放锁，wait()会释放锁（同步监视器）。</li></ol></li></ol><h4 id="4-生产者和消费者例题"><a href="#4-生产者和消费者例题" class="headerlink" title="4.生产者和消费者例题"></a>4.生产者和消费者例题</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">线程通信的应用：经典例题：生产者/消费者问题</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 生产者(Productor)将产品交给店员(Clerk)，而消费者(Customer)从店员处取走产品，</span></span><br><span class="line"><span class="comment">* 店员一次只能持有固定数量的产品(比如:20），如果生产者试图生产更多的产品，店员</span></span><br><span class="line"><span class="comment">* 会叫生产者停一下，如果店中有空位放产品了再通知生产者继续生产；如果店中没有产品</span></span><br><span class="line"><span class="comment">* 了，店员会告诉消费者等一下，如果店中有产品了再通知消费者来取走产品。</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 分析：</span></span><br><span class="line"><span class="comment">* 1. 是否是多线程问题？是，生产者线程，消费者线程</span></span><br><span class="line"><span class="comment">* 2. 是否有共享数据？是，店员（或产品）</span></span><br><span class="line"><span class="comment">* 3. 如何解决线程的安全问题？同步机制,有三种方法</span></span><br><span class="line"><span class="comment">* 4. 是否涉及线程的通信？是</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>代码演示：</p><p>讲解：细节在于两者class Clerk中的两个方法。生产者消费者Clerk是同一个对象，使用同步方法解决线程安全问题，生产者消费者用的也是同一个同步监视器this，因此生产消费不会同时进行。</p><p>根据题目供给关系，产多不产，没了不卖。即当产品大于20，生产者被wait，释放锁。这时消费者拿锁，生产完后notify解锁一个生产者去生产，若生产速度等于消费速度，则会保持平衡</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Clerk</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">productCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//生产产品</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">produceProduct</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(productCount &lt; <span class="number">20</span>)&#123;</span><br><span class="line">            productCount++;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:开始生产第&quot;</span> + productCount + <span class="string">&quot;个产品&quot;</span>);</span><br><span class="line"></span><br><span class="line">            notify();</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//等待</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//消费产品</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">consumeProduct</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(productCount &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:开始消费第&quot;</span> + productCount + <span class="string">&quot;个产品&quot;</span>);</span><br><span class="line">            productCount--;</span><br><span class="line"></span><br><span class="line">            notify();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//等待</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Producer</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;<span class="comment">//生产者</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Clerk clerk;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Producer</span><span class="params">(Clerk clerk)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.clerk = clerk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(getName() + <span class="string">&quot;:开始生产产品.....&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            clerk.produceProduct();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Consumer</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;<span class="comment">//消费者</span></span><br><span class="line">    <span class="keyword">private</span> Clerk clerk;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Consumer</span><span class="params">(Clerk clerk)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.clerk = clerk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(getName() + <span class="string">&quot;:开始消费产品.....&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">20</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            clerk.consumeProduct();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Clerk</span> <span class="variable">clerk</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Clerk</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Producer</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Producer</span>(clerk);</span><br><span class="line">        p1.setName(<span class="string">&quot;生产者1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Consumer</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Consumer</span>(clerk);</span><br><span class="line">        c1.setName(<span class="string">&quot;消费者1&quot;</span>);</span><br><span class="line">        <span class="type">Consumer</span> <span class="variable">c2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Consumer</span>(clerk);</span><br><span class="line">        c2.setName(<span class="string">&quot;消费者2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        p1.start();</span><br><span class="line">        c1.start();</span><br><span class="line">        c2.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="5-会释放锁的操作"><a href="#5-会释放锁的操作" class="headerlink" title="5.会释放锁的操作"></a>5.会释放锁的操作</h4><p><img src="/2022/08/29/Java%E9%AB%98%E7%BA%A7-%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%B8%B8%E7%94%A8%E7%B1%BB-%E6%9E%9A%E4%B8%BE%E7%B1%BB%E4%B8%8E%E6%B3%A8%E8%A7%A3/img%5CSnipaste_2022-01-25_22-00-13.png" alt="Snipaste_2022-01-25_22-00-13"></p><h4 id="6-不会释放锁的操作"><a href="#6-不会释放锁的操作" class="headerlink" title="6.不会释放锁的操作"></a>6.不会释放锁的操作</h4><p><img src="/2022/08/29/Java%E9%AB%98%E7%BA%A7-%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%B8%B8%E7%94%A8%E7%B1%BB-%E6%9E%9A%E4%B8%BE%E7%B1%BB%E4%B8%8E%E6%B3%A8%E8%A7%A3/img%5CSnipaste_2022-01-25_22-00-23.png" alt="Snipaste_2022-01-25_22-00-23"></p><h3 id="6-创建线程的方式三"><a href="#6-创建线程的方式三" class="headerlink" title="6.创建线程的方式三"></a>6.创建线程的方式三</h3><h4 id="1-实现Callable接口"><a href="#1-实现Callable接口" class="headerlink" title="1.实现Callable接口"></a>1.实现Callable接口</h4><p>实现Callable接口。 — JDK 5.0新增</p><p>说明：</p><ol><li><p><strong>创建实现类实现Callable接口，并重写call方法</strong>（该方法返回值类型是Object，所以是可以返回任何类型，且是可以抛出异常的。）</p></li><li><p>new一个实现类对象，将实现类对象作为实参new一个FutureTask对象。</p></li><li><p>将FutureTask对象作为实参，new一个Thread来调用start()方法。（Thread构造器也是用Runnable类型接受的，实际上FutureTask也实现了Runnable接口）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">NumThread</span> <span class="variable">numThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NumThread</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">FutureTask</span> <span class="variable">futureTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FutureTask</span>(numThread);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask).start();</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h4 id="2-代码演示-2"><a href="#2-代码演示-2" class="headerlink" title="2.代码演示"></a>2.代码演示</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建一个实现Callable的实现类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NumThread</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&#123;</span><br><span class="line">    <span class="comment">//2.实现call方法，将此线程需要执行的操作声明在call()中</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadNew</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//3.创建Callable接口实现类的对象</span></span><br><span class="line">        <span class="type">NumThread</span> <span class="variable">numThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NumThread</span>();</span><br><span class="line">        <span class="comment">//4.将此Callable接口实现类的对象作为传递到FutureTask构造器中，创建FutureTask的对象</span></span><br><span class="line">        <span class="type">FutureTask</span> <span class="variable">futureTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FutureTask</span>(numThread);</span><br><span class="line">        <span class="comment">//5.将FutureTask的对象作为参数传递到Thread类的构造器中，创建Thread对象，并调用start()</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//6.获取Callable中call方法的返回值，如不想有返回值，可以在重写call方法时返回null。</span></span><br><span class="line">            <span class="comment">//get()返回值即为FutureTask构造器参数Callable实现类重写的call()的返回值。</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">sum</span> <span class="operator">=</span> futureTask.get();</span><br><span class="line">            System.out.println(<span class="string">&quot;总和为：&quot;</span> + sum);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-创建线程的方式四"><a href="#7-创建线程的方式四" class="headerlink" title="7.创建线程的方式四"></a>7.创建线程的方式四</h3><h4 id="1-线程池"><a href="#1-线程池" class="headerlink" title="1.线程池"></a>1.线程池</h4><p><strong>背景</strong>：经常创建和销毁、使用量特别大的资源，比如并发情况下的线程，</p><p>对性能影响很大。 </p><p><strong>思路</strong>：提前创建好多个线程，放入线程池中，使用时直接获取，使用完</p><p>放回池中。可以避免频繁创建销毁、实现重复利用。类似生活中的公共交</p><p>通工具。</p><p><strong>好处</strong>：</p><ol><li>提高响应速度（减少了创建新线程的时间）</li><li>降低资源消耗（重复利用线程池中线程，不需要每次都创建）</li><li>便于线程管理<ol><li>corePoolSize：核心池的大小</li><li>maximumPoolSize：最大线程数 </li><li>keepAliveTime：线程没有任务时最多保持多长时间后会终止</li></ol></li></ol><h4 id="2-说明："><a href="#2-说明：" class="headerlink" title="2.说明："></a>2.说明：</h4><p>1.创建线程池：提供指定线程数量的线程池</p><p>方式一：</p><ul><li>ThreadPoolExecutor service &#x3D; new ThreadPoolExecutor(CORE_POOL_SIZE)</li></ul><p>方式二：</p><ul><li><p>Executors 工具类，可以直接调用里面的静态方法（newFixedThreadPool）。返回值是ThreadPoolExecutor，它继承了AbstractExecutorService，这个类实现了ExecutorService接口</p></li><li><p>ExecutorService接口（execute()、submit()、shutdown()、shutdownNow()都是这个接口中的方法）</p></li></ul><ol start="2"><li>向线程池提交任务（实现Runnable接口的run方法的类）–可提交多次</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">service.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;适合使用于Runnable</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    ... <span class="comment">// 线程执行的任务</span></span><br><span class="line">&#125;&#125;);</span><br><span class="line"> <span class="comment">//service.submit(Callable callable);//适合使用于Callable</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>3.关闭线程池</p><p>service.shutdown(); </p><ul><li><strong>设置线程池的状态为SHUTDOWN，然后中断所有没有正在执行任务的线程</strong></li></ul><p>service.shutdownNow(); </p><ul><li><strong>设置线程池的状态为 STOP，然后尝试停止所有的正在执行或暂停任务的线程，并返回等待执行任务的列表</strong></li></ul><h4 id="3-代码演示"><a href="#3-代码演示" class="headerlink" title="3.代码演示"></a>3.代码演示</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumberThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt;= <span class="number">100</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: &quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NumberThread1</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt;= <span class="number">100</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> != <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: &quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPool</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//1. 提供指定线程数量的线程池</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">service1</span> <span class="operator">=</span> (ThreadPoolExecutor) service;</span><br><span class="line">        <span class="comment">//设置线程池的属性</span></span><br><span class="line"><span class="comment">//        System.out.println(service.getClass());</span></span><br><span class="line"><span class="comment">//        service1.setCorePoolSize(15);</span></span><br><span class="line"><span class="comment">//        service1.setKeepAliveTime();</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.执行指定的线程的操作。需要提供实现Runnable接口或Callable接口实现类的对象</span></span><br><span class="line">        service.execute(<span class="keyword">new</span> <span class="title class_">NumberThread</span>());<span class="comment">//适合适用于Runnable</span></span><br><span class="line">        service.execute(<span class="keyword">new</span> <span class="title class_">NumberThread1</span>());<span class="comment">//适合适用于Runnable</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        service.submit(Callable callable);//适合使用于Callable</span></span><br><span class="line">        <span class="comment">//3.关闭连接池</span></span><br><span class="line">        service.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2-常用类"><a href="#2-常用类" class="headerlink" title="2.常用类"></a>2.常用类</h2><h3 id="1-String"><a href="#1-String" class="headerlink" title="1.String"></a>1.String</h3><h4 id="1-String详细介绍"><a href="#1-String详细介绍" class="headerlink" title="1.String详细介绍"></a>1.String详细介绍</h4><ol><li><p>String:字符串，使用一对””引起来表示。</p></li><li><p>String声明为final的，不可被继承</p></li><li><p>String实现了Serializable接口：表示字符串是支持序列化的。</p><p>​          实现了Comparable接口：表示String可以比较大小</p></li><li><p>String内部定义了final char[] value用于存储字符串数据</p></li><li><p>String:代表不可变的字符序列。简称：不可变性。</p><p><strong>体现：</strong> </p><ol><li><p>当对字符串<strong>重新赋值</strong>时，<strong>需要重写指定内存区域赋值</strong>，不能使用原有的value进行赋值。</p><p>String s1 &#x3D; “abc”;   s1 &#x3D; “hello”;</p></li><li><p>当对现有的字符串进行<strong>连接操作</strong>时，也<strong>需要重新指定内存区域赋值</strong>，不能使用原有的value进行赋值。</p><p>String s3 &#x3D; “ wwe;   s3 +&#x3D;s1;</p></li><li><p>当调用String的replace()方法<strong>修改指定字符或字符串</strong>时，<strong>也需要重新指定内存区域赋值</strong>，不能使用原有的value进行赋值。  String s4 &#x3D; “abc”;  String s5 &#x3D; s4.replace(‘a’, ‘m’);&#x2F;&#x2F;左老右新</p></li></ol></li><li><p>通过<strong>字面量的方式（区别于new）</strong>给一个字符串赋值，此时的字符串值声明在字符串常量池中。（下结详细讲解）</p></li><li><p><strong>字符串常量池中是不会存储相同内容的字符串的（有复用性）</strong>。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;<span class="comment">//字面量的定义方式</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">System.out.println(s1 == s2); <span class="literal">true</span><span class="comment">//比较s1和s2的地址值</span></span><br><span class="line">s1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">System.out.println(s1 == s2); <span class="literal">false</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="2-String两种实例化区别"><a href="#2-String两种实例化区别" class="headerlink" title="2.String两种实例化区别"></a>2.String两种实例化区别</h4><p>String的实例化方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式一：通过字面量定义的方式</span></span><br><span class="line"><span class="type">String</span>  <span class="variable">s1</span>  <span class="operator">=</span>  <span class="string">&quot;javaEE &quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式二：通过new + 构造器的方式</span></span><br><span class="line"><span class="type">String</span>  <span class="variable">s3</span>  <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">String</span> ( <span class="string">&quot;javaEE &quot;</span> );</span><br></pre></td></tr></table></figure><p> 不同点：</p><ol><li>字面量定义的方式是在方法区常量池中开辟空间存放字符，<strong>栈空间中声明的对象直接指向常量池的字符串</strong></li><li>构造器方式是在方法区常量池中查找有无一样的字符串，没有则开辟新空间存放字符，栈空间指向堆中新造的对象实例，堆空间String类对象实例指向常量池中声明char数组存储的字符串</li></ol><p>相同点：<strong>字符都是存放在常量池中，只不过一个直接获取，一个是间接获取</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;java&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">System.out.print(str1==str2); <span class="comment">//false str1是常量池中字符串地址，str2是堆空间中对象实例的地址</span></span><br></pre></td></tr></table></figure><p><img src="/2022/08/29/Java%E9%AB%98%E7%BA%A7-%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%B8%B8%E7%94%A8%E7%B1%BB-%E6%9E%9A%E4%B8%BE%E7%B1%BB%E4%B8%8E%E6%B3%A8%E8%A7%A3/img%5CSnipaste_2022-01-26_10-21-28.png" alt="Snipaste_2022-01-26_10-21-28">面试题：</p><ol><li><p>面试题：String s &#x3D; new String(“abc”);方式创建对象，在内存中创建了几个对象？两个。一个是堆空间中new结构，另一个是char[]对应的常量池中的数据：”abc”</p></li><li><p><strong>引用数据类型通过值传递来改变本身数据，值传递传的是地址。但是对于String类型有不可变性，传递地址到形参，修改数据也只是在常量池新造的，原本的数据没有被修改</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">面试题：</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;good&quot;</span>);</span><br><span class="line">    <span class="type">char</span>[] ch = &#123; <span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;s&#x27;</span>, <span class="string">&#x27;t&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">(String str, <span class="type">char</span> ch[])</span> &#123;</span><br><span class="line">        str = <span class="string">&quot;test ok&quot;</span>;</span><br><span class="line">        ch[<span class="number">0</span>] = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">StringTest</span> <span class="variable">ex</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringTest</span>();</span><br><span class="line">        ex.change(ex.str, ex.ch);</span><br><span class="line">        System.out.println(ex.str);<span class="comment">//good</span></span><br><span class="line">        System.out.println(ex.ch);<span class="comment">//best</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h4 id="3-String不同连接操作"><a href="#3-String不同连接操作" class="headerlink" title="3.String不同连接操作"></a>3.String不同连接操作</h4><p>结论：</p><ol><li><p><strong>常量与常量的拼接结果在常量池</strong>。且常量池中不会存在相同内容的常量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;javaEEhadoop&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;javaEE&quot;</span> + <span class="string">&quot;hadoop&quot;</span>;</span><br><span class="line">System.out.println(s3 == s4);<span class="comment">//true 地址一样</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><strong>只要其中有一个是变量，结果就在堆中</strong>。（相当于new的方式）</p><p>内存解析：在方法区常量池中查找有无一样的字符串，没有则开辟新空间存放字符，栈空间指向堆中新造的对象实例，堆空间String类对象实例指向常量池中声明char数组存储的字符串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;javaEE&quot;</span>;</span><br><span class="line">   <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;hadoop&quot;</span>;</span><br><span class="line">   <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;javaEEhadoop&quot;</span>;</span><br><span class="line">   <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> s1 + <span class="string">&quot;hadoop&quot;</span>;</span><br><span class="line">   <span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> <span class="string">&quot;javaEE&quot;</span> + s2;</span><br><span class="line">   <span class="type">String</span> <span class="variable">s6</span> <span class="operator">=</span> s1 + s2;</span><br><span class="line">   <span class="comment">//3、4、5、6、地址值各不相同。带变量的相当于new了空间在堆中</span></span><br><span class="line">   </span><br></pre></td></tr></table></figure></li><li><p><strong>拼接问题调用intern()方法（String中的方法），字符返回值就在常量池中</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">   <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;javaEE&quot;</span>;</span><br><span class="line">   <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;javaEEhadoop&quot;</span>;</span><br><span class="line">   <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> s1 + <span class="string">&quot;hadoop&quot;</span>;</span><br><span class="line">   <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> s3.intern();<span class="comment">//返回值得到的s4使用的常量池中已经存在的“javaEEhadoop”</span></span><br><span class="line">   System.out.println(s4 == s2);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">####  面试题：</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line"><span class="type">String</span>  <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;javaEEhadoop&quot;</span> ;</span><br><span class="line"><span class="keyword">final</span>  <span class="type">String</span>  <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;javaEE&quot;</span> ;  <span class="comment">//加上final 就成常量了</span></span><br><span class="line"><span class="type">String</span>  <span class="variable">s3</span>  <span class="operator">=</span>  s2  +  <span class="string">&quot;hadoop&quot;</span> ; <span class="comment">//这里相加就是在常量池中的，地址值一样</span></span><br><span class="line"></span><br><span class="line">System.out.println(s1 == s3);  <span class="comment">//true</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="4-JVM字符串常量池存放位置说明"><a href="#4-JVM字符串常量池存放位置说明" class="headerlink" title="4.JVM字符串常量池存放位置说明"></a>4.JVM字符串常量池存放位置说明</h4><p>JDK 1.6(JDK 6.0 ,java 6.0)：字符串常量池存储在方法区（具体体现是：永久区）</p><p>JDK 1.7 ：字符串常量池存储在堆空间</p><p>JDK 1.8 ：字符串常量池存储在方法区（改名为元空间）</p><h4 id="5-String常用方法"><a href="#5-String常用方法" class="headerlink" title="5.String常用方法"></a>5.String常用方法</h4><h5 id="1-一档"><a href="#1-一档" class="headerlink" title="1.一档"></a>1.一档</h5><ol><li><p>int length()：</p><p>返回字符串的<strong>长度</strong>： return value.length</p><p>String s1 &#x3D; “aBc” ;  int len &#x3D; s1.length();</p></li><li><p>char charAt(int index)：</p><p>返回某<strong>索引处的字符</strong>return value[index]</p><p>String s1 &#x3D; “aBc” ;  char ch &#x3D; charAt(0) ; &#x2F;&#x2F;a</p></li><li><p>boolean isEmpty()：</p><p>判断<strong>是否是空</strong>字符串：return value.length &#x3D;&#x3D; 0</p><p>String s1 &#x3D; “aBc” ;  boolean bo &#x3D; s1.isEmpty(); &#x2F;&#x2F; fasle</p></li><li><p>String toLowerCase()：</p><p>使用默认语言环境，将 String 中的所有字符转换为<strong>小写</strong>   String   s2 &#x3D; s1.toLowerCase();</p></li><li><p>String toUpperCase()：</p><p>使用默认语言环境，将 String 中的所有字符转换为<strong>大写</strong>String   s2 &#x3D; s1.toUpperCase();</p></li><li><p>String trim()：</p><p>返回字符串的副本，忽略前导空白和尾部空白</p><p><strong>去掉字符串头尾的空格</strong></p></li><li><p>boolean equals(Object obj)：</p><p>比较字符串的<strong>内容是否相同</strong></p></li><li><p>boolean equalsIgnoreCase(String anotherString)：</p><p>与equals方法类似，<strong>忽略大小写</strong></p></li><li><p>String concat(String str):</p><p>将指定<strong>字符串连接到此字符串的结尾</strong>。 等价于用“+”</p></li><li><p>int compareTo(String anotherString)：</p><p>比较两个<strong>字符串的大小</strong></p><p>s1.compareTo(s2);</p><p>比较Ascll值，用调用者减实参，返回正数，调用者大，否则实参大</p></li><li><p>String substring(int beginIndex)：</p><p><strong>返回一个新的字符串，它是此字符串的从beginIndex开始截取到最后的一个子字符串。</strong></p></li><li><p>String substring(int beginIndex, int endIndex) ：</p><p>返回一个新字符串，它是此<strong>字符串从beginIndex开始截取到endIndex(不包含)的一个子字符串。[ a ,  b)</strong></p></li></ol><h5 id="2-二档"><a href="#2-二档" class="headerlink" title="2.二档"></a>2.二档</h5><ol><li><p>boolean endsWith(String suffix)：</p><p>测试此字符串是否以指定的后缀结束<br>String str1 &#x3D; “hellowworld”;<br>boolean b1 &#x3D; str1.endsWith(“rld”);&#x2F;&#x2F;可是多个字符</p></li><li><p>boolean startsWith(String prefix)：</p><p>测试此字符串是否以指定的前缀开始</p></li><li><p>boolean startsWith(String prefix, int toffset)：</p><p>测试此字符串从指定索引 ( 包含 ) 开始的子字符串是否以指定前缀开始</p></li><li><p>boolean contains(CharSequence s)：</p><p>当且仅当此字符串包含指定的 char 值序列时（字符匹配），返回 true<br>String str1 &#x3D; “hellowworld”;<br>String str2 &#x3D; “wor”;<br>System.out.println(str1.contains(str2));&#x2F;&#x2F;ture</p></li><li><p>int indexOf(String str)：</p><p>返回指定子字符串在此字符串中第一次出现处的索引（从左往右）</p></li><li><p>int indexOf(String str, int fromIndex)：</p><p>返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始</p></li><li><p>int lastIndexOf(String str)：</p><p>返回指定子字符串在此字符串中最右边出现处的索引</p></li><li><p>int lastIndexOf(String str, int fromIndex)：</p><p>返回指定子字符串在此字符串中最后一次出现处的索引，从指定的索引开始反向搜索</p></li><li><p>注：indexOf和lastIndexOf方法如果未找到都是返回-1</p></li><li><p>什么情况下，indexOf(str)和lastIndexOf(str)返回值相同？<br>情况一：存在唯一的一个str。情况二：不存在str</p></li></ol><h5 id="3-三档"><a href="#3-三档" class="headerlink" title="3.三档"></a>3.三档</h5><p><strong>替换：</strong></p><ol><li><p>String replace(char oldChar, char newChar)：</p><p>返回一个新的字符串，它是通过用 newChar <strong>替换此字符串中出现的所有 oldChar 得到的。</strong><br>String str1 &#x3D; “北京尚硅谷教育北京”;<br>String str2 &#x3D; str1.replace(‘北’, ‘东’);</p></li><li><p>String replace(CharSequence target, CharSequence replacement)：</p><p>使用指定的字面值替换序列替换此字符串所有匹配字面值目标序列的子字符串。<br>String str3 &#x3D; str1.replace(“北京”, “上海”);</p></li><li><p>String replaceAll(String regex, String replacement)：</p><p>使用给定的 replacement 替换此字符串所有匹配给定的<strong>正则表达式</strong>的子字符串。<br>&#x2F;&#x2F;把字符串中的数字替换成,，如果结果中开头和结尾有，的话去掉<br>String str &#x3D; “12hello34world5java7891mysql456”;<br>String string &#x3D; str.replaceAll(“\d+”, “,”).replaceAll(“^,|,$”, “”);<br>System.out.println(string);</p></li><li><p>String replaceFirst(String regex, String replacement)：</p><p>使用给定的 replacement 替换此字符串匹配给定的<strong>正则表达式</strong>的第一个子字符串。</p></li></ol><p><strong>匹配:</strong></p><p>​      boolean matches(String regex)： 告知此字符串是否匹配给定的正则表达式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str = <span class="string">&quot;12345&quot;</span>;</span><br><span class="line"><span class="comment">//判断str字符串中是否全部有数字组成，即有1-n个数字组成</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">matches</span> <span class="operator">=</span> str.matches(<span class="string">&quot;\\d+&quot;</span>);</span><br><span class="line">System.out.println(matches);</span><br></pre></td></tr></table></figure><p><strong>切片：</strong></p><ol><li><p>String[] split(String regex)：</p><p>根据给定正则表达式的匹配拆分此字符串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str = <span class="string">&quot;hello|world|java&quot;</span>;</span><br><span class="line">String[] strs = str.split(<span class="string">&quot;\\|&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; strs.length; i++) &#123;</span><br><span class="line">    System.out.println(strs[i])</span><br></pre></td></tr></table></figure></li><li><p>String[] split(String regex, int limit)：</p><p>根据匹配给定的正则表达式来拆分此字符串，最多不超过limit个，如果超过了，剩下的全部都放到最后一个元素中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">str2 = <span class="string">&quot;hello.world.java&quot;</span>;</span><br><span class="line">String[] strs2 = str2.split(<span class="string">&quot;\\.&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; strs2.length; i++) &#123;</span><br><span class="line">    System.out.println(strs2[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="6-String-与其他类型的转换"><a href="#6-String-与其他类型的转换" class="headerlink" title="6.String 与其他类型的转换"></a>6.String 与其他类型的转换</h4><h5 id="1-复习与包装类的转换"><a href="#1-复习与包装类的转换" class="headerlink" title="1.复习与包装类的转换"></a>1.复习与包装类的转换</h5><p>复习：String 与基本数据类型、包装类之间的转换。</p><ol><li><p>String –&gt; 基本数据类型、包装类：调用包装类的静态方法：parseXxx(str)</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;123&quot;</span>;</span><br><span class="line"><span class="comment">//      int num = (int)str1;//错误的</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> Integer.parseInt(str1);</span><br></pre></td></tr></table></figure></li><li><p>基本数据类型、包装类 –&gt; String:调用String重载的valueOf(xxx)</p></li></ol>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> String.valueOf(num);<span class="comment">//&quot;123&quot; 方式一</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> num + <span class="string">&quot;&quot;</span>; <span class="comment">//方式二</span></span><br></pre></td></tr></table></figure><h5 id="2-与char"><a href="#2-与char" class="headerlink" title="2.与char[ ]"></a>2.与char[ ]</h5><p>String 与 char[]之间的转换</p><ol><li><p>String –&gt; char[]:调用String的toCharArray()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;abc123&quot;</span>;  <span class="comment">//题目： a21cb3</span></span><br><span class="line"><span class="type">char</span>[] charArray = str1.toCharArray();</span><br></pre></td></tr></table></figure></li><li><p>char[] –&gt; String:调用String的构造器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>[] arr = <span class="keyword">new</span> <span class="title class_">char</span>[]&#123;<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;o&#x27;</span>&#125;;</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(arr);</span><br></pre></td></tr></table></figure></li></ol><h5 id="3-与byte"><a href="#3-与byte" class="headerlink" title="3.与byte [ ]"></a>3.与byte [ ]</h5><p>String 与 byte[]之间的转换</p><ol><li><p>编码：String –&gt; byte[]</p><p>调用String的getBytes()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;abc123中国&quot;</span>;</span><br><span class="line"><span class="type">byte</span>[] bytes = str1.getBytes();<span class="comment">//使用默认的字符集，进行编码。</span></span><br><span class="line">System.out.println(Arrays.toString(bytes));</span><br><span class="line"><span class="type">byte</span>[] gbks = str1.getBytes(<span class="string">&quot;gbk&quot;</span>);<span class="comment">//使用gbk字符集进行编码。由于会写错编码集，所以会有异常。</span></span><br><span class="line">System.out.println(Arrays.toString(gbks));</span><br></pre></td></tr></table></figure></li><li><p>解码：byte[] –&gt; String</p><p>调用String的构造器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bytes);<span class="comment">//使用默认的字符集，进行解码。</span></span><br><span class="line">System.out.println(str2);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(gbks);</span><br><span class="line">System.out.println(str3);<span class="comment">//出现乱码。原因：编码集和解码集不一致！</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(gbks, <span class="string">&quot;gbk&quot;</span>);</span><br><span class="line">System.out.println(str4);<span class="comment">//没有出现乱码。原因：编码集和解码集一致！</span></span><br></pre></td></tr></table></figure></li></ol><p>编码与解码：</p><ol><li>编码：字符串 –&gt;字节  (看得懂 —&gt;看不懂的二进制数据)</li><li>解码：编码的逆过程，字节 –&gt; 字符串 （看不懂的二进制数据 —&gt; 看得懂）</li><li>说明：解码时，要求解码使用的字符集必须与编码时使用的字符集一致，否则会出现乱码。</li></ol><h3 id="2-StringBuffer及Builder"><a href="#2-StringBuffer及Builder" class="headerlink" title="2.StringBuffer及Builder"></a>2.StringBuffer及Builder</h3><h4 id="1-面试题-三者String异同"><a href="#1-面试题-三者String异同" class="headerlink" title="1.面试题: 三者String异同"></a>1.面试题: 三者String异同</h4><p>面试题：String、StringBuffer、StringBuilder三者的异同？</p><ol><li>String:<strong>不可变的字符序列</strong>；底层使用<strong>char[]存储</strong></li><li>StringBuffer:<strong>可变</strong>的字符序列；<strong>线程安全</strong>的（使用synchronized同步方法），效率低；底层使用<strong>char[]存储</strong></li><li>StringBuilder:<strong>可变</strong>的字符序列；jdk5.0新增的，<strong>线程不安全</strong>的，效率高；底层使用<strong>char[]存储</strong></li><li><strong>StringBuffer、StringBuilder只区别在线程是否安全</strong></li></ol><p><strong>可变性理解：声明一个确定的字符串，可修改原有的字符串</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuffer</span> <span class="variable">sb1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;abc&quot;</span>); <span class="comment">//声明方式</span></span><br><span class="line">sb1.setCharAt(<span class="number">0</span>,<span class="string">&#x27;m&#x27;</span>); <span class="comment">//此方法无返回值</span></span><br><span class="line">System.out.println(sb1); <span class="comment">//mbc </span></span><br></pre></td></tr></table></figure><p><strong>源码分析：底层的具体区别</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>();<span class="comment">//char[] value = new char[0];</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);<span class="comment">//char[] value =  new char[]&#123;&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">sb1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line"><span class="comment">//char[] value = new char[16];底层创建了一个长度是16的数组。</span></span><br><span class="line">System.out.println(sb1.length());<span class="comment">//0</span></span><br><span class="line">sb1.append(<span class="string">&#x27;a&#x27;</span>);   <span class="comment">//value[0] = &#x27;a&#x27;;</span></span><br><span class="line">sb1.append(<span class="string">&#x27;b&#x27;</span>);   <span class="comment">//value[1] = &#x27;b&#x27;;</span></span><br><span class="line"></span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">sb2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line"><span class="comment">//char[] value = new char[&quot;abc&quot;.length() + 16];底层结构</span></span><br><span class="line">System.out.println(sb2.length());<span class="comment">//输出具体存在的字符个数：3</span></span><br></pre></td></tr></table></figure><p><strong>扩容问题:</strong>    sb1.append(‘a’); </p><ol><li><p>如果要添加的数据底层数组盛不下了，那就需要扩容底层的数组。</p></li><li><p>默认情况下，扩容为原来容量的2倍 + 2，同时将<strong>原有数组中的元素复制到新的数组中。</strong></p></li><li><p>指导意义：</p><p>由于在超出容量，添加新容量复制数组会降低效率，开发中建议大家使用：StringBuffer(int capacity) 或 StringBuilder(int capacity)</p><p><strong>提前指定好所需的容量</strong></p></li></ol><h4 id="2-StringBuffer常用方法"><a href="#2-StringBuffer常用方法" class="headerlink" title="2.StringBuffer常用方法"></a>2.StringBuffer常用方法</h4><p>由于StringBuffer、StringBuilder在方法上差别不大，只区别在线程安全与否，这里只举StringBuffer的方法</p><p>StringBuffer的常用方法：</p><ol><li><p>StringBuffer  append(xxx)</p><p>提供了很多的append()方法，用于进行字符串拼接</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuffer</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">s1.append(<span class="number">1</span>);</span><br><span class="line">s1.append(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">System.out.println(s1); <span class="comment">//abc11</span></span><br></pre></td></tr></table></figure><ol start="2"><li><p>StringBuffer delete(int start,int end)</p><p>删除指定位置的内容 [ a  ,   b ) 左闭右开的</p><p>s1.delete(2,4);</p></li><li><p>StringBuffer replace(int start, int end, String str)</p><p>把 [ start , end ) 位置替换为str</p><p> s1.replace(2,4,”hello”);</p></li><li><p>StringBuffer insert(int offset, xxx)</p><p>在指定位置插入xxx</p><p>s1.insert(2,”wwe”);</p></li><li><p>StringBuffer reverse() </p><p>把当前字符序列逆转</p><p>s1.reverse();</p></li><li><p>public int indexOf(String str) </p><p>返回指定字符串位置索引，没有返回 -1。</p><p>System.out.println(s1.indexOf(“b”));</p></li><li><p>public String substring(int start,int end)</p><p>返回一个从start开始到end索引结束的左闭右开区间的子字符串</p><p>String s2 &#x3D; s1.substring(1, 3);</p></li><li><p>public int length()  </p><p>长度  s1.length();</p></li><li><p>public char charAt(int n )</p><p>返回指定索引字符：从 0 开始</p></li><li><p>public void setCharAt(int n ,char ch)</p><p>无返回值，添加指定在指定索引处</p></li></ol><p>总结：重点注意一下方法</p><p>增：append(xxx)<br>删：delete(int start,int end)<br>改：setCharAt(int n ,char ch) &#x2F; replace(int start, int end, String str)</p><p>查：charAt(int n )</p><p>插：insert(int offset, xxx)<br>长度：length();<br>*遍历：for() + charAt() &#x2F; toString()</p><h4 id="3-三者效率对比"><a href="#3-三者效率对比" class="headerlink" title="3.三者效率对比"></a>3.三者效率对比</h4><p>对比String、StringBuffer、StringBuilder三者的效率：</p><p>从高到低排列：StringBuilder &gt; StringBuffer &gt; String</p><p>测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//初始设置</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">    <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="comment">//开始对比</span></span><br><span class="line">    startTime = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20000</span>; i++) &#123;</span><br><span class="line">        buffer.append(String.valueOf(i));</span><br><span class="line">    &#125;</span><br><span class="line">    endTime = System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;StringBuffer的执行时间：&quot;</span> + (endTime - startTime));</span><br><span class="line"></span><br><span class="line">startTime = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20000</span>; i++) &#123;</span><br><span class="line">    builder.append(String.valueOf(i));</span><br><span class="line">&#125;</span><br><span class="line">endTime = System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">&quot;StringBuilder的执行时间：&quot;</span> + (endTime - startTime));</span><br><span class="line"></span><br><span class="line">startTime = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20000</span>; i++) &#123;</span><br><span class="line">    text = text + i;</span><br><span class="line">&#125;</span><br><span class="line">endTime = System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">&quot;String的执行时间：&quot;</span> + (endTime - startTime));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-String与两者的之间转换"><a href="#4-String与两者的之间转换" class="headerlink" title="4.String与两者的之间转换"></a>4.String与两者的之间转换</h4><ol><li><p>String —&gt; StringBuffer、StringBuilder </p><p>调用StringBuffer、StringBuilder 构造器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span>  <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="type">StringBuffer</span>  <span class="variable">sb1</span>  <span class="operator">=</span>  <span class="keyword">new</span>   <span class="title class_">StringBuffer</span>(s1);</span><br></pre></td></tr></table></figure></li><li><p>StringBuffer、StringBuilder —&gt;String </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式一：调用String构造器</span></span><br><span class="line"><span class="type">StringBuffer</span>  <span class="variable">sb1</span>  <span class="operator">=</span>  <span class="keyword">new</span>   <span class="title class_">StringBuffer</span>(<span class="string">&quot;abcc&quot;</span>);</span><br><span class="line"><span class="type">String</span>  <span class="variable">s1</span> <span class="operator">=</span>  <span class="keyword">new</span>  <span class="title class_">String</span>(sb1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式二：StringBuffer、StringBuilder的toString( ) </span></span><br><span class="line"><span class="type">StringBuffer</span>  <span class="variable">sb1</span>  <span class="operator">=</span>  <span class="keyword">new</span>   <span class="title class_">StringBuffer</span>(<span class="string">&quot;abcc&quot;</span>);</span><br><span class="line"><span class="type">String</span>  <span class="variable">s1</span> <span class="operator">=</span> sb1.toString() ;  </span><br></pre></td></tr></table></figure></li></ol><h3 id="3-关于String常见算法题"><a href="#3-关于String常见算法题" class="headerlink" title="3.关于String常见算法题"></a>3.关于String常见算法题</h3><h4 id="1-指定字符反转"><a href="#1-指定字符反转" class="headerlink" title="1.指定字符反转"></a>1.指定字符反转</h4><p>将一个字符串进行反转。将字符串中指定部分进行反转。比如“abcdefg”反转为“abcfedcg”</p><p>具体代码演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式一：转换为char数组，在转回</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">reverse1</span><span class="params">(String str, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (str != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">char</span>[] c1 = str.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start, j = end; i &lt; j; j--, i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">temp</span> <span class="operator">=</span> c1[i];</span><br><span class="line">            c1[i] = c1[j];</span><br><span class="line">            c1[j] = temp;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(c1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式二:利用String连接</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">reverse2</span><span class="params">(String str, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (str != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> str.substring(<span class="number">0</span>, start);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> end; i &gt;= start; i--) &#123;</span><br><span class="line">            s1 += str.charAt(i);</span><br><span class="line">        &#125;</span><br><span class="line">        s1 += str.substring(end + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> s1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式三：效率更高，利用StringBuilder可变性直接连接</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">reverse3</span><span class="params">(String str, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(str!=<span class="literal">null</span>)&#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">stringBuffer</span> <span class="operator">=</span> newStringBuilder(str.length());</span><br><span class="line">        stringBuffer.append(str.substring(<span class="number">0</span>,start));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=end ;i&gt;=start ; i--)&#123;</span><br><span class="line">            stringBuffer.append(str.charAt(i));</span><br><span class="line">        &#125;</span><br><span class="line">        stringBuffer.append(str.substring(end+<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">return</span> stringBuffer.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-字符串中出现的次数"><a href="#2-字符串中出现的次数" class="headerlink" title="2.字符串中出现的次数"></a>2.字符串中出现的次数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">获取一个字符串在另一个字符串中出现的次数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">number</span><span class="params">(String str,String str1)</span>&#123;</span><br><span class="line">   <span class="type">int</span> <span class="variable">mainStr</span> <span class="operator">=</span> str.length();</span><br><span class="line">   <span class="type">int</span> <span class="variable">subStr</span> <span class="operator">=</span>  str1.length();</span><br><span class="line">   <span class="type">int</span> index=<span class="number">0</span>,count=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">if</span>(mainStr&gt;=subStr)&#123;</span><br><span class="line">       <span class="keyword">while</span>((index=str.indexOf(str1,index))!=-<span class="number">1</span>)&#123;</span><br><span class="line">           count++;</span><br><span class="line">           index+=subStr;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> count;</span><br><span class="line">   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-获取两个字符串中最大相同子串"><a href="#3-获取两个字符串中最大相同子串" class="headerlink" title="3.获取两个字符串中最大相同子串"></a>3.获取两个字符串中最大相同子串</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment"> 情况一：只有一个最大字符子串</span></span><br><span class="line"><span class="comment">    获取两个字符串中最大相同子串</span></span><br><span class="line"><span class="comment">    str1=&quot;abcwerthelloyuiodef&quot; str2 = &quot;cvhellobnm&quot;</span></span><br><span class="line"><span class="comment">    提示：将短的那个串进行长度依次递减的子串与较长的串比较</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getMaxSameString</span><span class="params">(String str1,String str2)</span>&#123;</span><br><span class="line"> <span class="keyword">if</span>(str1!=<span class="literal">null</span> &amp;&amp; str2!=<span class="literal">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">   <span class="type">String</span> <span class="variable">maxStr</span> <span class="operator">=</span> (str1.length()&gt;=str2.length())?str1:str2;</span><br><span class="line">    <span class="type">String</span> <span class="variable">minStr</span> <span class="operator">=</span> (str1.length()&lt;str2.length())?str1:str2;</span><br><span class="line">         <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> minStr.length();</span><br><span class="line">          <span class="comment">//每一轮都少一个，在第二层循环从左往右移动对比。</span></span><br><span class="line">         <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span> ; i&lt;minStr.length() ; i++) &#123; </span><br><span class="line">          <span class="comment">//因subString是左闭右开，所以包括length</span></span><br><span class="line">             <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>, y = length - i; y &lt;= length; x++, y++) &#123;</span><br><span class="line">             <span class="type">String</span> <span class="variable">subStr</span> <span class="operator">=</span> minStr.substring(x,y);</span><br><span class="line">             <span class="keyword">if</span>(maxStr.contains(subStr))&#123;</span><br><span class="line">                 <span class="keyword">return</span> subStr;</span><br><span class="line">             &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">// 情况二：如果存在多个长度相同的最大相同子串</span></span><br><span class="line">    <span class="comment">// 此时先返回String[]，后面可以用集合中的ArrayList替换，较方便</span></span><br><span class="line">    <span class="keyword">public</span> String[] getMaxSameString1(String str1, String str2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (str1 != <span class="literal">null</span> &amp;&amp; str2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">StringBuffer</span> <span class="variable">sBuffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">            <span class="type">String</span> <span class="variable">maxString</span> <span class="operator">=</span> (str1.length() &gt; str2.length()) ? str1 : str2;</span><br><span class="line">            <span class="type">String</span> <span class="variable">minString</span> <span class="operator">=</span> (str1.length() &gt; str2.length()) ? str2 : str1;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> minString.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>, y = len - i; y &lt;= len; x++, y++) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">subString</span> <span class="operator">=</span> minString.substring(x, y);</span><br><span class="line">                <span class="keyword">if</span> (maxString.contains(subString)) &#123;</span><br><span class="line">                    sBuffer.append(subString + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//                System.out.println(sBuffer);</span></span><br><span class="line">                <span class="keyword">if</span> (sBuffer.length() != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            String[] split = sBuffer.toString().replaceAll(<span class="string">&quot;,$&quot;</span>, <span class="string">&quot;&quot;</span>).split(<span class="string">&quot;\\,&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> split;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-JDK-8之前日期和时间"><a href="#4-JDK-8之前日期和时间" class="headerlink" title="4.JDK 8之前日期和时间"></a>4.JDK 8之前日期和时间</h3><p>JDK 8之前日期和时间的API测试</p><h4 id="1-System类"><a href="#1-System类" class="headerlink" title="1.System类"></a>1.System类</h4><p>System类中的currentTimeMillis()</p><p>返回当前时间与1970年1月1日0时0分0秒之间以毫秒为单位的时间差。</p><p>称为时间戳</p><p>long time &#x3D; System.currentTimeMillis();<br>System.out.println(time);</p><h4 id="2-date类"><a href="#2-date类" class="headerlink" title="2.date类"></a>2.date类</h4><p>java.util.Date类 是 java.sql.Date类 的 父类（前者是java程序中常用的，后者是数据库中常用的时间）</p><p>1.两个构造器的使用</p><ol><li><p>构造器一：Date()：创建一个对应当前时间的Date对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Date</span> <span class="variable">date1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">System.out.println(date1.toString());</span><br><span class="line"><span class="comment">//Sat Feb 16 16:35:31 GMT+08:00 2019</span></span><br><span class="line">System.out.println(date1.getTime());</span><br><span class="line"><span class="comment">//1550306204104 从1970年1月1日0时0分0秒</span></span><br></pre></td></tr></table></figure></li><li><p>构造器二：创建指定毫秒数的Date对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Date</span> <span class="variable">date2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">155030620410L</span>);</span><br><span class="line"><span class="comment">//也是从1970年1月1日0时0分0秒计算</span></span><br><span class="line">System.out.println(date2.toString());</span><br></pre></td></tr></table></figure></li></ol><p>2.两个方法的使用</p><ol><li><p>toString():显示当前的年、月、日、时、分、秒</p><p>System.out.println(date1.toString());<br>输出格式：Sat Feb 16 16:35:31 GMT+08:00 2019</p></li><li><p>getTime():获取当前Date对象对应的毫秒数。（时间戳）</p><p>System.out.println(date1.getTime());<br>输出格式：1550306204104</p></li></ol><p>3.java.sql.Date对应着数据库中的日期类型的变量</p><ol><li><p>如何实例化？  </p><p>只能用指定毫秒数的构造器了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java.sql.<span class="type">Date</span> <span class="variable">date3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">java</span>.sql.Date(<span class="number">355325345L</span>);</span><br><span class="line">System.out.println(date3);</span><br><span class="line"><span class="comment">//其toString输出格式1971-02-13  区别于util包下的</span></span><br></pre></td></tr></table></figure></li><li><p>如何将java.util.Date对象转换为java.sql.Date对象</p><p>情况一：声明父类，new子类—（强转）多态性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Date</span> <span class="variable">date4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">java</span>.sql.Date(<span class="number">2343243242323L</span>);</span><br><span class="line">java.sql.<span class="type">Date</span> <span class="variable">date5</span> <span class="operator">=</span> (java.sql.Date)date4;</span><br></pre></td></tr></table></figure></li></ol><p>​     情况二：声明父类，new父类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Date</span> <span class="variable">date6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">  java.sql.<span class="type">Date</span> <span class="variable">date7</span> <span class="operator">=</span>  <span class="keyword">new</span>  <span class="title class_">java</span>.sql.Date(date6.getTime());</span><br></pre></td></tr></table></figure><p>   ​</p><h4 id="3-SimpleDateFormat类"><a href="#3-SimpleDateFormat类" class="headerlink" title="3.SimpleDateFormat类"></a>3.SimpleDateFormat类</h4><p>SimpleDateFormat的使用：<strong>SimpleDateFormat对日期Date类的格式化和解析</strong></p><p>1.两个操作：</p><ol><li><p>格式化：日期 —&gt;字符串 </p><p>String  format(Date date )</p></li><li><p>解析：格式化的逆过程，字符串 —&gt; 日期</p><p>Date  parse(String  string )  该字符串日期格式是与构造器对应格式</p></li></ol><p>2.类型一：默认构造器，格式化日期单一</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实例化SimpleDateFormat :  使用默认的构造器</span></span><br><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">sdf</span>  <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>();</span><br><span class="line"><span class="comment">//格式化：日期 ---&gt;字符串</span></span><br><span class="line"><span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">System.out.println(date);<span class="comment">//Thu Jan 27 20:03:38 CST 2022</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">format</span> <span class="operator">=</span> sdf.format(date);</span><br><span class="line">System.out.println(format);<span class="comment">//22-1-27 下午8:03</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//解析：格式化的逆过程，字符串 ---&gt; 日期</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;19-12-18 上午11:43&quot;</span>; <span class="comment">//只能是这种格式</span></span><br><span class="line"><span class="type">Date</span> <span class="variable">date1</span> <span class="operator">=</span> sdf.parse(str);</span><br><span class="line">System.out.println(date1);<span class="comment">//Wed Dec 18 11:43:00 CST 2019</span></span><br></pre></td></tr></table></figure><p>3.类型二：调用带参构造器，可选择合适的日期格式的构造器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">sdf1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>);<span class="comment">//y年，M月，d天，h小时，m分钟，s秒</span></span><br><span class="line">    <span class="comment">//格式化</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">format1</span> <span class="operator">=</span> sdf1.format(date);</span><br><span class="line">    System.out.println(format1);<span class="comment">//2019-02-18 11:48:27</span></span><br><span class="line">    <span class="comment">//解析:要求字符串必须是符合SimpleDateFormat识别的格式(通过构造器参数体现),否则，抛异常</span></span><br><span class="line">    <span class="type">Date</span> <span class="variable">date2</span> <span class="operator">=</span> sdf1.parse(<span class="string">&quot;2020-02-18 11:48:27&quot;</span>);</span><br><span class="line">    System.out.println(date2);<span class="comment">//Tue Feb 18 11:48:27 CST 2020</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-Calendar日历类"><a href="#4-Calendar日历类" class="headerlink" title="4.Calendar日历类"></a>4.Calendar日历类</h4><p>Calendar日历类(抽象类：不能new对象）的使用：</p><h5 id="1-实例化"><a href="#1-实例化" class="headerlink" title="1.实例化"></a>1.实例化</h5><ol><li><p>方式一：创建其子类（GregorianCalendar）的对象</p></li><li><p>方式二：调用其静态方法getInstance()</p><p>其实第二种方式也是new的GregorianCalendar对象，方式二容易记住</p><p><strong>Calendar  calendar  &#x3D;  Calendar.getInstance();</strong></p></li></ol><h5 id="2-常用方法"><a href="#2-常用方法" class="headerlink" title="2.常用方法"></a>2.常用方法</h5><p>注意：</p><p>获取月份时：一月是0，二月是1….12月是11</p><p>获取星期时：周日是1，周一是2…周六是7</p><ol><li><p>int  get()</p><p>获取指定信息：YEAR、MONTH、DAY_OF_YEAR等等</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Calendar</span>  <span class="variable">calendar</span>  <span class="operator">=</span>  Calendar.getInstance();</span><br><span class="line"><span class="type">int</span> <span class="variable">days</span> <span class="operator">=</span> calendar.get(Calendar.DAY_OF_MONTH); <span class="comment">//这月的第几天</span></span><br><span class="line">System.out.println(days);</span><br><span class="line"><span class="comment">//这年的第几天：DAY_OF_YEAR</span></span><br></pre></td></tr></table></figure></li><li><p>void  set()</p><p>修改指定信息     ，calendar可变性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Calendar</span>  <span class="variable">calendar</span>  <span class="operator">=</span>  Calendar.getInstance();</span><br><span class="line">calendar.set(Calendar.DAY_OF_MONTH,<span class="number">22</span>);</span><br><span class="line">days = calendar.get(Calendar.DAY_OF_MONTH);</span><br><span class="line">System.out.println(days);<span class="comment">//22</span></span><br></pre></td></tr></table></figure></li><li><p>void  add()</p><p>增加指定信息个数，负数为减少个数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> calendar.add(Calendar.DAY_OF_MONTH,-<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">Calendar</span>  <span class="variable">calendar</span>  <span class="operator">=</span>  Calendar.getInstance();</span><br><span class="line">calendar.add(Calendar.DAY_OF_MONTH,-<span class="number">3</span>);</span><br><span class="line">days = calendar.get(Calendar.DAY_OF_MONTH);</span><br><span class="line">System.out.println(days);</span><br></pre></td></tr></table></figure></li><li><p>Date  getTime()</p><p><strong>获取Date类型的日期：日历类—&gt; Date</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Calendar</span>  <span class="variable">calendar</span>  <span class="operator">=</span>  Calendar.getInstance();</span><br><span class="line"><span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> calendar.getTime();</span><br><span class="line">System.out.println(date);</span><br></pre></td></tr></table></figure></li><li><p>void  setTime()</p><p><strong>Date类 —&gt; 日历类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Calendar</span>  <span class="variable">calendar</span>  <span class="operator">=</span>  Calendar.getInstance();</span><br><span class="line"><span class="type">Date</span> <span class="variable">date1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">calendar.setTime(date1); <span class="comment">//不用返回值，对象可变</span></span><br><span class="line"> days = calendar.get(Calendar.DAY_OF_MONTH);</span><br><span class="line">    System.out.println(days);</span><br></pre></td></tr></table></figure></li></ol><h5 id="3-练习"><a href="#3-练习" class="headerlink" title="3.练习"></a>3.练习</h5><p>练习一：字符串”2020-09-08”转换为java.sql.Date</p><p>字符串–&gt;SimpleDateFormat类–&gt;util.Date类—&gt;sql.Date类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">birth</span> <span class="operator">=</span> <span class="string">&quot;2020-09-08&quot;</span>;</span><br><span class="line"> <span class="type">SimpleDateFormat</span> <span class="variable">sdf1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line"> <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> sdf1.parse(birth);</span><br><span class="line">java.sql.<span class="type">Date</span> <span class="variable">birthDate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">java</span>.sql.Date(date.getTime());</span><br><span class="line">System.out.println(birthDate);</span><br></pre></td></tr></table></figure><p>练习二：”三天打渔两天晒网”   1990-01-01  xxxx-xx-xx 打渔？晒网？</p><p>举例：2020-09-08 ？ 总天数</p><p>总天数 % 5 &#x3D;&#x3D; 1,2,3 : 打渔<br>总天数 % 5 &#x3D;&#x3D; 4,0 : 晒网</p><p>总天数的计算？<br>方式一：( date2.getTime() - date1.getTime()) &#x2F; (1000 * 60 * 60 * 24) + 1<br>方式二：1990-01-01  –&gt; 2019-12-31  +  2020-01-01 –&gt;2020-09-08</p><h3 id="5-JDK8中日期和时间"><a href="#5-JDK8中日期和时间" class="headerlink" title="5.JDK8中日期和时间"></a>5.JDK8中日期和时间</h3><h4 id="1-总体介绍"><a href="#1-总体介绍" class="headerlink" title="1.总体介绍"></a>1.总体介绍</h4><ol><li>java.time  包含值对象的基础包</li><li>java.time.chrono  提供对不同日历系统的访问</li><li>java.time.format   格式化和解析时间和日期</li><li>java.time.temporal    包括底层框架和扩展特性</li><li>java.time.zone    包含时区支持的类</li></ol><p>说明：</p><p>大多数开发者只会用到基础包和format包，也可能会用到temporal包。因此，尽管有68个新的公开类型，大多数开发者，大概只会用到其中的三分之一</p><h4 id="1-LocalDate-x2F-Time-x2F-DateTime"><a href="#1-LocalDate-x2F-Time-x2F-DateTime" class="headerlink" title="1.LocalDate&#x2F;Time&#x2F;DateTime"></a>1.LocalDate&#x2F;Time&#x2F;DateTime</h4><h5 id="1-出现背景"><a href="#1-出现背景" class="headerlink" title="1.出现背景"></a>1.出现背景</h5><p>JDK 1.0中包含了一个java.util.Date类，但是它的大多数方法已经在JDK 1.1引入Calendar类之后被弃用了。而Calendar并不比Date好多少。<strong>它们面临的问题是</strong>：</p><ol><li><p>可变性：像日期和时间这样的类应该是<strong>不可变</strong>的。</p></li><li><p>偏移性：<strong>Date中的年份是从1900开始</strong>的，而<strong>月份都从0开始</strong>。</p><p>Date date1 &#x3D; new Date(2020 - 1900,9 - 1,8);<br>System.out.println(date1);&#x2F;&#x2F;Tue Sep 08 00:00:00 GMT+08:00 2020</p></li><li><p>格式化：格式化只对Date有用，Calendar则不行。</p></li><li><p>此外，它们也不是线程安全的；不能处理闰秒等</p></li></ol><h5 id="2-主要介绍及方法"><a href="#2-主要介绍及方法" class="headerlink" title="2.主要介绍及方法"></a>2.主要介绍及方法</h5><p>LocalDate（只有日期）、LocalTime（只有时间）、LocalDateTime （日期加时间）的使用</p><p>说明：</p><ol><li><p><strong>LocalDateTime</strong>相较于LocalDate、LocalTime，使用频率要高</p></li><li><p>类似于Calendar</p></li></ol><p><strong>主要方法使用</strong>：主要以LocalDateTime举例</p><ol><li><p><strong>now()  —–静态方法（实例化方式一）</strong></p><p><strong>获取当前的日期、时间、日期+时间</strong></p><p>LocalDate localDate &#x3D; LocalDate.now();<br>LocalTime localTime &#x3D; LocalTime.now();<br>LocalDateTime localDateTime &#x3D; LocalDateTime.now();</p></li><li><p><strong>of()   —–静态方法（实例化方式二）</strong></p><p><strong>设置指定的年、月、日、时、分、秒。没有偏移量</strong></p><p>LocalDateTime localDateTime1 &#x3D; LocalDateTime.of(2020, 10, 6, 13, 23, 43);</p></li><li><p><strong>getXxx()：获取相关的属性</strong></p><p> System.out.println(localDateTime.getDayOfMonth());<br> System.out.println(localDateTime.getDayOfWeek());<br> System.out.println(localDateTime.getMonth());<br> System.out.println(localDateTime.getMonthValue());<br> System.out.println(localDateTime.getMinute());</p></li><li><p>withXxx()：设置相关的属性—有返回值，体现不可变性</p><p> LocalDate localDate1 &#x3D; localDate.withDayOfMonth(22);<br> System.out.println(localDate);18–原来的不变<br> System.out.println(localDate1);20 </p></li><li><p>plusMonths(3)：加个数—-有返回值，体现不可变性</p><p> LocalDateTime localDateTime3 &#x3D; localDateTime.plusMonths(3);<br>System.out.println(localDateTime);<br>System.out.println(localDateTime3);</p></li><li><p>minusDays(6)：减个数—–有返回值，体现不可变性</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LocalDateTime</span> <span class="variable">localDateTime4</span> <span class="operator">=</span> localDateTime.minusDays(<span class="number">6</span>);</span><br><span class="line">System.out.println(localDateTime);</span><br><span class="line">System.out.println(localDateTime4);</span><br></pre></td></tr></table></figure><h4 id="2-Instan类瞬时"><a href="#2-Instan类瞬时" class="headerlink" title="2.Instan类瞬时"></a>2.Instan类瞬时</h4><p><strong>说明：</strong></p><ol><li><p><strong>时间线上的一个瞬时点。 这可能被用来记录应用程序中的事件时间戳。</strong></p></li><li><p>类似于 java.util.Date类</p></li></ol><p><strong>主要方法使用：</strong></p><ol><li><p><strong>now()  —–静态方法（实例化方式）</strong></p><p>获取本初子午线对应的标准时间(0时线，和北京时间差8小时)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Instant</span> <span class="variable">instant</span> <span class="operator">=</span> Instant.now();</span><br><span class="line">System.out.println(instant);<span class="comment">//2019-02-18T07:29:41.719Z</span></span><br></pre></td></tr></table></figure></li><li><p>atOffset(ZoneOffset.ofHours(8))</p><p>添加时间的偏移量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">OffsetDateTime</span> <span class="variable">offsetDateTime</span>   <span class="operator">=</span>  instant.atOffset(ZoneOffset.ofHours(<span class="number">8</span>));</span><br><span class="line">System.out.println(offsetDateTime);<span class="comment">//2019-02-18T15:32:50.611+08:00</span></span><br></pre></td></tr></table></figure></li><li><p>toEpochMilli(long  Milli)</p><p>获取自1970年1月1日0时0分0秒（UTC）开始的毫秒数  —&gt; Date类的getTime()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">milli</span> <span class="operator">=</span> instant.toEpochMilli();</span><br><span class="line">System.out.println(milli);</span><br></pre></td></tr></table></figure></li><li><p>ofEpochMilli()</p><p>通过给定的毫秒数，获取Instant实例  –&gt;Date(long millis)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Instant</span> <span class="variable">instant1</span> <span class="operator">=</span> Instant.ofEpochMilli(<span class="number">1550475314878L</span>);</span><br><span class="line">System.out.println(instant1);</span><br></pre></td></tr></table></figure></li></ol><h4 id="3-DateTimeFormatter-类"><a href="#3-DateTimeFormatter-类" class="headerlink" title="3.DateTimeFormatter 类"></a>3.DateTimeFormatter 类</h4><p>java.time.format.DateTimeFormatter 类</p><p><strong>该类提供了三种格式化方法：</strong></p><ol><li><p>预定义的标准格式ISO_LOCAL_DATE_TIME;ISO_LOCAL_DATE;ISO_LOCAL_TIME</p></li><li><p>本地化相关的格式</p><p>ofLocalizedDateTime(FormatStyle.LONG)</p></li><li><p>自定义的格式</p><p><strong>ofPattern(“yyyy-MM-dd hh:mm:ss”)</strong></p></li></ol><p><strong>使用说明：</strong></p><ol><li><p><strong>预定义的标准格式</strong></p><p>ISO_LOCAL_DATE_TIME    日期+时间</p><p>ISO_LOCAL_DATE               日期</p><p>ISO_LOCAL_TIME               时间</p><p><strong>实例化：</strong></p><p>DateTimeFormatter  formatter  &#x3D;  DateTimeFormatter.ISO_LOCAL_DATE_TIME;</p><p><strong>format( ) 格式化:日期–&gt;字符串</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="type">LocalDateTime</span> <span class="variable">localDateTime</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> formatter.format(localDateTime);</span><br><span class="line">System.out.println(localDateTime);<span class="comment">// 2019-02-18T15:42:18.797</span></span><br><span class="line">System.out.println(str1); <span class="comment">// 2019-02-18T15:42:18.797</span></span><br></pre></td></tr></table></figure><p><strong>parse() 解析：字符串 –&gt;日期 返回值类型为TemporalAccessor</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">TemporalAccessor</span> <span class="variable">parse</span> <span class="operator">=</span> formatter.parse(<span class="string">&quot;2019-02-18T15:42:18.797&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(parse);<span class="comment">//2019-02-18T15:42:18.797</span></span><br></pre></td></tr></table></figure></li><li><p><strong>本地化相关的格式  –解析方式一样，不列举</strong></p><p><strong>适用于LocalDateTime（日期+时间形式）：</strong></p><p>ofLocalizedDateTime(FormatStyle.SHORT);</p><ol><li>FormatStyle.LONG   2022年1月28日 上午11时56分26秒</li><li>FormatStyle.MEDIUM   2022-1-28 11:57:15</li><li>FormatStyle.SHORT      22-1-28 上午11:57</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DateTimeFormatter</span> <span class="variable">formatter1</span> <span class="operator">=</span> DateTimeFormatter.ofLocalizedDateTime(FormatStyle.SHORT);</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> formatter1.format(localDateTime);</span><br><span class="line">System.out.println(str2);<span class="comment">//2019年2月18日 下午03时47分16秒</span></span><br></pre></td></tr></table></figure><p><strong>适用于LocalizedDate()（日期）：</strong></p><p>ofLocalizedDate(FormatStyle.FULL);</p><ol><li><p>FormatStyle.LONG       2022年1月28日</p></li><li><p>FormatStyle.MEDIUM    2022-1-28</p></li><li><p>FormatStyle.SHORT       22-1-28</p></li><li><p>FormatStyle.FULL    2022年1月28日 星期五</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DateTimeFormatter</span> <span class="variable">formatter2</span> <span class="operator">=</span> DateTimeFormatter.ofLocalizedDate(FormatStyle.FULL);</span><br><span class="line"><span class="comment">//格式化</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span>formatter2.format(LocalDate.now());</span><br><span class="line">System.out.println(str3);<span class="comment">//2019-2-18  </span></span><br></pre></td></tr></table></figure></li></ol></li><li><p><strong>自定义的格式</strong></p><p><strong>ofPattern(“yyyy-MM-dd hh:mm:ss”)</strong></p><p>yyyy-MM-dd hh:mm:ss   2019-02-18 03:52:09</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DateTimeFormatter</span> <span class="variable">formatter3</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>);</span><br><span class="line"><span class="comment">//格式化</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> formatter3.format(LocalDateTime.now());</span><br><span class="line">System.out.println(str4);<span class="comment">//2019-02-18 03:52:09</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//解析</span></span><br><span class="line"><span class="type">TemporalAccessor</span> <span class="variable">accessor</span> <span class="operator">=</span> formatter3.parse(<span class="string">&quot;2019-02-18 03:52:09&quot;</span>);</span><br><span class="line">System.out.println(accessor);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="6-Java比较器"><a href="#6-Java比较器" class="headerlink" title="6.Java比较器"></a>6.Java比较器</h3><h4 id="1-介绍-4"><a href="#1-介绍-4" class="headerlink" title="1.介绍"></a>1.介绍</h4><p>在Java中经常会涉及到对象数组的排序问题，那么就涉及到对象之间的比较问题。 </p><p>Java实现对象排序的方式有两种：</p><ol><li>自然排序：java.lang.Comparable</li><li>定制排序：java.util.Comparator</li></ol><p><strong>一、说明：</strong></p><p>Java中的对象，正常情况下，只能进行比较：&#x3D;&#x3D;  或  !&#x3D; 。不能使用 &gt; 或 &lt; 的但是在开发场景中，我们需要对多个对象进行排序，言外之意，就需要比较对象的大小。</p><p><strong>如何实现？</strong></p><p>使用两个接口中的任何一个：Comparable 或 Comparator</p><p><strong>二、Comparable接口与Comparator的使用的对比：</strong></p><p>Comparable<strong>接口的方式一旦一定，保证Comparable接口实现类的对象在任何位置都可以比较大小。</strong></p><p>Comparator接口属于<strong>临时性的比较</strong>。</p><h4 id="2-Comparable自然排序"><a href="#2-Comparable自然排序" class="headerlink" title="2.Comparable自然排序"></a>2.Comparable自然排序</h4><p>Comparable接口的使用举例：  自然排序</p><p> <strong>通过Collections.sort 或Arrays.sort内部调用此重写的compareTo进行排序</strong></p><ol><li><p>像String、包装类等实现了Comparable接口，重写了compareTo(obj)方法，给出了比较两个对象大小的方式。</p></li><li><p>像String、包装类重写compareTo()方法以后，默认进行了从小到大的排列</p></li><li><p><strong>重写compareTo(obj)的规则  (默认由小到大) ：</strong></p><ol><li>如果当前对象this大于形参对象obj，则返回正整数，</li><li>如果当前对象this小于形参对象obj，则返回负整数，</li><li>如果当前对象this等于形参对象obj，则返回零。</li></ol></li><li><p>对于<strong>自定义类</strong>来说，如果需要排序，我们可以让<strong>自定义类实现Comparable接口，重写compareTo(obj)方法。</strong>在compareTo(obj)方法中指明如何排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//指明商品比较大小的方式:按照价格从低到高排序,再按照产品名称从高到低排序</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Object o)</span> &#123;</span><br><span class="line"><span class="comment">//        System.out.println(&quot;**************&quot;);</span></span><br><span class="line">        <span class="keyword">if</span>(o <span class="keyword">instanceof</span> Goods)&#123;</span><br><span class="line">            <span class="type">Goods</span> <span class="variable">goods</span> <span class="operator">=</span> (Goods)o;</span><br><span class="line">            <span class="comment">//方式一：</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">this</span>.price &gt; goods.price)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">this</span>.price &lt; goods.price)&#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//            return 0;</span></span><br><span class="line"><span class="comment">//          价格相同的按照名称字符大小排序</span></span><br><span class="line">          <span class="keyword">return</span> -<span class="built_in">this</span>.name.compareTo(goods.name);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//方式二：调用包装类已有的compare</span></span><br><span class="line"><span class="comment">//           return Double.compare(this.price,goods.price);</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        return 0;</span></span><br><span class="line"><span class="comment">//如果传入的不是本类型的数据，抛出个提示异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;传入的数据类型不一致！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> */</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">    String[] arr = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;AA&quot;</span>,<span class="string">&quot;CC&quot;</span>,<span class="string">&quot;KK&quot;</span>,<span class="string">&quot;MM&quot;</span>,<span class="string">&quot;GG&quot;</span>,<span class="string">&quot;JJ&quot;</span>,<span class="string">&quot;DD&quot;</span>&#125;;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    Arrays.sort(arr);</span><br><span class="line"></span><br><span class="line">    System.out.println(Arrays.toString(arr)); <span class="comment">//[AA, CC, DD, GG, JJ, KK, MM]</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">    Goods[] arr = <span class="keyword">new</span> <span class="title class_">Goods</span>[<span class="number">5</span>];</span><br><span class="line">    arr[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">Goods</span>(<span class="string">&quot;lenovoMouse&quot;</span>,<span class="number">34</span>);</span><br><span class="line">    arr[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">Goods</span>(<span class="string">&quot;dellMouse&quot;</span>,<span class="number">43</span>);</span><br><span class="line">    arr[<span class="number">2</span>] = <span class="keyword">new</span> <span class="title class_">Goods</span>(<span class="string">&quot;xiaomiMouse&quot;</span>,<span class="number">12</span>);</span><br><span class="line">    arr[<span class="number">3</span>] = <span class="keyword">new</span> <span class="title class_">Goods</span>(<span class="string">&quot;huaweiMouse&quot;</span>,<span class="number">65</span>);</span><br><span class="line">    arr[<span class="number">4</span>] = <span class="keyword">new</span> <span class="title class_">Goods</span>(<span class="string">&quot;microsoftMouse&quot;</span>,<span class="number">43</span>);</span><br><span class="line"></span><br><span class="line">    Arrays.sort(arr);<span class="comment">//内部调用Goods重写CompareTo方法</span></span><br><span class="line"></span><br><span class="line">    System.out.println(Arrays.toString(arr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="3-Comparator定制排序"><a href="#3-Comparator定制排序" class="headerlink" title="3.Comparator定制排序"></a>3.Comparator定制排序</h4><p><strong>1.背景：</strong></p><p>当元素的类型<strong>没有实现java.lang.Comparable接口</strong>而又不方便修改代码（String类内重写的方法不能修改），或者实现了java.lang.Comparable接口的排序规则不适合当前的操作，那么可以考虑使用 Comparator 的对象<strong>临时创建一个排序规则来排序</strong></p><p>**2.重写compare(Object o1,Object o2)规则  ( 默认由小到大 )  ： **</p><p>比较o1和o2的大小：</p><ol><li>如果方法返回正整数，则表示o1大于o2；</li><li>如果返回0，表示相等；</li><li>返回负整数，表示o1小于o2。</li></ol><h4 id="3-自定义Comparator类"><a href="#3-自定义Comparator类" class="headerlink" title="3.自定义Comparator类"></a>3.自定义Comparator类</h4><p> <strong>通过Collections.sort 或Arrays.sort内部调用此重写的compare进行排序</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">String[] arr = <span class="keyword">new</span> <span class="title class_">String</span>[ ] &#123; <span class="string">&quot;AA&quot;</span>,<span class="string">&quot;CC&quot;</span>,<span class="string">&quot;KK&quot;</span>,<span class="string">&quot;MM&quot;</span>,<span class="string">&quot;GG&quot;</span>,<span class="string">&quot;JJ&quot;</span>,<span class="string">&quot;DD&quot;</span> &#125; ;</span><br><span class="line">   Arrays.sort(arr, <span class="keyword">new</span> <span class="title class_">Comparator</span>()&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>  <span class="type">int</span>  <span class="title function_">compare</span><span class="params">(Object o1, Object o2)</span> &#123;</span><br><span class="line"><span class="comment">//1. 如果方法返回正整数，则表示o1大于o2；</span></span><br><span class="line"><span class="comment">//2. 如果返回0，表示相等；</span></span><br><span class="line"><span class="comment">//3. 返回负整数，表示o1小于o2。</span></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">&#125; ) ;</span><br></pre></td></tr></table></figure><p><strong>具体代码演示：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line"> String[] arr = <span class="keyword">new</span> <span class="title class_">String</span>[]      &#123;<span class="string">&quot;AA&quot;</span>,<span class="string">&quot;CC&quot;</span>,<span class="string">&quot;KK&quot;</span>,<span class="string">&quot;MM&quot;</span>,<span class="string">&quot;GG&quot;</span>,<span class="string">&quot;JJ&quot;</span>,<span class="string">&quot;DD&quot;</span>&#125;;</span><br><span class="line">   Arrays.sort(arr,<span class="keyword">new</span> <span class="title class_">Comparator</span>()&#123;</span><br><span class="line">            <span class="comment">//按照字符串从大到小的顺序排列</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object o1, Object o2)</span> &#123;</span><br><span class="line">     <span class="keyword">if</span>(o1 <span class="keyword">instanceof</span> String &amp;&amp; o2 <span class="keyword">instanceof</span>  String)&#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> (String) o1;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> (String) o2;</span><br><span class="line">                    <span class="keyword">return</span> -s1.compareTo(s2);</span><br><span class="line">                &#125;</span><br><span class="line"><span class="comment">//                return 0;</span></span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;输入的数据类型不一致&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="7-System类"><a href="#7-System类" class="headerlink" title="7.System类"></a>7.System类</h3><h4 id="1-介绍-5"><a href="#1-介绍-5" class="headerlink" title="1.介绍"></a>1.介绍</h4><ol><li>System类代表系统，系统级的很多属性和控制方法都放置在该类的内部。</li><li>该类位于java.lang包。 </li><li><strong>由于该类的构造器是private的，所以无法创建该类的对象，也就是无法实例化该类。其内部的成员变量和成员方法都是static的，所以也可以很方便的进行调用。</strong></li></ol><h4 id="2-成员方法"><a href="#2-成员方法" class="headerlink" title="2.成员方法"></a>2.成员方法</h4><ol><li><p>native long currentTimeMillis()</p><p>该方法的作用是返回当前的计算机时间，时间的表达格式为当前计算机时</p><p>间和GMT时间(格林威治时间)1970年1月1号0时0分0秒所差的毫秒数</p></li><li><p>void exit(int status)</p><p>该方法的作用是退出程序。其中status的值为0代表正常退出，非零代表</p><p>异常退出。使用该方法可以在图形界面编程中实现程序的退出功能等</p></li><li><p>void gc()</p><p>该方法的作用是请求系统进行垃圾回收。至于系统是否立刻回收，则</p><p>取决于系统中垃圾回收算法的实现以及系统执行时的情况</p></li><li><p>String getProperty(String key)</p><p>方法的作用是获得系统中属性名为key的属性对应的值。系统中常见</p><p>的属性名以及属性的作用</p><p>java . version  java 运行环境版本</p><p>java.home    java安装目录</p><p>os . version      操作系统的版本</p><p>os . name     操作系统的名称</p><p>user . name    用户的账户名称</p><p>user . home   用户的主目录</p><p>user.dir        用户的当前工作目录</p></li></ol><h3 id="8-Math类"><a href="#8-Math类" class="headerlink" title="8.Math类"></a>8.Math类</h3><h4 id="1-介绍-6"><a href="#1-介绍-6" class="headerlink" title="1.介绍"></a>1.介绍</h4><p>java.lang.Math提供了一系列静态方法用于科学计算。其方法的参数和返回值类型一般为double型。</p><h4 id="2-常用方法-1"><a href="#2-常用方法-1" class="headerlink" title="2.常用方法"></a>2.常用方法</h4><ol><li>abs（） 绝对值</li><li>acos,asin,atan,cos,sin,tan 三角函数</li><li>sqrt（） 平方根</li><li>pow(double a,doble b) a的b次幂</li><li>log（） 自然对数</li><li>exp（） e为底指数</li><li>max(double a,double b)</li><li>min(double a,double b)</li><li>random() 返回0.0到1.0的随机数</li><li>long round(double a) double型数据a转换为long型（四舍五入）</li><li>toDegrees(double angrad) 弧度—&gt;角度</li><li>toRadians(double angdeg) 角度—&gt;弧度</li></ol><h3 id="9-BigInteger类"><a href="#9-BigInteger类" class="headerlink" title="9.BigInteger类"></a>9.BigInteger类</h3><h4 id="1-介绍-7"><a href="#1-介绍-7" class="headerlink" title="1.介绍"></a>1.介绍</h4><ol><li>Integer类作为int的包装类，能存储的最大整型值为231-1，Long类也是有限的，最大为263-1。如果要表示再大的整数，不管是基本数据类型还是他们的包装类都无能为力，更不用说进行运算了。</li><li>java.math包的BigInteger可以表示不可变的任意精度的整数。BigInteger 提供所有 Java 的基本整数操作符的对应物，并提供 java.lang.Math 的所有相关方法。另外，BigInteger 还提供以下运算：模算术、GCD 计算、质数测试、素数生成、位操作以及一些其他操作。</li></ol><p>构造器 ：BigInteger(String val)：根据字符串构建BigInteger对象</p><p>BigInteger bi &#x3D; new BigInteger(“1243323434343434241123”);</p><h4 id="2-常用方法-2"><a href="#2-常用方法-2" class="headerlink" title="2.常用方法"></a>2.常用方法</h4><ol><li><p><strong>public BigInteger abs()</strong></p><p>返回此 BigInteger 的绝对值的 BigInteger。 </p></li><li><p><strong>BigInteger add(BigInteger val)</strong> </p><p>返回其值为 (this + val) 的 BigInteger</p></li><li><p><strong>BigInteger subtract(BigInteger val)</strong> </p><p>返回其值为 (this - val) 的 BigInteger</p></li><li><p><strong>BigInteger multiply(BigInteger val)</strong> </p><p>返回其值为 (this * val) 的 BigInteger</p></li><li><p><strong>BigInteger divide(BigInteger val)</strong> </p><p>返回其值为 (this &#x2F; val) 的 BigInteger。整数相除只保留整数部分。 </p></li><li><p><strong>BigInteger remainder(BigInteger val)</strong> </p><p>返回其值为 (this % val) 的 BigInteger。 </p></li><li><p><strong>BigInteger[] divideAndRemainder(BigInteger val)</strong></p><p>返回包含 (this &#x2F; val) 后跟(this % val) 的两个 BigInteger 的数组。 </p></li><li><p><strong>BigInteger pow(int exponent)</strong> </p><p>返回其值为 (thisexponent) 的 BigInteger。</p></li></ol><h3 id="10-BigDecimal类"><a href="#10-BigDecimal类" class="headerlink" title="10.BigDecimal类"></a>10.BigDecimal类</h3><h4 id="1-介绍-8"><a href="#1-介绍-8" class="headerlink" title="1.介绍"></a>1.介绍</h4><ol><li>一般的Float类和Double类可以用来做科学计算或工程计算，但在商业计算中，要求数字精度比较高，故用到java.math.BigDecimal类。 </li><li>BigDecimal类支持不可变的、任意精度的有符号十进制定点数。</li></ol><p>构造器 :   </p><ol><li>public BigDecimal(double val) </li><li>public BigDecimal(String val)</li></ol><h4 id="2-常用方法-3"><a href="#2-常用方法-3" class="headerlink" title="2.常用方法"></a>2.常用方法</h4><ol><li><p>public BigDecimal add(BigDecimal augend)</p><p>加法</p></li><li><p>public BigDecimal subtract(BigDecimal subtrahend)</p><p>减法</p></li><li><p>public BigDecimal multiply(BigDecimal multiplicand)</p><p>乘法</p></li><li><p>public BigDecimal divide(BigDecimal divisor, int scale, int roundingMode)</p><p>除法 （BigDecimal对象 ， 保留几位小数  ， 是否四舍五入）</p><p>BigDecimal.ROUND_HALF_UP   要四舍五入BigDecimal.ROUND_HALF_DOWN  不四舍五入</p><p>代码演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">   <span class="type">BigDecimal</span> <span class="variable">bd1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;12435.351&quot;</span>);</span><br><span class="line">   <span class="type">BigDecimal</span> <span class="variable">bd2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;11&quot;</span>);</span><br><span class="line">   </span><br><span class="line">   System.out.println(bi);   <span class="comment">//12435.351</span></span><br><span class="line">   <span class="comment">// System.out.println(bd1.divide(bd2));</span></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">System.out.println(bd1.divide(bd2, BigDecimal.ROUND_HALF_UP));</span><br><span class="line">   System.out.println(bd1.divide(bd2, <span class="number">15</span>, BigDecimal.ROUND_HALF_UP));</span><br></pre></td></tr></table></figure></li></ol><h2 id="3-枚举类与注解"><a href="#3-枚举类与注解" class="headerlink" title="3.枚举类与注解"></a>3.枚举类与注解</h2><h3 id="1-枚举类的使用"><a href="#1-枚举类的使用" class="headerlink" title="1.枚举类的使用"></a>1.枚举类的使用</h3><h4 id="1-介绍-9"><a href="#1-介绍-9" class="headerlink" title="1.介绍"></a>1.介绍</h4><ol><li>枚举类的理解：<strong>类的对象只有有限个，确定的</strong>。我们称此类为枚举类</li><li><strong>当需要定义一组常量时，强烈建议使用枚举类</strong></li><li>如果枚举类中只有一个对象，则可以作为单例模式的实现方式。</li><li>如一下的用处：<ol><li>星期：Monday(星期一)、……、Sunday(星期天) </li><li>性别：Man(男)、Woman(女) </li><li>季节：Spring(春节)……Winter(冬天) </li><li>支付方式：Cash（现金）、WeChatPay（微信）、Alipay(支付宝)、BankCard(银行卡)、CreditCard(信用卡) </li><li>就职状态：Busy、Free、Vocation、Dimission</li><li>订单状态：Nonpayment（未付款）、Paid（已付款）、Delivered（已发货）、</li><li>Return（退货）、Checked（已确认）Fulfilled（已配货）、</li><li>线程状态：创建、就绪、运行、阻塞、死亡</li></ol></li></ol><h4 id="2-自定义枚举类"><a href="#2-自定义枚举类" class="headerlink" title="2.自定义枚举类"></a>2.自定义枚举类</h4><h5 id="1-如何自定义枚举类"><a href="#1-如何自定义枚举类" class="headerlink" title="1.如何自定义枚举类"></a>1.如何自定义枚举类</h5><p>方式一：jdk5.0之前，自定义枚举类</p><ol><li><p>声明当前枚举类对象中的属性: private final修饰</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String seasonName;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String seasonDesc;</span><br></pre></td></tr></table></figure></li><li><p>私有化类的构造器,并给对象属性赋值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="title function_">Season</span><span class="params">(String seasonName,String seasonDesc)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.seasonName = seasonName;</span><br><span class="line"><span class="built_in">this</span>.seasonDesc = seasonDesc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>提供当前枚举类的多个对象：public static final的（<strong>在枚举类内部new全局常量的对象</strong>）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">SPRING</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;春天&quot;</span>,<span class="string">&quot;春暖花开&quot;</span>);</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">SUMMER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;夏天&quot;</span>,<span class="string">&quot;夏日炎炎&quot;</span>);</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">AUTUMN</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;秋天&quot;</span>,<span class="string">&quot;秋高气爽&quot;</span>);</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">WINTER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;冬天&quot;</span>,<span class="string">&quot;冰天雪地&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>其他诉求：获取枚举类对象的属性  或  提供toString()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">getSeasonName</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> seasonName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getSeasonDesc</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> seasonDesc;</span><br><span class="line">&#125; <span class="comment">//或重写toString方法去提供用户所需的常量</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><p>全部代码演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义枚举类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Season</span>&#123;</span><br><span class="line">    <span class="comment">//1.声明Season对象的属性:private final修饰</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonDesc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.私有化类的构造器,并给对象属性赋值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Season</span><span class="params">(String seasonName,String seasonDesc)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.seasonName = seasonName;</span><br><span class="line">        <span class="built_in">this</span>.seasonDesc = seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.提供当前枚举类的多个对象：public static final的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">SPRING</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;春天&quot;</span>,<span class="string">&quot;春暖花开&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">SUMMER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;夏天&quot;</span>,<span class="string">&quot;夏日炎炎&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">AUTUMN</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;秋天&quot;</span>,<span class="string">&quot;秋高气爽&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">WINTER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;冬天&quot;</span>,<span class="string">&quot;冰天雪地&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.其他诉求1：获取枚举类对象的属性</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSeasonName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> seasonName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSeasonDesc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4.其他诉求1：提供toString()</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Season&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;seasonName=&#x27;&quot;</span> + seasonName + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, seasonDesc=&#x27;&quot;</span> + seasonDesc + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="2-声明调用自定义枚举类"><a href="#2-声明调用自定义枚举类" class="headerlink" title="2.声明调用自定义枚举类"></a>2.声明调用自定义枚举类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Season</span> <span class="variable">spring</span> <span class="operator">=</span> Season.SPRING;   <span class="comment">//“  类名 . 内部new的全局常量  ”</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span>  <span class="variable">s1</span>  <span class="operator">=</span>   spring . getSeasonDesc( ) ;</span><br></pre></td></tr></table></figure><h4 id="3-enum关键字定义枚举类"><a href="#3-enum关键字定义枚举类" class="headerlink" title="3.enum关键字定义枚举类"></a>3.enum关键字定义枚举类</h4><h5 id="1-如何定义enum类"><a href="#1-如何定义enum类" class="headerlink" title="1.如何定义enum类"></a>1.如何定义enum类</h5><p>方式二：jdk5.0，可以使用enum关键字定义枚举类</p><p>说明：定义的枚举类默认继承于java.lang.Enum类</p><ol><li><p>enum定义的枚举类区别于自定义枚举类在于，这里首先的得提供当前枚举类的多个或单个对象，<strong>由于这些对象在枚举类中都是全局常量，所以省略了多余的代码，只需写对象名后加“（属性赋值）”，如有多个则用逗号隔开，最后一个用分号</strong></p><p>代码演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">enum</span> <span class="title class_">Season</span>&#123;  <span class="comment">//--   enum + 类名  来定义类</span></span><br><span class="line">       SPRING(<span class="string">&quot;春天&quot;</span>,<span class="string">&quot;春暖花开&quot;</span>),</span><br><span class="line">       SUMMER(<span class="string">&quot;夏天&quot;</span>,<span class="string">&quot;夏日炎炎&quot;</span>),</span><br><span class="line">       AUTUMN(<span class="string">&quot;秋天&quot;</span>,<span class="string">&quot;秋高气爽&quot;</span>),</span><br><span class="line">       WINTER(<span class="string">&quot;冬天&quot;</span>,<span class="string">&quot;冰天雪地&quot;</span>);</span><br><span class="line">       <span class="comment">//如果没有属性：</span></span><br><span class="line">       SPRING,</span><br><span class="line">       SUMMER,</span><br><span class="line">       AUTUMN,</span><br><span class="line">       WINTER;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>声明当前枚举类对象中的属性: private final修饰</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String seasonName;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String seasonDesc;</span><br></pre></td></tr></table></figure></li><li><p>私有化类的构造器,并给对象属性赋值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="title function_">Season</span><span class="params">(String seasonName,String seasonDesc)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.seasonName = seasonName;</span><br><span class="line"></span><br><span class="line"><span class="built_in">this</span>.seasonDesc = seasonDesc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h5 id="2-enum类中常用方法"><a href="#2-enum类中常用方法" class="headerlink" title="2.enum类中常用方法"></a>2.enum类中常用方法</h5><ol><li><p>values()</p><p><strong>返回枚举类型的对象数组</strong>。该方法可以很方便地遍历所有的枚举值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Season1[] values = Season1.values();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; values.length;i++)&#123;</span><br><span class="line">    System.out.println(values[i]);</span><br><span class="line">    <span class="comment">//输出：SPRIN GSUMMER AUTUMN WINTER</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>valueOf(String str)   —<strong>声明一个枚举类对象方式</strong></p><p>可以把一个字符串转为对应的枚举类对象。要求字符串必须是枚举类对象 的“名字”。如不是，会有运行时异常：IllegalArgumentException。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//valueOf(String objName):返回枚举类中对象名是objName的对象。</span></span><br><span class="line">        <span class="type">Season1</span> <span class="variable">winter</span> <span class="operator">=</span> Season1.valueOf(<span class="string">&quot;WINTER&quot;</span>); <span class="comment">//传入的参数必须存在于枚举类中</span></span><br><span class="line"><span class="comment">//如果没有objName的枚举类对象，则抛异常：     IllegalArgumentException</span></span><br><span class="line"><span class="comment">//   Season1 winter = Season1.valueOf(&quot;WINTER1&quot;);</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>toString()    — 也可考虑重写</p><p>返回当前枚举类对象常量的名称</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(winter.toString()); <span class="comment">//WINTER</span></span><br></pre></td></tr></table></figure></li></ol><h5 id="3-enum枚举类实现接口"><a href="#3-enum枚举类实现接口" class="headerlink" title="3.enum枚举类实现接口"></a>3.enum枚举类实现接口</h5><p>情况一：<strong>实现接口，在enum类中实现抽象方法</strong></p><ol><li>&#96;&#96;&#96;java<br>enum Season1 implements Info{<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">2. 重写接口中抽象方法</span><br><span class="line"></span><br><span class="line">3. **这里多个对象都共用一个重写的方法 （这不是重点讲的）**</span><br><span class="line"></span><br><span class="line">情况二：**让枚举类的对象分别实现接口中的抽象方法**</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">enum Season1 implements Info&#123;</span><br><span class="line">SPRING(&quot;春天&quot;,&quot;春暖花开&quot;)&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void show() &#123;</span><br><span class="line">        System.out.println(&quot;春天在哪里？&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">SUMMER(&quot;夏天&quot;,&quot;夏日炎炎&quot;)&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void show() &#123;</span><br><span class="line">        System.out.println(&quot;宁夏&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">AUTUMN(&quot;秋天&quot;,&quot;秋高气爽&quot;)&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void show() &#123;</span><br><span class="line">        System.out.println(&quot;秋天不回来&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">WINTER(&quot;冬天&quot;,&quot;冰天雪地&quot;)&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void show() &#123;</span><br><span class="line">        System.out.println(&quot;大约在冬季&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><h3 id="2-注解Annotation"><a href="#2-注解Annotation" class="headerlink" title="2.注解Annotation"></a>2.注解Annotation</h3><h4 id="1-注解的概述"><a href="#1-注解的概述" class="headerlink" title="1.注解的概述"></a>1.注解的概述</h4><p>① jdk 5.0 新增的功能</p><p>② Annotation 其实就是代码里的特殊标记, <strong>这些标记可以在编译, 类加载, 运行时被读取, 并执行相应的处理</strong>。通过使用 Annotation,程序员可以在不改变原有逻辑的情况下, 在源文件中嵌入一些补充信息。</p><p>③在JavaSE中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等。在JavaEE&#x2F;Android中注解占据了更重要的角色，例如用来配置应用程序的任何切面，代替JavaEE旧版中所遗留的繁冗代码和XML配置等。</p><p>.框架  &#x3D;  注解  +  反射机制  +  设计模式</p><h4 id="2-Annocation使用示例"><a href="#2-Annocation使用示例" class="headerlink" title="2.Annocation使用示例"></a>2.Annocation使用示例</h4><p>示例一：生成文档相关的注解</p><ol><li>@author <strong>标明开发该类模块的作者</strong>，多个作者之间使用,分割</li><li>@version 标明该类模块的版本</li><li>@see 参考转向，也就是相关主题</li><li>@since 从哪个版本开始增加的</li><li>@param 对方法中某参数的说明，如果没有参数就不能写</li><li>@return 对方法返回值的说明，如果方法的返回值类型是void就不能写</li><li>@exception 对方法可能抛出的异常进行说明 ，如果方法没有用throws显式抛出的异常就不能写</li></ol><p>示例二：在编译时进行格式检查(JDK内置的三个基本注解)</p><ol><li><p>@Override: 限定<strong>重写父类方法</strong>, 该注解只能用于方法</p></li><li><p>@Deprecated: 用于表示所修饰的元素(类, 方法等)已过时。通常是因为所修饰<strong>的结构危险</strong>或<strong>存在更好的选择</strong></p></li><li><p>@SuppressWarnings: <strong>抑制编译器警告</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;unused&quot;)</span> <span class="comment">//提示声明还未使用</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="meta">@SuppressWarnings(&#123; &quot;unused&quot;, &quot;rawtypes&quot; &#125;)</span></span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br></pre></td></tr></table></figure></li></ol><p>示例三：跟踪代码依赖性，实现替代配置文件功能</p><h4 id="3-如何自定义注解"><a href="#3-如何自定义注解" class="headerlink" title="3.如何自定义注解"></a>3.如何自定义注解</h4><p>参照@SuppressWarnings定义</p><ol><li><p><strong>注解声明为：@interface</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>内部定义成员，通常使用value表示</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>可以指定成员的默认值，使用default定义  ，有单个成员时可在声明时指定值</p><p><strong>使用default在内部初始值</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>有单个成员时可在声明时指定值</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MyAnnotation(value=&quot;abc&quot;)</span> <span class="comment">//value可加可不加</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">.....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果<strong>自定义注解没有成员，表明是一个标识作用</strong>。</p></li></ol><p><strong>注意：</strong></p><ol><li>如果注解有成员，在使用注解时，需要指明成员的值。</li><li>自定义注解必须配上注解的信息处理流程(使用反射)才有意义。</li><li>自定义注解通过都会指明两个元注解：Retention、Target</li></ol><h4 id="4-jdk-提供的4种元注解"><a href="#4-jdk-提供的4种元注解" class="headerlink" title="4.jdk 提供的4种元注解"></a>4.jdk 提供的4种元注解</h4><p><strong>元注解：对现有的注解进行解释说明的注解</strong></p><ol><li><p>Retention：指定所修饰的 Annotation 的生命周期：SOURCE（没编译时就不在了）\CLASS（默认行为–编译时还在）\RUNTIME （运行时还在）</p><p><strong>只有声明为RUNTIME生命周期的注解，才能通过反射获取</strong>。</p></li><li><p>Target  :  用于指定被修饰的 Annotation 能用于修饰哪些程序元素</p><p>以下的出现的频率较低</p></li><li><p>Documented  :  表示所修饰的注解在被javadoc解析时，保留下来。</p><p>一般情况以下被javadoc解析为.class文件中没有注解，但是加上这个注解可将注解保留下来</p></li><li><p>Inherited  :  被它修饰的 Annotation 将具有继承性。</p><p>用它注解时，该类的子类也拥有同父类一样的注解</p></li><li><p>代码演示：</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">   <span class="meta">@Inherited</span></span><br><span class="line">   <span class="meta">@Repeatable(MyAnnotations.class)</span></span><br><span class="line">   <span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line">   <span class="meta">@Target(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE,TYPE_PARAMETER,TYPE_USE&#125;)</span></span><br><span class="line">   <span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line"></span><br><span class="line">String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="5-通过反射获取注解信息"><a href="#5-通过反射获取注解信息" class="headerlink" title="5.通过反射获取注解信息"></a>5.通过反射获取注解信息</h4><p>—到反射内容时系统讲解</p><p>6.jdk 8 中注解的新特性：</p><h5 id="1-可重复注解"><a href="#1-可重复注解" class="headerlink" title="1.可重复注解"></a>1.可重复注解</h5><p>需求：使用两个同名的注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MyAnnotation(value=&quot;hi&quot;)</span></span><br><span class="line"><span class="meta">@MyAnnotation(value=&quot;abc&quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>① 在MyAnnotation上声明@Repeatable，成员值为MyAnnotations.class</p><p>② MyAnnotation的Target和Retention<strong>等元注解</strong>与MyAnnotations<strong>相同</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Inherited</span>  <span class="comment">//---原来的注解</span></span><br><span class="line"><span class="meta">@Repeatable(MyAnnotations.class)</span><span class="comment">//---操作一</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE,TYPE_PARAMETER,TYPE_USE&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line"></span><br><span class="line">String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Inherited</span>   <span class="comment">//-----重复的注解 </span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotations &#123;</span><br><span class="line"></span><br><span class="line">MyAnnotation[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-类型注解"><a href="#2-类型注解" class="headerlink" title="2.类型注解"></a>2.类型注解</h5><p>类型注解：能在多个类型中注解</p><p>ElementType.TYPE_PARAMETER 表示该注解能写在类型变量的声明语句中（如：泛型声明。)<br>ElementType.TYPE_USE 表示该注解能写在使用类型的任何语句中。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java-编程高级&quot;&gt;&lt;a href=&quot;#Java-编程高级&quot; class=&quot;headerlink&quot; title=&quot;Java 编程高级&quot;&gt;&lt;/a&gt;Java 编程高级&lt;/h1&gt;&lt;h2 id=&quot;1-多线程&quot;&gt;&lt;a href=&quot;#1-多线程&quot; class=&quot;header</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>关于hexo博客插入图片内容解决方法</title>
    <link href="http://example.com/2022/08/27/%E5%8D%9A%E5%AE%A2%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87/"/>
    <id>http://example.com/2022/08/27/%E5%8D%9A%E5%AE%A2%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87/</id>
    <published>2022-08-26T16:00:00.000Z</published>
    <updated>2022-08-29T03:53:23.073Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、插入图片要求："><a href="#一、插入图片要求：" class="headerlink" title="一、插入图片要求："></a>一、插入图片要求：</h3><ul><li><p>md文件名和存放其图片文件夹一致</p></li><li><p>md图片访问路径的分割符使用 &#x2F;</p></li><li><p>图片访问路径中不能有空格</p></li><li><p>md中图片使用相对路径访问，如 .&#x2F;xxx&#x2F;yyy.jpg 或 xxx&#x2F;yyy.jpg</p></li><li><p>下载hexo-asset-image图片访问插件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save hexo-asset-image </span><br></pre></td></tr></table></figure></li></ul><h3 id="二、具体步骤"><a href="#二、具体步骤" class="headerlink" title="二、具体步骤"></a>二、具体步骤</h3><h5 id="步骤一：博客根目录下的source-x2F-post下，创建同名md文件和存图文件夹"><a href="#步骤一：博客根目录下的source-x2F-post下，创建同名md文件和存图文件夹" class="headerlink" title="步骤一：博客根目录下的source&#x2F;_post下，创建同名md文件和存图文件夹"></a>步骤一：博客根目录下的source&#x2F;_post下，创建同名md文件和存图文件夹</h5><p>![image-20220827104613441](博客插入图片 &#x2F;image-20220827104613441.png)</p><h5 id="步骤二：以相对路径的方式引入一张图片"><a href="#步骤二：以相对路径的方式引入一张图片" class="headerlink" title="步骤二：以相对路径的方式引入一张图片"></a>步骤二：以相对路径的方式引入一张图片</h5><img src="/2022/08/27/%E5%8D%9A%E5%AE%A2%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87/image-20220827104843261.png" alt="image-20220827104843261" style="zoom: 67%;"><h4 id="步骤三：下载图片访问插件"><a href="#步骤三：下载图片访问插件" class="headerlink" title="步骤三：下载图片访问插件"></a>步骤三：下载图片访问插件</h4><p><img src="/2022/08/27/%E5%8D%9A%E5%AE%A2%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87/image-20220827104959034.png"></p><h4 id="步骤四：生成网站静态文件和进行本地预览"><a href="#步骤四：生成网站静态文件和进行本地预览" class="headerlink" title="步骤四：生成网站静态文件和进行本地预览"></a>步骤四：生成网站静态文件和进行本地预览</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo g </span><br><span class="line"></span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><h5 id="预览结果："><a href="#预览结果：" class="headerlink" title="预览结果："></a>预览结果：</h5><img src="/2022/08/27/%E5%8D%9A%E5%AE%A2%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87/image-20220827105405180.png" alt="image-20220827105405180" style="zoom:50%;"><h5 id="该图片路径："><a href="#该图片路径：" class="headerlink" title="该图片路径："></a>该图片路径：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cannot GET /.com//%E9%95%87%E5%BA%97%E4%B9%8B%E5%AE%9D%5C%E5%8F%A4%E9%A3%8E%E7%BE%8E%E5%A5%B3.jpg</span><br></pre></td></tr></table></figure><h2 id="三、图片还是无法显示，经过网上的一番查找，得以解决"><a href="#三、图片还是无法显示，经过网上的一番查找，得以解决" class="headerlink" title="三、图片还是无法显示，经过网上的一番查找，得以解决:"></a>三、图片还是无法显示，经过网上的一番查找，得以解决:</h2><h4 id="首先：删除原来的插件"><a href="#首先：删除原来的插件" class="headerlink" title="首先：删除原来的插件"></a>首先：删除原来的插件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm remove hexo-asset-image</span><br></pre></td></tr></table></figure><h4 id="其次：下载修改版的插件修改版的hexo-asset-image"><a href="#其次：下载修改版的插件修改版的hexo-asset-image" class="headerlink" title="其次：下载修改版的插件修改版的hexo-asset-image"></a>其次：下载修改版的插件<a href="https://github.com/CodeFalling/hexo-asset-image">修改版的hexo-asset-image</a></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save https://github.com/CodeFalling/hexo-asset-image</span><br></pre></td></tr></table></figure><h4 id="再次：重新操作一波"><a href="#再次：重新操作一波" class="headerlink" title="再次：重新操作一波"></a>再次：重新操作一波</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hexo cl</span><br><span class="line"></span><br><span class="line">hexo g</span><br><span class="line"></span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><h4 id="效果显著："><a href="#效果显著：" class="headerlink" title="效果显著："></a>效果显著：</h4><img src="/2022/08/27/%E5%8D%9A%E5%AE%A2%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87/image-20220827110447646.png" alt="image-20220827110447646" style="zoom:50%;">]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;一、插入图片要求：&quot;&gt;&lt;a href=&quot;#一、插入图片要求：&quot; class=&quot;headerlink&quot; title=&quot;一、插入图片要求：&quot;&gt;&lt;/a&gt;一、插入图片要求：&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;md文件名和存放其图片文件夹一致&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>GitHub + Hexo + Node.js + Git搭建个人博客</title>
    <link href="http://example.com/2022/08/25/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    <id>http://example.com/2022/08/25/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</id>
    <published>2022-08-25T09:45:41.000Z</published>
    <updated>2022-08-29T03:58:02.665Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、搭建环境"><a href="#1、搭建环境" class="headerlink" title="1、搭建环境"></a>1、搭建环境</h3><p>操作系统系统：Windows10</p><p>Node.js：v14.18.2</p><p>Git：2.37.2.windows.2 </p><h3 id="2、Node-js安装及配置"><a href="#2、Node-js安装及配置" class="headerlink" title="2、Node.js安装及配置"></a>2、Node.js安装及配置</h3><p><a href="https://nodejs.org/zh-cn/download/releases/">node.js以往的版本</a></p><h4 id="步骤一：下载并安装"><a href="#步骤一：下载并安装" class="headerlink" title="步骤一：下载并安装"></a>步骤一：下载并安装</h4><p>下载完成后进行安装，node.js安装一路next直至完成</p><h4 id="步骤二：检查是否安装成功"><a href="#步骤二：检查是否安装成功" class="headerlink" title="步骤二：检查是否安装成功"></a>步骤二：检查是否安装成功</h4><p>【win+R】键，输入cmd，然后回车，打开cmd窗口</p><ul><li><p>检查其是否安装成功，输入 node -v</p></li><li><p>检查npm是否也安装成功 ，输入 npm -v</p><blockquote><p>新版的Node.js已自带npm，安装Node.js时会一起安装，npm的作用就是对Node.js依赖的包进行管理，也可以理解为用来安装&#x2F;卸载Node.js需要装的东西</p></blockquote></li></ul><h4 id="步骤三：配置默认安装目录和缓存日志目录"><a href="#步骤三：配置默认安装目录和缓存日志目录" class="headerlink" title="步骤三：配置默认安装目录和缓存日志目录"></a>步骤三：配置默认安装目录和缓存日志目录</h4><p>为了不占用C盘空间，修改node.js的全局模块module的下载路径和cache缓存路径，其默认位置在<code>C:\Users\用户名\AppData\Roaming\npm</code></p><ul><li><p>在我们安装node.js目录下创建两个文件夹，名分别为<code>node_global</code>和<code>node_cache</code>，且在这<code>node_global</code>文件夹下在创建一个名为<code>node_modules</code>的文件夹</p></li><li><p>win+R，cmd打开控制台，输入以下命令修改其默认路径</p><p>npm config set prefix “F:\Develop_tools\node_js\node_global” </p><p>npm config set cache “F:\Develop_tools\node_js\node_cache”</p></li></ul><h4 id="步骤四：配置nodejs环境变量"><a href="#步骤四：配置nodejs环境变量" class="headerlink" title="步骤四：配置nodejs环境变量"></a>步骤四：配置nodejs环境变量</h4><p>将默认配置的nmp路径<code>C:\Users\用户名\AppData\Roaming\npm</code>删除，添加一个你新建的global路径</p><img src="/2022/08/25/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/image-20220825154829124.png" alt="image-20220825154829124" style="zoom:67%;"><p>在系统变量（环境变量）添加NODE_PATH，用来告诉系统， 下载的模块或者包都在这里了</p><img src="/2022/08/25/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/image-20220825143044875.png" alt="image-20220825143044875" style="zoom: 67%;"><p>在系统变量（环境变量）PATH中添加NODE_PATH</p><img src="/2022/08/25/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/image-20220825144710580.png" alt="image-20220825144710580" style="zoom:67%;"><h4 id="步骤五：设置npm淘宝镜像"><a href="#步骤五：设置npm淘宝镜像" class="headerlink" title="步骤五：设置npm淘宝镜像"></a>步骤五：设置npm淘宝镜像</h4><p>使用阿里定制的cnpm命令行工具代替默认的npm，输入以下代码</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><p>检查是否安装成功：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cnpm -v</span><br></pre></td></tr></table></figure><p>安装成功之后，以后安装依赖包的方式和npm的是一样的，只是npm的命令换成是cnpm就可以了。</p><h3 id="3、Git安装"><a href="#3、Git安装" class="headerlink" title="3、Git安装"></a>3、Git安装</h3><p><a href="https://git-scm.com/">Git 官网下载</a></p><p>Git安装比较简单，下载后一路next直至完成即可，无需多余配置</p><h3 id="4、Github建立仓库"><a href="#4、Github建立仓库" class="headerlink" title="4、Github建立仓库"></a>4、Github建立仓库</h3><ul><li><p>仓库名：用户名.github.io</p></li><li><p>branch：默认名为main，这里可以修改，一旦创建就无法修改了</p></li></ul><h3 id="5、下载hexo-script-的安装脚本"><a href="#5、下载hexo-script-的安装脚本" class="headerlink" title="5、下载hexo-script]的安装脚本"></a>5、下载hexo-script]的安装脚本</h3><ul><li><p>选择最新版本,只需下载install.sh即可，<a href="https://github.com/kjhuanhao/hexo-script/releases"><strong>下载install.sh</strong></a></p></li><li><p>选择一个你想存放博客文件的位置，创建一个文件夹，名字随意，将下载好的install.sh放到其中</p></li><li><p>我创建了一个[myblog]文件夹，然后在此文件夹下，<strong>右键打开git bash</strong></p></li></ul><hr><h3 id="6、检测node-js和git环境"><a href="#6、检测node-js和git环境" class="headerlink" title="6、检测node.js和git环境"></a>6、检测node.js和git环境</h3><h4 id="检测node-js环境"><a href="#检测node-js环境" class="headerlink" title="检测node.js环境"></a>检测node.js环境</h4><p>在存放install.sh脚本的目录中,右键打开git bash然后运行以下命令:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source install.sh test_node</span><br></pre></td></tr></table></figure><p>如果出现了如图的情况证明环境变量是配置成功的</p><p>(出现了版本号和成功的提示信息代表配置成功)</p><p><img src="/2022/08/25/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/image-20220825151430500.png" alt="image-20220825151430500"></p><p>如果你并发现有版本号的出现,而是红色的错误信息,你可能需要手动配置node.js的环境变量,或者重新安装node.js并注意勾选<strong>Add to PATH</strong></p><hr><h4 id="检测git环境"><a href="#检测git环境" class="headerlink" title="检测git环境"></a>检测git环境</h4><p>如果你想要检测git环境或者查看当前git的版本号,您可以在存放install.sh脚本的目录中,右键打开git bash运行以下命令:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source install.sh test_git</span><br></pre></td></tr></table></figure><p>一般情况下安装git工具后git环境是会自动配置的,可以无需检测git环境.此脚本可以用于linux系统,出现版本号信息则配置为成功.</p><p><img src="/2022/08/25/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/image-20220825151534207.png" alt="image-20220825151534207"></p><hr><h3 id="7、一键安装hexo博客"><a href="#7、一键安装hexo博客" class="headerlink" title="7、一键安装hexo博客"></a>7、一键安装hexo博客</h3><p>您需要在存放install.sh脚本的目录中,右键打开git bash运行以下命令:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source install.sh hexo_win</span><br></pre></td></tr></table></figure><p>提示:此时你可以去来一杯卡布奇诺,大约两分钟的时间,博客即可自动安装完成,如图:</p><img src="/2022/08/25/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/image-20220825152443388.png" alt="image-20220825152443388" style="zoom:50%;"><p>当您看到出现<code>Please run hexo s to check it out!</code>的提示,证明您已经安装成功,此时你可以运行hexo s 然后查看你的博客</p><p>自动完成全部安装过程并生成博客文件</p><img src="/2022/08/25/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/image-20220825152153353.png" alt="image-20220825152153353" style="zoom: 67%;"><p>进入hexblog目录，输入命令 hexo  s ，开启本地预览</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd hexoblog</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>注意:要先cd到hexoblog目录哦!执行以上命令即可</p><img src="/2022/08/25/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/image-20220825152528941.png" alt="image-20220825152528941" style="zoom:67%;"><blockquote><p>在浏览器访问:<a href="http://localhost:4000/">http://localhost:4000 </a>,你就可以在本地预览了,浏览情况如图:</p></blockquote><img src="/2022/08/25/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/image-20220825152718571.png" alt="image-20220825152718571" style="zoom:67%;"><h3 id="8、生成SSH秘钥并配置GitHub"><a href="#8、生成SSH秘钥并配置GitHub" class="headerlink" title="8、生成SSH秘钥并配置GitHub"></a>8、生成SSH秘钥并配置GitHub</h3><p>这是你的github与本地传输数据时需要使用的密钥</p><p>您需要在存放install.sh脚本的目录中,右键打开git bash运行以下命令:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./install.sh git_ssh</span><br></pre></td></tr></table></figure><img src="/2022/08/25/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/image-20220825162832088.png" alt="image-20220825162832088" style="zoom:67%;"><p>可以看到会有四条可执行命令，输入对应数字可以执行对应的命令</p><ul><li><p>执行1后，一直按回车，直至结束，输入yes，可以一键生成秘钥</p><ul><li>生成密钥位置：C:\Users\用户名\ .ssh\id_rsa.pub</li><li>如果你的电脑已经存在秘钥,程序将会自动退出</li></ul></li><li><p>执行2后，可以查看你电脑中已生成的秘钥</p><ul><li><p>将上述生成密钥与github中进行配置</p></li><li><p>进入Github —&gt; 头像 —&gt; Setting —&gt; SSH and GPG keys —&gt; New SSH key</p></li></ul></li><li><p>执行3后，可以检查秘钥是否配置github成功</p></li><li><p>执行4后，可以检查秘钥是否配置coding成功 </p><ul><li>coding是腾讯云的，咱们是与github对接，不用管这个</li></ul></li></ul><hr><h3 id="9、配置博客部署GitHub"><a href="#9、配置博客部署GitHub" class="headerlink" title="9、配置博客部署GitHub"></a>9、配置博客部署GitHub</h3><p>在_config.yml文件中修改，注意冒号后面有空格</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repository:</span> <span class="string">git@github.com:用户名/用户名.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">main</span>  <span class="comment">#创建仓库时默认使用的branch</span></span><br></pre></td></tr></table></figure><h3 id="10、更换博客主题"><a href="#10、更换博客主题" class="headerlink" title="10、更换博客主题"></a>10、更换博客主题</h3><p><a href="https://hexo.io/themes/">hexo提供多种多样的主题：Themes | Hexo</a></p><ul><li>只要知道主题的github地址，使用git clone 下载到themes文件中</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/Shen-Yu/hexo-theme-ayer themes/ayer</span><br></pre></td></tr></table></figure><ul><li>修改_config.yml文件</li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">ayer</span></span><br></pre></td></tr></table></figure><ul><li>如果更换主题后无法打开网站，则下载渲染插件</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-renderer-pug hexo-renderer-stylus</span><br></pre></td></tr></table></figure><h3 id="11、发布第一篇博客"><a href="#11、发布第一篇博客" class="headerlink" title="11、发布第一篇博客"></a>11、发布第一篇博客</h3><p>hexo博客可以使用markdown编写，它会将markdown文件进行解析成网页，之后将它们发布到github上，就可以通过<code>http://用户名.github.io/</code></p><p>使用hexo自动创建md文件，会在source下的_post中创建</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new &quot;文件名&quot;</span><br></pre></td></tr></table></figure><p>也可以自己引入md文件到_post，md中的图片文件夹也引入进来，md文件中引用的图片应以相对路径引入</p><img src="/2022/08/25/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/image-20220825182617976.png" alt="image-20220825182617976" style="zoom:67%;"><blockquote><p>注意：md文章开头必须得有 Front Matter格式的信息，其中至少填写title和date</p><p><img src="/2022/08/25/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/image-20220825183120172.png" alt="image-20220825183120172"></p><p><a href="https://blog.csdn.net/qq_42549254/article/details/102721177">Front Matter其他参数</a></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo cl 或 hexo clean </span><br></pre></td></tr></table></figure><p>清除缓存文件 db.json 和已生成的静态文件 public 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure><p>生成网站静态文件到默认设置的 public 文件夹。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>启动本地服务器，用于预览主题。默认地址： <a href="http://localhost:4000/">http://localhost:4000/</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>自动生成网站静态文件，并部署到GitHub设定的仓库。</p><p>访问地址：http:&#x2F;&#x2F;用户名.github.io&#x2F;即可访问你的网站啦！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1、搭建环境&quot;&gt;&lt;a href=&quot;#1、搭建环境&quot; class=&quot;headerlink&quot; title=&quot;1、搭建环境&quot;&gt;&lt;/a&gt;1、搭建环境&lt;/h3&gt;&lt;p&gt;操作系统系统：Windows10&lt;/p&gt;
&lt;p&gt;Node.js：v14.18.2&lt;/p&gt;
&lt;p&gt;Git：2.</summary>
      
    
    
    
    
  </entry>
  
</feed>
